// src/version.ts
function _assert_this_initialized(self) {
    if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
}
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
        var info = gen[key](arg);
        var value = info.value;
    } catch (error) {
        reject(error);
        return;
    }
    if (info.done) {
        resolve(value);
    } else {
        Promise.resolve(value).then(_next, _throw);
    }
}
function _async_to_generator(fn) {
    return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve, reject) {
            var gen = fn.apply(self, args);
            function _next(value) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
            }
            function _throw(err) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
            }
            _next(undefined);
        });
    };
}
function _call_super(_this, derived, args) {
    derived = _get_prototype_of(derived);
    return _possible_constructor_return(_this, _is_native_reflect_construct() ? Reflect.construct(derived, args || [], _get_prototype_of(_this).constructor) : derived.apply(_this, args));
}
function _class_call_check(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _construct(Parent, args, Class) {
    if (_is_native_reflect_construct()) {
        _construct = Reflect.construct;
    } else {
        _construct = function construct(Parent, args, Class) {
            var a = [
                null
            ];
            a.push.apply(a, args);
            var Constructor = Function.bind.apply(Parent, a);
            var instance = new Constructor();
            if (Class) _set_prototype_of(instance, Class.prototype);
            return instance;
        };
    }
    return _construct.apply(null, arguments);
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _create_class(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
}
function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function _get_prototype_of(o) {
    _get_prototype_of = Object.setPrototypeOf ? Object.getPrototypeOf : function getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _get_prototype_of(o);
}
function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _set_prototype_of(subClass, superClass);
}
function _is_native_function(fn) {
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
}
function _object_spread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
                return Object.getOwnPropertyDescriptor(source, sym).enumerable;
            }));
        }
        ownKeys.forEach(function(key) {
            _define_property(target, key, source[key]);
        });
    }
    return target;
}
function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly) {
            symbols = symbols.filter(function(sym) {
                return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            });
        }
        keys.push.apply(keys, symbols);
    }
    return keys;
}
function _object_spread_props(target, source) {
    source = source != null ? source : {};
    if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
        ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
    }
    return target;
}
function _possible_constructor_return(self, call) {
    if (call && (_type_of(call) === "object" || typeof call === "function")) {
        return call;
    }
    return _assert_this_initialized(self);
}
function _set_prototype_of(o, p) {
    _set_prototype_of = Object.setPrototypeOf || function setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _set_prototype_of(o, p);
}
function _type_of(obj) {
    "@swc/helpers - typeof";
    return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
function _wrap_native_super(Class) {
    var _cache = typeof Map === "function" ? new Map() : undefined;
    _wrap_native_super = function wrapNativeSuper(Class) {
        if (Class === null || !_is_native_function(Class)) return Class;
        if (typeof Class !== "function") {
            throw new TypeError("Super expression must either be null or a function");
        }
        if (typeof _cache !== "undefined") {
            if (_cache.has(Class)) return _cache.get(Class);
            _cache.set(Class, Wrapper);
        }
        function Wrapper() {
            return _construct(Class, arguments, _get_prototype_of(this).constructor);
        }
        Wrapper.prototype = Object.create(Class.prototype, {
            constructor: {
                value: Wrapper,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        return _set_prototype_of(Wrapper, Class);
    };
    return _wrap_native_super(Class);
}
function _is_native_reflect_construct() {
    try {
        var result = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
    } catch (_) {}
    return (_is_native_reflect_construct = function() {
        return !!result;
    })();
}
function _ts_generator(thisArg, body) {
    var f, y, t, _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    }, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
    return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(g && (g = 0, op[0] && (_ = 0)), _)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
}
var WALLET_ADAPTER_CORE_VERSION = "5.5.4";
// src/WalletCore.ts
import EventEmitter from "eventemitter3";
import { AccountAddress, Cedra as Cedra2, Network as Network3, NetworkToChainId } from "@cedra-labs/ts-sdk";
import { getCedraWallets, isWalletWithRequiredFeatureSet, UserResponseStatus } from "@cedra-labs/wallet-standard";
// src/ga/index.ts
var GA4 = /*#__PURE__*/ function() {
    "use strict";
    function GA4() {
        _class_call_check(this, GA4);
        this.cedraGAID = true;
        this.injectGA(this.cedraGAID);
    }
    _create_class(GA4, [
        {
            key: "gtag",
            value: function gtag(a, b, c) {
                var dataLayer = window.dataLayer || [];
                dataLayer.push(arguments);
            }
        },
        {
            key: "injectGA",
            value: function injectGA(gaID) {
                if (typeof window === "undefined") return;
                if (!gaID) return;
                var head = document.getElementsByTagName("head")[0];
                var myScript = document.createElement("script");
                myScript.setAttribute("src", "https://www.googletagmanager.com/gtag/js?id=".concat(gaID));
                var that = this;
                myScript.onload = function() {
                    that.gtag("js", /* @__PURE__ */ new Date());
                    that.gtag("config", "".concat(gaID), {
                        send_page_view: false
                    });
                };
                head.insertBefore(myScript, head.children[1]);
            }
        }
    ]);
    return GA4;
}();
// src/error/index.ts
var WalletError = /*#__PURE__*/ function(Error1) {
    "use strict";
    _inherits(WalletError, Error1);
    function WalletError(message, error) {
        _class_call_check(this, WalletError);
        var _this;
        _this = _call_super(this, WalletError, [
            message
        ]);
        _this.error = error;
        return _this;
    }
    return WalletError;
}(_wrap_native_super(Error));
var WalletNotSelectedError = /*#__PURE__*/ function(WalletError) {
    "use strict";
    _inherits(WalletNotSelectedError, WalletError);
    function WalletNotSelectedError() {
        _class_call_check(this, WalletNotSelectedError);
        var _this;
        _this = _call_super(this, WalletNotSelectedError, arguments);
        _this.name = "WalletNotSelectedError";
        return _this;
    }
    return WalletNotSelectedError;
}(WalletError);
var WalletNotReadyError = /*#__PURE__*/ function(WalletError) {
    "use strict";
    _inherits(WalletNotReadyError, WalletError);
    function WalletNotReadyError() {
        _class_call_check(this, WalletNotReadyError);
        var _this;
        _this = _call_super(this, WalletNotReadyError, arguments);
        _this.name = "WalletNotReadyError";
        return _this;
    }
    return WalletNotReadyError;
}(WalletError);
var WalletConnectionError = /*#__PURE__*/ function(WalletError) {
    "use strict";
    _inherits(WalletConnectionError, WalletError);
    function WalletConnectionError() {
        _class_call_check(this, WalletConnectionError);
        var _this;
        _this = _call_super(this, WalletConnectionError, arguments);
        _this.name = "WalletConnectionError";
        return _this;
    }
    return WalletConnectionError;
}(WalletError);
var WalletDisconnectionError = /*#__PURE__*/ function(WalletError) {
    "use strict";
    _inherits(WalletDisconnectionError, WalletError);
    function WalletDisconnectionError() {
        _class_call_check(this, WalletDisconnectionError);
        var _this;
        _this = _call_super(this, WalletDisconnectionError, arguments);
        _this.name = "WalletDisconnectionError";
        return _this;
    }
    return WalletDisconnectionError;
}(WalletError);
var WalletAccountError = /*#__PURE__*/ function(WalletError) {
    "use strict";
    _inherits(WalletAccountError, WalletError);
    function WalletAccountError() {
        _class_call_check(this, WalletAccountError);
        var _this;
        _this = _call_super(this, WalletAccountError, arguments);
        _this.name = "WalletAccountError";
        return _this;
    }
    return WalletAccountError;
}(WalletError);
var WalletGetNetworkError = /*#__PURE__*/ function(WalletError) {
    "use strict";
    _inherits(WalletGetNetworkError, WalletError);
    function WalletGetNetworkError() {
        _class_call_check(this, WalletGetNetworkError);
        var _this;
        _this = _call_super(this, WalletGetNetworkError, arguments);
        _this.name = "WalletGetNetworkError";
        return _this;
    }
    return WalletGetNetworkError;
}(WalletError);
var WalletAccountChangeError = /*#__PURE__*/ function(WalletError) {
    "use strict";
    _inherits(WalletAccountChangeError, WalletError);
    function WalletAccountChangeError() {
        _class_call_check(this, WalletAccountChangeError);
        var _this;
        _this = _call_super(this, WalletAccountChangeError, arguments);
        _this.name = "WalletAccountChangeError";
        return _this;
    }
    return WalletAccountChangeError;
}(WalletError);
var WalletNetworkChangeError = /*#__PURE__*/ function(WalletError) {
    "use strict";
    _inherits(WalletNetworkChangeError, WalletError);
    function WalletNetworkChangeError() {
        _class_call_check(this, WalletNetworkChangeError);
        var _this;
        _this = _call_super(this, WalletNetworkChangeError, arguments);
        _this.name = "WalletNetworkChangeError";
        return _this;
    }
    return WalletNetworkChangeError;
}(WalletError);
var WalletNotConnectedError = /*#__PURE__*/ function(WalletError) {
    "use strict";
    _inherits(WalletNotConnectedError, WalletError);
    function WalletNotConnectedError() {
        _class_call_check(this, WalletNotConnectedError);
        var _this;
        _this = _call_super(this, WalletNotConnectedError, arguments);
        _this.name = "WalletNotConnectedError";
        return _this;
    }
    return WalletNotConnectedError;
}(WalletError);
var WalletSignMessageError = /*#__PURE__*/ function(WalletError) {
    "use strict";
    _inherits(WalletSignMessageError, WalletError);
    function WalletSignMessageError() {
        _class_call_check(this, WalletSignMessageError);
        var _this;
        _this = _call_super(this, WalletSignMessageError, arguments);
        _this.name = "WalletSignMessageError";
        return _this;
    }
    return WalletSignMessageError;
}(WalletError);
var WalletSignMessageAndVerifyError = /*#__PURE__*/ function(WalletError) {
    "use strict";
    _inherits(WalletSignMessageAndVerifyError, WalletError);
    function WalletSignMessageAndVerifyError() {
        _class_call_check(this, WalletSignMessageAndVerifyError);
        var _this;
        _this = _call_super(this, WalletSignMessageAndVerifyError, arguments);
        _this.name = "WalletSignMessageAndVerifyError";
        return _this;
    }
    return WalletSignMessageAndVerifyError;
}(WalletError);
var WalletSignAndSubmitMessageError = /*#__PURE__*/ function(WalletError) {
    "use strict";
    _inherits(WalletSignAndSubmitMessageError, WalletError);
    function WalletSignAndSubmitMessageError() {
        _class_call_check(this, WalletSignAndSubmitMessageError);
        var _this;
        _this = _call_super(this, WalletSignAndSubmitMessageError, arguments);
        _this.name = "WalletSignAndSubmitMessageError";
        return _this;
    }
    return WalletSignAndSubmitMessageError;
}(WalletError);
var WalletSignTransactionError = /*#__PURE__*/ function(WalletError) {
    "use strict";
    _inherits(WalletSignTransactionError, WalletError);
    function WalletSignTransactionError() {
        _class_call_check(this, WalletSignTransactionError);
        var _this;
        _this = _call_super(this, WalletSignTransactionError, arguments);
        _this.name = "WalletSignTransactionError";
        return _this;
    }
    return WalletSignTransactionError;
}(WalletError);
var WalletNotSupportedMethod = /*#__PURE__*/ function(WalletError) {
    "use strict";
    _inherits(WalletNotSupportedMethod, WalletError);
    function WalletNotSupportedMethod() {
        _class_call_check(this, WalletNotSupportedMethod);
        var _this;
        _this = _call_super(this, WalletNotSupportedMethod, arguments);
        _this.name = "WalletNotSupportedMethod";
        return _this;
    }
    return WalletNotSupportedMethod;
}(WalletError);
var WalletChangeNetworkError = /*#__PURE__*/ function(WalletError) {
    "use strict";
    _inherits(WalletChangeNetworkError, WalletError);
    function WalletChangeNetworkError() {
        _class_call_check(this, WalletChangeNetworkError);
        var _this;
        _this = _call_super(this, WalletChangeNetworkError, arguments);
        _this.name = "WalletChangeNetworkError";
        return _this;
    }
    return WalletChangeNetworkError;
}(WalletError);
var WalletSubmitTransactionError = /*#__PURE__*/ function(WalletError) {
    "use strict";
    _inherits(WalletSubmitTransactionError, WalletError);
    function WalletSubmitTransactionError() {
        _class_call_check(this, WalletSubmitTransactionError);
        var _this;
        _this = _call_super(this, WalletSubmitTransactionError, arguments);
        _this.name = "WalletSubmitTransactionError";
        return _this;
    }
    return WalletSubmitTransactionError;
}(WalletError);
var WalletNotFoundError = /*#__PURE__*/ function(WalletError) {
    "use strict";
    _inherits(WalletNotFoundError, WalletError);
    function WalletNotFoundError() {
        _class_call_check(this, WalletNotFoundError);
        var _this;
        _this = _call_super(this, WalletNotFoundError, arguments);
        _this.name = "WalletNotFoundError";
        return _this;
    }
    return WalletNotFoundError;
}(WalletError);
// src/constants.ts
var WalletReadyState = /* @__PURE__ */ function(WalletReadyState2) {
    WalletReadyState2["Installed"] = "Installed";
    WalletReadyState2["NotDetected"] = "NotDetected";
    return WalletReadyState2;
}(WalletReadyState || {});
var NetworkName = /* @__PURE__ */ function(NetworkName2) {
    NetworkName2["Mainnet"] = "mainnet";
    NetworkName2["Testnet"] = "testnet";
    NetworkName2["Devnet"] = "devnet";
    return NetworkName2;
}(NetworkName || {});
var ChainIdToAnsSupportedNetworkMap = {
    "1": "mainnet",
    // mainnet
    "2": "testnet"
};
var CEDRA_CONNECT_BASE_URL = "https://cedraconnect.app";
var CEDRA_CONNECT_ACCOUNT_URL = "https://cedraconnect.app/dashboard/main-account";
// src/utils/helpers.ts
import { Cedra, CedraConfig, Hex, Network, NetworkToNodeAPI } from "@cedra-labs/ts-sdk";
function isMobile() {
    return /Mobile|iP(hone|od|ad)|Android|BlackBerry|IEMobile|Kindle|NetFront|Silk-Accelerated|(hpw|web)OS|Fennec|Minimo|Opera M(obi|ini)|Blazer|Dolfin|Dolphin|Skyfire|Zune/i.test(navigator.userAgent);
}
function isInAppBrowser() {
    var isIphone = /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(navigator.userAgent);
    var isAndroid = /(Android).*Version\/[\d.]+.*Chrome\/[^\s]+ Mobile/i.test(navigator.userAgent);
    return isIphone || isAndroid;
}
function isRedirectable() {
    if (typeof navigator === "undefined" || !navigator) return false;
    return isMobile() && !isInAppBrowser();
}
function generalizedErrorMessage(error) {
    return (typeof error === "undefined" ? "undefined" : _type_of(error)) === "object" && "message" in error ? error.message : error;
}
var getCedraConfig = function(networkInfo, dappConfig) {
    if (!networkInfo) {
        throw new Error("Undefined network");
    }
    if (isCedraNetwork(networkInfo)) {
        var currentNetwork = convertNetwork(networkInfo);
        if (isCedraLiveNetwork(currentNetwork)) {
            var apiKey = dappConfig === null || dappConfig === void 0 ? void 0 : dappConfig.cedraApiKeys;
            return new CedraConfig({
                network: currentNetwork,
                clientConfig: {
                    API_KEY: apiKey ? apiKey[currentNetwork] : void 0
                }
            });
        }
        return new CedraConfig({
            network: currentNetwork
        });
    }
    var knownNetworks = {
        okx: "https://wallet.okx.com/fullnode/cedra/discover/rpc"
    };
    if (networkInfo.url) {
        var isKnownNetwork = Object.values(knownNetworks).includes(networkInfo.url);
        if (isKnownNetwork) {
            return new CedraConfig({
                network: Network.CUSTOM,
                fullnode: networkInfo.url
            });
        }
    }
    throw new Error("Invalid network, network ".concat(networkInfo.name, " not supported with Cedra wallet adapter to prevent user from using an unexpected network."));
};
var isCedraNetwork = function(networkInfo) {
    if (!networkInfo) {
        throw new Error("Undefined network");
    }
    return NetworkToNodeAPI[networkInfo.name] !== void 0;
};
var isCedraLiveNetwork = function(networkInfo) {
    return networkInfo === "devnet" || networkInfo === "testnet" || networkInfo === "mainnet";
};
var fetchDevnetChainId = function() {
    return _async_to_generator(function() {
        var cedra;
        return _ts_generator(this, function(_state) {
            switch(_state.label){
                case 0:
                    cedra = new Cedra();
                    return [
                        4,
                        cedra.getChainId()
                    ];
                case 1:
                    return [
                        2,
                        _state.sent()
                    ];
            }
        });
    })();
};
var handlePublishPackageTransaction = function(transactionInput) {
    var metadataBytes = transactionInput.data.functionArguments[0];
    if (typeof metadataBytes === "string") {
        metadataBytes = Hex.fromHexInput(metadataBytes).toUint8Array();
    }
    var byteCode = transactionInput.data.functionArguments[1];
    if (Array.isArray(byteCode)) {
        byteCode = byteCode.map(function(byte) {
            if (typeof byte === "string") {
                return Hex.fromHexInput(byte).toUint8Array();
            }
            return byte;
        });
    } else {
        throw new WalletSignAndSubmitMessageError("The bytecode argument must be an array.").message;
    }
    return {
        metadataBytes: metadataBytes,
        byteCode: byteCode
    };
};
function convertNetwork(networkInfo) {
    switch(networkInfo === null || networkInfo === void 0 ? void 0 : networkInfo.name){
        case "mainnet":
            return Network.MAINNET;
        case "testnet":
            return Network.TESTNET;
        case "devnet":
            return Network.DEVNET;
        case "local":
            return Network.LOCAL;
        default:
            throw new Error("Invalid Cedra network name");
    }
}
// src/utils/localStorage.ts
var LOCAL_STORAGE_ITEM_KEY = "CedraWalletName";
function setLocalStorage(walletName) {
    localStorage.setItem(LOCAL_STORAGE_ITEM_KEY, walletName);
}
function removeLocalStorage() {
    localStorage.removeItem(LOCAL_STORAGE_ITEM_KEY);
}
function getLocalStorage() {
    localStorage.getItem(LOCAL_STORAGE_ITEM_KEY);
}
// src/utils/walletSelector.ts
function partitionWallets(wallets) {
    var partitionFunction = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : isInstalledOrLoadable;
    var defaultWallets = [];
    var moreWallets = [];
    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
    try {
        for(var _iterator = wallets[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
            var wallet = _step.value;
            if (partitionFunction(wallet)) defaultWallets.push(wallet);
            else moreWallets.push(wallet);
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally{
        try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
            }
        } finally{
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }
    return {
        defaultWallets: defaultWallets,
        moreWallets: moreWallets
    };
}
function isInstalledOrLoadable(wallet) {
    return wallet.readyState === "Installed" /* Installed */ ;
}
function isInstallRequired(wallet) {
    var isWalletReady = isInstalledOrLoadable(wallet);
    var isMobile2 = !isWalletReady && isRedirectable();
    return !isMobile2 && !isWalletReady;
}
function truncateAddress(address) {
    if (!address) return;
    return "".concat(address.slice(0, 6), "...").concat(address.slice(-5));
}
function isCedraConnectWallet(wallet) {
    if (!wallet.url) return false;
    return wallet.url.startsWith(CEDRA_CONNECT_BASE_URL);
}
function getCedraConnectWallets(wallets) {
    var _partitionWallets = partitionWallets(wallets, isCedraConnectWallet), defaultWallets = _partitionWallets.defaultWallets, moreWallets = _partitionWallets.moreWallets;
    return {
        cedraConnectWallets: defaultWallets,
        otherWallets: moreWallets
    };
}
function groupAndSortWallets(wallets, options) {
    var _getCedraConnectWallets = getCedraConnectWallets(wallets), cedraConnectWallets = _getCedraConnectWallets.cedraConnectWallets, otherWallets = _getCedraConnectWallets.otherWallets;
    var _partitionWallets = partitionWallets(otherWallets), defaultWallets = _partitionWallets.defaultWallets, moreWallets = _partitionWallets.moreWallets;
    if (options === null || options === void 0 ? void 0 : options.sortCedraConnectWallets) {
        cedraConnectWallets.sort(options.sortCedraConnectWallets);
    }
    if (options === null || options === void 0 ? void 0 : options.sortAvailableWallets) {
        defaultWallets.sort(options.sortAvailableWallets);
    }
    if (options === null || options === void 0 ? void 0 : options.sortInstallableWallets) {
        moreWallets.sort(options.sortInstallableWallets);
    }
    return {
        /** Wallets that use social login to create an account on the blockchain */ cedraConnectWallets: cedraConnectWallets,
        /** Wallets that are currently installed or loadable. */ availableWallets: defaultWallets,
        /** Wallets that are NOT currently installed or loadable. */ installableWallets: moreWallets
    };
}
// src/registry.ts
var cedraStandardSupportedWalletList = [
    {
        name: "Nightly",
        url: "https://nightly.app/",
        icon: "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4NCjwhLS0gR2VuZXJhdG9yOiBBZG9iZSBJbGx1c3RyYXRvciAyOC4wLjAsIFNWRyBFeHBvcnQgUGx1Zy1JbiAuIFNWRyBWZXJzaW9uOiA2LjAwIEJ1aWxkIDApICAtLT4NCjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iV2Fyc3R3YV8xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4PSIwcHgiIHk9IjBweCINCgkgdmlld0JveD0iMCAwIDg1MS41IDg1MS41IiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCA4NTEuNSA4NTEuNTsiIHhtbDpzcGFjZT0icHJlc2VydmUiPg0KPHN0eWxlIHR5cGU9InRleHQvY3NzIj4NCgkuc3Qwe2ZpbGw6IzYwNjdGOTt9DQoJLnN0MXtmaWxsOiNGN0Y3Rjc7fQ0KPC9zdHlsZT4NCjxnPg0KCTxnIGlkPSJXYXJzdHdhXzJfMDAwMDAwMTQ2MDk2NTQyNTMxODA5NDY0NjAwMDAwMDg2NDc4NTIwMDIxMTY5MTg2ODhfIj4NCgkJPHBhdGggY2xhc3M9InN0MCIgZD0iTTEyNCwwaDYwMy42YzY4LjUsMCwxMjQsNTUuNSwxMjQsMTI0djYwMy42YzAsNjguNS01NS41LDEyNC0xMjQsMTI0SDEyNGMtNjguNSwwLTEyNC01NS41LTEyNC0xMjRWMTI0DQoJCQlDMCw1NS41LDU1LjUsMCwxMjQsMHoiLz4NCgk8L2c+DQoJPGcgaWQ9IldhcnN0d2FfMyI+DQoJCTxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik02MjMuNSwxNzAuM2MtMzcuNCw1Mi4yLTg0LjIsODguNC0xMzkuNSwxMTIuNmMtMTkuMi01LjMtMzguOS04LTU4LjMtNy44Yy0xOS40LTAuMi0zOS4xLDIuNi01OC4zLDcuOA0KCQkJYy01NS4zLTI0LjMtMTAyLjEtNjAuMy0xMzkuNS0xMTIuNmMtMTEuMywyOC40LTU0LjgsMTI2LjQtMi42LDI2My40YzAsMC0xNi43LDcxLjUsMTQsMTMyLjljMCwwLDQ0LjQtMjAuMSw3OS43LDguMg0KCQkJYzM2LjksMjkuOSwyNS4xLDU4LjcsNTEuMSw4My41YzIyLjQsMjIuOSw1NS43LDIyLjksNTUuNywyMi45czMzLjMsMCw1NS43LTIyLjhjMjYtMjQuNywxNC4zLTUzLjUsNTEuMS04My41DQoJCQljMzUuMi0yOC4zLDc5LjctOC4yLDc5LjctOC4yYzMwLjYtNjEuNCwxNC0xMzIuOSwxNC0xMzIuOUM2NzguMywyOTYuNyw2MzQuOSwxOTguNyw2MjMuNSwxNzAuM3ogTTI1My4xLDQxNC44DQoJCQljLTI4LjQtNTguMy0zNi4yLTEzOC4zLTE4LjMtMjAxLjVjMjMuNyw2MCw1NS45LDg2LjksOTQuMiwxMTUuM0MzMTIuOCwzNjIuMywyODIuMywzOTQuMSwyNTMuMSw0MTQuOHogTTMzNC44LDUxNy41DQoJCQljLTIyLjQtOS45LTI3LjEtMjkuNC0yNy4xLTI5LjRjMzAuNS0xOS4yLDc1LjQtNC41LDc2LjgsNDAuOUMzNjAuOSw1MTQuNywzNTMsNTI1LjQsMzM0LjgsNTE3LjV6IE00MjUuNyw2NzguNw0KCQkJYy0xNiwwLTI5LTExLjUtMjktMjUuNnMxMy0yNS42LDI5LTI1LjZzMjksMTEuNSwyOSwyNS42QzQ1NC43LDY2Ny4zLDQ0MS43LDY3OC43LDQyNS43LDY3OC43eiBNNTE2LjcsNTE3LjUNCgkJCWMtMTguMiw4LTI2LTIuOC00OS43LDExLjVjMS41LTQ1LjQsNDYuMi02MC4xLDc2LjgtNDAuOUM1NDMuOCw0ODgsNTM5LDUwNy42LDUxNi43LDUxNy41eiBNNTk4LjMsNDE0LjgNCgkJCWMtMjkuMS0yMC43LTU5LjctNTIuNC03Ni04Ni4yYzM4LjMtMjguNCw3MC42LTU1LjQsOTQuMi0xMTUuM0M2MzQuNiwyNzYuNSw2MjYuOCwzNTYuNiw1OTguMyw0MTQuOHoiLz4NCgk8L2c+DQo8L2c+DQo8L3N2Zz4NCg==",
        readyState: "NotDetected" /* NotDetected */ ,
        isAIP62Standard: true,
        deeplinkProvider: "nightly://v1?network=cedra&url="
    },
    {
        name: "Zedra",
        url: "https://chromewebstore.google.com/detail/zedra-wallet/pbeefngmcchkcibdodceimammkigfanl",
        icon: "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyBpZD0iTGF5ZXJfMiIgZGF0YS1uYW1lPSJMYXllciAyIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDgwIDEwODAiPgogIDxkZWZzPgogICAgPHN0eWxlPgogICAgICAuY2xzLTEgewogICAgICAgIGZpbGw6ICNiOGZmZGU7CiAgICAgIH0KICAgIDwvc3R5bGU+CiAgPC9kZWZzPgogIDxnIGlkPSJMYXllcl8xLTIiIGRhdGEtbmFtZT0iTGF5ZXIgMSI+CiAgICA8cmVjdCBjbGFzcz0iY2xzLTEiIHdpZHRoPSIxMDgwIiBoZWlnaHQ9IjEwODAiIHJ4PSIxMjAuNTQiIHJ5PSIxMjAuNTQiLz4KICAgIDxnPgogICAgICA8cGF0aCBkPSJtMzIyLjQ3LDIxOS4xMWgzNTMuNDdjMTMuMzgsMCwyNS42Miw3LjUxLDMxLjY5LDE5LjQzbDExMC43OSwyMTcuNjljNi43NiwxMy4yOCw0LjUyLDI5LjM3LTUuNjEsNDAuM2wtMTE5LjU0LDEyOWMtMTMuNDYsMTQuNTMtMzYuMiwxNS4yNi01MC41NywxLjYybC03Ny41Ni03My42NGMtMTQuNDYtMTMuNzMtMTQuOC0zNi42Ni0uNzctNTAuODJsNDIuOTYtNDMuMzVjMjIuMjgtMjIuNDgsNi4yOS02MC42OS0yNS4zNi02MC41OWwtMjU5LjQuNzljLTE5LjY4LjA2LTM1LjY3LTE1Ljg4LTM1LjY3LTM1LjU2di0xMDkuMzFjMC0xOS42NCwxNS45Mi0zNS41NiwzNS41Ni0zNS41NloiLz4KICAgICAgPHBhdGggZD0ibTc1Ny41Myw4NjAuODloLTM1My40N2MtMTMuMzgsMC0yNS42Mi03LjUxLTMxLjY5LTE5LjQzbC0xMTAuNzktMjE3LjY5Yy02Ljc2LTEzLjI4LTQuNTItMjkuMzcsNS42MS00MC4zbDExOS41NC0xMjljMTMuNDYtMTQuNTMsMzYuMi0xNS4yNiw1MC41Ny0xLjYybDc3LjU2LDczLjY0YzE0LjQ2LDEzLjczLDE0LjgsMzYuNjYuNzcsNTAuODJsLTQyLjk2LDQzLjM1Yy0yMi4yOCwyMi40OC02LjI5LDYwLjY5LDI1LjM2LDYwLjU5bDI1OS40LS43OWMxOS42OC0uMDYsMzUuNjcsMTUuODgsMzUuNjcsMzUuNTZ2MTA5LjMxYzAsMTkuNjQtMTUuOTIsMzUuNTYtMzUuNTYsMzUuNTZaIi8+CiAgICA8L2c+CiAgPC9nPgo8L3N2Zz4=",
        readyState: "NotDetected" /* NotDetected */ ,
        isAIP62Standard: true,
        deeplinkProvider: "https://zedra.app/"
    }
];
// src/sdkWallets.ts
import { CedraConnectAppleWallet, CedraConnectGoogleWallet } from "@cedra-labs/wallet-adapter-plugin";
import { Network as Network2 } from "@cedra-labs/ts-sdk";
function getSDKWallets(dappConfig) {
    var sdkWallets = [];
    if (typeof window !== "undefined") {
        sdkWallets.push(new CedraConnectGoogleWallet(_object_spread({
            network: dappConfig === null || dappConfig === void 0 ? void 0 : dappConfig.network,
            dappId: dappConfig === null || dappConfig === void 0 ? void 0 : dappConfig.cedraConnectDappId
        }, dappConfig === null || dappConfig === void 0 ? void 0 : dappConfig.cedraConnect)), new CedraConnectAppleWallet(_object_spread({
            network: dappConfig === null || dappConfig === void 0 ? void 0 : dappConfig.network,
            dappId: dappConfig === null || dappConfig === void 0 ? void 0 : dappConfig.cedraConnectDappId
        }, dappConfig === null || dappConfig === void 0 ? void 0 : dappConfig.cedraConnect)));
    }
    if ((dappConfig === null || dappConfig === void 0 ? void 0 : dappConfig.network) === Network2.MAINNET) {} else {}
    return sdkWallets;
}
// src/WalletCore.ts
var WalletCore = /*#__PURE__*/ function(EventEmitter) {
    "use strict";
    _inherits(WalletCore, EventEmitter);
    function WalletCore(optInWallets, dappConfig, disableTelemetry) {
        _class_call_check(this, WalletCore);
        var _this;
        _this = _call_super(this, WalletCore);
        // Local private variable to hold the wallet that is currently connected
        _this._wallet = null;
        // Local private variable to hold SDK wallets in the adapter
        _this._sdkWallets = [];
        // Local array that holds all the wallets that are AIP-62 standard compatible
        _this._standard_wallets = [];
        // Local array that holds all the wallets that are AIP-62 standard compatible but are not installed on the user machine
        _this._standard_not_detected_wallets = [];
        // Local private variable to hold the network that is currently connected
        _this._network = null;
        // Local private variable to hold the wallet connected state
        _this._connected = false;
        // Local private variable to hold the connecting state
        _this._connecting = false;
        // Local private variable to hold the account that is currently connected
        _this._account = null;
        // Private array that holds all the Wallets a dapp decided to opt-in to
        _this._optInWallets = [];
        // Local flag to disable the adapter telemetry tool
        _this._disableTelemetry = false;
        // Google Analytics 4 module
        _this.ga4 = null;
        _this._optInWallets = optInWallets || [];
        _this._dappConfig = dappConfig;
        _this._disableTelemetry = disableTelemetry !== null && disableTelemetry !== void 0 ? disableTelemetry : false;
        _this._sdkWallets = getSDKWallets(_this._dappConfig);
        if (!_this._disableTelemetry) {
            _this.ga4 = new GA4();
        }
        _this.fetchExtensionAIP62CedraWallets();
        _this.fetchSDKAIP62CedraWallets();
        _this.appendNotDetectedStandardSupportedWallets();
        return _this;
    }
    _create_class(WalletCore, [
        {
            key: "fetchExtensionAIP62CedraWallets",
            value: function fetchExtensionAIP62CedraWallets() {
                var _getCedraWallets = getCedraWallets(), cedraWallets = _getCedraWallets.cedraWallets, on = _getCedraWallets.on;
                this.setExtensionAIP62Wallets(cedraWallets);
                if (typeof window === "undefined") return;
                var that = this;
                var removeRegisterListener = on("register", function() {
                    var _getCedraWallets = getCedraWallets(), cedraWallets2 = _getCedraWallets.cedraWallets;
                    that.setExtensionAIP62Wallets(cedraWallets2);
                });
                var removeUnregisterListener = on("unregister", function() {
                    var _getCedraWallets = getCedraWallets(), cedraWallets2 = _getCedraWallets.cedraWallets;
                    that.setExtensionAIP62Wallets(cedraWallets2);
                });
            }
        },
        {
            /**
   * Set AIP-62 extension wallets
   *
   * @param extensionwWallets
   */ key: "setExtensionAIP62Wallets",
            value: function setExtensionAIP62Wallets(extensionwWallets) {
                var _this = this;
                extensionwWallets.map(function(wallet) {
                    if (_this.excludeWallet(wallet)) {
                        return;
                    }
                    _this._standard_wallets = _this._standard_wallets.filter(function(item) {
                        return item.name !== wallet.name;
                    });
                    var isValid = isWalletWithRequiredFeatureSet(wallet);
                    if (isValid) {
                        var index = _this._standard_not_detected_wallets.findIndex(function(notDetctedWallet) {
                            return notDetctedWallet.name == wallet.name;
                        });
                        if (index !== -1) {
                            _this._standard_not_detected_wallets.splice(index, 1);
                        }
                        wallet.readyState = "Installed" /* Installed */ ;
                        _this._standard_wallets.push(wallet);
                        _this.emit("standardWalletsAdded", wallet);
                    }
                });
            }
        },
        {
            /**
   * Set AIP-62 SDK wallets
   */ key: "fetchSDKAIP62CedraWallets",
            value: function fetchSDKAIP62CedraWallets() {
                var _this = this;
                this._sdkWallets.map(function(wallet) {
                    if (_this.excludeWallet(wallet)) {
                        return;
                    }
                    var isValid = isWalletWithRequiredFeatureSet(wallet);
                    if (isValid) {
                        wallet.readyState = "Installed" /* Installed */ ;
                        _this._standard_wallets.push(wallet);
                    }
                });
            }
        },
        {
            // Since we can't discover AIP-62 wallets that are not installed on the user machine,
            // we hold a AIP-62 wallets registry to show on the wallet selector modal for the users.
            // Append wallets from wallet standard support registry to the `_standard_not_detected_wallets` array
            // when wallet is not installed on the user machine
            key: "appendNotDetectedStandardSupportedWallets",
            value: function appendNotDetectedStandardSupportedWallets() {
                var _this = this;
                cedraStandardSupportedWalletList.map(function(supportedWallet) {
                    var existingStandardWallet = _this._standard_wallets.find(function(wallet) {
                        return wallet.name == supportedWallet.name;
                    });
                    if (existingStandardWallet) {
                        return;
                    }
                    if (_this.excludeWallet(supportedWallet)) {
                        return;
                    }
                    if (!existingStandardWallet) {
                        _this._standard_not_detected_wallets.push(supportedWallet);
                        _this.emit("standardNotDetectedWalletAdded", supportedWallet);
                    }
                });
            }
        },
        {
            /**
   * A function that excludes an AIP-62 compatible wallet the dapp doesnt want to include
   *
   * @param wallet AdapterWallet | AdapterNotDetectedWallet
   * @returns boolean
   */ key: "excludeWallet",
            value: function excludeWallet(wallet) {
                if (this._optInWallets.length > 0 && !this._optInWallets.includes(wallet.name)) {
                    return true;
                }
                return false;
            }
        },
        {
            key: "recordEvent",
            value: function recordEvent(eventName, additionalInfo) {
                var _this__wallet, _this__network, _this__network1, _this_ga4;
                (_this_ga4 = this.ga4) === null || _this_ga4 === void 0 ? void 0 : _this_ga4.gtag("event", "wallet_adapter_".concat(eventName), _object_spread({
                    wallet: (_this__wallet = this._wallet) === null || _this__wallet === void 0 ? void 0 : _this__wallet.name,
                    network: (_this__network = this._network) === null || _this__network === void 0 ? void 0 : _this__network.name,
                    network_url: (_this__network1 = this._network) === null || _this__network1 === void 0 ? void 0 : _this__network1.url,
                    adapter_core_version: WALLET_ADAPTER_CORE_VERSION,
                    send_to: true
                }, additionalInfo));
            }
        },
        {
            /**
   * Helper function to ensure wallet exists
   *
   * @param wallet A wallet
   */ key: "ensureWalletExists",
            value: function ensureWalletExists(wallet) {
                if (!wallet) {
                    throw new WalletNotConnectedError().name;
                }
                if (!(wallet.readyState === "Installed" /* Installed */ )) throw new WalletNotReadyError("Wallet is not set").name;
            }
        },
        {
            /**
   * Helper function to ensure account exists
   *
   * @param account An account
   */ key: "ensureAccountExists",
            value: function ensureAccountExists(account) {
                if (!account) {
                    throw new WalletAccountError("Account is not set").name;
                }
            }
        },
        {
            key: "setAnsName",
            value: /**
   * Queries and sets ANS name for the current connected wallet account
   */ function setAnsName() {
                return _async_to_generator(function() {
                    var _this__network, cedraConfig, cedra, name, error;
                    return _ts_generator(this, function(_state) {
                        switch(_state.label){
                            case 0:
                                if (!(((_this__network = this._network) === null || _this__network === void 0 ? void 0 : _this__network.chainId) && this._account)) return [
                                    3,
                                    4
                                ];
                                if (this._account.ansName) return [
                                    2
                                ];
                                if (!ChainIdToAnsSupportedNetworkMap[this._network.chainId] || !isCedraNetwork(this._network)) {
                                    this._account.ansName = void 0;
                                    return [
                                        2
                                    ];
                                }
                                cedraConfig = getCedraConfig(this._network, this._dappConfig);
                                cedra = new Cedra2(cedraConfig);
                                _state.label = 1;
                            case 1:
                                _state.trys.push([
                                    1,
                                    3,
                                    ,
                                    4
                                ]);
                                return [
                                    4,
                                    cedra.ans.getPrimaryName({
                                        address: this._account.address.toString()
                                    })
                                ];
                            case 2:
                                name = _state.sent();
                                this._account.ansName = name;
                                return [
                                    3,
                                    4
                                ];
                            case 3:
                                error = _state.sent();
                                console.log("Error setting ANS name ".concat(error));
                                return [
                                    3,
                                    4
                                ];
                            case 4:
                                return [
                                    2
                                ];
                        }
                    });
                }).call(this);
            }
        },
        {
            /**
   * Function to cleat wallet adapter data.
   *
   * - Removes current connected wallet state
   * - Removes current connected account state
   * - Removes current connected network state
   * - Removes autoconnect local storage value
   */ key: "clearData",
            value: function clearData() {
                this._connected = false;
                this.setWallet(null);
                this.setAccount(null);
                this.setNetwork(null);
                removeLocalStorage();
            }
        },
        {
            /**
   * Sets the connected wallet
   *
   * @param wallet A wallet
   */ key: "setWallet",
            value: function setWallet(wallet) {
                this._wallet = wallet;
            }
        },
        {
            /**
   * Sets the connected account
   *
   * @param account An account
   */ key: "setAccount",
            value: function setAccount(account) {
                this._account = account;
            }
        },
        {
            /**
   * Sets the connected network
   *
   * @param network A network
   */ key: "setNetwork",
            value: function setNetwork(network) {
                this._network = network;
            }
        },
        {
            /**
   * Helper function to detect whether a wallet is connected
   *
   * @returns boolean
   */ key: "isConnected",
            value: function isConnected() {
                return this._connected;
            }
        },
        {
            key: "wallets",
            get: /**
   * Getter to fetch all detected wallets
   */ function get() {
                return this._standard_wallets;
            }
        },
        {
            key: "notDetectedWallets",
            get: function get() {
                return this._standard_not_detected_wallets;
            }
        },
        {
            key: "wallet",
            get: /**
   * Getter for the current connected wallet
   *
   * @return wallet info
   * @throws WalletNotSelectedError
   */ function get() {
                try {
                    if (!this._wallet) return null;
                    return this._wallet;
                } catch (error) {
                    throw new WalletNotSelectedError(error).message;
                }
            }
        },
        {
            key: "account",
            get: /**
   * Getter for the current connected account
   *
   * @return account info
   * @throws WalletAccountError
   */ function get() {
                try {
                    return this._account;
                } catch (error) {
                    throw new WalletAccountError(error).message;
                }
            }
        },
        {
            key: "network",
            get: /**
   * Getter for the current wallet network
   *
   * @return network info
   * @throws WalletGetNetworkError
   */ function get() {
                try {
                    return this._network;
                } catch (error) {
                    throw new WalletGetNetworkError(error).message;
                }
            }
        },
        {
            key: "connect",
            value: /**
   * Helper function to run some checks before we connect with a wallet.
   *
   * @param walletName. The wallet name we want to connect with.
   */ function connect(walletName) {
                return _async_to_generator(function() {
                    var selectedWallet2, uninstalledWallet, url, location, allDetectedWallets, selectedWallet, _this__wallet;
                    return _ts_generator(this, function(_state) {
                        switch(_state.label){
                            case 0:
                                if (isRedirectable()) {
                                    selectedWallet2 = this._standard_not_detected_wallets.find(function(wallet) {
                                        return wallet.name === walletName;
                                    });
                                    if (selectedWallet2) {
                                        uninstalledWallet = selectedWallet2;
                                        if (uninstalledWallet.deeplinkProvider) {
                                            url = encodeURIComponent(window.location.href);
                                            location = uninstalledWallet.deeplinkProvider.concat(url);
                                            window.location.href = location;
                                            return [
                                                2
                                            ];
                                        }
                                    }
                                }
                                allDetectedWallets = this._standard_wallets;
                                selectedWallet = allDetectedWallets.find(function(wallet) {
                                    return wallet.name === walletName;
                                });
                                if (!selectedWallet) return [
                                    2
                                ];
                                if (this._connected && this._account) {
                                    ;
                                    if (((_this__wallet = this._wallet) === null || _this__wallet === void 0 ? void 0 : _this__wallet.name) === walletName) throw new WalletConnectionError("".concat(walletName, " wallet is already connected")).message;
                                }
                                return [
                                    4,
                                    this.connectWallet(selectedWallet, function() {
                                        return _async_to_generator(function() {
                                            var response;
                                            return _ts_generator(this, function(_state) {
                                                switch(_state.label){
                                                    case 0:
                                                        return [
                                                            4,
                                                            selectedWallet.features["cedra:connect"].connect()
                                                        ];
                                                    case 1:
                                                        response = _state.sent();
                                                        if (response.status === UserResponseStatus.REJECTED) {
                                                            throw new WalletConnectionError("User has rejected the request").message;
                                                        }
                                                        return [
                                                            2,
                                                            {
                                                                account: response.args,
                                                                output: void 0
                                                            }
                                                        ];
                                                }
                                            });
                                        })();
                                    })
                                ];
                            case 1:
                                _state.sent();
                                return [
                                    2
                                ];
                        }
                    });
                }).call(this);
            }
        },
        {
            key: "signIn",
            value: /**
   * Signs into the wallet by connecting and signing an authentication messages.
   *
   * For more information, visit: https://siwa.cedra.dev
   *
   * @param args
   * @param args.input The CedraSignInInput which defines how the SIWA Message should be constructed
   * @param args.walletName The name of the wallet to sign into
   * @returns The CedraSignInOutput which contains the account and signature information
   */ function signIn(args) {
                return _async_to_generator(function() {
                    var input, walletName, allDetectedWallets, selectedWallet;
                    return _ts_generator(this, function(_state) {
                        switch(_state.label){
                            case 0:
                                input = args.input, walletName = args.walletName;
                                allDetectedWallets = this._standard_wallets;
                                selectedWallet = allDetectedWallets.find(function(wallet) {
                                    return wallet.name === walletName;
                                });
                                if (!selectedWallet) {
                                    throw new WalletNotFoundError("Wallet ".concat(walletName, " not found")).message;
                                }
                                if (!selectedWallet.features["cedra:signIn"]) {
                                    throw new WalletNotSupportedMethod("cedra:signIn is not supported by ".concat(walletName)).message;
                                }
                                return [
                                    4,
                                    this.connectWallet(selectedWallet, function() {
                                        return _async_to_generator(function() {
                                            var response;
                                            return _ts_generator(this, function(_state) {
                                                switch(_state.label){
                                                    case 0:
                                                        if (!selectedWallet.features["cedra:signIn"]) {
                                                            throw new WalletNotSupportedMethod("cedra:signIn is not supported by ".concat(selectedWallet.name)).message;
                                                        }
                                                        return [
                                                            4,
                                                            selectedWallet.features["cedra:signIn"].signIn(input)
                                                        ];
                                                    case 1:
                                                        response = _state.sent();
                                                        if (response.status === UserResponseStatus.REJECTED) {
                                                            throw new WalletConnectionError("User has rejected the request").message;
                                                        }
                                                        return [
                                                            2,
                                                            {
                                                                account: response.args.account,
                                                                output: response.args
                                                            }
                                                        ];
                                                }
                                            });
                                        })();
                                    })
                                ];
                            case 1:
                                return [
                                    2,
                                    _state.sent()
                                ];
                        }
                    });
                }).call(this);
            }
        },
        {
            key: "connectWallet",
            value: /**
   * Connects a wallet to the dapp.
   * On connect success, we set the current account and the network, and keeping the selected wallet
   * name in LocalStorage to support autoConnect function.
   *
   * @param selectedWallet. The wallet we want to connect.
   * @emit emits "connect" event
   * @throws WalletConnectionError
   */ function connectWallet(selectedWallet, onConnect) {
                return _async_to_generator(function() {
                    var _ref, account, output, network, error, errMsg;
                    return _ts_generator(this, function(_state) {
                        switch(_state.label){
                            case 0:
                                _state.trys.push([
                                    0,
                                    4,
                                    5,
                                    6
                                ]);
                                this._connecting = true;
                                this.setWallet(selectedWallet);
                                return [
                                    4,
                                    onConnect()
                                ];
                            case 1:
                                _ref = _state.sent(), account = _ref.account, output = _ref.output;
                                this.setAccount(account);
                                return [
                                    4,
                                    selectedWallet.features["cedra:network"].network()
                                ];
                            case 2:
                                network = _state.sent();
                                this.setNetwork(network);
                                return [
                                    4,
                                    this.setAnsName()
                                ];
                            case 3:
                                _state.sent();
                                setLocalStorage(selectedWallet.name);
                                this._connected = true;
                                this.recordEvent("wallet_connect");
                                this.emit("connect", account);
                                return [
                                    2,
                                    output
                                ];
                            case 4:
                                error = _state.sent();
                                this.clearData();
                                errMsg = generalizedErrorMessage(error);
                                throw new WalletConnectionError(errMsg).message;
                            case 5:
                                this._connecting = false;
                                return [
                                    7
                                ];
                            case 6:
                                return [
                                    2
                                ];
                        }
                    });
                }).call(this);
            }
        },
        {
            key: "disconnect",
            value: /**
   * Disconnect the current connected wallet. On success, we clear the
   * current account, current network and LocalStorage data.
   *
   * @emit emits "disconnect" event
   * @throws WalletDisconnectionError
   */ function disconnect() {
                return _async_to_generator(function() {
                    var error, errMsg;
                    return _ts_generator(this, function(_state) {
                        switch(_state.label){
                            case 0:
                                _state.trys.push([
                                    0,
                                    2,
                                    ,
                                    3
                                ]);
                                this.ensureWalletExists(this._wallet);
                                return [
                                    4,
                                    this._wallet.features["cedra:disconnect"].disconnect()
                                ];
                            case 1:
                                _state.sent();
                                this.clearData();
                                this.recordEvent("wallet_disconnect");
                                this.emit("disconnect");
                                return [
                                    3,
                                    3
                                ];
                            case 2:
                                error = _state.sent();
                                errMsg = generalizedErrorMessage(error);
                                throw new WalletDisconnectionError(errMsg).message;
                            case 3:
                                return [
                                    2
                                ];
                        }
                    });
                }).call(this);
            }
        },
        {
            key: "signAndSubmitTransaction",
            value: /**
   * Signs and submits a transaction to chain
   *
   * @param transactionInput InputTransactionData
   * @returns CedraSignAndSubmitTransactionOutput
   */ function signAndSubmitTransaction(transactionInput) {
                return _async_to_generator(function() {
                    var ref, _transactionInput_options, _transactionInput_options1, cedraConfig2, cedra2, transaction2, signAndSubmitTransactionMethod, response3, response2, cedraConfig, cedra, transaction, signTransactionResponse, response, error, errMsg;
                    return _ts_generator(this, function(_state) {
                        switch(_state.label){
                            case 0:
                                _state.trys.push([
                                    0,
                                    9,
                                    ,
                                    10
                                ]);
                                if ("function" in transactionInput.data) {
                                    if (transactionInput.data.function === "0x1::account::rotate_authentication_key_call") {
                                        throw new WalletSignAndSubmitMessageError("SCAM SITE DETECTED").message;
                                    }
                                    if (transactionInput.data.function === "0x1::code::publish_package_txn") {
                                        ;
                                        ref = handlePublishPackageTransaction(transactionInput), transactionInput.data.functionArguments[0] = ref.metadataBytes, transactionInput.data.functionArguments[1] = ref.byteCode, ref;
                                    }
                                }
                                this.ensureWalletExists(this._wallet);
                                this.ensureAccountExists(this._account);
                                this.recordEvent("sign_and_submit_transaction");
                                if (!this._wallet.features["cedra:signAndSubmitTransaction"]) return [
                                    3,
                                    5
                                ];
                                if (!(this._wallet.features["cedra:signAndSubmitTransaction"].version !== "1.1.0")) return [
                                    3,
                                    3
                                ];
                                cedraConfig2 = getCedraConfig(this._network, this._dappConfig);
                                cedra2 = new Cedra2(cedraConfig2);
                                return [
                                    4,
                                    cedra2.transaction.build.simple({
                                        sender: this._account.address.toString(),
                                        data: transactionInput.data,
                                        options: transactionInput.options
                                    })
                                ];
                            case 1:
                                transaction2 = _state.sent();
                                signAndSubmitTransactionMethod = this._wallet.features["cedra:signAndSubmitTransaction"].signAndSubmitTransaction;
                                return [
                                    4,
                                    signAndSubmitTransactionMethod(transaction2)
                                ];
                            case 2:
                                response3 = _state.sent();
                                if (response3.status === UserResponseStatus.REJECTED) {
                                    throw new WalletConnectionError("User has rejected the request").message;
                                }
                                return [
                                    2,
                                    response3.args
                                ];
                            case 3:
                                return [
                                    4,
                                    this._wallet.features["cedra:signAndSubmitTransaction"].signAndSubmitTransaction({
                                        payload: transactionInput.data,
                                        gasUnitPrice: (_transactionInput_options = transactionInput.options) === null || _transactionInput_options === void 0 ? void 0 : _transactionInput_options.gasUnitPrice,
                                        maxGasAmount: (_transactionInput_options1 = transactionInput.options) === null || _transactionInput_options1 === void 0 ? void 0 : _transactionInput_options1.maxGasAmount
                                    })
                                ];
                            case 4:
                                response2 = _state.sent();
                                if (response2.status === UserResponseStatus.REJECTED) {
                                    throw new WalletConnectionError("User has rejected the request").message;
                                }
                                return [
                                    2,
                                    response2.args
                                ];
                            case 5:
                                cedraConfig = getCedraConfig(this._network, this._dappConfig);
                                cedra = new Cedra2(cedraConfig);
                                return [
                                    4,
                                    cedra.transaction.build.simple({
                                        sender: this._account.address,
                                        data: transactionInput.data,
                                        options: transactionInput.options
                                    })
                                ];
                            case 6:
                                transaction = _state.sent();
                                return [
                                    4,
                                    this.signTransaction({
                                        transactionOrPayload: transaction
                                    })
                                ];
                            case 7:
                                signTransactionResponse = _state.sent();
                                return [
                                    4,
                                    this.submitTransaction({
                                        transaction: transaction,
                                        senderAuthenticator: signTransactionResponse.authenticator
                                    })
                                ];
                            case 8:
                                response = _state.sent();
                                return [
                                    2,
                                    {
                                        hash: response.hash
                                    }
                                ];
                            case 9:
                                error = _state.sent();
                                errMsg = generalizedErrorMessage(error);
                                throw new WalletSignAndSubmitMessageError(errMsg).message;
                            case 10:
                                return [
                                    2
                                ];
                        }
                    });
                }).call(this);
            }
        },
        {
            key: "signTransaction",
            value: /**
   * Signs a transaction
   *
   * This method supports 2 input types -
   * 1. A raw transaction that was already built by the dapp,
   * 2. A transaction data input as JSON. This is for the wallet to be able to simulate before signing
   *
   * @param transactionOrPayload AnyRawTransaction | InputTransactionData
   * @param asFeePayer optional. A flag indicates to sign the transaction as the fee payer
   * @param options optional. Transaction options
   *
   * @returns AccountAuthenticator
   */ function signTransaction(args) {
                return _async_to_generator(function() {
                    var transactionOrPayload, asFeePayer, _this__wallet_features_cedrasignTransaction, _this__wallet, response, _transactionOrPayload_options, _transactionOrPayload_options1, _transactionOrPayload_options2, _transactionOrPayload_options3, _transactionOrPayload_options4, _this__wallet1, signTransactionV1_1StandardInput, walletSignTransactionMethod, response1, _this__wallet2, cedraConfig, cedra, transaction, response2, error, errMsg;
                    return _ts_generator(this, function(_state) {
                        switch(_state.label){
                            case 0:
                                transactionOrPayload = args.transactionOrPayload, asFeePayer = args.asFeePayer;
                                _state.label = 1;
                            case 1:
                                _state.trys.push([
                                    1,
                                    9,
                                    ,
                                    10
                                ]);
                                this.ensureWalletExists(this._wallet);
                                this.ensureAccountExists(this._account);
                                this.recordEvent("sign_transaction");
                                if (!("rawTransaction" in transactionOrPayload)) return [
                                    3,
                                    3
                                ];
                                return [
                                    4,
                                    (_this__wallet = this._wallet) === null || _this__wallet === void 0 ? void 0 : _this__wallet.features["cedra:signTransaction"].signTransaction(transactionOrPayload, asFeePayer)
                                ];
                            case 2:
                                response = _state.sent();
                                if (response.status === UserResponseStatus.REJECTED) {
                                    throw new WalletConnectionError("User has rejected the request").message;
                                }
                                return [
                                    2,
                                    {
                                        authenticator: response.args,
                                        rawTransaction: transactionOrPayload.rawTransaction.bcsToBytes()
                                    }
                                ];
                            case 3:
                                if (!(((_this__wallet_features_cedrasignTransaction = this._wallet.features["cedra:signTransaction"]) === null || _this__wallet_features_cedrasignTransaction === void 0 ? void 0 : _this__wallet_features_cedrasignTransaction.version) === "1.1")) return [
                                    3,
                                    5
                                ];
                                signTransactionV1_1StandardInput = {
                                    payload: transactionOrPayload.data,
                                    expirationTimestamp: (_transactionOrPayload_options = transactionOrPayload.options) === null || _transactionOrPayload_options === void 0 ? void 0 : _transactionOrPayload_options.expirationTimestamp,
                                    expirationSecondsFromNow: (_transactionOrPayload_options1 = transactionOrPayload.options) === null || _transactionOrPayload_options1 === void 0 ? void 0 : _transactionOrPayload_options1.expirationSecondsFromNow,
                                    gasUnitPrice: (_transactionOrPayload_options2 = transactionOrPayload.options) === null || _transactionOrPayload_options2 === void 0 ? void 0 : _transactionOrPayload_options2.gasUnitPrice,
                                    maxGasAmount: (_transactionOrPayload_options3 = transactionOrPayload.options) === null || _transactionOrPayload_options3 === void 0 ? void 0 : _transactionOrPayload_options3.maxGasAmount,
                                    sequenceNumber: (_transactionOrPayload_options4 = transactionOrPayload.options) === null || _transactionOrPayload_options4 === void 0 ? void 0 : _transactionOrPayload_options4.accountSequenceNumber,
                                    sender: transactionOrPayload.sender ? {
                                        address: AccountAddress.from(transactionOrPayload.sender)
                                    } : void 0
                                };
                                walletSignTransactionMethod = (_this__wallet1 = this._wallet) === null || _this__wallet1 === void 0 ? void 0 : _this__wallet1.features["cedra:signTransaction"].signTransaction;
                                return [
                                    4,
                                    walletSignTransactionMethod(signTransactionV1_1StandardInput)
                                ];
                            case 4:
                                response1 = _state.sent();
                                if (response1.status === UserResponseStatus.REJECTED) {
                                    throw new WalletConnectionError("User has rejected the request").message;
                                }
                                return [
                                    2,
                                    {
                                        authenticator: response1.args.authenticator,
                                        rawTransaction: response1.args.rawTransaction.bcsToBytes()
                                    }
                                ];
                            case 5:
                                cedraConfig = getCedraConfig(this._network, this._dappConfig);
                                cedra = new Cedra2(cedraConfig);
                                return [
                                    4,
                                    cedra.transaction.build.simple({
                                        sender: this._account.address,
                                        data: transactionOrPayload.data,
                                        options: transactionOrPayload.options,
                                        withFeePayer: transactionOrPayload.withFeePayer
                                    })
                                ];
                            case 6:
                                transaction = _state.sent();
                                return [
                                    4,
                                    (_this__wallet2 = this._wallet) === null || _this__wallet2 === void 0 ? void 0 : _this__wallet2.features["cedra:signTransaction"].signTransaction(transaction, asFeePayer)
                                ];
                            case 7:
                                response2 = _state.sent();
                                if (response2.status === UserResponseStatus.REJECTED) {
                                    throw new WalletConnectionError("User has rejected the request").message;
                                }
                                return [
                                    2,
                                    {
                                        authenticator: response2.args,
                                        rawTransaction: transaction.bcsToBytes()
                                    }
                                ];
                            case 8:
                                return [
                                    3,
                                    10
                                ];
                            case 9:
                                error = _state.sent();
                                errMsg = generalizedErrorMessage(error);
                                throw new WalletSignTransactionError(errMsg).message;
                            case 10:
                                return [
                                    2
                                ];
                        }
                    });
                }).call(this);
            }
        },
        {
            key: "signMessage",
            value: /**
   * Sign a message (doesnt submit to chain).
   *
   * @param message - CedraSignMessageInput
   *
   * @return response from the wallet's signMessage function
   * @throws WalletSignMessageError
   */ function signMessage(message) {
                return _async_to_generator(function() {
                    var _this__wallet_features_cedrasignMessage, _this__wallet, response, error, errMsg;
                    return _ts_generator(this, function(_state) {
                        switch(_state.label){
                            case 0:
                                _state.trys.push([
                                    0,
                                    2,
                                    ,
                                    3
                                ]);
                                this.ensureWalletExists(this._wallet);
                                this.recordEvent("sign_message");
                                return [
                                    4,
                                    (_this__wallet = this._wallet) === null || _this__wallet === void 0 ? void 0 : (_this__wallet_features_cedrasignMessage = _this__wallet.features["cedra:signMessage"]) === null || _this__wallet_features_cedrasignMessage === void 0 ? void 0 : _this__wallet_features_cedrasignMessage.signMessage(message)
                                ];
                            case 1:
                                response = _state.sent();
                                if (response.status === UserResponseStatus.REJECTED) {
                                    throw new WalletConnectionError("User has rejected the request").message;
                                }
                                return [
                                    2,
                                    response.args
                                ];
                            case 2:
                                error = _state.sent();
                                errMsg = generalizedErrorMessage(error);
                                throw new WalletSignMessageError(errMsg).message;
                            case 3:
                                return [
                                    2
                                ];
                        }
                    });
                }).call(this);
            }
        },
        {
            key: "submitTransaction",
            value: /**
   * Submits transaction to chain
   *
   * @param transaction - InputSubmitTransactionData
   * @returns PendingTransactionResponse
   */ function submitTransaction(transaction) {
                return _async_to_generator(function() {
                    var additionalSignersAuthenticators, transactionType, cedraConfig, cedra, multiAgentTxn, errMsg;
                    return _ts_generator(this, function(_state) {
                        try {
                            this.ensureWalletExists(this._wallet);
                            additionalSignersAuthenticators = transaction.additionalSignersAuthenticators;
                            transactionType = additionalSignersAuthenticators !== void 0 ? "multi-agent" : "simple";
                            this.recordEvent("submit_transaction", {
                                transaction_type: transactionType
                            });
                            cedraConfig = getCedraConfig(this._network, this._dappConfig);
                            cedra = new Cedra2(cedraConfig);
                            if (additionalSignersAuthenticators !== void 0) {
                                multiAgentTxn = _object_spread_props(_object_spread({}, transaction), {
                                    additionalSignersAuthenticators: additionalSignersAuthenticators
                                });
                                return [
                                    2,
                                    cedra.transaction.submit.multiAgent(multiAgentTxn)
                                ];
                            } else {
                                return [
                                    2,
                                    cedra.transaction.submit.simple(transaction)
                                ];
                            }
                        } catch (error) {
                            errMsg = generalizedErrorMessage(error);
                            throw new WalletSubmitTransactionError(errMsg).message;
                        }
                        return [
                            2
                        ];
                    });
                }).call(this);
            }
        },
        {
            key: "onAccountChange",
            value: /**
   Event for when account has changed on the wallet
   @return the new account info
   @throws WalletAccountChangeError
   */ function onAccountChange() {
                return _async_to_generator(function() {
                    var _this, _this__wallet_features_cedraonAccountChange, error, errMsg;
                    return _ts_generator(this, function(_state) {
                        switch(_state.label){
                            case 0:
                                _this = this;
                                _state.label = 1;
                            case 1:
                                _state.trys.push([
                                    1,
                                    3,
                                    ,
                                    4
                                ]);
                                this.ensureWalletExists(this._wallet);
                                return [
                                    4,
                                    (_this__wallet_features_cedraonAccountChange = this._wallet.features["cedra:onAccountChange"]) === null || _this__wallet_features_cedraonAccountChange === void 0 ? void 0 : _this__wallet_features_cedraonAccountChange.onAccountChange(function(data) {
                                        return _async_to_generator(function() {
                                            return _ts_generator(this, function(_state) {
                                                switch(_state.label){
                                                    case 0:
                                                        this.setAccount(data);
                                                        return [
                                                            4,
                                                            this.setAnsName()
                                                        ];
                                                    case 1:
                                                        _state.sent();
                                                        this.recordEvent("account_change");
                                                        this.emit("accountChange", this._account);
                                                        return [
                                                            2
                                                        ];
                                                }
                                            });
                                        }).call(_this);
                                    })
                                ];
                            case 2:
                                _state.sent();
                                return [
                                    3,
                                    4
                                ];
                            case 3:
                                error = _state.sent();
                                errMsg = generalizedErrorMessage(error);
                                throw new WalletAccountChangeError(errMsg).message;
                            case 4:
                                return [
                                    2
                                ];
                        }
                    });
                }).call(this);
            }
        },
        {
            key: "onNetworkChange",
            value: /**
   Event for when network has changed on the wallet
   @return the new network info
   @throws WalletNetworkChangeError
   */ function onNetworkChange() {
                return _async_to_generator(function() {
                    var _this, _this__wallet_features_cedraonNetworkChange, error, errMsg;
                    return _ts_generator(this, function(_state) {
                        switch(_state.label){
                            case 0:
                                _this = this;
                                _state.label = 1;
                            case 1:
                                _state.trys.push([
                                    1,
                                    3,
                                    ,
                                    4
                                ]);
                                this.ensureWalletExists(this._wallet);
                                return [
                                    4,
                                    (_this__wallet_features_cedraonNetworkChange = this._wallet.features["cedra:onNetworkChange"]) === null || _this__wallet_features_cedraonNetworkChange === void 0 ? void 0 : _this__wallet_features_cedraonNetworkChange.onNetworkChange(function(data) {
                                        return _async_to_generator(function() {
                                            return _ts_generator(this, function(_state) {
                                                switch(_state.label){
                                                    case 0:
                                                        this.setNetwork(data);
                                                        return [
                                                            4,
                                                            this.setAnsName()
                                                        ];
                                                    case 1:
                                                        _state.sent();
                                                        this.emit("networkChange", this._network);
                                                        return [
                                                            2
                                                        ];
                                                }
                                            });
                                        }).call(_this);
                                    })
                                ];
                            case 2:
                                _state.sent();
                                return [
                                    3,
                                    4
                                ];
                            case 3:
                                error = _state.sent();
                                errMsg = generalizedErrorMessage(error);
                                throw new WalletNetworkChangeError(errMsg).message;
                            case 4:
                                return [
                                    2
                                ];
                        }
                    });
                }).call(this);
            }
        },
        {
            key: "changeNetwork",
            value: /**
   * Sends a change network request to the wallet to change the connected network
   *
   * @param network - Network
   * @returns CedraChangeNetworkOutput
   */ function changeNetwork(network) {
                return _async_to_generator(function() {
                    var _this__network, chainId, _tmp, networkInfo, response, error, errMsg;
                    return _ts_generator(this, function(_state) {
                        switch(_state.label){
                            case 0:
                                _state.trys.push([
                                    0,
                                    6,
                                    ,
                                    7
                                ]);
                                this.ensureWalletExists(this._wallet);
                                this.recordEvent("change_network_request", {
                                    from: (_this__network = this._network) === null || _this__network === void 0 ? void 0 : _this__network.name,
                                    to: network
                                });
                                if (!(network === Network3.DEVNET)) return [
                                    3,
                                    2
                                ];
                                return [
                                    4,
                                    fetchDevnetChainId()
                                ];
                            case 1:
                                _tmp = _state.sent();
                                return [
                                    3,
                                    3
                                ];
                            case 2:
                                _tmp = NetworkToChainId[network];
                                _state.label = 3;
                            case 3:
                                chainId = _tmp;
                                networkInfo = {
                                    name: network,
                                    chainId: chainId
                                };
                                if (!this._wallet.features["cedra:changeNetwork"]) return [
                                    3,
                                    5
                                ];
                                return [
                                    4,
                                    this._wallet.features["cedra:changeNetwork"].changeNetwork(networkInfo)
                                ];
                            case 4:
                                response = _state.sent();
                                if (response.status === UserResponseStatus.REJECTED) {
                                    throw new WalletConnectionError("User has rejected the request").message;
                                }
                                return [
                                    2,
                                    response.args
                                ];
                            case 5:
                                throw new WalletChangeNetworkError("".concat(this._wallet.name, " does not support changing network request")).message;
                            case 6:
                                error = _state.sent();
                                errMsg = generalizedErrorMessage(error);
                                throw new WalletChangeNetworkError(errMsg).message;
                            case 7:
                                return [
                                    2
                                ];
                        }
                    });
                }).call(this);
            }
        },
        {
            key: "signMessageAndVerify",
            value: /**
   * Signs a message and verifies the signer
   * @param message - CedraSignMessageInput
   * @returns boolean
   */ function signMessageAndVerify(message) {
                return _async_to_generator(function() {
                    var response, cedraConfig, signingMessage, error, errMsg;
                    return _ts_generator(this, function(_state) {
                        switch(_state.label){
                            case 0:
                                _state.trys.push([
                                    0,
                                    4,
                                    ,
                                    5
                                ]);
                                this.ensureWalletExists(this._wallet);
                                this.ensureAccountExists(this._account);
                                this.recordEvent("sign_message_and_verify");
                                return [
                                    4,
                                    this._wallet.features["cedra:signMessage"].signMessage(message)
                                ];
                            case 1:
                                response = _state.sent();
                                if (response.status === UserResponseStatus.REJECTED) {
                                    throw new WalletConnectionError("Failed to sign a message").message;
                                }
                                cedraConfig = getCedraConfig(this._network, this._dappConfig);
                                signingMessage = new TextEncoder().encode(response.args.fullMessage);
                                if (!("verifySignatureAsync" in this._account.publicKey)) return [
                                    3,
                                    3
                                ];
                                return [
                                    4,
                                    this._account.publicKey.verifySignatureAsync({
                                        cedraConfig: cedraConfig,
                                        message: signingMessage,
                                        signature: response.args.signature,
                                        options: {
                                            throwErrorWithReason: true
                                        }
                                    })
                                ];
                            case 2:
                                return [
                                    2,
                                    _state.sent()
                                ];
                            case 3:
                                return [
                                    2,
                                    this._account.publicKey.verifySignature({
                                        message: signingMessage,
                                        signature: response.args.signature
                                    })
                                ];
                            case 4:
                                error = _state.sent();
                                errMsg = generalizedErrorMessage(error);
                                throw new WalletSignMessageAndVerifyError(errMsg).message;
                            case 5:
                                return [
                                    2
                                ];
                        }
                    });
                }).call(this);
            }
        }
    ]);
    return WalletCore;
}(EventEmitter);
// src/index.ts
if (typeof window !== "undefined") {
    window.WALLET_ADAPTER_CORE_VERSION = WALLET_ADAPTER_CORE_VERSION;
}
export { CEDRA_CONNECT_ACCOUNT_URL, CEDRA_CONNECT_BASE_URL, ChainIdToAnsSupportedNetworkMap, NetworkName, WalletCore, WalletReadyState, cedraStandardSupportedWalletList, convertNetwork, fetchDevnetChainId, generalizedErrorMessage, getCedraConfig, getCedraConnectWallets, getLocalStorage, getSDKWallets, groupAndSortWallets, handlePublishPackageTransaction, isCedraConnectWallet, isCedraLiveNetwork, isCedraNetwork, isInAppBrowser, isInstallRequired, isInstalledOrLoadable, isMobile, isRedirectable, partitionWallets, removeLocalStorage, setLocalStorage, truncateAddress };
