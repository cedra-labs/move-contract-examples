"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _createStarExport(obj) { Object.keys(obj) .filter((key) => key !== "default" && key !== "__esModule") .forEach((key) => { if (exports.hasOwnProperty(key)) { return; } Object.defineProperty(exports, key, {enumerable: true, configurable: true, get: () => obj[key]}); }); } function _nullishCoalesce(lhs, rhsFn) { if (lhs != null) { return lhs; } else { return rhsFn(); } } function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }var _core = require('@wallet-standard/core'); _createStarExport(_core);var _tssdk = require('@cedra-labs/ts-sdk');var C=class o extends _tssdk.Serializable{constructor({address:e,publicKey:r,ansName:t}){super(),this.address=_tssdk.AccountAddress.from(e),this.publicKey=r,this.ansName=t}serialize(e){if(this.address.serialize(e),this.publicKey instanceof _tssdk.Ed25519PublicKey)e.serializeU32AsUleb128(_tssdk.SigningScheme.Ed25519);else if(this.publicKey instanceof _tssdk.MultiEd25519PublicKey)e.serializeU32AsUleb128(_tssdk.SigningScheme.MultiEd25519);else if(this.publicKey instanceof _tssdk.AnyPublicKey)e.serializeU32AsUleb128(_tssdk.SigningScheme.SingleKey);else if(this.publicKey instanceof _tssdk.MultiKey)e.serializeU32AsUleb128(_tssdk.SigningScheme.MultiKey);else throw new Error("Unsupported public key");this.publicKey.serialize(e),e.serializeStr(_nullishCoalesce(this.ansName, () => ("")))}static deserialize(e){let r=_tssdk.AccountAddress.deserialize(e),t=e.deserializeUleb128AsU32(),n;switch(t){case _tssdk.SigningScheme.Ed25519:n=_tssdk.Ed25519PublicKey.deserialize(e);break;case _tssdk.SigningScheme.MultiEd25519:n=_tssdk.MultiEd25519PublicKey.deserialize(e);break;case _tssdk.SigningScheme.SingleKey:n=_tssdk.AnyPublicKey.deserialize(e);break;case _tssdk.SigningScheme.MultiKey:n=_tssdk.MultiKey.deserialize(e);break;default:throw new Error(`Unknown variant index for WrappedPublicKey: ${t}`)}let s=e.deserializeStr()||void 0;return new o({address:r,publicKey:n,ansName:s})}};var A="cedra:devnet",y= exports.CEDRA_TESTNET_CHAIN ="cedra:testnet",x= exports.CEDRA_LOCALNET_CHAIN ="cedra:localnet",h= exports.CEDRA_MAINNET_CHAIN ="cedra:mainnet",R= exports.CEDRA_CHAINS =[A,y,x,h];var N=["cedra:account","cedra:connect","cedra:disconnect","cedra:network","cedra:onAccountChange","cedra:onNetworkChange","cedra:signMessage","cedra:signTransaction"];function I(o,e=[]){return[...N,...e].every(r=>r in o.features)}function W(){let{get:o,on:e}=_core.getWallets.call(void 0, ),r=o(),t=[];return r.map(n=>{I(n)&&t.push(n)}),{cedraWallets:t,on:e}}var S=(t=>(t[t.Unauthorized=4100]="Unauthorized",t[t.Unsupported=4200]="Unsupported",t[t.InternalError=-30001]="InternalError",t))(S||{}),g= exports.CedraWalletErrors =Object.freeze({4100:{status:"Unauthorized",message:"The requested method and/or account has not been authorized by the user."},[-30001]:{status:"Internal error",message:"Something went wrong within the wallet."},4200:{status:"Unsupported",message:"The requested feature is not supported."}}),m= exports.CedraWalletError =class o extends Error{constructor(e,r){super(_nullishCoalesce(_nullishCoalesce(r, () => (_optionalChain([g, 'access', _2 => _2[e], 'optionalAccess', _3 => _3.message]))), () => ("Unknown error occurred"))),this.code=e,this.status=_nullishCoalesce(_optionalChain([g, 'access', _4 => _4[e], 'optionalAccess', _5 => _5.status]), () => ("Unknown error")),this.name="CedraWalletError",Object.setPrototypeOf(this,o.prototype)}};var _="cedra:signAndSubmitTransaction";var z="cedra:signMessage";var H="cedra:account";var j="cedra:connect";var J="cedra:network";var Q="cedra:onAccountChange";var Y="cedra:onNetworkChange";var ee="cedra:changeNetwork";var re="cedra:disconnect";var ae="cedra:signTransaction";var se="cedra:openInMobileApp";var pe="cedra:signIn";var w=(r=>(r.APPROVED="Approved",r.REJECTED="Rejected",r))(w||{});exports.AccountInfo = C; exports.CEDRA_CHAINS = R; exports.CEDRA_DEVNET_CHAIN = A; exports.CEDRA_LOCALNET_CHAIN = x; exports.CEDRA_MAINNET_CHAIN = h; exports.CEDRA_TESTNET_CHAIN = y; exports.CedraChangeNetworkNamespace = ee; exports.CedraConnectNamespace = j; exports.CedraDisconnectNamespace = re; exports.CedraGetAccountNamespace = H; exports.CedraGetNetworkNamespace = J; exports.CedraOnAccountChangeNamespace = Q; exports.CedraOnNetworkChangeNamespace = Y; exports.CedraOpenInMobileAppNamespace = se; exports.CedraSignAndSubmitTransactionNamespace = _; exports.CedraSignInNamespace = pe; exports.CedraSignMessageNamespace = z; exports.CedraSignTransactionNamespace = ae; exports.CedraWalletError = m; exports.CedraWalletErrorCode = S; exports.CedraWalletErrors = g; exports.UserResponseStatus = w; exports.getCedraWallets = W; exports.isWalletWithRequiredFeatureSet = I;
//# sourceMappingURL=index.js.map