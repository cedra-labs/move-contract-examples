{"version":3,"sources":["/home/egor/Desktop/work/cedra-wallet-adapter/packages/wallet-adapter-core/dist/index.mjs","../src/version.ts","../src/WalletCore.ts","../src/ga/index.ts","../src/error/index.ts","../src/constants.ts","../src/utils/helpers.ts","../src/utils/localStorage.ts","../src/utils/walletSelector.ts","../src/registry.ts","../src/sdkWallets.ts"],"names":["WALLET_ADAPTER_CORE_VERSION","EventEmitter","AccountAddress","Cedra","Network","NetworkToChainId","getCedraWallets","isWalletWithRequiredFeatureSet","UserResponseStatus","GA4","cedraGAID","injectGA","gtag","a","b","c","dataLayer","window","push","arguments","gaID","head","document","getElementsByTagName","myScript","createElement","setAttribute","that","onload","Date","send_page_view","insertBefore","children","WalletError","message","error","Error","WalletNotSelectedError","WalletNotReadyError","name","WalletConnectionError","WalletDisconnectionError","WalletAccountError","WalletGetNetworkError","WalletAccountChangeError","WalletNetworkChangeError","WalletNotConnectedError","WalletSignMessageError","WalletSignMessageAndVerifyError","WalletSignAndSubmitMessageError","WalletSignTransactionError","WalletNotSupportedMethod","WalletChangeNetworkError","WalletSubmitTransactionError","WalletNotFoundError","WalletReadyState","NetworkName","ChainIdToAnsSupportedNetworkMap","CedraConfig","isMobile","isIphone","isAndroid","CEDRA_CONNECT_BASE_URL","CEDRA_CONNECT_ACCOUNT_URL","Hex","NetworkToNodeAPI","isInAppBrowser","test","navigator","userAgent","isCedraNetwork","networkInfo","currentNetwork","convertNetwork","isCedraLiveNetwork","apiKey","dappConfig","cedraApiKeys","network","clientConfig","API_KEY","knownNetworks","isKnownNetwork","Object","values","includes","url","CUSTOM","fullnode","fetchDevnetChainId","cedra","getChainId","handlePublishPackageTransaction","transactionInput","metadataBytes","data","functionArguments","fromHexInput","toUint8Array","byte","MAINNET","TESTNET","DEVNET","LOCAL","setLocalStorage","localStorage","removeItem","LOCAL_STORAGE_ITEM_KEY","getLocalStorage","getItem","moreWallets","walletName","setItem","removeLocalStorage","partitionWallets","wallets","partitionFunction","isInstalledOrLoadable","defaultWallets","wallet","readyState","isInstallRequired","isWalletReady","isRedirectable","truncateAddress","address","slice","isCedraConnectWallet","startsWith","getCedraConnectWallets","cedraConnectWallets","otherWallets","groupAndSortWallets","options","sortCedraConnectWallets","sort","sortAvailableWallets","availableWallets","installableWallets","cedraStandardSupportedWalletList","icon","isAIP62Standard","deeplinkProvider","sdkWallets","CedraConnectGoogleWallet","cedraConnect","CedraConnectAppleWallet","dappId","cedraConnectDappId","WalletCore","fetchExtensionAIP62CedraWallets","_disableTelemetry","_sdkWallets","getSDKWallets","_dappConfig","setExtensionAIP62Wallets","removeUnregisterListener","_standard_wallets","_network","_connected","_connecting","_account","_optInWallets","ga4","optInWallets","disableTelemetry","fetchSDKAIP62CedraWallets","appendNotDetectedStandardSupportedWallets","cedraWallets","on","removeRegisterListener","extensionwWallets","map","excludeWallet","filter","item","emit","isValid","existingStandardWallet","find","supportedWallet","_standard_not_detected_wallets","length","recordEvent","eventName","additionalInfo","ensureWalletExists","ensureAccountExists","setAnsName","account","cedraConfig","chainId","ansName","ans","getPrimaryName","console","log","clearData","setWallet","setAccount","setNetwork","_wallet","isConnected"],"mappings":"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","sourcesContent":["// src/version.ts\nvar WALLET_ADAPTER_CORE_VERSION = \"5.5.4\";\n\n// src/WalletCore.ts\nimport EventEmitter from \"eventemitter3\";\nimport {\n  AccountAddress,\n  Cedra as Cedra2,\n  Network as Network3,\n  NetworkToChainId\n} from \"@cedra-labs/ts-sdk\";\nimport {\n  getCedraWallets,\n  isWalletWithRequiredFeatureSet,\n  UserResponseStatus\n} from \"@cedra-labs/wallet-standard\";\n\n// src/ga/index.ts\nvar GA4 = class {\n  constructor() {\n    this.cedraGAID = true;\n    this.injectGA(this.cedraGAID);\n  }\n  gtag(a, b, c) {\n    let dataLayer = window.dataLayer || [];\n    dataLayer.push(arguments);\n  }\n  injectGA(gaID) {\n    if (typeof window === \"undefined\") return;\n    if (!gaID) return;\n    const head = document.getElementsByTagName(\"head\")[0];\n    var myScript = document.createElement(\"script\");\n    myScript.setAttribute(\n      \"src\",\n      `https://www.googletagmanager.com/gtag/js?id=${gaID}`\n    );\n    const that = this;\n    myScript.onload = function() {\n      that.gtag(\"js\", /* @__PURE__ */ new Date());\n      that.gtag(\"config\", `${gaID}`, {\n        send_page_view: false\n      });\n    };\n    head.insertBefore(myScript, head.children[1]);\n  }\n};\n\n// src/error/index.ts\nvar WalletError = class extends Error {\n  constructor(message, error) {\n    super(message);\n    this.error = error;\n  }\n};\nvar WalletNotSelectedError = class extends WalletError {\n  constructor() {\n    super(...arguments);\n    this.name = \"WalletNotSelectedError\";\n  }\n};\nvar WalletNotReadyError = class extends WalletError {\n  constructor() {\n    super(...arguments);\n    this.name = \"WalletNotReadyError\";\n  }\n};\nvar WalletConnectionError = class extends WalletError {\n  constructor() {\n    super(...arguments);\n    this.name = \"WalletConnectionError\";\n  }\n};\nvar WalletDisconnectionError = class extends WalletError {\n  constructor() {\n    super(...arguments);\n    this.name = \"WalletDisconnectionError\";\n  }\n};\nvar WalletAccountError = class extends WalletError {\n  constructor() {\n    super(...arguments);\n    this.name = \"WalletAccountError\";\n  }\n};\nvar WalletGetNetworkError = class extends WalletError {\n  constructor() {\n    super(...arguments);\n    this.name = \"WalletGetNetworkError\";\n  }\n};\nvar WalletAccountChangeError = class extends WalletError {\n  constructor() {\n    super(...arguments);\n    this.name = \"WalletAccountChangeError\";\n  }\n};\nvar WalletNetworkChangeError = class extends WalletError {\n  constructor() {\n    super(...arguments);\n    this.name = \"WalletNetworkChangeError\";\n  }\n};\nvar WalletNotConnectedError = class extends WalletError {\n  constructor() {\n    super(...arguments);\n    this.name = \"WalletNotConnectedError\";\n  }\n};\nvar WalletSignMessageError = class extends WalletError {\n  constructor() {\n    super(...arguments);\n    this.name = \"WalletSignMessageError\";\n  }\n};\nvar WalletSignMessageAndVerifyError = class extends WalletError {\n  constructor() {\n    super(...arguments);\n    this.name = \"WalletSignMessageAndVerifyError\";\n  }\n};\nvar WalletSignAndSubmitMessageError = class extends WalletError {\n  constructor() {\n    super(...arguments);\n    this.name = \"WalletSignAndSubmitMessageError\";\n  }\n};\nvar WalletSignTransactionError = class extends WalletError {\n  constructor() {\n    super(...arguments);\n    this.name = \"WalletSignTransactionError\";\n  }\n};\nvar WalletNotSupportedMethod = class extends WalletError {\n  constructor() {\n    super(...arguments);\n    this.name = \"WalletNotSupportedMethod\";\n  }\n};\nvar WalletChangeNetworkError = class extends WalletError {\n  constructor() {\n    super(...arguments);\n    this.name = \"WalletChangeNetworkError\";\n  }\n};\nvar WalletSubmitTransactionError = class extends WalletError {\n  constructor() {\n    super(...arguments);\n    this.name = \"WalletSubmitTransactionError\";\n  }\n};\nvar WalletNotFoundError = class extends WalletError {\n  constructor() {\n    super(...arguments);\n    this.name = \"WalletNotFoundError\";\n  }\n};\n\n// src/constants.ts\nvar WalletReadyState = /* @__PURE__ */ ((WalletReadyState2) => {\n  WalletReadyState2[\"Installed\"] = \"Installed\";\n  WalletReadyState2[\"NotDetected\"] = \"NotDetected\";\n  return WalletReadyState2;\n})(WalletReadyState || {});\nvar NetworkName = /* @__PURE__ */ ((NetworkName2) => {\n  NetworkName2[\"Mainnet\"] = \"mainnet\";\n  NetworkName2[\"Testnet\"] = \"testnet\";\n  NetworkName2[\"Devnet\"] = \"devnet\";\n  return NetworkName2;\n})(NetworkName || {});\nvar ChainIdToAnsSupportedNetworkMap = {\n  \"1\": \"mainnet\",\n  // mainnet\n  \"2\": \"testnet\"\n  // testnet\n};\nvar CEDRA_CONNECT_BASE_URL = \"https://cedraconnect.app\";\nvar CEDRA_CONNECT_ACCOUNT_URL = \"https://cedraconnect.app/dashboard/main-account\";\n\n// src/utils/helpers.ts\nimport {\n  Cedra,\n  CedraConfig,\n  Hex,\n  Network,\n  NetworkToNodeAPI\n} from \"@cedra-labs/ts-sdk\";\nfunction isMobile() {\n  return /Mobile|iP(hone|od|ad)|Android|BlackBerry|IEMobile|Kindle|NetFront|Silk-Accelerated|(hpw|web)OS|Fennec|Minimo|Opera M(obi|ini)|Blazer|Dolfin|Dolphin|Skyfire|Zune/i.test(\n    navigator.userAgent\n  );\n}\nfunction isInAppBrowser() {\n  const isIphone = /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(\n    navigator.userAgent\n  );\n  const isAndroid = /(Android).*Version\\/[\\d.]+.*Chrome\\/[^\\s]+ Mobile/i.test(\n    navigator.userAgent\n  );\n  return isIphone || isAndroid;\n}\nfunction isRedirectable() {\n  if (typeof navigator === \"undefined\" || !navigator) return false;\n  return isMobile() && !isInAppBrowser();\n}\nfunction generalizedErrorMessage(error) {\n  return typeof error === \"object\" && \"message\" in error ? error.message : error;\n}\nvar getCedraConfig = (networkInfo, dappConfig) => {\n  if (!networkInfo) {\n    throw new Error(\"Undefined network\");\n  }\n  if (isCedraNetwork(networkInfo)) {\n    const currentNetwork = convertNetwork(networkInfo);\n    if (isCedraLiveNetwork(currentNetwork)) {\n      const apiKey = dappConfig?.cedraApiKeys;\n      return new CedraConfig({\n        network: currentNetwork,\n        clientConfig: { API_KEY: apiKey ? apiKey[currentNetwork] : void 0 }\n      });\n    }\n    return new CedraConfig({\n      network: currentNetwork\n    });\n  }\n  const knownNetworks = {\n    okx: \"https://wallet.okx.com/fullnode/cedra/discover/rpc\"\n  };\n  if (networkInfo.url) {\n    const isKnownNetwork = Object.values(knownNetworks).includes(\n      networkInfo.url\n    );\n    if (isKnownNetwork) {\n      return new CedraConfig({\n        network: Network.CUSTOM,\n        fullnode: networkInfo.url\n      });\n    }\n  }\n  throw new Error(\n    `Invalid network, network ${networkInfo.name} not supported with Cedra wallet adapter to prevent user from using an unexpected network.`\n  );\n};\nvar isCedraNetwork = (networkInfo) => {\n  if (!networkInfo) {\n    throw new Error(\"Undefined network\");\n  }\n  return NetworkToNodeAPI[networkInfo.name] !== void 0;\n};\nvar isCedraLiveNetwork = (networkInfo) => {\n  return networkInfo === \"devnet\" || networkInfo === \"testnet\" || networkInfo === \"mainnet\";\n};\nvar fetchDevnetChainId = async () => {\n  const cedra = new Cedra();\n  return await cedra.getChainId();\n};\nvar handlePublishPackageTransaction = (transactionInput) => {\n  let metadataBytes = transactionInput.data.functionArguments[0];\n  if (typeof metadataBytes === \"string\") {\n    metadataBytes = Hex.fromHexInput(metadataBytes).toUint8Array();\n  }\n  let byteCode = transactionInput.data.functionArguments[1];\n  if (Array.isArray(byteCode)) {\n    byteCode = byteCode.map((byte) => {\n      if (typeof byte === \"string\") {\n        return Hex.fromHexInput(byte).toUint8Array();\n      }\n      return byte;\n    });\n  } else {\n    throw new WalletSignAndSubmitMessageError(\n      \"The bytecode argument must be an array.\"\n    ).message;\n  }\n  return { metadataBytes, byteCode };\n};\nfunction convertNetwork(networkInfo) {\n  switch (networkInfo?.name) {\n    case \"mainnet\":\n      return Network.MAINNET;\n    case \"testnet\":\n      return Network.TESTNET;\n    case \"devnet\":\n      return Network.DEVNET;\n    case \"local\":\n      return Network.LOCAL;\n    default:\n      throw new Error(\"Invalid Cedra network name\");\n  }\n}\n\n// src/utils/localStorage.ts\nvar LOCAL_STORAGE_ITEM_KEY = \"CedraWalletName\";\nfunction setLocalStorage(walletName) {\n  localStorage.setItem(LOCAL_STORAGE_ITEM_KEY, walletName);\n}\nfunction removeLocalStorage() {\n  localStorage.removeItem(LOCAL_STORAGE_ITEM_KEY);\n}\nfunction getLocalStorage() {\n  localStorage.getItem(LOCAL_STORAGE_ITEM_KEY);\n}\n\n// src/utils/walletSelector.ts\nfunction partitionWallets(wallets, partitionFunction = isInstalledOrLoadable) {\n  const defaultWallets = [];\n  const moreWallets = [];\n  for (const wallet of wallets) {\n    if (partitionFunction(wallet)) defaultWallets.push(wallet);\n    else moreWallets.push(wallet);\n  }\n  return { defaultWallets, moreWallets };\n}\nfunction isInstalledOrLoadable(wallet) {\n  return wallet.readyState === \"Installed\" /* Installed */;\n}\nfunction isInstallRequired(wallet) {\n  const isWalletReady = isInstalledOrLoadable(wallet);\n  const isMobile2 = !isWalletReady && isRedirectable();\n  return !isMobile2 && !isWalletReady;\n}\nfunction truncateAddress(address) {\n  if (!address) return;\n  return `${address.slice(0, 6)}...${address.slice(-5)}`;\n}\nfunction isCedraConnectWallet(wallet) {\n  if (!wallet.url) return false;\n  return wallet.url.startsWith(CEDRA_CONNECT_BASE_URL);\n}\nfunction getCedraConnectWallets(wallets) {\n  const { defaultWallets, moreWallets } = partitionWallets(\n    wallets,\n    isCedraConnectWallet\n  );\n  return { cedraConnectWallets: defaultWallets, otherWallets: moreWallets };\n}\nfunction groupAndSortWallets(wallets, options) {\n  const { cedraConnectWallets, otherWallets } = getCedraConnectWallets(wallets);\n  const { defaultWallets, moreWallets } = partitionWallets(otherWallets);\n  if (options?.sortCedraConnectWallets) {\n    cedraConnectWallets.sort(options.sortCedraConnectWallets);\n  }\n  if (options?.sortAvailableWallets) {\n    defaultWallets.sort(options.sortAvailableWallets);\n  }\n  if (options?.sortInstallableWallets) {\n    moreWallets.sort(options.sortInstallableWallets);\n  }\n  return {\n    /** Wallets that use social login to create an account on the blockchain */\n    cedraConnectWallets,\n    /** Wallets that are currently installed or loadable. */\n    availableWallets: defaultWallets,\n    /** Wallets that are NOT currently installed or loadable. */\n    installableWallets: moreWallets\n  };\n}\n\n// src/registry.ts\nvar cedraStandardSupportedWalletList = [\n  {\n    name: \"Nightly\",\n    url: \"https://nightly.app/\",\n    icon: \"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4NCjwhLS0gR2VuZXJhdG9yOiBBZG9iZSBJbGx1c3RyYXRvciAyOC4wLjAsIFNWRyBFeHBvcnQgUGx1Zy1JbiAuIFNWRyBWZXJzaW9uOiA2LjAwIEJ1aWxkIDApICAtLT4NCjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iV2Fyc3R3YV8xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4PSIwcHgiIHk9IjBweCINCgkgdmlld0JveD0iMCAwIDg1MS41IDg1MS41IiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCA4NTEuNSA4NTEuNTsiIHhtbDpzcGFjZT0icHJlc2VydmUiPg0KPHN0eWxlIHR5cGU9InRleHQvY3NzIj4NCgkuc3Qwe2ZpbGw6IzYwNjdGOTt9DQoJLnN0MXtmaWxsOiNGN0Y3Rjc7fQ0KPC9zdHlsZT4NCjxnPg0KCTxnIGlkPSJXYXJzdHdhXzJfMDAwMDAwMTQ2MDk2NTQyNTMxODA5NDY0NjAwMDAwMDg2NDc4NTIwMDIxMTY5MTg2ODhfIj4NCgkJPHBhdGggY2xhc3M9InN0MCIgZD0iTTEyNCwwaDYwMy42YzY4LjUsMCwxMjQsNTUuNSwxMjQsMTI0djYwMy42YzAsNjguNS01NS41LDEyNC0xMjQsMTI0SDEyNGMtNjguNSwwLTEyNC01NS41LTEyNC0xMjRWMTI0DQoJCQlDMCw1NS41LDU1LjUsMCwxMjQsMHoiLz4NCgk8L2c+DQoJPGcgaWQ9IldhcnN0d2FfMyI+DQoJCTxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik02MjMuNSwxNzAuM2MtMzcuNCw1Mi4yLTg0LjIsODguNC0xMzkuNSwxMTIuNmMtMTkuMi01LjMtMzguOS04LTU4LjMtNy44Yy0xOS40LTAuMi0zOS4xLDIuNi01OC4zLDcuOA0KCQkJYy01NS4zLTI0LjMtMTAyLjEtNjAuMy0xMzkuNS0xMTIuNmMtMTEuMywyOC40LTU0LjgsMTI2LjQtMi42LDI2My40YzAsMC0xNi43LDcxLjUsMTQsMTMyLjljMCwwLDQ0LjQtMjAuMSw3OS43LDguMg0KCQkJYzM2LjksMjkuOSwyNS4xLDU4LjcsNTEuMSw4My41YzIyLjQsMjIuOSw1NS43LDIyLjksNTUuNywyMi45czMzLjMsMCw1NS43LTIyLjhjMjYtMjQuNywxNC4zLTUzLjUsNTEuMS04My41DQoJCQljMzUuMi0yOC4zLDc5LjctOC4yLDc5LjctOC4yYzMwLjYtNjEuNCwxNC0xMzIuOSwxNC0xMzIuOUM2NzguMywyOTYuNyw2MzQuOSwxOTguNyw2MjMuNSwxNzAuM3ogTTI1My4xLDQxNC44DQoJCQljLTI4LjQtNTguMy0zNi4yLTEzOC4zLTE4LjMtMjAxLjVjMjMuNyw2MCw1NS45LDg2LjksOTQuMiwxMTUuM0MzMTIuOCwzNjIuMywyODIuMywzOTQuMSwyNTMuMSw0MTQuOHogTTMzNC44LDUxNy41DQoJCQljLTIyLjQtOS45LTI3LjEtMjkuNC0yNy4xLTI5LjRjMzAuNS0xOS4yLDc1LjQtNC41LDc2LjgsNDAuOUMzNjAuOSw1MTQuNywzNTMsNTI1LjQsMzM0LjgsNTE3LjV6IE00MjUuNyw2NzguNw0KCQkJYy0xNiwwLTI5LTExLjUtMjktMjUuNnMxMy0yNS42LDI5LTI1LjZzMjksMTEuNSwyOSwyNS42QzQ1NC43LDY2Ny4zLDQ0MS43LDY3OC43LDQyNS43LDY3OC43eiBNNTE2LjcsNTE3LjUNCgkJCWMtMTguMiw4LTI2LTIuOC00OS43LDExLjVjMS41LTQ1LjQsNDYuMi02MC4xLDc2LjgtNDAuOUM1NDMuOCw0ODgsNTM5LDUwNy42LDUxNi43LDUxNy41eiBNNTk4LjMsNDE0LjgNCgkJCWMtMjkuMS0yMC43LTU5LjctNTIuNC03Ni04Ni4yYzM4LjMtMjguNCw3MC42LTU1LjQsOTQuMi0xMTUuM0M2MzQuNiwyNzYuNSw2MjYuOCwzNTYuNiw1OTguMyw0MTQuOHoiLz4NCgk8L2c+DQo8L2c+DQo8L3N2Zz4NCg==\",\n    readyState: \"NotDetected\" /* NotDetected */,\n    isAIP62Standard: true,\n    deeplinkProvider: \"nightly://v1?network=cedra&url=\"\n  },\n  {\n    name: \"Zedra\",\n    url: \"https://chromewebstore.google.com/detail/zedra-wallet/pbeefngmcchkcibdodceimammkigfanl\",\n    icon: \"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyBpZD0iTGF5ZXJfMiIgZGF0YS1uYW1lPSJMYXllciAyIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDgwIDEwODAiPgogIDxkZWZzPgogICAgPHN0eWxlPgogICAgICAuY2xzLTEgewogICAgICAgIGZpbGw6ICNiOGZmZGU7CiAgICAgIH0KICAgIDwvc3R5bGU+CiAgPC9kZWZzPgogIDxnIGlkPSJMYXllcl8xLTIiIGRhdGEtbmFtZT0iTGF5ZXIgMSI+CiAgICA8cmVjdCBjbGFzcz0iY2xzLTEiIHdpZHRoPSIxMDgwIiBoZWlnaHQ9IjEwODAiIHJ4PSIxMjAuNTQiIHJ5PSIxMjAuNTQiLz4KICAgIDxnPgogICAgICA8cGF0aCBkPSJtMzIyLjQ3LDIxOS4xMWgzNTMuNDdjMTMuMzgsMCwyNS42Miw3LjUxLDMxLjY5LDE5LjQzbDExMC43OSwyMTcuNjljNi43NiwxMy4yOCw0LjUyLDI5LjM3LTUuNjEsNDAuM2wtMTE5LjU0LDEyOWMtMTMuNDYsMTQuNTMtMzYuMiwxNS4yNi01MC41NywxLjYybC03Ny41Ni03My42NGMtMTQuNDYtMTMuNzMtMTQuOC0zNi42Ni0uNzctNTAuODJsNDIuOTYtNDMuMzVjMjIuMjgtMjIuNDgsNi4yOS02MC42OS0yNS4zNi02MC41OWwtMjU5LjQuNzljLTE5LjY4LjA2LTM1LjY3LTE1Ljg4LTM1LjY3LTM1LjU2di0xMDkuMzFjMC0xOS42NCwxNS45Mi0zNS41NiwzNS41Ni0zNS41NloiLz4KICAgICAgPHBhdGggZD0ibTc1Ny41Myw4NjAuODloLTM1My40N2MtMTMuMzgsMC0yNS42Mi03LjUxLTMxLjY5LTE5LjQzbC0xMTAuNzktMjE3LjY5Yy02Ljc2LTEzLjI4LTQuNTItMjkuMzcsNS42MS00MC4zbDExOS41NC0xMjljMTMuNDYtMTQuNTMsMzYuMi0xNS4yNiw1MC41Ny0xLjYybDc3LjU2LDczLjY0YzE0LjQ2LDEzLjczLDE0LjgsMzYuNjYuNzcsNTAuODJsLTQyLjk2LDQzLjM1Yy0yMi4yOCwyMi40OC02LjI5LDYwLjY5LDI1LjM2LDYwLjU5bDI1OS40LS43OWMxOS42OC0uMDYsMzUuNjcsMTUuODgsMzUuNjcsMzUuNTZ2MTA5LjMxYzAsMTkuNjQtMTUuOTIsMzUuNTYtMzUuNTYsMzUuNTZaIi8+CiAgICA8L2c+CiAgPC9nPgo8L3N2Zz4=\",\n    readyState: \"NotDetected\" /* NotDetected */,\n    isAIP62Standard: true,\n    deeplinkProvider: \"https://zedra.app/\"\n  }\n];\n\n// src/sdkWallets.ts\nimport {\n  CedraConnectAppleWallet,\n  CedraConnectGoogleWallet\n} from \"@cedra-labs/wallet-adapter-plugin\";\nimport { Network as Network2 } from \"@cedra-labs/ts-sdk\";\nfunction getSDKWallets(dappConfig) {\n  const sdkWallets = [];\n  if (typeof window !== \"undefined\") {\n    sdkWallets.push(\n      new CedraConnectGoogleWallet({\n        network: dappConfig?.network,\n        dappId: dappConfig?.cedraConnectDappId,\n        ...dappConfig?.cedraConnect\n      }),\n      new CedraConnectAppleWallet({\n        network: dappConfig?.network,\n        dappId: dappConfig?.cedraConnectDappId,\n        ...dappConfig?.cedraConnect\n      })\n    );\n  }\n  if (dappConfig?.network === Network2.MAINNET) {\n  } else {\n  }\n  return sdkWallets;\n}\n\n// src/WalletCore.ts\nvar WalletCore = class extends EventEmitter {\n  constructor(optInWallets, dappConfig, disableTelemetry) {\n    super();\n    // Local private variable to hold the wallet that is currently connected\n    this._wallet = null;\n    // Local private variable to hold SDK wallets in the adapter\n    this._sdkWallets = [];\n    // Local array that holds all the wallets that are AIP-62 standard compatible\n    this._standard_wallets = [];\n    // Local array that holds all the wallets that are AIP-62 standard compatible but are not installed on the user machine\n    this._standard_not_detected_wallets = [];\n    // Local private variable to hold the network that is currently connected\n    this._network = null;\n    // Local private variable to hold the wallet connected state\n    this._connected = false;\n    // Local private variable to hold the connecting state\n    this._connecting = false;\n    // Local private variable to hold the account that is currently connected\n    this._account = null;\n    // Private array that holds all the Wallets a dapp decided to opt-in to\n    this._optInWallets = [];\n    // Local flag to disable the adapter telemetry tool\n    this._disableTelemetry = false;\n    // Google Analytics 4 module\n    this.ga4 = null;\n    this._optInWallets = optInWallets || [];\n    this._dappConfig = dappConfig;\n    this._disableTelemetry = disableTelemetry ?? false;\n    this._sdkWallets = getSDKWallets(this._dappConfig);\n    if (!this._disableTelemetry) {\n      this.ga4 = new GA4();\n    }\n    this.fetchExtensionAIP62CedraWallets();\n    this.fetchSDKAIP62CedraWallets();\n    this.appendNotDetectedStandardSupportedWallets();\n  }\n  fetchExtensionAIP62CedraWallets() {\n    let { cedraWallets, on } = getCedraWallets();\n    this.setExtensionAIP62Wallets(cedraWallets);\n    if (typeof window === \"undefined\") return;\n    const that = this;\n    const removeRegisterListener = on(\"register\", function() {\n      let { cedraWallets: cedraWallets2 } = getCedraWallets();\n      that.setExtensionAIP62Wallets(cedraWallets2);\n    });\n    const removeUnregisterListener = on(\"unregister\", function() {\n      let { cedraWallets: cedraWallets2 } = getCedraWallets();\n      that.setExtensionAIP62Wallets(cedraWallets2);\n    });\n  }\n  /**\n   * Set AIP-62 extension wallets\n   *\n   * @param extensionwWallets\n   */\n  setExtensionAIP62Wallets(extensionwWallets) {\n    extensionwWallets.map((wallet) => {\n      if (this.excludeWallet(wallet)) {\n        return;\n      }\n      this._standard_wallets = this._standard_wallets.filter(\n        (item) => item.name !== wallet.name\n      );\n      const isValid = isWalletWithRequiredFeatureSet(wallet);\n      if (isValid) {\n        const index = this._standard_not_detected_wallets.findIndex(\n          (notDetctedWallet) => notDetctedWallet.name == wallet.name\n        );\n        if (index !== -1) {\n          this._standard_not_detected_wallets.splice(index, 1);\n        }\n        wallet.readyState = \"Installed\" /* Installed */;\n        this._standard_wallets.push(wallet);\n        this.emit(\"standardWalletsAdded\", wallet);\n      }\n    });\n  }\n  /**\n   * Set AIP-62 SDK wallets\n   */\n  fetchSDKAIP62CedraWallets() {\n    this._sdkWallets.map((wallet) => {\n      if (this.excludeWallet(wallet)) {\n        return;\n      }\n      const isValid = isWalletWithRequiredFeatureSet(wallet);\n      if (isValid) {\n        wallet.readyState = \"Installed\" /* Installed */;\n        this._standard_wallets.push(wallet);\n      }\n    });\n  }\n  // Since we can't discover AIP-62 wallets that are not installed on the user machine,\n  // we hold a AIP-62 wallets registry to show on the wallet selector modal for the users.\n  // Append wallets from wallet standard support registry to the `_standard_not_detected_wallets` array\n  // when wallet is not installed on the user machine\n  appendNotDetectedStandardSupportedWallets() {\n    cedraStandardSupportedWalletList.map((supportedWallet) => {\n      const existingStandardWallet = this._standard_wallets.find(\n        (wallet) => wallet.name == supportedWallet.name\n      );\n      if (existingStandardWallet) {\n        return;\n      }\n      if (this.excludeWallet(supportedWallet)) {\n        return;\n      }\n      if (!existingStandardWallet) {\n        this._standard_not_detected_wallets.push(supportedWallet);\n        this.emit(\"standardNotDetectedWalletAdded\", supportedWallet);\n      }\n    });\n  }\n  /**\n   * A function that excludes an AIP-62 compatible wallet the dapp doesnt want to include\n   *\n   * @param wallet AdapterWallet | AdapterNotDetectedWallet\n   * @returns boolean\n   */\n  excludeWallet(wallet) {\n    if (this._optInWallets.length > 0 && !this._optInWallets.includes(wallet.name)) {\n      return true;\n    }\n    return false;\n  }\n  recordEvent(eventName, additionalInfo) {\n    this.ga4?.gtag(\"event\", `wallet_adapter_${eventName}`, {\n      wallet: this._wallet?.name,\n      network: this._network?.name,\n      network_url: this._network?.url,\n      adapter_core_version: WALLET_ADAPTER_CORE_VERSION,\n      send_to: true,\n      ...additionalInfo\n    });\n  }\n  /**\n   * Helper function to ensure wallet exists\n   *\n   * @param wallet A wallet\n   */\n  ensureWalletExists(wallet) {\n    if (!wallet) {\n      throw new WalletNotConnectedError().name;\n    }\n    if (!(wallet.readyState === \"Installed\" /* Installed */))\n      throw new WalletNotReadyError(\"Wallet is not set\").name;\n  }\n  /**\n   * Helper function to ensure account exists\n   *\n   * @param account An account\n   */\n  ensureAccountExists(account) {\n    if (!account) {\n      throw new WalletAccountError(\"Account is not set\").name;\n    }\n  }\n  /**\n   * Queries and sets ANS name for the current connected wallet account\n   */\n  async setAnsName() {\n    if (this._network?.chainId && this._account) {\n      if (this._account.ansName) return;\n      if (!ChainIdToAnsSupportedNetworkMap[this._network.chainId] || !isCedraNetwork(this._network)) {\n        this._account.ansName = void 0;\n        return;\n      }\n      const cedraConfig = getCedraConfig(this._network, this._dappConfig);\n      const cedra = new Cedra2(cedraConfig);\n      try {\n        const name = await cedra.ans.getPrimaryName({\n          address: this._account.address.toString()\n        });\n        this._account.ansName = name;\n      } catch (error) {\n        console.log(`Error setting ANS name ${error}`);\n      }\n    }\n  }\n  /**\n   * Function to cleat wallet adapter data.\n   *\n   * - Removes current connected wallet state\n   * - Removes current connected account state\n   * - Removes current connected network state\n   * - Removes autoconnect local storage value\n   */\n  clearData() {\n    this._connected = false;\n    this.setWallet(null);\n    this.setAccount(null);\n    this.setNetwork(null);\n    removeLocalStorage();\n  }\n  /**\n   * Sets the connected wallet\n   *\n   * @param wallet A wallet\n   */\n  setWallet(wallet) {\n    this._wallet = wallet;\n  }\n  /**\n   * Sets the connected account\n   *\n   * @param account An account\n   */\n  setAccount(account) {\n    this._account = account;\n  }\n  /**\n   * Sets the connected network\n   *\n   * @param network A network\n   */\n  setNetwork(network) {\n    this._network = network;\n  }\n  /**\n   * Helper function to detect whether a wallet is connected\n   *\n   * @returns boolean\n   */\n  isConnected() {\n    return this._connected;\n  }\n  /**\n   * Getter to fetch all detected wallets\n   */\n  get wallets() {\n    return this._standard_wallets;\n  }\n  get notDetectedWallets() {\n    return this._standard_not_detected_wallets;\n  }\n  /**\n   * Getter for the current connected wallet\n   *\n   * @return wallet info\n   * @throws WalletNotSelectedError\n   */\n  get wallet() {\n    try {\n      if (!this._wallet) return null;\n      return this._wallet;\n    } catch (error) {\n      throw new WalletNotSelectedError(error).message;\n    }\n  }\n  /**\n   * Getter for the current connected account\n   *\n   * @return account info\n   * @throws WalletAccountError\n   */\n  get account() {\n    try {\n      return this._account;\n    } catch (error) {\n      throw new WalletAccountError(error).message;\n    }\n  }\n  /**\n   * Getter for the current wallet network\n   *\n   * @return network info\n   * @throws WalletGetNetworkError\n   */\n  get network() {\n    try {\n      return this._network;\n    } catch (error) {\n      throw new WalletGetNetworkError(error).message;\n    }\n  }\n  /**\n   * Helper function to run some checks before we connect with a wallet.\n   *\n   * @param walletName. The wallet name we want to connect with.\n   */\n  async connect(walletName) {\n    if (isRedirectable()) {\n      const selectedWallet2 = this._standard_not_detected_wallets.find(\n        (wallet) => wallet.name === walletName\n      );\n      if (selectedWallet2) {\n        const uninstalledWallet = selectedWallet2;\n        if (uninstalledWallet.deeplinkProvider) {\n          const url = encodeURIComponent(window.location.href);\n          const location = uninstalledWallet.deeplinkProvider.concat(url);\n          window.location.href = location;\n          return;\n        }\n      }\n    }\n    const allDetectedWallets = this._standard_wallets;\n    const selectedWallet = allDetectedWallets.find(\n      (wallet) => wallet.name === walletName\n    );\n    if (!selectedWallet) return;\n    if (this._connected && this._account) {\n      if (this._wallet?.name === walletName)\n        throw new WalletConnectionError(\n          `${walletName} wallet is already connected`\n        ).message;\n    }\n    await this.connectWallet(selectedWallet, async () => {\n      const response = await selectedWallet.features[\"cedra:connect\"].connect();\n      if (response.status === UserResponseStatus.REJECTED) {\n        throw new WalletConnectionError(\"User has rejected the request\").message;\n      }\n      return { account: response.args, output: void 0 };\n    });\n  }\n  /**\n   * Signs into the wallet by connecting and signing an authentication messages.\n   *\n   * For more information, visit: https://siwa.cedra.dev\n   *\n   * @param args\n   * @param args.input The CedraSignInInput which defines how the SIWA Message should be constructed\n   * @param args.walletName The name of the wallet to sign into\n   * @returns The CedraSignInOutput which contains the account and signature information\n   */\n  async signIn(args) {\n    const { input, walletName } = args;\n    const allDetectedWallets = this._standard_wallets;\n    const selectedWallet = allDetectedWallets.find(\n      (wallet) => wallet.name === walletName\n    );\n    if (!selectedWallet) {\n      throw new WalletNotFoundError(`Wallet ${walletName} not found`).message;\n    }\n    if (!selectedWallet.features[\"cedra:signIn\"]) {\n      throw new WalletNotSupportedMethod(\n        `cedra:signIn is not supported by ${walletName}`\n      ).message;\n    }\n    return await this.connectWallet(selectedWallet, async () => {\n      if (!selectedWallet.features[\"cedra:signIn\"]) {\n        throw new WalletNotSupportedMethod(\n          `cedra:signIn is not supported by ${selectedWallet.name}`\n        ).message;\n      }\n      const response = await selectedWallet.features[\"cedra:signIn\"].signIn(input);\n      if (response.status === UserResponseStatus.REJECTED) {\n        throw new WalletConnectionError(\"User has rejected the request\").message;\n      }\n      return { account: response.args.account, output: response.args };\n    });\n  }\n  /**\n   * Connects a wallet to the dapp.\n   * On connect success, we set the current account and the network, and keeping the selected wallet\n   * name in LocalStorage to support autoConnect function.\n   *\n   * @param selectedWallet. The wallet we want to connect.\n   * @emit emits \"connect\" event\n   * @throws WalletConnectionError\n   */\n  async connectWallet(selectedWallet, onConnect) {\n    try {\n      this._connecting = true;\n      this.setWallet(selectedWallet);\n      const { account, output } = await onConnect();\n      this.setAccount(account);\n      const network = await selectedWallet.features[\"cedra:network\"].network();\n      this.setNetwork(network);\n      await this.setAnsName();\n      setLocalStorage(selectedWallet.name);\n      this._connected = true;\n      this.recordEvent(\"wallet_connect\");\n      this.emit(\"connect\", account);\n      return output;\n    } catch (error) {\n      this.clearData();\n      const errMsg = generalizedErrorMessage(error);\n      throw new WalletConnectionError(errMsg).message;\n    } finally {\n      this._connecting = false;\n    }\n  }\n  /**\n   * Disconnect the current connected wallet. On success, we clear the\n   * current account, current network and LocalStorage data.\n   *\n   * @emit emits \"disconnect\" event\n   * @throws WalletDisconnectionError\n   */\n  async disconnect() {\n    try {\n      this.ensureWalletExists(this._wallet);\n      await this._wallet.features[\"cedra:disconnect\"].disconnect();\n      this.clearData();\n      this.recordEvent(\"wallet_disconnect\");\n      this.emit(\"disconnect\");\n    } catch (error) {\n      const errMsg = generalizedErrorMessage(error);\n      throw new WalletDisconnectionError(errMsg).message;\n    }\n  }\n  /**\n   * Signs and submits a transaction to chain\n   *\n   * @param transactionInput InputTransactionData\n   * @returns CedraSignAndSubmitTransactionOutput\n   */\n  async signAndSubmitTransaction(transactionInput) {\n    try {\n      if (\"function\" in transactionInput.data) {\n        if (transactionInput.data.function === \"0x1::account::rotate_authentication_key_call\") {\n          throw new WalletSignAndSubmitMessageError(\"SCAM SITE DETECTED\").message;\n        }\n        if (transactionInput.data.function === \"0x1::code::publish_package_txn\") {\n          ({\n            metadataBytes: transactionInput.data.functionArguments[0],\n            byteCode: transactionInput.data.functionArguments[1]\n          } = handlePublishPackageTransaction(transactionInput));\n        }\n      }\n      this.ensureWalletExists(this._wallet);\n      this.ensureAccountExists(this._account);\n      this.recordEvent(\"sign_and_submit_transaction\");\n      if (this._wallet.features[\"cedra:signAndSubmitTransaction\"]) {\n        if (this._wallet.features[\"cedra:signAndSubmitTransaction\"].version !== \"1.1.0\") {\n          const cedraConfig2 = getCedraConfig(this._network, this._dappConfig);\n          const cedra2 = new Cedra2(cedraConfig2);\n          const transaction2 = await cedra2.transaction.build.simple({\n            sender: this._account.address.toString(),\n            data: transactionInput.data,\n            options: transactionInput.options\n          });\n          const signAndSubmitTransactionMethod = this._wallet.features[\"cedra:signAndSubmitTransaction\"].signAndSubmitTransaction;\n          const response3 = await signAndSubmitTransactionMethod(\n            transaction2\n          );\n          if (response3.status === UserResponseStatus.REJECTED) {\n            throw new WalletConnectionError(\"User has rejected the request\").message;\n          }\n          return response3.args;\n        }\n        const response2 = await this._wallet.features[\"cedra:signAndSubmitTransaction\"].signAndSubmitTransaction({\n          payload: transactionInput.data,\n          gasUnitPrice: transactionInput.options?.gasUnitPrice,\n          maxGasAmount: transactionInput.options?.maxGasAmount\n        });\n        if (response2.status === UserResponseStatus.REJECTED) {\n          throw new WalletConnectionError(\"User has rejected the request\").message;\n        }\n        return response2.args;\n      }\n      const cedraConfig = getCedraConfig(this._network, this._dappConfig);\n      const cedra = new Cedra2(cedraConfig);\n      const transaction = await cedra.transaction.build.simple({\n        sender: this._account.address,\n        data: transactionInput.data,\n        options: transactionInput.options\n      });\n      const signTransactionResponse = await this.signTransaction({\n        transactionOrPayload: transaction\n      });\n      const response = await this.submitTransaction({\n        transaction,\n        senderAuthenticator: signTransactionResponse.authenticator\n      });\n      return { hash: response.hash };\n    } catch (error) {\n      const errMsg = generalizedErrorMessage(error);\n      throw new WalletSignAndSubmitMessageError(errMsg).message;\n    }\n  }\n  /**\n   * Signs a transaction\n   *\n   * This method supports 2 input types -\n   * 1. A raw transaction that was already built by the dapp,\n   * 2. A transaction data input as JSON. This is for the wallet to be able to simulate before signing\n   *\n   * @param transactionOrPayload AnyRawTransaction | InputTransactionData\n   * @param asFeePayer optional. A flag indicates to sign the transaction as the fee payer\n   * @param options optional. Transaction options\n   *\n   * @returns AccountAuthenticator\n   */\n  async signTransaction(args) {\n    const { transactionOrPayload, asFeePayer } = args;\n    try {\n      this.ensureWalletExists(this._wallet);\n      this.ensureAccountExists(this._account);\n      this.recordEvent(\"sign_transaction\");\n      if (\"rawTransaction\" in transactionOrPayload) {\n        const response = await this._wallet?.features[\"cedra:signTransaction\"].signTransaction(\n          transactionOrPayload,\n          asFeePayer\n        );\n        if (response.status === UserResponseStatus.REJECTED) {\n          throw new WalletConnectionError(\"User has rejected the request\").message;\n        }\n        return {\n          authenticator: response.args,\n          rawTransaction: transactionOrPayload.rawTransaction.bcsToBytes()\n        };\n      } else if (this._wallet.features[\"cedra:signTransaction\"]?.version === \"1.1\") {\n        const signTransactionV1_1StandardInput = {\n          payload: transactionOrPayload.data,\n          expirationTimestamp: transactionOrPayload.options?.expirationTimestamp,\n          expirationSecondsFromNow: transactionOrPayload.options?.expirationSecondsFromNow,\n          gasUnitPrice: transactionOrPayload.options?.gasUnitPrice,\n          maxGasAmount: transactionOrPayload.options?.maxGasAmount,\n          sequenceNumber: transactionOrPayload.options?.accountSequenceNumber,\n          sender: transactionOrPayload.sender ? { address: AccountAddress.from(transactionOrPayload.sender) } : void 0\n        };\n        const walletSignTransactionMethod = this._wallet?.features[\"cedra:signTransaction\"].signTransaction;\n        const response = await walletSignTransactionMethod(\n          signTransactionV1_1StandardInput\n        );\n        if (response.status === UserResponseStatus.REJECTED) {\n          throw new WalletConnectionError(\"User has rejected the request\").message;\n        }\n        return {\n          authenticator: response.args.authenticator,\n          rawTransaction: response.args.rawTransaction.bcsToBytes()\n        };\n      } else {\n        const cedraConfig = getCedraConfig(this._network, this._dappConfig);\n        const cedra = new Cedra2(cedraConfig);\n        const transaction = await cedra.transaction.build.simple({\n          sender: this._account.address,\n          data: transactionOrPayload.data,\n          options: transactionOrPayload.options,\n          withFeePayer: transactionOrPayload.withFeePayer\n        });\n        const response = await this._wallet?.features[\"cedra:signTransaction\"].signTransaction(\n          transaction,\n          asFeePayer\n        );\n        if (response.status === UserResponseStatus.REJECTED) {\n          throw new WalletConnectionError(\"User has rejected the request\").message;\n        }\n        return {\n          authenticator: response.args,\n          rawTransaction: transaction.bcsToBytes()\n        };\n      }\n    } catch (error) {\n      const errMsg = generalizedErrorMessage(error);\n      throw new WalletSignTransactionError(errMsg).message;\n    }\n  }\n  /**\n   * Sign a message (doesnt submit to chain).\n   *\n   * @param message - CedraSignMessageInput\n   *\n   * @return response from the wallet's signMessage function\n   * @throws WalletSignMessageError\n   */\n  async signMessage(message) {\n    try {\n      this.ensureWalletExists(this._wallet);\n      this.recordEvent(\"sign_message\");\n      const response = await this._wallet?.features[\"cedra:signMessage\"]?.signMessage(message);\n      if (response.status === UserResponseStatus.REJECTED) {\n        throw new WalletConnectionError(\"User has rejected the request\").message;\n      }\n      return response.args;\n    } catch (error) {\n      const errMsg = generalizedErrorMessage(error);\n      throw new WalletSignMessageError(errMsg).message;\n    }\n  }\n  /**\n   * Submits transaction to chain\n   *\n   * @param transaction - InputSubmitTransactionData\n   * @returns PendingTransactionResponse\n   */\n  async submitTransaction(transaction) {\n    try {\n      this.ensureWalletExists(this._wallet);\n      const { additionalSignersAuthenticators } = transaction;\n      const transactionType = additionalSignersAuthenticators !== void 0 ? \"multi-agent\" : \"simple\";\n      this.recordEvent(\"submit_transaction\", {\n        transaction_type: transactionType\n      });\n      const cedraConfig = getCedraConfig(this._network, this._dappConfig);\n      const cedra = new Cedra2(cedraConfig);\n      if (additionalSignersAuthenticators !== void 0) {\n        const multiAgentTxn = {\n          ...transaction,\n          additionalSignersAuthenticators\n        };\n        return cedra.transaction.submit.multiAgent(multiAgentTxn);\n      } else {\n        return cedra.transaction.submit.simple(transaction);\n      }\n    } catch (error) {\n      const errMsg = generalizedErrorMessage(error);\n      throw new WalletSubmitTransactionError(errMsg).message;\n    }\n  }\n  /**\n   Event for when account has changed on the wallet\n   @return the new account info\n   @throws WalletAccountChangeError\n   */\n  async onAccountChange() {\n    try {\n      this.ensureWalletExists(this._wallet);\n      await this._wallet.features[\"cedra:onAccountChange\"]?.onAccountChange(\n        async (data) => {\n          this.setAccount(data);\n          await this.setAnsName();\n          this.recordEvent(\"account_change\");\n          this.emit(\"accountChange\", this._account);\n        }\n      );\n    } catch (error) {\n      const errMsg = generalizedErrorMessage(error);\n      throw new WalletAccountChangeError(errMsg).message;\n    }\n  }\n  /**\n   Event for when network has changed on the wallet\n   @return the new network info\n   @throws WalletNetworkChangeError\n   */\n  async onNetworkChange() {\n    try {\n      this.ensureWalletExists(this._wallet);\n      await this._wallet.features[\"cedra:onNetworkChange\"]?.onNetworkChange(\n        async (data) => {\n          this.setNetwork(data);\n          await this.setAnsName();\n          this.emit(\"networkChange\", this._network);\n        }\n      );\n    } catch (error) {\n      const errMsg = generalizedErrorMessage(error);\n      throw new WalletNetworkChangeError(errMsg).message;\n    }\n  }\n  /**\n   * Sends a change network request to the wallet to change the connected network\n   *\n   * @param network - Network\n   * @returns CedraChangeNetworkOutput\n   */\n  async changeNetwork(network) {\n    try {\n      this.ensureWalletExists(this._wallet);\n      this.recordEvent(\"change_network_request\", {\n        from: this._network?.name,\n        to: network\n      });\n      const chainId = network === Network3.DEVNET ? await fetchDevnetChainId() : NetworkToChainId[network];\n      const networkInfo = {\n        name: network,\n        chainId\n      };\n      if (this._wallet.features[\"cedra:changeNetwork\"]) {\n        const response = await this._wallet.features[\"cedra:changeNetwork\"].changeNetwork(\n          networkInfo\n        );\n        if (response.status === UserResponseStatus.REJECTED) {\n          throw new WalletConnectionError(\"User has rejected the request\").message;\n        }\n        return response.args;\n      }\n      throw new WalletChangeNetworkError(\n        `${this._wallet.name} does not support changing network request`\n      ).message;\n    } catch (error) {\n      const errMsg = generalizedErrorMessage(error);\n      throw new WalletChangeNetworkError(errMsg).message;\n    }\n  }\n  /**\n   * Signs a message and verifies the signer\n   * @param message - CedraSignMessageInput\n   * @returns boolean\n   */\n  async signMessageAndVerify(message) {\n    try {\n      this.ensureWalletExists(this._wallet);\n      this.ensureAccountExists(this._account);\n      this.recordEvent(\"sign_message_and_verify\");\n      const response = await this._wallet.features[\"cedra:signMessage\"].signMessage(message);\n      if (response.status === UserResponseStatus.REJECTED) {\n        throw new WalletConnectionError(\"Failed to sign a message\").message;\n      }\n      const cedraConfig = getCedraConfig(this._network, this._dappConfig);\n      const signingMessage = new TextEncoder().encode(\n        response.args.fullMessage\n      );\n      if (\"verifySignatureAsync\" in this._account.publicKey) {\n        return await this._account.publicKey.verifySignatureAsync({\n          cedraConfig,\n          message: signingMessage,\n          signature: response.args.signature,\n          options: { throwErrorWithReason: true }\n        });\n      }\n      return this._account.publicKey.verifySignature({\n        message: signingMessage,\n        signature: response.args.signature\n      });\n    } catch (error) {\n      const errMsg = generalizedErrorMessage(error);\n      throw new WalletSignMessageAndVerifyError(errMsg).message;\n    }\n  }\n};\n\n// src/index.ts\nif (typeof window !== \"undefined\") {\n  window.WALLET_ADAPTER_CORE_VERSION = WALLET_ADAPTER_CORE_VERSION;\n}\nexport {\n  CEDRA_CONNECT_ACCOUNT_URL,\n  CEDRA_CONNECT_BASE_URL,\n  ChainIdToAnsSupportedNetworkMap,\n  NetworkName,\n  WalletCore,\n  WalletReadyState,\n  cedraStandardSupportedWalletList,\n  convertNetwork,\n  fetchDevnetChainId,\n  generalizedErrorMessage,\n  getCedraConfig,\n  getCedraConnectWallets,\n  getLocalStorage,\n  getSDKWallets,\n  groupAndSortWallets,\n  handlePublishPackageTransaction,\n  isCedraConnectWallet,\n  isCedraLiveNetwork,\n  isCedraNetwork,\n  isInAppBrowser,\n  isInstallRequired,\n  isInstalledOrLoadable,\n  isMobile,\n  isRedirectable,\n  partitionWallets,\n  removeLocalStorage,\n  setLocalStorage,\n  truncateAddress\n};\n","export const WALLET_ADAPTER_CORE_VERSION = \"5.5.4\";\n","import EventEmitter from \"eventemitter3\";\nimport {\n  AccountAddress,\n  AccountAuthenticator,\n  AnyPublicKey,\n  AnyPublicKeyVariant,\n  AnyRawTransaction,\n  Cedra,\n  Ed25519PublicKey,\n  InputSubmitTransactionData,\n  MultiEd25519PublicKey,\n  MultiEd25519Signature,\n  Network,\n  NetworkToChainId,\n  PendingTransactionResponse,\n} from \"@cedra-labs/ts-sdk\";\nimport {\n  CedraWallet,\n  getCedraWallets,\n  isWalletWithRequiredFeatureSet,\n  UserResponseStatus,\n  CedraSignAndSubmitTransactionOutput,\n  UserResponse,\n  CedraSignTransactionOutputV1_1,\n  CedraSignTransactionInputV1_1,\n  CedraSignTransactionMethod,\n  CedraSignTransactionMethodV1_1,\n  NetworkInfo,\n  AccountInfo,\n  CedraSignMessageInput,\n  CedraSignMessageOutput,\n  CedraChangeNetworkOutput,\n  CedraSignInInput,\n  CedraSignInOutput,\n} from \"@cedra-labs/wallet-standard\";\nimport { CedraConnectWalletConfig } from \"@cedra-labs/wallet-adapter-plugin\";\n\nexport type {\n  NetworkInfo,\n  AccountInfo,\n  CedraSignAndSubmitTransactionOutput,\n  CedraSignTransactionOutputV1_1,\n  CedraSignMessageInput,\n  CedraSignMessageOutput,\n  CedraChangeNetworkOutput,\n} from \"@cedra-labs/wallet-standard\";\nexport type {\n  AccountAuthenticator,\n  AnyRawTransaction,\n  InputGenerateTransactionOptions,\n  PendingTransactionResponse,\n  InputSubmitTransactionData,\n  Network,\n  AnyPublicKey,\n  AccountAddress,\n} from \"@cedra-labs/ts-sdk\";\n\nimport { GA4 } from \"./ga\";\nimport {\n  WalletChangeNetworkError,\n  WalletAccountChangeError,\n  WalletAccountError,\n  WalletConnectionError,\n  WalletGetNetworkError,\n  WalletNetworkChangeError,\n  WalletNotConnectedError,\n  WalletNotReadyError,\n  WalletNotSelectedError,\n  WalletSignAndSubmitMessageError,\n  WalletSignMessageError,\n  WalletSignTransactionError,\n  WalletSignMessageAndVerifyError,\n  WalletDisconnectionError,\n  WalletSubmitTransactionError,\n  WalletNotSupportedMethod,\n  WalletNotFoundError,\n} from \"./error\";\nimport { ChainIdToAnsSupportedNetworkMap, WalletReadyState } from \"./constants\";\nimport { WALLET_ADAPTER_CORE_VERSION } from \"./version\";\nimport {\n  fetchDevnetChainId,\n  generalizedErrorMessage,\n  getCedraConfig,\n  handlePublishPackageTransaction,\n  isCedraNetwork,\n  isRedirectable,\n  removeLocalStorage,\n  setLocalStorage,\n} from \"./utils\";\nimport { cedraStandardSupportedWalletList } from \"./registry\";\nimport { getSDKWallets } from \"./sdkWallets\";\nimport {\n  AvailableWallets,\n  CedraStandardSupportedWallet,\n  InputTransactionData,\n} from \"./utils/types\";\n\n// An adapter wallet types is a wallet that is compatible with the wallet standard and the wallet adapter properties\nexport type AdapterWallet = CedraWallet & {\n  readyState?: WalletReadyState;\n};\n\n// An adapter not detected wallet types is a wallet that is compatible with the wallet standard but not detected\nexport type AdapterNotDetectedWallet = Omit<\n  AdapterWallet,\n  \"features\" | \"version\" | \"chains\" | \"accounts\"\n> & {\n  readyState: WalletReadyState.NotDetected;\n};\n\nexport interface DappConfig {\n  network: Network;\n  cedraApiKeys?: Partial<Record<Network, string>>;\n  cedraConnectDappId?: string;\n  cedraConnect?: Omit<CedraConnectWalletConfig, \"network\">;\n  /**\n   * @deprecated will be removed in a future version\n   */\n  mizuwallet?: {\n    manifestURL: string;\n    appId?: string;\n  };\n  msafeWalletConfig?: {\n    appId?: string;\n    appUrl?: string;\n  };\n}\n\nexport declare interface WalletCoreEvents {\n  connect(account: AccountInfo | null): void;\n  disconnect(): void;\n  standardWalletsAdded(wallets: AdapterWallet): void;\n  standardNotDetectedWalletAdded(wallets: AdapterNotDetectedWallet): void;\n  networkChange(network: NetworkInfo | null): void;\n  accountChange(account: AccountInfo | null): void;\n}\n\nexport type AdapterAccountInfo = Omit<AccountInfo, \"ansName\"> & {\n  // ansName is a read-only property on the standard AccountInfo type\n  ansName?: string;\n};\n\nexport class WalletCore extends EventEmitter<WalletCoreEvents> {\n  // Local private variable to hold the wallet that is currently connected\n  private _wallet: AdapterWallet | null = null;\n\n  // Local private variable to hold SDK wallets in the adapter\n  private readonly _sdkWallets: AdapterWallet[] = [];\n\n  // Local array that holds all the wallets that are AIP-62 standard compatible\n  private _standard_wallets: AdapterWallet[] = [];\n\n  // Local array that holds all the wallets that are AIP-62 standard compatible but are not installed on the user machine\n  private _standard_not_detected_wallets: AdapterNotDetectedWallet[] = [];\n\n  // Local private variable to hold the network that is currently connected\n  private _network: NetworkInfo | null = null;\n\n  // Local private variable to hold the wallet connected state\n  private _connected: boolean = false;\n\n  // Local private variable to hold the connecting state\n  private _connecting: boolean = false;\n\n  // Local private variable to hold the account that is currently connected\n  private _account: AdapterAccountInfo | null = null;\n\n  // JSON configuration for CedraConnect\n  private _dappConfig: DappConfig | undefined;\n\n  // Private array that holds all the Wallets a dapp decided to opt-in to\n  private _optInWallets: ReadonlyArray<AvailableWallets> = [];\n\n  // Local flag to disable the adapter telemetry tool\n  private _disableTelemetry: boolean = false;\n\n  // Google Analytics 4 module\n  private readonly ga4: GA4 | null = null;\n\n  constructor(\n    optInWallets?: ReadonlyArray<AvailableWallets>,\n    dappConfig?: DappConfig,\n    disableTelemetry?: boolean\n  ) {\n    super();\n    this._optInWallets = optInWallets || [];\n    this._dappConfig = dappConfig;\n    this._disableTelemetry = disableTelemetry ?? false;\n    this._sdkWallets = getSDKWallets(this._dappConfig);\n\n    // If disableTelemetry set to false (by default), start GA4\n    if (!this._disableTelemetry) {\n      this.ga4 = new GA4();\n    }\n    // Strategy to detect AIP-62 standard compatible extension wallets\n    this.fetchExtensionAIP62CedraWallets();\n    // Strategy to detect AIP-62 standard compatible SDK wallets.\n    // We separate the extension and sdk detection process so we dont refetch sdk wallets everytime a new\n    // extension wallet is detected\n    this.fetchSDKAIP62CedraWallets();\n    // Strategy to append not detected AIP-62 standard compatible extension wallets\n    this.appendNotDetectedStandardSupportedWallets();\n  }\n\n  private fetchExtensionAIP62CedraWallets(): void {\n    let { cedraWallets, on } = getCedraWallets();\n    this.setExtensionAIP62Wallets(cedraWallets);\n\n    if (typeof window === \"undefined\") return;\n    // Adds an event listener for new wallets that get registered after the dapp has been loaded,\n    // receiving an unsubscribe function, which it can later use to remove the listener\n    const that = this;\n    const removeRegisterListener = on(\"register\", function () {\n      let { cedraWallets } = getCedraWallets();\n      that.setExtensionAIP62Wallets(cedraWallets);\n    });\n\n    const removeUnregisterListener = on(\"unregister\", function () {\n      let { cedraWallets } = getCedraWallets();\n      that.setExtensionAIP62Wallets(cedraWallets);\n    });\n  }\n\n  /**\n   * Set AIP-62 extension wallets\n   *\n   * @param extensionwWallets\n   */\n  private setExtensionAIP62Wallets(\n    extensionwWallets: readonly CedraWallet[]\n  ): void {\n    extensionwWallets.map((wallet: AdapterWallet) => {\n      if (this.excludeWallet(wallet)) {\n        return;\n      }\n\n      // Remove optional duplications in the _all_wallets array\n      this._standard_wallets = this._standard_wallets.filter(\n        (item) => item.name !== wallet.name\n      );\n\n      const isValid = isWalletWithRequiredFeatureSet(wallet);\n      if (isValid) {\n        // check if we already have this wallet as a not detected wallet\n        const index = this._standard_not_detected_wallets.findIndex(\n          (notDetctedWallet) => notDetctedWallet.name == wallet.name\n        );\n        // if we do, remove it from the not detected wallets array as it is now become detected\n        if (index !== -1) {\n          this._standard_not_detected_wallets.splice(index, 1);\n        }\n\n        wallet.readyState = WalletReadyState.Installed;\n        this._standard_wallets.push(wallet);\n        this.emit(\"standardWalletsAdded\", wallet);\n      }\n    });\n  }\n\n  /**\n   * Set AIP-62 SDK wallets\n   */\n  private fetchSDKAIP62CedraWallets(): void {\n    this._sdkWallets.map((wallet: AdapterWallet) => {\n      if (this.excludeWallet(wallet)) {\n        return;\n      }\n      const isValid = isWalletWithRequiredFeatureSet(wallet);\n\n      if (isValid) {\n        wallet.readyState = WalletReadyState.Installed;\n        this._standard_wallets.push(wallet);\n      }\n    });\n  }\n\n  // Since we can't discover AIP-62 wallets that are not installed on the user machine,\n  // we hold a AIP-62 wallets registry to show on the wallet selector modal for the users.\n  // Append wallets from wallet standard support registry to the `_standard_not_detected_wallets` array\n  // when wallet is not installed on the user machine\n  private appendNotDetectedStandardSupportedWallets(): void {\n    // Loop over the registry map\n    cedraStandardSupportedWalletList.map((supportedWallet) => {\n      // Check if we already have this wallet as a detected AIP-62 wallet standard\n      const existingStandardWallet = this._standard_wallets.find(\n        (wallet) => wallet.name == supportedWallet.name\n      );\n      // If it is detected, it means the user has the wallet installed, so dont add it to the wallets array\n      if (existingStandardWallet) {\n        return;\n      }\n      // If AIP-62 wallet detected but it is excluded by the dapp, dont add it to the wallets array\n      if (this.excludeWallet(supportedWallet)) {\n        return;\n      }\n      // If AIP-62 wallet does not exist, append it to the wallet selector modal\n      // as an undetected wallet\n      if (!existingStandardWallet) {\n        this._standard_not_detected_wallets.push(supportedWallet);\n        this.emit(\"standardNotDetectedWalletAdded\", supportedWallet);\n      }\n    });\n  }\n\n  /**\n   * A function that excludes an AIP-62 compatible wallet the dapp doesnt want to include\n   *\n   * @param wallet AdapterWallet | AdapterNotDetectedWallet\n   * @returns boolean\n   */\n  excludeWallet(wallet: AdapterWallet | AdapterNotDetectedWallet): boolean {\n    // If _optInWallets is not empty, and does not include the provided wallet,\n    // return true to exclude the wallet, otherwise return false\n    if (\n      this._optInWallets.length > 0 &&\n      !this._optInWallets.includes(wallet.name as AvailableWallets)\n    ) {\n      return true;\n    }\n    return false;\n  }\n\n  private recordEvent(eventName: string, additionalInfo?: object): void {\n    this.ga4?.gtag(\"event\", `wallet_adapter_${eventName}`, {\n      wallet: this._wallet?.name,\n      network: this._network?.name,\n      network_url: this._network?.url,\n      adapter_core_version: WALLET_ADAPTER_CORE_VERSION,\n      send_to: process.env.GAID,\n      ...additionalInfo,\n    });\n  }\n\n  /**\n   * Helper function to ensure wallet exists\n   *\n   * @param wallet A wallet\n   */\n  private ensureWalletExists(\n    wallet: AdapterWallet | null\n  ): asserts wallet is AdapterWallet {\n    if (!wallet) {\n      throw new WalletNotConnectedError().name;\n    }\n    if (!(wallet.readyState === WalletReadyState.Installed))\n      throw new WalletNotReadyError(\"Wallet is not set\").name;\n  }\n\n  /**\n   * Helper function to ensure account exists\n   *\n   * @param account An account\n   */\n  private ensureAccountExists(\n    account: AccountInfo | null\n  ): asserts account is AccountInfo {\n    if (!account) {\n      throw new WalletAccountError(\"Account is not set\").name;\n    }\n  }\n\n  /**\n   * Queries and sets ANS name for the current connected wallet account\n   */\n  private async setAnsName(): Promise<void> {\n    if (this._network?.chainId && this._account) {\n      if (this._account.ansName) return;\n      // ANS supports only MAINNET or TESTNET\n      if (\n        !ChainIdToAnsSupportedNetworkMap[this._network.chainId] ||\n        !isCedraNetwork(this._network)\n      ) {\n        this._account.ansName = undefined;\n        return;\n      }\n\n      const cedraConfig = getCedraConfig(this._network, this._dappConfig);\n      const cedra = new Cedra(cedraConfig);\n      try {\n        const name = await cedra.ans.getPrimaryName({\n          address: this._account.address.toString(),\n        });\n        this._account.ansName = name;\n      } catch (error: any) {\n        console.log(`Error setting ANS name ${error}`);\n      }\n    }\n  }\n\n  /**\n   * Function to cleat wallet adapter data.\n   *\n   * - Removes current connected wallet state\n   * - Removes current connected account state\n   * - Removes current connected network state\n   * - Removes autoconnect local storage value\n   */\n  private clearData(): void {\n    this._connected = false;\n    this.setWallet(null);\n    this.setAccount(null);\n    this.setNetwork(null);\n    removeLocalStorage();\n  }\n\n  /**\n   * Sets the connected wallet\n   *\n   * @param wallet A wallet\n   */\n  setWallet(wallet: CedraWallet | null): void {\n    this._wallet = wallet;\n  }\n\n  /**\n   * Sets the connected account\n   *\n   * @param account An account\n   */\n  setAccount(account: AccountInfo | null): void {\n    this._account = account;\n  }\n\n  /**\n   * Sets the connected network\n   *\n   * @param network A network\n   */\n  setNetwork(network: NetworkInfo | null): void {\n    this._network = network;\n  }\n\n  /**\n   * Helper function to detect whether a wallet is connected\n   *\n   * @returns boolean\n   */\n  isConnected(): boolean {\n    return this._connected;\n  }\n\n  /**\n   * Getter to fetch all detected wallets\n   */\n  get wallets(): ReadonlyArray<CedraWallet> {\n    return this._standard_wallets;\n  }\n\n  get notDetectedWallets(): ReadonlyArray<AdapterNotDetectedWallet> {\n    return this._standard_not_detected_wallets;\n  }\n\n  /**\n   * Getter for the current connected wallet\n   *\n   * @return wallet info\n   * @throws WalletNotSelectedError\n   */\n  get wallet(): CedraWallet | null {\n    try {\n      if (!this._wallet) return null;\n      return this._wallet;\n    } catch (error: any) {\n      throw new WalletNotSelectedError(error).message;\n    }\n  }\n\n  /**\n   * Getter for the current connected account\n   *\n   * @return account info\n   * @throws WalletAccountError\n   */\n  get account(): AccountInfo | null {\n    try {\n      return this._account;\n    } catch (error: any) {\n      throw new WalletAccountError(error).message;\n    }\n  }\n\n  /**\n   * Getter for the current wallet network\n   *\n   * @return network info\n   * @throws WalletGetNetworkError\n   */\n  get network(): NetworkInfo | null {\n    try {\n      return this._network;\n    } catch (error: any) {\n      throw new WalletGetNetworkError(error).message;\n    }\n  }\n\n  /**\n   * Helper function to run some checks before we connect with a wallet.\n   *\n   * @param walletName. The wallet name we want to connect with.\n   */\n  async connect(walletName: string): Promise<void | string> {\n    // First, handle mobile case\n    // Check if we are in a redirectable view (i.e on mobile AND not in an in-app browser)\n    if (isRedirectable()) {\n      const selectedWallet = this._standard_not_detected_wallets.find(\n        (wallet: AdapterNotDetectedWallet) => wallet.name === walletName\n      );\n\n      if (selectedWallet) {\n        // If wallet has a deeplinkProvider property, use it\n        const uninstalledWallet =\n          selectedWallet as unknown as CedraStandardSupportedWallet;\n        if (uninstalledWallet.deeplinkProvider) {\n          const url = encodeURIComponent(window.location.href);\n          const location = uninstalledWallet.deeplinkProvider.concat(url);\n          window.location.href = location;\n          return;\n        }\n      }\n    }\n\n    // Checks the wallet exists in the detected wallets array\n    const allDetectedWallets = this._standard_wallets;\n\n    const selectedWallet = allDetectedWallets.find(\n      (wallet: AdapterWallet) => wallet.name === walletName\n    );\n\n    if (!selectedWallet) return;\n\n    // Check if wallet is already connected\n    if (this._connected && this._account) {\n      // if the selected wallet is already connected, we don't need to connect again\n      if (this._wallet?.name === walletName)\n        throw new WalletConnectionError(\n          `${walletName} wallet is already connected`\n        ).message;\n    }\n\n    await this.connectWallet(selectedWallet, async () => {\n      const response = await selectedWallet.features[\"cedra:connect\"].connect();\n      if (response.status === UserResponseStatus.REJECTED) {\n        throw new WalletConnectionError(\"User has rejected the request\")\n          .message;\n      }\n\n      return { account: response.args, output: undefined };\n    });\n  }\n\n  /**\n   * Signs into the wallet by connecting and signing an authentication messages.\n   *\n   * For more information, visit: https://siwa.cedra.dev\n   *\n   * @param args\n   * @param args.input The CedraSignInInput which defines how the SIWA Message should be constructed\n   * @param args.walletName The name of the wallet to sign into\n   * @returns The CedraSignInOutput which contains the account and signature information\n   */\n  async signIn(args: {\n    input: CedraSignInInput;\n    walletName: string;\n  }): Promise<CedraSignInOutput> {\n    const { input, walletName } = args;\n\n    const allDetectedWallets = this._standard_wallets;\n    const selectedWallet = allDetectedWallets.find(\n      (wallet: AdapterWallet) => wallet.name === walletName\n    );\n\n    if (!selectedWallet) {\n      throw new WalletNotFoundError(`Wallet ${walletName} not found`).message;\n    }\n\n    if (!selectedWallet.features[\"cedra:signIn\"]) {\n      throw new WalletNotSupportedMethod(\n        `cedra:signIn is not supported by ${walletName}`\n      ).message;\n    }\n\n    return await this.connectWallet(selectedWallet, async () => {\n      if (!selectedWallet.features[\"cedra:signIn\"]) {\n        throw new WalletNotSupportedMethod(\n          `cedra:signIn is not supported by ${selectedWallet.name}`\n        ).message;\n      }\n\n      const response =\n        await selectedWallet.features[\"cedra:signIn\"].signIn(input);\n      if (response.status === UserResponseStatus.REJECTED) {\n        throw new WalletConnectionError(\"User has rejected the request\")\n          .message;\n      }\n\n      return { account: response.args.account, output: response.args };\n    });\n  }\n\n  /**\n   * Connects a wallet to the dapp.\n   * On connect success, we set the current account and the network, and keeping the selected wallet\n   * name in LocalStorage to support autoConnect function.\n   *\n   * @param selectedWallet. The wallet we want to connect.\n   * @emit emits \"connect\" event\n   * @throws WalletConnectionError\n   */\n  private async connectWallet<T>(\n    selectedWallet: AdapterWallet,\n    onConnect: () => Promise<{ account: AccountInfo; output: T }>\n  ): Promise<T> {\n    try {\n      this._connecting = true;\n      this.setWallet(selectedWallet);\n      const { account, output } = await onConnect();\n      this.setAccount(account);\n      const network = await selectedWallet.features[\"cedra:network\"].network();\n      this.setNetwork(network);\n      await this.setAnsName();\n      setLocalStorage(selectedWallet.name);\n      this._connected = true;\n      this.recordEvent(\"wallet_connect\");\n      this.emit(\"connect\", account);\n      return output;\n    } catch (error: any) {\n      this.clearData();\n      const errMsg = generalizedErrorMessage(error);\n      throw new WalletConnectionError(errMsg).message;\n    } finally {\n      this._connecting = false;\n    }\n  }\n\n  /**\n   * Disconnect the current connected wallet. On success, we clear the\n   * current account, current network and LocalStorage data.\n   *\n   * @emit emits \"disconnect\" event\n   * @throws WalletDisconnectionError\n   */\n  async disconnect(): Promise<void> {\n    try {\n      this.ensureWalletExists(this._wallet);\n      await this._wallet.features[\"cedra:disconnect\"].disconnect();\n      this.clearData();\n      this.recordEvent(\"wallet_disconnect\");\n      this.emit(\"disconnect\");\n    } catch (error: any) {\n      const errMsg = generalizedErrorMessage(error);\n      throw new WalletDisconnectionError(errMsg).message;\n    }\n  }\n\n  /**\n   * Signs and submits a transaction to chain\n   *\n   * @param transactionInput InputTransactionData\n   * @returns CedraSignAndSubmitTransactionOutput\n   */\n  async signAndSubmitTransaction(\n    transactionInput: InputTransactionData\n  ): Promise<CedraSignAndSubmitTransactionOutput> {\n    try {\n      if (\"function\" in transactionInput.data) {\n        if (\n          transactionInput.data.function ===\n          \"0x1::account::rotate_authentication_key_call\"\n        ) {\n          throw new WalletSignAndSubmitMessageError(\"SCAM SITE DETECTED\")\n            .message;\n        }\n\n        if (\n          transactionInput.data.function === \"0x1::code::publish_package_txn\"\n        ) {\n          ({\n            metadataBytes: transactionInput.data.functionArguments[0],\n            byteCode: transactionInput.data.functionArguments[1],\n          } = handlePublishPackageTransaction(transactionInput));\n        }\n      }\n      this.ensureWalletExists(this._wallet);\n      this.ensureAccountExists(this._account);\n      this.recordEvent(\"sign_and_submit_transaction\");\n\n      if (this._wallet.features[\"cedra:signAndSubmitTransaction\"]) {\n        // check for backward compatibility. before version 1.1.0 the standard expected\n        // AnyRawTransaction input so the adapter built the transaction before sending it to the wallet\n        if (\n          this._wallet.features[\"cedra:signAndSubmitTransaction\"].version !==\n          \"1.1.0\"\n        ) {\n          const cedraConfig = getCedraConfig(this._network, this._dappConfig);\n\n          const cedra = new Cedra(cedraConfig);\n          const transaction = await cedra.transaction.build.simple({\n            sender: this._account.address.toString(),\n            data: transactionInput.data,\n            options: transactionInput.options,\n          });\n\n          type CedraSignAndSubmitTransactionV1Method = (\n            transaction: AnyRawTransaction\n          ) => Promise<UserResponse<CedraSignAndSubmitTransactionOutput>>;\n\n          const signAndSubmitTransactionMethod = this._wallet.features[\n            \"cedra:signAndSubmitTransaction\"\n          ]\n            .signAndSubmitTransaction as unknown as CedraSignAndSubmitTransactionV1Method;\n\n          const response = (await signAndSubmitTransactionMethod(\n            transaction\n          )) as UserResponse<CedraSignAndSubmitTransactionOutput>;\n\n          if (response.status === UserResponseStatus.REJECTED) {\n            throw new WalletConnectionError(\"User has rejected the request\")\n              .message;\n          }\n\n          return response.args;\n        }\n\n        const response = await this._wallet.features[\n          \"cedra:signAndSubmitTransaction\"\n        ].signAndSubmitTransaction({\n          payload: transactionInput.data,\n          gasUnitPrice: transactionInput.options?.gasUnitPrice,\n          maxGasAmount: transactionInput.options?.maxGasAmount,\n        });\n        if (response.status === UserResponseStatus.REJECTED) {\n          throw new WalletConnectionError(\"User has rejected the request\")\n            .message;\n        }\n        return response.args;\n      }\n\n      // If wallet does not support signAndSubmitTransaction\n      // the adapter will sign and submit it for the dapp.\n      const cedraConfig = getCedraConfig(this._network, this._dappConfig);\n      const cedra = new Cedra(cedraConfig);\n      const transaction = await cedra.transaction.build.simple({\n        sender: this._account.address,\n        data: transactionInput.data,\n        options: transactionInput.options,\n      });\n\n      const signTransactionResponse = await this.signTransaction({\n        transactionOrPayload: transaction,\n      });\n      const response = await this.submitTransaction({\n        transaction,\n        senderAuthenticator: signTransactionResponse.authenticator,\n      });\n      return { hash: response.hash };\n    } catch (error: any) {\n      const errMsg = generalizedErrorMessage(error);\n      throw new WalletSignAndSubmitMessageError(errMsg).message;\n    }\n  }\n\n  /**\n   * Signs a transaction\n   *\n   * This method supports 2 input types -\n   * 1. A raw transaction that was already built by the dapp,\n   * 2. A transaction data input as JSON. This is for the wallet to be able to simulate before signing\n   *\n   * @param transactionOrPayload AnyRawTransaction | InputTransactionData\n   * @param asFeePayer optional. A flag indicates to sign the transaction as the fee payer\n   * @param options optional. Transaction options\n   *\n   * @returns AccountAuthenticator\n   */\n  async signTransaction(args: {\n    transactionOrPayload: AnyRawTransaction | InputTransactionData;\n    asFeePayer?: boolean;\n  }): Promise<{\n    authenticator: AccountAuthenticator;\n    rawTransaction: Uint8Array;\n  }> {\n    const { transactionOrPayload, asFeePayer } = args;\n    /**\n     * All standard compatible wallets should support AnyRawTransaction for signTransaction version 1.0.0\n     * For standard signTransaction version 1.1.0, the standard expects a transaction input\n     *\n     * So, if the input is AnyRawTransaction, we can directly call the wallet's signTransaction method\n     *\n     *\n     * If the input is InputTransactionData, we need to\n     * 1. check if the wallet supports signTransaction version 1.1.0 - if so, we convert the input to the standard expected input\n     * 2. if it does not support signTransaction version 1.1.0, we convert it to a rawTransaction input and call the wallet's signTransaction method\n     */\n\n    try {\n      this.ensureWalletExists(this._wallet);\n      this.ensureAccountExists(this._account);\n      this.recordEvent(\"sign_transaction\");\n\n      // dapp sends a generated transaction (i.e AnyRawTransaction), which is supported by the wallet standard at signTransaction version 1.0.0\n      if (\"rawTransaction\" in transactionOrPayload) {\n        const response = (await this._wallet?.features[\n          \"cedra:signTransaction\"\n        ].signTransaction(\n          transactionOrPayload,\n          asFeePayer\n        )) as UserResponse<AccountAuthenticator>;\n        if (response.status === UserResponseStatus.REJECTED) {\n          throw new WalletConnectionError(\"User has rejected the request\")\n            .message;\n        }\n        return {\n          authenticator: response.args,\n          rawTransaction: transactionOrPayload.rawTransaction.bcsToBytes(),\n        };\n      } // dapp sends a transaction data input (i.e InputTransactionData), which is supported by the wallet standard at signTransaction version 1.1.0\n      else if (\n        this._wallet.features[\"cedra:signTransaction\"]?.version === \"1.1\"\n      ) {\n        // convert input to standard expected input\n        const signTransactionV1_1StandardInput: CedraSignTransactionInputV1_1 =\n          {\n            payload: transactionOrPayload.data,\n            expirationTimestamp:\n              transactionOrPayload.options?.expirationTimestamp,\n            expirationSecondsFromNow:\n              transactionOrPayload.options?.expirationSecondsFromNow,\n            gasUnitPrice: transactionOrPayload.options?.gasUnitPrice,\n            maxGasAmount: transactionOrPayload.options?.maxGasAmount,\n            sequenceNumber: transactionOrPayload.options?.accountSequenceNumber,\n            sender: transactionOrPayload.sender\n              ? { address: AccountAddress.from(transactionOrPayload.sender) }\n              : undefined,\n          };\n\n        const walletSignTransactionMethod = this._wallet?.features[\n          \"cedra:signTransaction\"\n        ].signTransaction as CedraSignTransactionMethod &\n          CedraSignTransactionMethodV1_1;\n\n        const response = (await walletSignTransactionMethod(\n          signTransactionV1_1StandardInput\n        )) as UserResponse<CedraSignTransactionOutputV1_1>;\n        if (response.status === UserResponseStatus.REJECTED) {\n          throw new WalletConnectionError(\"User has rejected the request\")\n            .message;\n        }\n        return {\n          authenticator: response.args.authenticator,\n          rawTransaction: response.args.rawTransaction.bcsToBytes(),\n        };\n      } else {\n        // dapp input is InputTransactionData but the wallet does not support it, so we convert it to a rawTransaction\n        const cedraConfig = getCedraConfig(this._network, this._dappConfig);\n        const cedra = new Cedra(cedraConfig);\n\n        const transaction = await cedra.transaction.build.simple({\n          sender: this._account.address,\n          data: transactionOrPayload.data,\n          options: transactionOrPayload.options,\n          withFeePayer: transactionOrPayload.withFeePayer,\n        });\n\n        const response = (await this._wallet?.features[\n          \"cedra:signTransaction\"\n        ].signTransaction(\n          transaction,\n          asFeePayer\n        )) as UserResponse<AccountAuthenticator>;\n        if (response.status === UserResponseStatus.REJECTED) {\n          throw new WalletConnectionError(\"User has rejected the request\")\n            .message;\n        }\n\n        return {\n          authenticator: response.args,\n          rawTransaction: transaction.bcsToBytes(),\n        };\n      }\n    } catch (error: any) {\n      const errMsg = generalizedErrorMessage(error);\n      throw new WalletSignTransactionError(errMsg).message;\n    }\n  }\n\n  /**\n   * Sign a message (doesnt submit to chain).\n   *\n   * @param message - CedraSignMessageInput\n   *\n   * @return response from the wallet's signMessage function\n   * @throws WalletSignMessageError\n   */\n  async signMessage(\n    message: CedraSignMessageInput\n  ): Promise<CedraSignMessageOutput> {\n    try {\n      this.ensureWalletExists(this._wallet);\n      this.recordEvent(\"sign_message\");\n\n      const response =\n        await this._wallet?.features[\"cedra:signMessage\"]?.signMessage(message);\n      if (response.status === UserResponseStatus.REJECTED) {\n        throw new WalletConnectionError(\"User has rejected the request\")\n          .message;\n      }\n      return response.args;\n    } catch (error: any) {\n      const errMsg = generalizedErrorMessage(error);\n      throw new WalletSignMessageError(errMsg).message;\n    }\n  }\n\n  /**\n   * Submits transaction to chain\n   *\n   * @param transaction - InputSubmitTransactionData\n   * @returns PendingTransactionResponse\n   */\n  async submitTransaction(\n    transaction: InputSubmitTransactionData\n  ): Promise<PendingTransactionResponse> {\n    // The standard does not support submitTransaction, so we use the adapter to submit the transaction\n    try {\n      this.ensureWalletExists(this._wallet);\n\n      const { additionalSignersAuthenticators } = transaction;\n      const transactionType =\n        additionalSignersAuthenticators !== undefined\n          ? \"multi-agent\"\n          : \"simple\";\n      this.recordEvent(\"submit_transaction\", {\n        transaction_type: transactionType,\n      });\n\n      const cedraConfig = getCedraConfig(this._network, this._dappConfig);\n      const cedra = new Cedra(cedraConfig);\n      if (additionalSignersAuthenticators !== undefined) {\n        const multiAgentTxn = {\n          ...transaction,\n          additionalSignersAuthenticators,\n        };\n        return cedra.transaction.submit.multiAgent(multiAgentTxn);\n      } else {\n        return cedra.transaction.submit.simple(transaction);\n      }\n    } catch (error: any) {\n      const errMsg = generalizedErrorMessage(error);\n      throw new WalletSubmitTransactionError(errMsg).message;\n    }\n  }\n\n  /**\n   Event for when account has changed on the wallet\n   @return the new account info\n   @throws WalletAccountChangeError\n   */\n  async onAccountChange(): Promise<void> {\n    try {\n      this.ensureWalletExists(this._wallet);\n      await this._wallet.features[\"cedra:onAccountChange\"]?.onAccountChange(\n        async (data: AccountInfo) => {\n          this.setAccount(data);\n          await this.setAnsName();\n          this.recordEvent(\"account_change\");\n          this.emit(\"accountChange\", this._account);\n        }\n      );\n    } catch (error: any) {\n      const errMsg = generalizedErrorMessage(error);\n      throw new WalletAccountChangeError(errMsg).message;\n    }\n  }\n\n  /**\n   Event for when network has changed on the wallet\n   @return the new network info\n   @throws WalletNetworkChangeError\n   */\n  async onNetworkChange(): Promise<void> {\n    try {\n      this.ensureWalletExists(this._wallet);\n      await this._wallet.features[\"cedra:onNetworkChange\"]?.onNetworkChange(\n        async (data: NetworkInfo) => {\n          this.setNetwork(data);\n          await this.setAnsName();\n          this.emit(\"networkChange\", this._network);\n        }\n      );\n    } catch (error: any) {\n      const errMsg = generalizedErrorMessage(error);\n      throw new WalletNetworkChangeError(errMsg).message;\n    }\n  }\n\n  /**\n   * Sends a change network request to the wallet to change the connected network\n   *\n   * @param network - Network\n   * @returns CedraChangeNetworkOutput\n   */\n  async changeNetwork(network: Network): Promise<CedraChangeNetworkOutput> {\n    try {\n      this.ensureWalletExists(this._wallet);\n      this.recordEvent(\"change_network_request\", {\n        from: this._network?.name,\n        to: network,\n      });\n      const chainId =\n        network === Network.DEVNET\n          ? await fetchDevnetChainId()\n          : NetworkToChainId[network];\n\n      const networkInfo: NetworkInfo = {\n        name: network,\n        chainId,\n      };\n\n      if (this._wallet.features[\"cedra:changeNetwork\"]) {\n        const response =\n          await this._wallet.features[\"cedra:changeNetwork\"].changeNetwork(\n            networkInfo\n          );\n        if (response.status === UserResponseStatus.REJECTED) {\n          throw new WalletConnectionError(\"User has rejected the request\")\n            .message;\n        }\n        return response.args;\n      }\n\n      throw new WalletChangeNetworkError(\n        `${this._wallet.name} does not support changing network request`\n      ).message;\n    } catch (error: any) {\n      const errMsg = generalizedErrorMessage(error);\n      throw new WalletChangeNetworkError(errMsg).message;\n    }\n  }\n\n  /**\n   * Signs a message and verifies the signer\n   * @param message - CedraSignMessageInput\n   * @returns boolean\n   */\n  async signMessageAndVerify(message: CedraSignMessageInput): Promise<boolean> {\n    try {\n      this.ensureWalletExists(this._wallet);\n      this.ensureAccountExists(this._account);\n      this.recordEvent(\"sign_message_and_verify\");\n\n      // sign the message\n      const response = (await this._wallet.features[\n        \"cedra:signMessage\"\n      ].signMessage(message)) as UserResponse<CedraSignMessageOutput>;\n\n      if (response.status === UserResponseStatus.REJECTED) {\n        throw new WalletConnectionError(\"Failed to sign a message\").message;\n      }\n\n      const cedraConfig = getCedraConfig(this._network, this._dappConfig);\n      const signingMessage = new TextEncoder().encode(\n        response.args.fullMessage\n      );\n      if (\"verifySignatureAsync\" in (this._account.publicKey as Object)) {\n        return await this._account.publicKey.verifySignatureAsync({\n          cedraConfig,\n          message: signingMessage,\n          signature: response.args.signature,\n          options: { throwErrorWithReason: true },\n        });\n      }\n      return this._account.publicKey.verifySignature({\n        message: signingMessage,\n        signature: response.args.signature,\n      });\n    } catch (error: any) {\n      const errMsg = generalizedErrorMessage(error);\n      throw new WalletSignMessageAndVerifyError(errMsg).message;\n    }\n  }\n}\n","export class GA4 {\n  readonly cedraGAID: string | undefined = process.env.GAID;\n\n  constructor() {\n    // Inject Cedra Google Analytics 4 script\n    this.injectGA(this.cedraGAID);\n  }\n\n  gtag(a: string, b: string | object, c?: object) {\n    let dataLayer = (window as any).dataLayer || [];\n    dataLayer.push(arguments);\n  }\n\n  private injectGA(gaID?: string) {\n    if (typeof window === \"undefined\") return;\n    if (!gaID) return;\n\n    const head = document.getElementsByTagName(\"head\")[0];\n\n    var myScript = document.createElement(\"script\");\n\n    myScript.setAttribute(\n      \"src\",\n      `https://www.googletagmanager.com/gtag/js?id=${gaID}`,\n    );\n\n    const that = this;\n    myScript.onload = function () {\n      that.gtag(\"js\", new Date());\n      that.gtag(\"config\", `${gaID}`, {\n        send_page_view: false,\n      });\n    };\n\n    head.insertBefore(myScript, head.children[1]);\n  }\n}\n","export class WalletError extends Error {\n  public error: any;\n\n  constructor(message?: string, error?: any) {\n    super(message);\n    this.error = error;\n  }\n}\n\nexport class WalletNotSelectedError extends WalletError {\n  name = \"WalletNotSelectedError\";\n}\n\nexport class WalletNotReadyError extends WalletError {\n  name = \"WalletNotReadyError\";\n}\n\nexport class WalletLoadError extends WalletError {\n  name = \"WalletLoadError\";\n}\n\nexport class WalletConfigError extends WalletError {\n  name = \"WalletConfigError\";\n}\n\nexport class WalletConnectionError extends WalletError {\n  name = \"WalletConnectionError\";\n}\n\nexport class WalletDisconnectedError extends WalletError {\n  name = \"WalletDisconnectedError\";\n}\n\nexport class WalletDisconnectionError extends WalletError {\n  name = \"WalletDisconnectionError\";\n}\n\nexport class WalletAccountError extends WalletError {\n  name = \"WalletAccountError\";\n}\nexport class WalletGetNetworkError extends WalletError {\n  name = \"WalletGetNetworkError\";\n}\n\nexport class WalletAccountChangeError extends WalletError {\n  name = \"WalletAccountChangeError\";\n}\n\nexport class WalletNetworkChangeError extends WalletError {\n  name = \"WalletNetworkChangeError\";\n}\n\nexport class WalletPublicKeyError extends WalletError {\n  name = \"WalletPublicKeyError\";\n}\n\nexport class WalletKeypairError extends WalletError {\n  name = \"WalletKeypairError\";\n}\n\nexport class WalletNotConnectedError extends WalletError {\n  name = \"WalletNotConnectedError\";\n}\n\nexport class WalletSendTransactionError extends WalletError {\n  name = \"WalletSendTransactionError\";\n}\n\nexport class WalletSignMessageError extends WalletError {\n  name = \"WalletSignMessageError\";\n}\n\nexport class WalletSignMessageAndVerifyError extends WalletError {\n  name = \"WalletSignMessageAndVerifyError\";\n}\n\nexport class WalletSignAndSubmitMessageError extends WalletError {\n  name = \"WalletSignAndSubmitMessageError\";\n}\n\nexport class WalletSignTransactionError extends WalletError {\n  name = \"WalletSignTransactionError\";\n}\n\nexport class WalletTimeoutError extends WalletError {\n  name = \"WalletTimeoutError\";\n}\n\nexport class WalletWindowBlockedError extends WalletError {\n  name = \"WalletWindowBlockedError\";\n}\n\nexport class WalletWindowClosedError extends WalletError {\n  name = \"WalletWindowClosedError\";\n}\n\nexport class WalletResponseError extends WalletError {\n  name = \"WalletResponseError\";\n}\n\nexport class WalletNotSupportedMethod extends WalletError {\n  name = \"WalletNotSupportedMethod\";\n}\n\nexport class WalletChangeNetworkError extends WalletError {\n  name = \"WalletChangeNetworkError\";\n}\n\nexport class WalletSubmitTransactionError extends WalletError {\n  name = \"WalletSubmitTransactionError\";\n}\n\nexport class WalletNotFoundError extends WalletError {\n  name = \"WalletNotFoundError\";\n}\n","export enum WalletReadyState {\n  /**\n   * Wallet can only be in one of two states - installed or not installed\n   * Installed: wallets are detected by the browser event listeners and means they are installed on the user's browser.\n   * NotDetected: wallets are not detected by the browser event listeners and means they are not installed on the user's browser.\n   */\n  Installed = \"Installed\",\n  NotDetected = \"NotDetected\",\n}\n\nexport enum NetworkName {\n  Mainnet = \"mainnet\",\n  Testnet = \"testnet\",\n  Devnet = \"devnet\",\n}\n\nexport const ChainIdToAnsSupportedNetworkMap: Record<string, string> = {\n  \"1\": \"mainnet\", // mainnet\n  \"2\": \"testnet\", // testnet\n};\n\n/** The base URL for all Cedra Connect wallets. */\nexport const CEDRA_CONNECT_BASE_URL = \"https://cedraconnect.app\";\n\n/** The URL to the Cedra Connect account page if the user is signed in to Cedra Connect. */\nexport const CEDRA_CONNECT_ACCOUNT_URL =\n  \"https://cedraconnect.app/dashboard/main-account\";\n","import {\n  Cedra,\n  CedraConfig,\n  Hex,\n  Network,\n  NetworkToNodeAPI,\n} from \"@cedra-labs/ts-sdk\";\nimport {\n  NetworkInfo,\n  NetworkInfo as StandardNetworkInfo,\n} from \"@cedra-labs/wallet-standard\";\n\nimport { DappConfig } from \"../WalletCore\";\nimport { WalletSignAndSubmitMessageError } from \"../error\";\nimport { InputTransactionData } from \"./types\";\n\nexport function isMobile(): boolean {\n  return /Mobile|iP(hone|od|ad)|Android|BlackBerry|IEMobile|Kindle|NetFront|Silk-Accelerated|(hpw|web)OS|Fennec|Minimo|Opera M(obi|ini)|Blazer|Dolfin|Dolphin|Skyfire|Zune/i.test(\n    navigator.userAgent,\n  );\n}\n\nexport function isInAppBrowser(): boolean {\n  const isIphone = /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(\n    navigator.userAgent,\n  );\n\n  const isAndroid = /(Android).*Version\\/[\\d.]+.*Chrome\\/[^\\s]+ Mobile/i.test(\n    navigator.userAgent,\n  );\n\n  return isIphone || isAndroid;\n}\n\nexport function isRedirectable(): boolean {\n  // SSR: return false\n  if (typeof navigator === \"undefined\" || !navigator) return false;\n\n  // if we are on mobile and NOT in a in-app browser we will redirect to a wallet app\n\n  return isMobile() && !isInAppBrowser();\n}\n\nexport function generalizedErrorMessage(error: any): string {\n  return typeof error === \"object\" && \"message\" in error\n    ? error.message\n    : error;\n}\n\n/**\n * Helper function to get CedraConfig that supports Cedra and Custom networks\n *\n * @param networkInfo\n * @param dappConfig\n * @returns CedraConfig\n */\nexport const getCedraConfig = (\n  networkInfo: NetworkInfo | null,\n  dappConfig: DappConfig | undefined,\n): CedraConfig => {\n  if (!networkInfo) {\n    throw new Error(\"Undefined network\");\n  }\n\n  if (isCedraNetwork(networkInfo)) {\n    const currentNetwork = convertNetwork(networkInfo);\n\n    if (isCedraLiveNetwork(currentNetwork)) {\n      const apiKey = dappConfig?.cedraApiKeys;\n      return new CedraConfig({\n        network: currentNetwork,\n        clientConfig: { API_KEY: apiKey ? apiKey[currentNetwork] : undefined },\n      });\n    }\n\n    return new CedraConfig({\n      network: currentNetwork,\n    });\n  }\n\n  const knownNetworks = {\n    okx: \"https://wallet.okx.com/fullnode/cedra/discover/rpc\",\n  };\n\n  if (networkInfo.url) {\n    const isKnownNetwork = Object.values(knownNetworks).includes(\n      networkInfo.url,\n    );\n\n    if (isKnownNetwork) {\n      return new CedraConfig({\n        network: Network.CUSTOM,\n        fullnode: networkInfo.url,\n      });\n    }\n  }\n\n  // Custom networks are not supported, please ensure that the wallet is returning the appropriate network Mainnet, Testnet, Devnet, Local\n  throw new Error(\n    `Invalid network, network ${networkInfo.name} not supported with Cedra wallet adapter to prevent user from using an unexpected network.`,\n  );\n};\n\n/**\n * Helper function to resolve if the current connected network is an Cedra network\n *\n * @param networkInfo\n * @returns boolean\n */\nexport const isCedraNetwork = (\n  networkInfo: NetworkInfo | StandardNetworkInfo | null,\n): boolean => {\n  if (!networkInfo) {\n    throw new Error(\"Undefined network\");\n  }\n  return NetworkToNodeAPI[networkInfo.name] !== undefined;\n};\n\nexport const isCedraLiveNetwork = (networkInfo: Network): boolean => {\n  return (\n    networkInfo === \"devnet\" ||\n    networkInfo === \"testnet\" ||\n    networkInfo === \"mainnet\"\n  );\n};\n\n/**\n * Helper function to fetch Devnet chain id\n */\nexport const fetchDevnetChainId = async (): Promise<number> => {\n  const cedra = new Cedra(); // default to devnet\n  return await cedra.getChainId();\n};\n\n/**\n * A helper function to handle the publish package transaction.\n * The Cedra SDK expects the metadataBytes and byteCode to be Uint8Array, but in case the arguments are passed in\n * as a string, this function converts the string to Uint8Array.\n */\nexport const handlePublishPackageTransaction = (\n  transactionInput: InputTransactionData,\n) => {\n  // convert the first argument, metadataBytes, to uint8array if is a string\n  let metadataBytes = transactionInput.data.functionArguments[0];\n  if (typeof metadataBytes === \"string\") {\n    metadataBytes = Hex.fromHexInput(metadataBytes).toUint8Array();\n  }\n\n  // convert the second argument, byteCode, to uint8array if is a string\n  let byteCode = transactionInput.data.functionArguments[1];\n  if (Array.isArray(byteCode)) {\n    byteCode = byteCode.map((byte) => {\n      if (typeof byte === \"string\") {\n        return Hex.fromHexInput(byte).toUint8Array();\n      }\n      return byte;\n    });\n  } else {\n    throw new WalletSignAndSubmitMessageError(\n      \"The bytecode argument must be an array.\",\n    ).message;\n  }\n\n  return { metadataBytes, byteCode };\n};\n\n// old => new\nexport function convertNetwork(networkInfo: NetworkInfo | null): Network {\n  switch (networkInfo?.name) {\n    case \"mainnet\" as Network:\n      return Network.MAINNET;\n    case \"testnet\" as Network:\n      return Network.TESTNET;\n    case \"devnet\" as Network:\n      return Network.DEVNET;\n    case \"local\" as Network:\n      return Network.LOCAL;\n    default:\n      throw new Error(\"Invalid Cedra network name\");\n  }\n}\n","const LOCAL_STORAGE_ITEM_KEY = \"CedraWalletName\";\n\nexport function setLocalStorage(walletName: string) {\n  localStorage.setItem(LOCAL_STORAGE_ITEM_KEY, walletName);\n}\n\nexport function removeLocalStorage() {\n  localStorage.removeItem(LOCAL_STORAGE_ITEM_KEY);\n}\n\nexport function getLocalStorage() {\n  localStorage.getItem(LOCAL_STORAGE_ITEM_KEY);\n}\n","import { WalletInfo } from \"./types\";\nimport { AdapterNotDetectedWallet, AdapterWallet } from \"../WalletCore\";\nimport { CEDRA_CONNECT_BASE_URL, WalletReadyState } from \"../constants\";\nimport { isRedirectable } from \"./helpers\";\n\n/**\n * A function that will partition the provided wallets into two list  `defaultWallets` and `moreWallets`.\n * By default, the wallets will be partitioned by whether or not they are installed or loadable.\n * You can pass your own partition function if you wish to customize this behavior.\n */\nexport function partitionWallets(\n  wallets: ReadonlyArray<AdapterWallet | AdapterNotDetectedWallet>,\n  partitionFunction: (\n    wallet: AdapterWallet | AdapterNotDetectedWallet,\n  ) => boolean = isInstalledOrLoadable,\n) {\n  const defaultWallets: Array<AdapterWallet> = [];\n  const moreWallets: Array<AdapterNotDetectedWallet> = [];\n\n  for (const wallet of wallets) {\n    if (partitionFunction(wallet)) defaultWallets.push(wallet as AdapterWallet);\n    else moreWallets.push(wallet as AdapterNotDetectedWallet);\n  }\n\n  return { defaultWallets, moreWallets };\n}\n\n/** Returns true if the wallet is installed or loadable. */\nexport function isInstalledOrLoadable(\n  wallet: AdapterWallet | AdapterNotDetectedWallet,\n) {\n  return wallet.readyState === WalletReadyState.Installed;\n}\n\n/**\n * Returns true if the user is on desktop and the provided wallet requires installation of a browser extension.\n * This can be used to decide whether to show a \"Connect\" button or \"Install\" link in the UI.\n */\nexport function isInstallRequired(\n  wallet: AdapterWallet | AdapterNotDetectedWallet,\n) {\n  const isWalletReady = isInstalledOrLoadable(wallet);\n  const isMobile = !isWalletReady && isRedirectable();\n\n  return !isMobile && !isWalletReady;\n}\n\n/** Truncates the provided wallet address at the middle with an ellipsis. */\nexport function truncateAddress(address: string | undefined) {\n  if (!address) return;\n  return `${address.slice(0, 6)}...${address.slice(-5)}`;\n}\n\n/** Returns `true` if the provided wallet is an Cedra Connect wallet. */\nexport function isCedraConnectWallet(wallet: WalletInfo | AdapterWallet) {\n  if (!wallet.url) return false;\n  return wallet.url.startsWith(CEDRA_CONNECT_BASE_URL);\n}\n\n/**\n * Partitions the `wallets` array so that Cedra Connect wallets are grouped separately from the rest.\n * Cedra Connect is a web wallet that uses social login to create accounts on the blockchain.\n */\nexport function getCedraConnectWallets(\n  wallets: ReadonlyArray<AdapterWallet | AdapterNotDetectedWallet>,\n) {\n  const { defaultWallets, moreWallets } = partitionWallets(\n    wallets,\n    isCedraConnectWallet,\n  );\n  return { cedraConnectWallets: defaultWallets, otherWallets: moreWallets };\n}\n\nexport interface WalletSortingOptions {\n  /** An optional function for sorting Cedra Connect wallets. */\n  sortCedraConnectWallets?: (a: AdapterWallet, b: AdapterWallet) => number;\n  /** An optional function for sorting wallets that are currently installed or loadable. */\n  sortAvailableWallets?: (\n    a: AdapterWallet | AdapterNotDetectedWallet,\n    b: AdapterWallet | AdapterNotDetectedWallet,\n  ) => number;\n  /** An optional function for sorting wallets that are NOT currently installed or loadable. */\n  sortInstallableWallets?: (\n    a: AdapterWallet | AdapterNotDetectedWallet,\n    b: AdapterWallet | AdapterNotDetectedWallet,\n  ) => number;\n}\n\n/**\n * Partitions the `wallets` array into three distinct groups:\n *\n * `cedraConnectWallets` - Wallets that use social login to create accounts on\n * the blockchain via Cedra Connect.\n *\n * `availableWallets` - Wallets that are currently installed or loadable by the client.\n *\n * `installableWallets` - Wallets that are NOT current installed or loadable and\n * require the client to install a browser extension first.\n *\n * Additionally, these wallet groups can be sorted by passing sort functions via the `options` argument.\n */\nexport function groupAndSortWallets(\n  wallets: ReadonlyArray<AdapterWallet | AdapterNotDetectedWallet>,\n  options?: WalletSortingOptions,\n) {\n  const { cedraConnectWallets, otherWallets } = getCedraConnectWallets(wallets);\n  const { defaultWallets, moreWallets } = partitionWallets(otherWallets);\n\n  if (options?.sortCedraConnectWallets) {\n    cedraConnectWallets.sort(options.sortCedraConnectWallets);\n  }\n  if (options?.sortAvailableWallets) {\n    defaultWallets.sort(options.sortAvailableWallets);\n  }\n  if (options?.sortInstallableWallets) {\n    moreWallets.sort(options.sortInstallableWallets);\n  }\n\n  return {\n    /** Wallets that use social login to create an account on the blockchain */\n    cedraConnectWallets,\n    /** Wallets that are currently installed or loadable. */\n    availableWallets: defaultWallets,\n    /** Wallets that are NOT currently installed or loadable. */\n    installableWallets: moreWallets,\n  };\n}\n","import { WalletReadyState } from \"./constants\";\nimport { CedraStandardSupportedWallet } from \"./utils/types\";\n\n/**\n * Registry of AIP-62 wallet standard supported wallets.\n * This list is used to show supported wallets even if they are not installed on the user machine.\n *\n * AIP-62 compatible wallets are required to add their wallet info here if they want to be detected by the adapter\n *\n * @param name - The name of your wallet cast to WalletName (Ex. \"Nightly\" as WalletName<\"Nightly\">)\n * @param url - The link to your chrome extension or main website where new users can create an account with your wallet.\n * @param icon - An icon for your wallet. Can be one of 4 data types. Be sure to follow the below format exactly (including the literal \",\" after base64).\n *        Format: `data:image/${\"svg+xml\" | \"webp\" | \"png\" | \"gif\"};base64,${string}`\n *        Note: ${...} data in the above format should be replaced. Other characters are literals (ex. \";\")\n * @param deeplinkProvider optional - An optional deeplink provider for the wallet. If the wallet is not installed, we can redirect the user to the wallet's deeplink provider\n * @example \"https://myWallet.app/explore?link=\"\n */\nexport const cedraStandardSupportedWalletList: Array<CedraStandardSupportedWallet> =\n  [\n    {\n      name: \"Nightly\",\n      url: \"https://nightly.app/\",\n      icon: \"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4NCjwhLS0gR2VuZXJhdG9yOiBBZG9iZSBJbGx1c3RyYXRvciAyOC4wLjAsIFNWRyBFeHBvcnQgUGx1Zy1JbiAuIFNWRyBWZXJzaW9uOiA2LjAwIEJ1aWxkIDApICAtLT4NCjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iV2Fyc3R3YV8xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4PSIwcHgiIHk9IjBweCINCgkgdmlld0JveD0iMCAwIDg1MS41IDg1MS41IiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCA4NTEuNSA4NTEuNTsiIHhtbDpzcGFjZT0icHJlc2VydmUiPg0KPHN0eWxlIHR5cGU9InRleHQvY3NzIj4NCgkuc3Qwe2ZpbGw6IzYwNjdGOTt9DQoJLnN0MXtmaWxsOiNGN0Y3Rjc7fQ0KPC9zdHlsZT4NCjxnPg0KCTxnIGlkPSJXYXJzdHdhXzJfMDAwMDAwMTQ2MDk2NTQyNTMxODA5NDY0NjAwMDAwMDg2NDc4NTIwMDIxMTY5MTg2ODhfIj4NCgkJPHBhdGggY2xhc3M9InN0MCIgZD0iTTEyNCwwaDYwMy42YzY4LjUsMCwxMjQsNTUuNSwxMjQsMTI0djYwMy42YzAsNjguNS01NS41LDEyNC0xMjQsMTI0SDEyNGMtNjguNSwwLTEyNC01NS41LTEyNC0xMjRWMTI0DQoJCQlDMCw1NS41LDU1LjUsMCwxMjQsMHoiLz4NCgk8L2c+DQoJPGcgaWQ9IldhcnN0d2FfMyI+DQoJCTxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik02MjMuNSwxNzAuM2MtMzcuNCw1Mi4yLTg0LjIsODguNC0xMzkuNSwxMTIuNmMtMTkuMi01LjMtMzguOS04LTU4LjMtNy44Yy0xOS40LTAuMi0zOS4xLDIuNi01OC4zLDcuOA0KCQkJYy01NS4zLTI0LjMtMTAyLjEtNjAuMy0xMzkuNS0xMTIuNmMtMTEuMywyOC40LTU0LjgsMTI2LjQtMi42LDI2My40YzAsMC0xNi43LDcxLjUsMTQsMTMyLjljMCwwLDQ0LjQtMjAuMSw3OS43LDguMg0KCQkJYzM2LjksMjkuOSwyNS4xLDU4LjcsNTEuMSw4My41YzIyLjQsMjIuOSw1NS43LDIyLjksNTUuNywyMi45czMzLjMsMCw1NS43LTIyLjhjMjYtMjQuNywxNC4zLTUzLjUsNTEuMS04My41DQoJCQljMzUuMi0yOC4zLDc5LjctOC4yLDc5LjctOC4yYzMwLjYtNjEuNCwxNC0xMzIuOSwxNC0xMzIuOUM2NzguMywyOTYuNyw2MzQuOSwxOTguNyw2MjMuNSwxNzAuM3ogTTI1My4xLDQxNC44DQoJCQljLTI4LjQtNTguMy0zNi4yLTEzOC4zLTE4LjMtMjAxLjVjMjMuNyw2MCw1NS45LDg2LjksOTQuMiwxMTUuM0MzMTIuOCwzNjIuMywyODIuMywzOTQuMSwyNTMuMSw0MTQuOHogTTMzNC44LDUxNy41DQoJCQljLTIyLjQtOS45LTI3LjEtMjkuNC0yNy4xLTI5LjRjMzAuNS0xOS4yLDc1LjQtNC41LDc2LjgsNDAuOUMzNjAuOSw1MTQuNywzNTMsNTI1LjQsMzM0LjgsNTE3LjV6IE00MjUuNyw2NzguNw0KCQkJYy0xNiwwLTI5LTExLjUtMjktMjUuNnMxMy0yNS42LDI5LTI1LjZzMjksMTEuNSwyOSwyNS42QzQ1NC43LDY2Ny4zLDQ0MS43LDY3OC43LDQyNS43LDY3OC43eiBNNTE2LjcsNTE3LjUNCgkJCWMtMTguMiw4LTI2LTIuOC00OS43LDExLjVjMS41LTQ1LjQsNDYuMi02MC4xLDc2LjgtNDAuOUM1NDMuOCw0ODgsNTM5LDUwNy42LDUxNi43LDUxNy41eiBNNTk4LjMsNDE0LjgNCgkJCWMtMjkuMS0yMC43LTU5LjctNTIuNC03Ni04Ni4yYzM4LjMtMjguNCw3MC42LTU1LjQsOTQuMi0xMTUuM0M2MzQuNiwyNzYuNSw2MjYuOCwzNTYuNiw1OTguMyw0MTQuOHoiLz4NCgk8L2c+DQo8L2c+DQo8L3N2Zz4NCg==\",\n      readyState: WalletReadyState.NotDetected,\n      isAIP62Standard: true,\n      deeplinkProvider: \"nightly://v1?network=cedra&url=\",\n    },\n\n    {\n      name: \"Zedra\",\n      url: \"https://chromewebstore.google.com/detail/zedra-wallet/pbeefngmcchkcibdodceimammkigfanl\",\n      icon: \"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyBpZD0iTGF5ZXJfMiIgZGF0YS1uYW1lPSJMYXllciAyIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDgwIDEwODAiPgogIDxkZWZzPgogICAgPHN0eWxlPgogICAgICAuY2xzLTEgewogICAgICAgIGZpbGw6ICNiOGZmZGU7CiAgICAgIH0KICAgIDwvc3R5bGU+CiAgPC9kZWZzPgogIDxnIGlkPSJMYXllcl8xLTIiIGRhdGEtbmFtZT0iTGF5ZXIgMSI+CiAgICA8cmVjdCBjbGFzcz0iY2xzLTEiIHdpZHRoPSIxMDgwIiBoZWlnaHQ9IjEwODAiIHJ4PSIxMjAuNTQiIHJ5PSIxMjAuNTQiLz4KICAgIDxnPgogICAgICA8cGF0aCBkPSJtMzIyLjQ3LDIxOS4xMWgzNTMuNDdjMTMuMzgsMCwyNS42Miw3LjUxLDMxLjY5LDE5LjQzbDExMC43OSwyMTcuNjljNi43NiwxMy4yOCw0LjUyLDI5LjM3LTUuNjEsNDAuM2wtMTE5LjU0LDEyOWMtMTMuNDYsMTQuNTMtMzYuMiwxNS4yNi01MC41NywxLjYybC03Ny41Ni03My42NGMtMTQuNDYtMTMuNzMtMTQuOC0zNi42Ni0uNzctNTAuODJsNDIuOTYtNDMuMzVjMjIuMjgtMjIuNDgsNi4yOS02MC42OS0yNS4zNi02MC41OWwtMjU5LjQuNzljLTE5LjY4LjA2LTM1LjY3LTE1Ljg4LTM1LjY3LTM1LjU2di0xMDkuMzFjMC0xOS42NCwxNS45Mi0zNS41NiwzNS41Ni0zNS41NloiLz4KICAgICAgPHBhdGggZD0ibTc1Ny41Myw4NjAuODloLTM1My40N2MtMTMuMzgsMC0yNS42Mi03LjUxLTMxLjY5LTE5LjQzbC0xMTAuNzktMjE3LjY5Yy02Ljc2LTEzLjI4LTQuNTItMjkuMzcsNS42MS00MC4zbDExOS41NC0xMjljMTMuNDYtMTQuNTMsMzYuMi0xNS4yNiw1MC41Ny0xLjYybDc3LjU2LDczLjY0YzE0LjQ2LDEzLjczLDE0LjgsMzYuNjYuNzcsNTAuODJsLTQyLjk2LDQzLjM1Yy0yMi4yOCwyMi40OC02LjI5LDYwLjY5LDI1LjM2LDYwLjU5bDI1OS40LS43OWMxOS42OC0uMDYsMzUuNjcsMTUuODgsMzUuNjcsMzUuNTZ2MTA5LjMxYzAsMTkuNjQtMTUuOTIsMzUuNTYtMzUuNTYsMzUuNTZaIi8+CiAgICA8L2c+CiAgPC9nPgo8L3N2Zz4=\",\n      readyState: WalletReadyState.NotDetected,\n      isAIP62Standard: true,\n      deeplinkProvider: \"https://zedra.app/\",\n    }\n  ];\n  \n","import {\n  CedraConnectAppleWallet,\n  CedraConnectGoogleWallet,\n} from \"@cedra-labs/wallet-adapter-plugin\";\nimport { Network } from \"@cedra-labs/ts-sdk\";\n// import { DevTWallet, TWallet } from \"@cedra-labs/cedra-wallet-adapter\";\n// import { MSafeWallet } from \"./msafeWallet.ts\";\nimport { DappConfig, AdapterWallet } from \"./WalletCore\";\n\nexport function getSDKWallets(dappConfig?: DappConfig) {\n  const sdkWallets: AdapterWallet[] = [];\n\n  // Need to check window is defined for CedraConnect\n  if (typeof window !== \"undefined\") {\n    sdkWallets.push(\n      new CedraConnectGoogleWallet({\n        network: dappConfig?.network,\n        dappId: dappConfig?.cedraConnectDappId,\n        ...dappConfig?.cedraConnect,\n      }),\n      new CedraConnectAppleWallet({\n        network: dappConfig?.network,\n        dappId: dappConfig?.cedraConnectDappId,\n        ...dappConfig?.cedraConnect,\n      }),\n    );\n  }\n\n  // Push production wallet if env is production, otherwise use dev wallet\n  if (dappConfig?.network === Network.MAINNET) {\n    // TODO twallet uses @cedra-labs/wallet-standard at version 0.0.11 while adapter uses\n    // a newer version (0.1.0) - this causes type mismatch. We should figure out how to handle it.\n    // sdkWallets.push(new TWallet() as any);\n  } else {\n    // sdkWallets.push(new DevTWallet() as any);\n  }\n\n  // if (dappConfig?.network) {\n  //   sdkWallets.push(\n  //     new MSafeWallet({\n  //       ...dappConfig?.msafeWalletConfig,\n  //       network: dappConfig.network,\n  //     })\n  //   );\n  // }\n\n  // Add new SDK wallet plugins (ones that should be installed as packages) here:\n  // Ex. sdkWallets.push(new YourSDKWallet(dappConfig))\n\n  return sdkWallets;\n}\n"]}