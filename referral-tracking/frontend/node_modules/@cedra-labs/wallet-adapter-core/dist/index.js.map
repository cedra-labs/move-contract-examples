{"version":3,"sources":["/home/egor/Desktop/work/cedra-wallet-adapter/packages/wallet-adapter-core/dist/index.js","../src/index.ts","../src/version.ts","../src/WalletCore.ts","../src/ga/index.ts","../src/error/index.ts","../src/constants.ts","../src/utils/helpers.ts","../src/utils/localStorage.ts","../src/utils/walletSelector.ts","../src/registry.ts","../src/sdkWallets.ts"],"names":["__create","Object","create","__defProp","defineProperty","__getOwnPropDesc","getOwnPropertyDescriptor","__getOwnPropNames","getOwnPropertyNames","__getProtoOf","getPrototypeOf","__hasOwnProp","prototype","hasOwnProperty","__export","target","all","name","get","enumerable","__copyProps","to","from","except","desc","key","call","__toESM","mod","isNodeMode","__esModule","value","__toCommonJS","index_exports","CEDRA_CONNECT_ACCOUNT_URL","CEDRA_CONNECT_BASE_URL","ChainIdToAnsSupportedNetworkMap","NetworkName","WalletCore","WalletReadyState","cedraStandardSupportedWalletList","convertNetwork","fetchDevnetChainId","generalizedErrorMessage","getCedraConfig","getCedraConnectWallets","getLocalStorage","getSDKWallets","groupAndSortWallets","handlePublishPackageTransaction","isCedraConnectWallet","isCedraLiveNetwork","isCedraNetwork","isInAppBrowser","isInstallRequired","isInstalledOrLoadable","isMobile","isRedirectable","partitionWallets","removeLocalStorage","setLocalStorage","truncateAddress","exports","WALLET_ADAPTER_CORE_VERSION","import_ts_sdk","require","import_wallet_standard","GA4","injectGA","cedraGAID","gtag","a","b","c","dataLayer","window","push","arguments","gaID","head","document","getElementsByTagName","myScript","createElement","setAttribute","that","onload","Date","send_page_view","insertBefore","children","WalletError","message","error","Error","WalletNotSelectedError","WalletNotReadyError","WalletConnectionError","WalletDisconnectionError","WalletAccountError","WalletGetNetworkError","WalletAccountChangeError","WalletNetworkChangeError","WalletNotConnectedError","WalletSignMessageError","WalletSignMessageAndVerifyError","WalletSignAndSubmitMessageError","WalletSignTransactionError","WalletNotSupportedMethod","WalletChangeNetworkError","WalletSubmitTransactionError","WalletNotFoundError","isIphone","test","navigator","userAgent","isAndroid","networkInfo","dappConfig","currentNetwork","apiKey","cedraApiKeys","CedraConfig","knownNetworks","url","network","okx","isKnownNetwork","values","includes","Network","CUSTOM","fullnode","NetworkToNodeAPI","cedra","metadataBytes","transactionInput","data","functionArguments","Hex","fromHexInput","toUint8Array","byteCode","Array","isArray","map","byte","LOCAL","LOCAL_STORAGE_ITEM_KEY","walletName","localStorage","setItem","removeItem","getItem","wallets","partitionFunction","moreWallets","wallet","readyState","cedraConnectWallets","defaultWallets","otherWallets","options","icon","import_wallet_adapter_plugin","isWalletReady","address","slice","startsWith","sortCedraConnectWallets","sort","sortAvailableWallets","sortInstallableWallets","availableWallets","installableWallets","isAIP62Standard","deeplinkProvider","sdkWallets","_optInWallets","_disableTelemetry","optInWallets","_connecting","_dappConfig","removeRegisterListener","fetchExtensionAIP62CedraWallets","_sdkWallets","_wallet","_standard_wallets","_standard_not_detected_wallets","_network","_connected","_account","ga4","disableTelemetry","fetchSDKAIP62CedraWallets","appendNotDetectedStandardSupportedWallets","getCedraWallets","cedraWallets","on","setExtensionAIP62Wallets","removeUnregisterListener","extensionwWallets","isValid","isWalletWithRequiredFeatureSet","index","findIndex","notDetctedWallet","splice","emit","excludeWallet","supportedWallet","existingStandardWallet","find","adapter_core_version","send_to","recordEvent","eventName","additionalInfo","ensureWalletExists","ensureAccountExists","account","setAnsName","cedraConfig","chainId","ansName","import_ts_sdk3","Cedra","toString","console","log","clearData","setWallet","setAccount","setNetwork"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\n// src/index.ts\nvar index_exports = {};\n__export(index_exports, {\n  CEDRA_CONNECT_ACCOUNT_URL: () => CEDRA_CONNECT_ACCOUNT_URL,\n  CEDRA_CONNECT_BASE_URL: () => CEDRA_CONNECT_BASE_URL,\n  ChainIdToAnsSupportedNetworkMap: () => ChainIdToAnsSupportedNetworkMap,\n  NetworkName: () => NetworkName,\n  WalletCore: () => WalletCore,\n  WalletReadyState: () => WalletReadyState,\n  cedraStandardSupportedWalletList: () => cedraStandardSupportedWalletList,\n  convertNetwork: () => convertNetwork,\n  fetchDevnetChainId: () => fetchDevnetChainId,\n  generalizedErrorMessage: () => generalizedErrorMessage,\n  getCedraConfig: () => getCedraConfig,\n  getCedraConnectWallets: () => getCedraConnectWallets,\n  getLocalStorage: () => getLocalStorage,\n  getSDKWallets: () => getSDKWallets,\n  groupAndSortWallets: () => groupAndSortWallets,\n  handlePublishPackageTransaction: () => handlePublishPackageTransaction,\n  isCedraConnectWallet: () => isCedraConnectWallet,\n  isCedraLiveNetwork: () => isCedraLiveNetwork,\n  isCedraNetwork: () => isCedraNetwork,\n  isInAppBrowser: () => isInAppBrowser,\n  isInstallRequired: () => isInstallRequired,\n  isInstalledOrLoadable: () => isInstalledOrLoadable,\n  isMobile: () => isMobile,\n  isRedirectable: () => isRedirectable,\n  partitionWallets: () => partitionWallets,\n  removeLocalStorage: () => removeLocalStorage,\n  setLocalStorage: () => setLocalStorage,\n  truncateAddress: () => truncateAddress\n});\nmodule.exports = __toCommonJS(index_exports);\n\n// src/version.ts\nvar WALLET_ADAPTER_CORE_VERSION = \"5.5.4\";\n\n// src/WalletCore.ts\nvar import_eventemitter3 = __toESM(require(\"eventemitter3\"));\nvar import_ts_sdk3 = require(\"@cedra-labs/ts-sdk\");\nvar import_wallet_standard = require(\"@cedra-labs/wallet-standard\");\n\n// src/ga/index.ts\nvar GA4 = class {\n  constructor() {\n    this.cedraGAID = true;\n    this.injectGA(this.cedraGAID);\n  }\n  gtag(a, b, c) {\n    let dataLayer = window.dataLayer || [];\n    dataLayer.push(arguments);\n  }\n  injectGA(gaID) {\n    if (typeof window === \"undefined\") return;\n    if (!gaID) return;\n    const head = document.getElementsByTagName(\"head\")[0];\n    var myScript = document.createElement(\"script\");\n    myScript.setAttribute(\n      \"src\",\n      `https://www.googletagmanager.com/gtag/js?id=${gaID}`\n    );\n    const that = this;\n    myScript.onload = function() {\n      that.gtag(\"js\", /* @__PURE__ */ new Date());\n      that.gtag(\"config\", `${gaID}`, {\n        send_page_view: false\n      });\n    };\n    head.insertBefore(myScript, head.children[1]);\n  }\n};\n\n// src/error/index.ts\nvar WalletError = class extends Error {\n  constructor(message, error) {\n    super(message);\n    this.error = error;\n  }\n};\nvar WalletNotSelectedError = class extends WalletError {\n  constructor() {\n    super(...arguments);\n    this.name = \"WalletNotSelectedError\";\n  }\n};\nvar WalletNotReadyError = class extends WalletError {\n  constructor() {\n    super(...arguments);\n    this.name = \"WalletNotReadyError\";\n  }\n};\nvar WalletConnectionError = class extends WalletError {\n  constructor() {\n    super(...arguments);\n    this.name = \"WalletConnectionError\";\n  }\n};\nvar WalletDisconnectionError = class extends WalletError {\n  constructor() {\n    super(...arguments);\n    this.name = \"WalletDisconnectionError\";\n  }\n};\nvar WalletAccountError = class extends WalletError {\n  constructor() {\n    super(...arguments);\n    this.name = \"WalletAccountError\";\n  }\n};\nvar WalletGetNetworkError = class extends WalletError {\n  constructor() {\n    super(...arguments);\n    this.name = \"WalletGetNetworkError\";\n  }\n};\nvar WalletAccountChangeError = class extends WalletError {\n  constructor() {\n    super(...arguments);\n    this.name = \"WalletAccountChangeError\";\n  }\n};\nvar WalletNetworkChangeError = class extends WalletError {\n  constructor() {\n    super(...arguments);\n    this.name = \"WalletNetworkChangeError\";\n  }\n};\nvar WalletNotConnectedError = class extends WalletError {\n  constructor() {\n    super(...arguments);\n    this.name = \"WalletNotConnectedError\";\n  }\n};\nvar WalletSignMessageError = class extends WalletError {\n  constructor() {\n    super(...arguments);\n    this.name = \"WalletSignMessageError\";\n  }\n};\nvar WalletSignMessageAndVerifyError = class extends WalletError {\n  constructor() {\n    super(...arguments);\n    this.name = \"WalletSignMessageAndVerifyError\";\n  }\n};\nvar WalletSignAndSubmitMessageError = class extends WalletError {\n  constructor() {\n    super(...arguments);\n    this.name = \"WalletSignAndSubmitMessageError\";\n  }\n};\nvar WalletSignTransactionError = class extends WalletError {\n  constructor() {\n    super(...arguments);\n    this.name = \"WalletSignTransactionError\";\n  }\n};\nvar WalletNotSupportedMethod = class extends WalletError {\n  constructor() {\n    super(...arguments);\n    this.name = \"WalletNotSupportedMethod\";\n  }\n};\nvar WalletChangeNetworkError = class extends WalletError {\n  constructor() {\n    super(...arguments);\n    this.name = \"WalletChangeNetworkError\";\n  }\n};\nvar WalletSubmitTransactionError = class extends WalletError {\n  constructor() {\n    super(...arguments);\n    this.name = \"WalletSubmitTransactionError\";\n  }\n};\nvar WalletNotFoundError = class extends WalletError {\n  constructor() {\n    super(...arguments);\n    this.name = \"WalletNotFoundError\";\n  }\n};\n\n// src/constants.ts\nvar WalletReadyState = /* @__PURE__ */ ((WalletReadyState2) => {\n  WalletReadyState2[\"Installed\"] = \"Installed\";\n  WalletReadyState2[\"NotDetected\"] = \"NotDetected\";\n  return WalletReadyState2;\n})(WalletReadyState || {});\nvar NetworkName = /* @__PURE__ */ ((NetworkName2) => {\n  NetworkName2[\"Mainnet\"] = \"mainnet\";\n  NetworkName2[\"Testnet\"] = \"testnet\";\n  NetworkName2[\"Devnet\"] = \"devnet\";\n  return NetworkName2;\n})(NetworkName || {});\nvar ChainIdToAnsSupportedNetworkMap = {\n  \"1\": \"mainnet\",\n  // mainnet\n  \"2\": \"testnet\"\n  // testnet\n};\nvar CEDRA_CONNECT_BASE_URL = \"https://cedraconnect.app\";\nvar CEDRA_CONNECT_ACCOUNT_URL = \"https://cedraconnect.app/dashboard/main-account\";\n\n// src/utils/helpers.ts\nvar import_ts_sdk = require(\"@cedra-labs/ts-sdk\");\nfunction isMobile() {\n  return /Mobile|iP(hone|od|ad)|Android|BlackBerry|IEMobile|Kindle|NetFront|Silk-Accelerated|(hpw|web)OS|Fennec|Minimo|Opera M(obi|ini)|Blazer|Dolfin|Dolphin|Skyfire|Zune/i.test(\n    navigator.userAgent\n  );\n}\nfunction isInAppBrowser() {\n  const isIphone = /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(\n    navigator.userAgent\n  );\n  const isAndroid = /(Android).*Version\\/[\\d.]+.*Chrome\\/[^\\s]+ Mobile/i.test(\n    navigator.userAgent\n  );\n  return isIphone || isAndroid;\n}\nfunction isRedirectable() {\n  if (typeof navigator === \"undefined\" || !navigator) return false;\n  return isMobile() && !isInAppBrowser();\n}\nfunction generalizedErrorMessage(error) {\n  return typeof error === \"object\" && \"message\" in error ? error.message : error;\n}\nvar getCedraConfig = (networkInfo, dappConfig) => {\n  if (!networkInfo) {\n    throw new Error(\"Undefined network\");\n  }\n  if (isCedraNetwork(networkInfo)) {\n    const currentNetwork = convertNetwork(networkInfo);\n    if (isCedraLiveNetwork(currentNetwork)) {\n      const apiKey = dappConfig?.cedraApiKeys;\n      return new import_ts_sdk.CedraConfig({\n        network: currentNetwork,\n        clientConfig: { API_KEY: apiKey ? apiKey[currentNetwork] : void 0 }\n      });\n    }\n    return new import_ts_sdk.CedraConfig({\n      network: currentNetwork\n    });\n  }\n  const knownNetworks = {\n    okx: \"https://wallet.okx.com/fullnode/cedra/discover/rpc\"\n  };\n  if (networkInfo.url) {\n    const isKnownNetwork = Object.values(knownNetworks).includes(\n      networkInfo.url\n    );\n    if (isKnownNetwork) {\n      return new import_ts_sdk.CedraConfig({\n        network: import_ts_sdk.Network.CUSTOM,\n        fullnode: networkInfo.url\n      });\n    }\n  }\n  throw new Error(\n    `Invalid network, network ${networkInfo.name} not supported with Cedra wallet adapter to prevent user from using an unexpected network.`\n  );\n};\nvar isCedraNetwork = (networkInfo) => {\n  if (!networkInfo) {\n    throw new Error(\"Undefined network\");\n  }\n  return import_ts_sdk.NetworkToNodeAPI[networkInfo.name] !== void 0;\n};\nvar isCedraLiveNetwork = (networkInfo) => {\n  return networkInfo === \"devnet\" || networkInfo === \"testnet\" || networkInfo === \"mainnet\";\n};\nvar fetchDevnetChainId = async () => {\n  const cedra = new import_ts_sdk.Cedra();\n  return await cedra.getChainId();\n};\nvar handlePublishPackageTransaction = (transactionInput) => {\n  let metadataBytes = transactionInput.data.functionArguments[0];\n  if (typeof metadataBytes === \"string\") {\n    metadataBytes = import_ts_sdk.Hex.fromHexInput(metadataBytes).toUint8Array();\n  }\n  let byteCode = transactionInput.data.functionArguments[1];\n  if (Array.isArray(byteCode)) {\n    byteCode = byteCode.map((byte) => {\n      if (typeof byte === \"string\") {\n        return import_ts_sdk.Hex.fromHexInput(byte).toUint8Array();\n      }\n      return byte;\n    });\n  } else {\n    throw new WalletSignAndSubmitMessageError(\n      \"The bytecode argument must be an array.\"\n    ).message;\n  }\n  return { metadataBytes, byteCode };\n};\nfunction convertNetwork(networkInfo) {\n  switch (networkInfo?.name) {\n    case \"mainnet\":\n      return import_ts_sdk.Network.MAINNET;\n    case \"testnet\":\n      return import_ts_sdk.Network.TESTNET;\n    case \"devnet\":\n      return import_ts_sdk.Network.DEVNET;\n    case \"local\":\n      return import_ts_sdk.Network.LOCAL;\n    default:\n      throw new Error(\"Invalid Cedra network name\");\n  }\n}\n\n// src/utils/localStorage.ts\nvar LOCAL_STORAGE_ITEM_KEY = \"CedraWalletName\";\nfunction setLocalStorage(walletName) {\n  localStorage.setItem(LOCAL_STORAGE_ITEM_KEY, walletName);\n}\nfunction removeLocalStorage() {\n  localStorage.removeItem(LOCAL_STORAGE_ITEM_KEY);\n}\nfunction getLocalStorage() {\n  localStorage.getItem(LOCAL_STORAGE_ITEM_KEY);\n}\n\n// src/utils/walletSelector.ts\nfunction partitionWallets(wallets, partitionFunction = isInstalledOrLoadable) {\n  const defaultWallets = [];\n  const moreWallets = [];\n  for (const wallet of wallets) {\n    if (partitionFunction(wallet)) defaultWallets.push(wallet);\n    else moreWallets.push(wallet);\n  }\n  return { defaultWallets, moreWallets };\n}\nfunction isInstalledOrLoadable(wallet) {\n  return wallet.readyState === \"Installed\" /* Installed */;\n}\nfunction isInstallRequired(wallet) {\n  const isWalletReady = isInstalledOrLoadable(wallet);\n  const isMobile2 = !isWalletReady && isRedirectable();\n  return !isMobile2 && !isWalletReady;\n}\nfunction truncateAddress(address) {\n  if (!address) return;\n  return `${address.slice(0, 6)}...${address.slice(-5)}`;\n}\nfunction isCedraConnectWallet(wallet) {\n  if (!wallet.url) return false;\n  return wallet.url.startsWith(CEDRA_CONNECT_BASE_URL);\n}\nfunction getCedraConnectWallets(wallets) {\n  const { defaultWallets, moreWallets } = partitionWallets(\n    wallets,\n    isCedraConnectWallet\n  );\n  return { cedraConnectWallets: defaultWallets, otherWallets: moreWallets };\n}\nfunction groupAndSortWallets(wallets, options) {\n  const { cedraConnectWallets, otherWallets } = getCedraConnectWallets(wallets);\n  const { defaultWallets, moreWallets } = partitionWallets(otherWallets);\n  if (options?.sortCedraConnectWallets) {\n    cedraConnectWallets.sort(options.sortCedraConnectWallets);\n  }\n  if (options?.sortAvailableWallets) {\n    defaultWallets.sort(options.sortAvailableWallets);\n  }\n  if (options?.sortInstallableWallets) {\n    moreWallets.sort(options.sortInstallableWallets);\n  }\n  return {\n    /** Wallets that use social login to create an account on the blockchain */\n    cedraConnectWallets,\n    /** Wallets that are currently installed or loadable. */\n    availableWallets: defaultWallets,\n    /** Wallets that are NOT currently installed or loadable. */\n    installableWallets: moreWallets\n  };\n}\n\n// src/registry.ts\nvar cedraStandardSupportedWalletList = [\n  {\n    name: \"Nightly\",\n    url: \"https://nightly.app/\",\n    icon: \"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4NCjwhLS0gR2VuZXJhdG9yOiBBZG9iZSBJbGx1c3RyYXRvciAyOC4wLjAsIFNWRyBFeHBvcnQgUGx1Zy1JbiAuIFNWRyBWZXJzaW9uOiA2LjAwIEJ1aWxkIDApICAtLT4NCjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iV2Fyc3R3YV8xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4PSIwcHgiIHk9IjBweCINCgkgdmlld0JveD0iMCAwIDg1MS41IDg1MS41IiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCA4NTEuNSA4NTEuNTsiIHhtbDpzcGFjZT0icHJlc2VydmUiPg0KPHN0eWxlIHR5cGU9InRleHQvY3NzIj4NCgkuc3Qwe2ZpbGw6IzYwNjdGOTt9DQoJLnN0MXtmaWxsOiNGN0Y3Rjc7fQ0KPC9zdHlsZT4NCjxnPg0KCTxnIGlkPSJXYXJzdHdhXzJfMDAwMDAwMTQ2MDk2NTQyNTMxODA5NDY0NjAwMDAwMDg2NDc4NTIwMDIxMTY5MTg2ODhfIj4NCgkJPHBhdGggY2xhc3M9InN0MCIgZD0iTTEyNCwwaDYwMy42YzY4LjUsMCwxMjQsNTUuNSwxMjQsMTI0djYwMy42YzAsNjguNS01NS41LDEyNC0xMjQsMTI0SDEyNGMtNjguNSwwLTEyNC01NS41LTEyNC0xMjRWMTI0DQoJCQlDMCw1NS41LDU1LjUsMCwxMjQsMHoiLz4NCgk8L2c+DQoJPGcgaWQ9IldhcnN0d2FfMyI+DQoJCTxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik02MjMuNSwxNzAuM2MtMzcuNCw1Mi4yLTg0LjIsODguNC0xMzkuNSwxMTIuNmMtMTkuMi01LjMtMzguOS04LTU4LjMtNy44Yy0xOS40LTAuMi0zOS4xLDIuNi01OC4zLDcuOA0KCQkJYy01NS4zLTI0LjMtMTAyLjEtNjAuMy0xMzkuNS0xMTIuNmMtMTEuMywyOC40LTU0LjgsMTI2LjQtMi42LDI2My40YzAsMC0xNi43LDcxLjUsMTQsMTMyLjljMCwwLDQ0LjQtMjAuMSw3OS43LDguMg0KCQkJYzM2LjksMjkuOSwyNS4xLDU4LjcsNTEuMSw4My41YzIyLjQsMjIuOSw1NS43LDIyLjksNTUuNywyMi45czMzLjMsMCw1NS43LTIyLjhjMjYtMjQuNywxNC4zLTUzLjUsNTEuMS04My41DQoJCQljMzUuMi0yOC4zLDc5LjctOC4yLDc5LjctOC4yYzMwLjYtNjEuNCwxNC0xMzIuOSwxNC0xMzIuOUM2NzguMywyOTYuNyw2MzQuOSwxOTguNyw2MjMuNSwxNzAuM3ogTTI1My4xLDQxNC44DQoJCQljLTI4LjQtNTguMy0zNi4yLTEzOC4zLTE4LjMtMjAxLjVjMjMuNyw2MCw1NS45LDg2LjksOTQuMiwxMTUuM0MzMTIuOCwzNjIuMywyODIuMywzOTQuMSwyNTMuMSw0MTQuOHogTTMzNC44LDUxNy41DQoJCQljLTIyLjQtOS45LTI3LjEtMjkuNC0yNy4xLTI5LjRjMzAuNS0xOS4yLDc1LjQtNC41LDc2LjgsNDAuOUMzNjAuOSw1MTQuNywzNTMsNTI1LjQsMzM0LjgsNTE3LjV6IE00MjUuNyw2NzguNw0KCQkJYy0xNiwwLTI5LTExLjUtMjktMjUuNnMxMy0yNS42LDI5LTI1LjZzMjksMTEuNSwyOSwyNS42QzQ1NC43LDY2Ny4zLDQ0MS43LDY3OC43LDQyNS43LDY3OC43eiBNNTE2LjcsNTE3LjUNCgkJCWMtMTguMiw4LTI2LTIuOC00OS43LDExLjVjMS41LTQ1LjQsNDYuMi02MC4xLDc2LjgtNDAuOUM1NDMuOCw0ODgsNTM5LDUwNy42LDUxNi43LDUxNy41eiBNNTk4LjMsNDE0LjgNCgkJCWMtMjkuMS0yMC43LTU5LjctNTIuNC03Ni04Ni4yYzM4LjMtMjguNCw3MC42LTU1LjQsOTQuMi0xMTUuM0M2MzQuNiwyNzYuNSw2MjYuOCwzNTYuNiw1OTguMyw0MTQuOHoiLz4NCgk8L2c+DQo8L2c+DQo8L3N2Zz4NCg==\",\n    readyState: \"NotDetected\" /* NotDetected */,\n    isAIP62Standard: true,\n    deeplinkProvider: \"nightly://v1?network=cedra&url=\"\n  },\n  {\n    name: \"Zedra\",\n    url: \"https://chromewebstore.google.com/detail/zedra-wallet/pbeefngmcchkcibdodceimammkigfanl\",\n    icon: \"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyBpZD0iTGF5ZXJfMiIgZGF0YS1uYW1lPSJMYXllciAyIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDgwIDEwODAiPgogIDxkZWZzPgogICAgPHN0eWxlPgogICAgICAuY2xzLTEgewogICAgICAgIGZpbGw6ICNiOGZmZGU7CiAgICAgIH0KICAgIDwvc3R5bGU+CiAgPC9kZWZzPgogIDxnIGlkPSJMYXllcl8xLTIiIGRhdGEtbmFtZT0iTGF5ZXIgMSI+CiAgICA8cmVjdCBjbGFzcz0iY2xzLTEiIHdpZHRoPSIxMDgwIiBoZWlnaHQ9IjEwODAiIHJ4PSIxMjAuNTQiIHJ5PSIxMjAuNTQiLz4KICAgIDxnPgogICAgICA8cGF0aCBkPSJtMzIyLjQ3LDIxOS4xMWgzNTMuNDdjMTMuMzgsMCwyNS42Miw3LjUxLDMxLjY5LDE5LjQzbDExMC43OSwyMTcuNjljNi43NiwxMy4yOCw0LjUyLDI5LjM3LTUuNjEsNDAuM2wtMTE5LjU0LDEyOWMtMTMuNDYsMTQuNTMtMzYuMiwxNS4yNi01MC41NywxLjYybC03Ny41Ni03My42NGMtMTQuNDYtMTMuNzMtMTQuOC0zNi42Ni0uNzctNTAuODJsNDIuOTYtNDMuMzVjMjIuMjgtMjIuNDgsNi4yOS02MC42OS0yNS4zNi02MC41OWwtMjU5LjQuNzljLTE5LjY4LjA2LTM1LjY3LTE1Ljg4LTM1LjY3LTM1LjU2di0xMDkuMzFjMC0xOS42NCwxNS45Mi0zNS41NiwzNS41Ni0zNS41NloiLz4KICAgICAgPHBhdGggZD0ibTc1Ny41Myw4NjAuODloLTM1My40N2MtMTMuMzgsMC0yNS42Mi03LjUxLTMxLjY5LTE5LjQzbC0xMTAuNzktMjE3LjY5Yy02Ljc2LTEzLjI4LTQuNTItMjkuMzcsNS42MS00MC4zbDExOS41NC0xMjljMTMuNDYtMTQuNTMsMzYuMi0xNS4yNiw1MC41Ny0xLjYybDc3LjU2LDczLjY0YzE0LjQ2LDEzLjczLDE0LjgsMzYuNjYuNzcsNTAuODJsLTQyLjk2LDQzLjM1Yy0yMi4yOCwyMi40OC02LjI5LDYwLjY5LDI1LjM2LDYwLjU5bDI1OS40LS43OWMxOS42OC0uMDYsMzUuNjcsMTUuODgsMzUuNjcsMzUuNTZ2MTA5LjMxYzAsMTkuNjQtMTUuOTIsMzUuNTYtMzUuNTYsMzUuNTZaIi8+CiAgICA8L2c+CiAgPC9nPgo8L3N2Zz4=\",\n    readyState: \"NotDetected\" /* NotDetected */,\n    isAIP62Standard: true,\n    deeplinkProvider: \"https://zedra.app/\"\n  }\n];\n\n// src/sdkWallets.ts\nvar import_wallet_adapter_plugin = require(\"@cedra-labs/wallet-adapter-plugin\");\nvar import_ts_sdk2 = require(\"@cedra-labs/ts-sdk\");\nfunction getSDKWallets(dappConfig) {\n  const sdkWallets = [];\n  if (typeof window !== \"undefined\") {\n    sdkWallets.push(\n      new import_wallet_adapter_plugin.CedraConnectGoogleWallet({\n        network: dappConfig?.network,\n        dappId: dappConfig?.cedraConnectDappId,\n        ...dappConfig?.cedraConnect\n      }),\n      new import_wallet_adapter_plugin.CedraConnectAppleWallet({\n        network: dappConfig?.network,\n        dappId: dappConfig?.cedraConnectDappId,\n        ...dappConfig?.cedraConnect\n      })\n    );\n  }\n  if (dappConfig?.network === import_ts_sdk2.Network.MAINNET) {\n  } else {\n  }\n  return sdkWallets;\n}\n\n// src/WalletCore.ts\nvar WalletCore = class extends import_eventemitter3.default {\n  constructor(optInWallets, dappConfig, disableTelemetry) {\n    super();\n    // Local private variable to hold the wallet that is currently connected\n    this._wallet = null;\n    // Local private variable to hold SDK wallets in the adapter\n    this._sdkWallets = [];\n    // Local array that holds all the wallets that are AIP-62 standard compatible\n    this._standard_wallets = [];\n    // Local array that holds all the wallets that are AIP-62 standard compatible but are not installed on the user machine\n    this._standard_not_detected_wallets = [];\n    // Local private variable to hold the network that is currently connected\n    this._network = null;\n    // Local private variable to hold the wallet connected state\n    this._connected = false;\n    // Local private variable to hold the connecting state\n    this._connecting = false;\n    // Local private variable to hold the account that is currently connected\n    this._account = null;\n    // Private array that holds all the Wallets a dapp decided to opt-in to\n    this._optInWallets = [];\n    // Local flag to disable the adapter telemetry tool\n    this._disableTelemetry = false;\n    // Google Analytics 4 module\n    this.ga4 = null;\n    this._optInWallets = optInWallets || [];\n    this._dappConfig = dappConfig;\n    this._disableTelemetry = disableTelemetry ?? false;\n    this._sdkWallets = getSDKWallets(this._dappConfig);\n    if (!this._disableTelemetry) {\n      this.ga4 = new GA4();\n    }\n    this.fetchExtensionAIP62CedraWallets();\n    this.fetchSDKAIP62CedraWallets();\n    this.appendNotDetectedStandardSupportedWallets();\n  }\n  fetchExtensionAIP62CedraWallets() {\n    let { cedraWallets, on } = (0, import_wallet_standard.getCedraWallets)();\n    this.setExtensionAIP62Wallets(cedraWallets);\n    if (typeof window === \"undefined\") return;\n    const that = this;\n    const removeRegisterListener = on(\"register\", function() {\n      let { cedraWallets: cedraWallets2 } = (0, import_wallet_standard.getCedraWallets)();\n      that.setExtensionAIP62Wallets(cedraWallets2);\n    });\n    const removeUnregisterListener = on(\"unregister\", function() {\n      let { cedraWallets: cedraWallets2 } = (0, import_wallet_standard.getCedraWallets)();\n      that.setExtensionAIP62Wallets(cedraWallets2);\n    });\n  }\n  /**\n   * Set AIP-62 extension wallets\n   *\n   * @param extensionwWallets\n   */\n  setExtensionAIP62Wallets(extensionwWallets) {\n    extensionwWallets.map((wallet) => {\n      if (this.excludeWallet(wallet)) {\n        return;\n      }\n      this._standard_wallets = this._standard_wallets.filter(\n        (item) => item.name !== wallet.name\n      );\n      const isValid = (0, import_wallet_standard.isWalletWithRequiredFeatureSet)(wallet);\n      if (isValid) {\n        const index = this._standard_not_detected_wallets.findIndex(\n          (notDetctedWallet) => notDetctedWallet.name == wallet.name\n        );\n        if (index !== -1) {\n          this._standard_not_detected_wallets.splice(index, 1);\n        }\n        wallet.readyState = \"Installed\" /* Installed */;\n        this._standard_wallets.push(wallet);\n        this.emit(\"standardWalletsAdded\", wallet);\n      }\n    });\n  }\n  /**\n   * Set AIP-62 SDK wallets\n   */\n  fetchSDKAIP62CedraWallets() {\n    this._sdkWallets.map((wallet) => {\n      if (this.excludeWallet(wallet)) {\n        return;\n      }\n      const isValid = (0, import_wallet_standard.isWalletWithRequiredFeatureSet)(wallet);\n      if (isValid) {\n        wallet.readyState = \"Installed\" /* Installed */;\n        this._standard_wallets.push(wallet);\n      }\n    });\n  }\n  // Since we can't discover AIP-62 wallets that are not installed on the user machine,\n  // we hold a AIP-62 wallets registry to show on the wallet selector modal for the users.\n  // Append wallets from wallet standard support registry to the `_standard_not_detected_wallets` array\n  // when wallet is not installed on the user machine\n  appendNotDetectedStandardSupportedWallets() {\n    cedraStandardSupportedWalletList.map((supportedWallet) => {\n      const existingStandardWallet = this._standard_wallets.find(\n        (wallet) => wallet.name == supportedWallet.name\n      );\n      if (existingStandardWallet) {\n        return;\n      }\n      if (this.excludeWallet(supportedWallet)) {\n        return;\n      }\n      if (!existingStandardWallet) {\n        this._standard_not_detected_wallets.push(supportedWallet);\n        this.emit(\"standardNotDetectedWalletAdded\", supportedWallet);\n      }\n    });\n  }\n  /**\n   * A function that excludes an AIP-62 compatible wallet the dapp doesnt want to include\n   *\n   * @param wallet AdapterWallet | AdapterNotDetectedWallet\n   * @returns boolean\n   */\n  excludeWallet(wallet) {\n    if (this._optInWallets.length > 0 && !this._optInWallets.includes(wallet.name)) {\n      return true;\n    }\n    return false;\n  }\n  recordEvent(eventName, additionalInfo) {\n    this.ga4?.gtag(\"event\", `wallet_adapter_${eventName}`, {\n      wallet: this._wallet?.name,\n      network: this._network?.name,\n      network_url: this._network?.url,\n      adapter_core_version: WALLET_ADAPTER_CORE_VERSION,\n      send_to: true,\n      ...additionalInfo\n    });\n  }\n  /**\n   * Helper function to ensure wallet exists\n   *\n   * @param wallet A wallet\n   */\n  ensureWalletExists(wallet) {\n    if (!wallet) {\n      throw new WalletNotConnectedError().name;\n    }\n    if (!(wallet.readyState === \"Installed\" /* Installed */))\n      throw new WalletNotReadyError(\"Wallet is not set\").name;\n  }\n  /**\n   * Helper function to ensure account exists\n   *\n   * @param account An account\n   */\n  ensureAccountExists(account) {\n    if (!account) {\n      throw new WalletAccountError(\"Account is not set\").name;\n    }\n  }\n  /**\n   * Queries and sets ANS name for the current connected wallet account\n   */\n  async setAnsName() {\n    if (this._network?.chainId && this._account) {\n      if (this._account.ansName) return;\n      if (!ChainIdToAnsSupportedNetworkMap[this._network.chainId] || !isCedraNetwork(this._network)) {\n        this._account.ansName = void 0;\n        return;\n      }\n      const cedraConfig = getCedraConfig(this._network, this._dappConfig);\n      const cedra = new import_ts_sdk3.Cedra(cedraConfig);\n      try {\n        const name = await cedra.ans.getPrimaryName({\n          address: this._account.address.toString()\n        });\n        this._account.ansName = name;\n      } catch (error) {\n        console.log(`Error setting ANS name ${error}`);\n      }\n    }\n  }\n  /**\n   * Function to cleat wallet adapter data.\n   *\n   * - Removes current connected wallet state\n   * - Removes current connected account state\n   * - Removes current connected network state\n   * - Removes autoconnect local storage value\n   */\n  clearData() {\n    this._connected = false;\n    this.setWallet(null);\n    this.setAccount(null);\n    this.setNetwork(null);\n    removeLocalStorage();\n  }\n  /**\n   * Sets the connected wallet\n   *\n   * @param wallet A wallet\n   */\n  setWallet(wallet) {\n    this._wallet = wallet;\n  }\n  /**\n   * Sets the connected account\n   *\n   * @param account An account\n   */\n  setAccount(account) {\n    this._account = account;\n  }\n  /**\n   * Sets the connected network\n   *\n   * @param network A network\n   */\n  setNetwork(network) {\n    this._network = network;\n  }\n  /**\n   * Helper function to detect whether a wallet is connected\n   *\n   * @returns boolean\n   */\n  isConnected() {\n    return this._connected;\n  }\n  /**\n   * Getter to fetch all detected wallets\n   */\n  get wallets() {\n    return this._standard_wallets;\n  }\n  get notDetectedWallets() {\n    return this._standard_not_detected_wallets;\n  }\n  /**\n   * Getter for the current connected wallet\n   *\n   * @return wallet info\n   * @throws WalletNotSelectedError\n   */\n  get wallet() {\n    try {\n      if (!this._wallet) return null;\n      return this._wallet;\n    } catch (error) {\n      throw new WalletNotSelectedError(error).message;\n    }\n  }\n  /**\n   * Getter for the current connected account\n   *\n   * @return account info\n   * @throws WalletAccountError\n   */\n  get account() {\n    try {\n      return this._account;\n    } catch (error) {\n      throw new WalletAccountError(error).message;\n    }\n  }\n  /**\n   * Getter for the current wallet network\n   *\n   * @return network info\n   * @throws WalletGetNetworkError\n   */\n  get network() {\n    try {\n      return this._network;\n    } catch (error) {\n      throw new WalletGetNetworkError(error).message;\n    }\n  }\n  /**\n   * Helper function to run some checks before we connect with a wallet.\n   *\n   * @param walletName. The wallet name we want to connect with.\n   */\n  async connect(walletName) {\n    if (isRedirectable()) {\n      const selectedWallet2 = this._standard_not_detected_wallets.find(\n        (wallet) => wallet.name === walletName\n      );\n      if (selectedWallet2) {\n        const uninstalledWallet = selectedWallet2;\n        if (uninstalledWallet.deeplinkProvider) {\n          const url = encodeURIComponent(window.location.href);\n          const location = uninstalledWallet.deeplinkProvider.concat(url);\n          window.location.href = location;\n          return;\n        }\n      }\n    }\n    const allDetectedWallets = this._standard_wallets;\n    const selectedWallet = allDetectedWallets.find(\n      (wallet) => wallet.name === walletName\n    );\n    if (!selectedWallet) return;\n    if (this._connected && this._account) {\n      if (this._wallet?.name === walletName)\n        throw new WalletConnectionError(\n          `${walletName} wallet is already connected`\n        ).message;\n    }\n    await this.connectWallet(selectedWallet, async () => {\n      const response = await selectedWallet.features[\"cedra:connect\"].connect();\n      if (response.status === import_wallet_standard.UserResponseStatus.REJECTED) {\n        throw new WalletConnectionError(\"User has rejected the request\").message;\n      }\n      return { account: response.args, output: void 0 };\n    });\n  }\n  /**\n   * Signs into the wallet by connecting and signing an authentication messages.\n   *\n   * For more information, visit: https://siwa.cedra.dev\n   *\n   * @param args\n   * @param args.input The CedraSignInInput which defines how the SIWA Message should be constructed\n   * @param args.walletName The name of the wallet to sign into\n   * @returns The CedraSignInOutput which contains the account and signature information\n   */\n  async signIn(args) {\n    const { input, walletName } = args;\n    const allDetectedWallets = this._standard_wallets;\n    const selectedWallet = allDetectedWallets.find(\n      (wallet) => wallet.name === walletName\n    );\n    if (!selectedWallet) {\n      throw new WalletNotFoundError(`Wallet ${walletName} not found`).message;\n    }\n    if (!selectedWallet.features[\"cedra:signIn\"]) {\n      throw new WalletNotSupportedMethod(\n        `cedra:signIn is not supported by ${walletName}`\n      ).message;\n    }\n    return await this.connectWallet(selectedWallet, async () => {\n      if (!selectedWallet.features[\"cedra:signIn\"]) {\n        throw new WalletNotSupportedMethod(\n          `cedra:signIn is not supported by ${selectedWallet.name}`\n        ).message;\n      }\n      const response = await selectedWallet.features[\"cedra:signIn\"].signIn(input);\n      if (response.status === import_wallet_standard.UserResponseStatus.REJECTED) {\n        throw new WalletConnectionError(\"User has rejected the request\").message;\n      }\n      return { account: response.args.account, output: response.args };\n    });\n  }\n  /**\n   * Connects a wallet to the dapp.\n   * On connect success, we set the current account and the network, and keeping the selected wallet\n   * name in LocalStorage to support autoConnect function.\n   *\n   * @param selectedWallet. The wallet we want to connect.\n   * @emit emits \"connect\" event\n   * @throws WalletConnectionError\n   */\n  async connectWallet(selectedWallet, onConnect) {\n    try {\n      this._connecting = true;\n      this.setWallet(selectedWallet);\n      const { account, output } = await onConnect();\n      this.setAccount(account);\n      const network = await selectedWallet.features[\"cedra:network\"].network();\n      this.setNetwork(network);\n      await this.setAnsName();\n      setLocalStorage(selectedWallet.name);\n      this._connected = true;\n      this.recordEvent(\"wallet_connect\");\n      this.emit(\"connect\", account);\n      return output;\n    } catch (error) {\n      this.clearData();\n      const errMsg = generalizedErrorMessage(error);\n      throw new WalletConnectionError(errMsg).message;\n    } finally {\n      this._connecting = false;\n    }\n  }\n  /**\n   * Disconnect the current connected wallet. On success, we clear the\n   * current account, current network and LocalStorage data.\n   *\n   * @emit emits \"disconnect\" event\n   * @throws WalletDisconnectionError\n   */\n  async disconnect() {\n    try {\n      this.ensureWalletExists(this._wallet);\n      await this._wallet.features[\"cedra:disconnect\"].disconnect();\n      this.clearData();\n      this.recordEvent(\"wallet_disconnect\");\n      this.emit(\"disconnect\");\n    } catch (error) {\n      const errMsg = generalizedErrorMessage(error);\n      throw new WalletDisconnectionError(errMsg).message;\n    }\n  }\n  /**\n   * Signs and submits a transaction to chain\n   *\n   * @param transactionInput InputTransactionData\n   * @returns CedraSignAndSubmitTransactionOutput\n   */\n  async signAndSubmitTransaction(transactionInput) {\n    try {\n      if (\"function\" in transactionInput.data) {\n        if (transactionInput.data.function === \"0x1::account::rotate_authentication_key_call\") {\n          throw new WalletSignAndSubmitMessageError(\"SCAM SITE DETECTED\").message;\n        }\n        if (transactionInput.data.function === \"0x1::code::publish_package_txn\") {\n          ({\n            metadataBytes: transactionInput.data.functionArguments[0],\n            byteCode: transactionInput.data.functionArguments[1]\n          } = handlePublishPackageTransaction(transactionInput));\n        }\n      }\n      this.ensureWalletExists(this._wallet);\n      this.ensureAccountExists(this._account);\n      this.recordEvent(\"sign_and_submit_transaction\");\n      if (this._wallet.features[\"cedra:signAndSubmitTransaction\"]) {\n        if (this._wallet.features[\"cedra:signAndSubmitTransaction\"].version !== \"1.1.0\") {\n          const cedraConfig2 = getCedraConfig(this._network, this._dappConfig);\n          const cedra2 = new import_ts_sdk3.Cedra(cedraConfig2);\n          const transaction2 = await cedra2.transaction.build.simple({\n            sender: this._account.address.toString(),\n            data: transactionInput.data,\n            options: transactionInput.options\n          });\n          const signAndSubmitTransactionMethod = this._wallet.features[\"cedra:signAndSubmitTransaction\"].signAndSubmitTransaction;\n          const response3 = await signAndSubmitTransactionMethod(\n            transaction2\n          );\n          if (response3.status === import_wallet_standard.UserResponseStatus.REJECTED) {\n            throw new WalletConnectionError(\"User has rejected the request\").message;\n          }\n          return response3.args;\n        }\n        const response2 = await this._wallet.features[\"cedra:signAndSubmitTransaction\"].signAndSubmitTransaction({\n          payload: transactionInput.data,\n          gasUnitPrice: transactionInput.options?.gasUnitPrice,\n          maxGasAmount: transactionInput.options?.maxGasAmount\n        });\n        if (response2.status === import_wallet_standard.UserResponseStatus.REJECTED) {\n          throw new WalletConnectionError(\"User has rejected the request\").message;\n        }\n        return response2.args;\n      }\n      const cedraConfig = getCedraConfig(this._network, this._dappConfig);\n      const cedra = new import_ts_sdk3.Cedra(cedraConfig);\n      const transaction = await cedra.transaction.build.simple({\n        sender: this._account.address,\n        data: transactionInput.data,\n        options: transactionInput.options\n      });\n      const signTransactionResponse = await this.signTransaction({\n        transactionOrPayload: transaction\n      });\n      const response = await this.submitTransaction({\n        transaction,\n        senderAuthenticator: signTransactionResponse.authenticator\n      });\n      return { hash: response.hash };\n    } catch (error) {\n      const errMsg = generalizedErrorMessage(error);\n      throw new WalletSignAndSubmitMessageError(errMsg).message;\n    }\n  }\n  /**\n   * Signs a transaction\n   *\n   * This method supports 2 input types -\n   * 1. A raw transaction that was already built by the dapp,\n   * 2. A transaction data input as JSON. This is for the wallet to be able to simulate before signing\n   *\n   * @param transactionOrPayload AnyRawTransaction | InputTransactionData\n   * @param asFeePayer optional. A flag indicates to sign the transaction as the fee payer\n   * @param options optional. Transaction options\n   *\n   * @returns AccountAuthenticator\n   */\n  async signTransaction(args) {\n    const { transactionOrPayload, asFeePayer } = args;\n    try {\n      this.ensureWalletExists(this._wallet);\n      this.ensureAccountExists(this._account);\n      this.recordEvent(\"sign_transaction\");\n      if (\"rawTransaction\" in transactionOrPayload) {\n        const response = await this._wallet?.features[\"cedra:signTransaction\"].signTransaction(\n          transactionOrPayload,\n          asFeePayer\n        );\n        if (response.status === import_wallet_standard.UserResponseStatus.REJECTED) {\n          throw new WalletConnectionError(\"User has rejected the request\").message;\n        }\n        return {\n          authenticator: response.args,\n          rawTransaction: transactionOrPayload.rawTransaction.bcsToBytes()\n        };\n      } else if (this._wallet.features[\"cedra:signTransaction\"]?.version === \"1.1\") {\n        const signTransactionV1_1StandardInput = {\n          payload: transactionOrPayload.data,\n          expirationTimestamp: transactionOrPayload.options?.expirationTimestamp,\n          expirationSecondsFromNow: transactionOrPayload.options?.expirationSecondsFromNow,\n          gasUnitPrice: transactionOrPayload.options?.gasUnitPrice,\n          maxGasAmount: transactionOrPayload.options?.maxGasAmount,\n          sequenceNumber: transactionOrPayload.options?.accountSequenceNumber,\n          sender: transactionOrPayload.sender ? { address: import_ts_sdk3.AccountAddress.from(transactionOrPayload.sender) } : void 0\n        };\n        const walletSignTransactionMethod = this._wallet?.features[\"cedra:signTransaction\"].signTransaction;\n        const response = await walletSignTransactionMethod(\n          signTransactionV1_1StandardInput\n        );\n        if (response.status === import_wallet_standard.UserResponseStatus.REJECTED) {\n          throw new WalletConnectionError(\"User has rejected the request\").message;\n        }\n        return {\n          authenticator: response.args.authenticator,\n          rawTransaction: response.args.rawTransaction.bcsToBytes()\n        };\n      } else {\n        const cedraConfig = getCedraConfig(this._network, this._dappConfig);\n        const cedra = new import_ts_sdk3.Cedra(cedraConfig);\n        const transaction = await cedra.transaction.build.simple({\n          sender: this._account.address,\n          data: transactionOrPayload.data,\n          options: transactionOrPayload.options,\n          withFeePayer: transactionOrPayload.withFeePayer\n        });\n        const response = await this._wallet?.features[\"cedra:signTransaction\"].signTransaction(\n          transaction,\n          asFeePayer\n        );\n        if (response.status === import_wallet_standard.UserResponseStatus.REJECTED) {\n          throw new WalletConnectionError(\"User has rejected the request\").message;\n        }\n        return {\n          authenticator: response.args,\n          rawTransaction: transaction.bcsToBytes()\n        };\n      }\n    } catch (error) {\n      const errMsg = generalizedErrorMessage(error);\n      throw new WalletSignTransactionError(errMsg).message;\n    }\n  }\n  /**\n   * Sign a message (doesnt submit to chain).\n   *\n   * @param message - CedraSignMessageInput\n   *\n   * @return response from the wallet's signMessage function\n   * @throws WalletSignMessageError\n   */\n  async signMessage(message) {\n    try {\n      this.ensureWalletExists(this._wallet);\n      this.recordEvent(\"sign_message\");\n      const response = await this._wallet?.features[\"cedra:signMessage\"]?.signMessage(message);\n      if (response.status === import_wallet_standard.UserResponseStatus.REJECTED) {\n        throw new WalletConnectionError(\"User has rejected the request\").message;\n      }\n      return response.args;\n    } catch (error) {\n      const errMsg = generalizedErrorMessage(error);\n      throw new WalletSignMessageError(errMsg).message;\n    }\n  }\n  /**\n   * Submits transaction to chain\n   *\n   * @param transaction - InputSubmitTransactionData\n   * @returns PendingTransactionResponse\n   */\n  async submitTransaction(transaction) {\n    try {\n      this.ensureWalletExists(this._wallet);\n      const { additionalSignersAuthenticators } = transaction;\n      const transactionType = additionalSignersAuthenticators !== void 0 ? \"multi-agent\" : \"simple\";\n      this.recordEvent(\"submit_transaction\", {\n        transaction_type: transactionType\n      });\n      const cedraConfig = getCedraConfig(this._network, this._dappConfig);\n      const cedra = new import_ts_sdk3.Cedra(cedraConfig);\n      if (additionalSignersAuthenticators !== void 0) {\n        const multiAgentTxn = {\n          ...transaction,\n          additionalSignersAuthenticators\n        };\n        return cedra.transaction.submit.multiAgent(multiAgentTxn);\n      } else {\n        return cedra.transaction.submit.simple(transaction);\n      }\n    } catch (error) {\n      const errMsg = generalizedErrorMessage(error);\n      throw new WalletSubmitTransactionError(errMsg).message;\n    }\n  }\n  /**\n   Event for when account has changed on the wallet\n   @return the new account info\n   @throws WalletAccountChangeError\n   */\n  async onAccountChange() {\n    try {\n      this.ensureWalletExists(this._wallet);\n      await this._wallet.features[\"cedra:onAccountChange\"]?.onAccountChange(\n        async (data) => {\n          this.setAccount(data);\n          await this.setAnsName();\n          this.recordEvent(\"account_change\");\n          this.emit(\"accountChange\", this._account);\n        }\n      );\n    } catch (error) {\n      const errMsg = generalizedErrorMessage(error);\n      throw new WalletAccountChangeError(errMsg).message;\n    }\n  }\n  /**\n   Event for when network has changed on the wallet\n   @return the new network info\n   @throws WalletNetworkChangeError\n   */\n  async onNetworkChange() {\n    try {\n      this.ensureWalletExists(this._wallet);\n      await this._wallet.features[\"cedra:onNetworkChange\"]?.onNetworkChange(\n        async (data) => {\n          this.setNetwork(data);\n          await this.setAnsName();\n          this.emit(\"networkChange\", this._network);\n        }\n      );\n    } catch (error) {\n      const errMsg = generalizedErrorMessage(error);\n      throw new WalletNetworkChangeError(errMsg).message;\n    }\n  }\n  /**\n   * Sends a change network request to the wallet to change the connected network\n   *\n   * @param network - Network\n   * @returns CedraChangeNetworkOutput\n   */\n  async changeNetwork(network) {\n    try {\n      this.ensureWalletExists(this._wallet);\n      this.recordEvent(\"change_network_request\", {\n        from: this._network?.name,\n        to: network\n      });\n      const chainId = network === import_ts_sdk3.Network.DEVNET ? await fetchDevnetChainId() : import_ts_sdk3.NetworkToChainId[network];\n      const networkInfo = {\n        name: network,\n        chainId\n      };\n      if (this._wallet.features[\"cedra:changeNetwork\"]) {\n        const response = await this._wallet.features[\"cedra:changeNetwork\"].changeNetwork(\n          networkInfo\n        );\n        if (response.status === import_wallet_standard.UserResponseStatus.REJECTED) {\n          throw new WalletConnectionError(\"User has rejected the request\").message;\n        }\n        return response.args;\n      }\n      throw new WalletChangeNetworkError(\n        `${this._wallet.name} does not support changing network request`\n      ).message;\n    } catch (error) {\n      const errMsg = generalizedErrorMessage(error);\n      throw new WalletChangeNetworkError(errMsg).message;\n    }\n  }\n  /**\n   * Signs a message and verifies the signer\n   * @param message - CedraSignMessageInput\n   * @returns boolean\n   */\n  async signMessageAndVerify(message) {\n    try {\n      this.ensureWalletExists(this._wallet);\n      this.ensureAccountExists(this._account);\n      this.recordEvent(\"sign_message_and_verify\");\n      const response = await this._wallet.features[\"cedra:signMessage\"].signMessage(message);\n      if (response.status === import_wallet_standard.UserResponseStatus.REJECTED) {\n        throw new WalletConnectionError(\"Failed to sign a message\").message;\n      }\n      const cedraConfig = getCedraConfig(this._network, this._dappConfig);\n      const signingMessage = new TextEncoder().encode(\n        response.args.fullMessage\n      );\n      if (\"verifySignatureAsync\" in this._account.publicKey) {\n        return await this._account.publicKey.verifySignatureAsync({\n          cedraConfig,\n          message: signingMessage,\n          signature: response.args.signature,\n          options: { throwErrorWithReason: true }\n        });\n      }\n      return this._account.publicKey.verifySignature({\n        message: signingMessage,\n        signature: response.args.signature\n      });\n    } catch (error) {\n      const errMsg = generalizedErrorMessage(error);\n      throw new WalletSignMessageAndVerifyError(errMsg).message;\n    }\n  }\n};\n\n// src/index.ts\nif (typeof window !== \"undefined\") {\n  window.WALLET_ADAPTER_CORE_VERSION = WALLET_ADAPTER_CORE_VERSION;\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (module.exports = {\n  CEDRA_CONNECT_ACCOUNT_URL,\n  CEDRA_CONNECT_BASE_URL,\n  ChainIdToAnsSupportedNetworkMap,\n  NetworkName,\n  WalletCore,\n  WalletReadyState,\n  cedraStandardSupportedWalletList,\n  convertNetwork,\n  fetchDevnetChainId,\n  generalizedErrorMessage,\n  getCedraConfig,\n  getCedraConnectWallets,\n  getLocalStorage,\n  getSDKWallets,\n  groupAndSortWallets,\n  handlePublishPackageTransaction,\n  isCedraConnectWallet,\n  isCedraLiveNetwork,\n  isCedraNetwork,\n  isInAppBrowser,\n  isInstallRequired,\n  isInstalledOrLoadable,\n  isMobile,\n  isRedirectable,\n  partitionWallets,\n  removeLocalStorage,\n  setLocalStorage,\n  truncateAddress\n});\n","import { WALLET_ADAPTER_CORE_VERSION } from \"./version\";\n\nexport type {\n  CedraSignInOutput,\n  CedraSignInInput,\n  CedraSignInRequiredFields,\n} from \"@cedra-labs/wallet-standard\";\n\nexport * from \"./WalletCore\";\nexport * from \"./constants\";\nexport * from \"./utils\";\nexport * from \"./sdkWallets\";\nexport * from \"./registry\";\n\n// inject adapter core version to the window\nif (typeof window !== \"undefined\") {\n  (window as any).WALLET_ADAPTER_CORE_VERSION = WALLET_ADAPTER_CORE_VERSION;\n}\n","export const WALLET_ADAPTER_CORE_VERSION = \"5.5.4\";\n","import EventEmitter from \"eventemitter3\";\nimport {\n  AccountAddress,\n  AccountAuthenticator,\n  AnyPublicKey,\n  AnyPublicKeyVariant,\n  AnyRawTransaction,\n  Cedra,\n  Ed25519PublicKey,\n  InputSubmitTransactionData,\n  MultiEd25519PublicKey,\n  MultiEd25519Signature,\n  Network,\n  NetworkToChainId,\n  PendingTransactionResponse,\n} from \"@cedra-labs/ts-sdk\";\nimport {\n  CedraWallet,\n  getCedraWallets,\n  isWalletWithRequiredFeatureSet,\n  UserResponseStatus,\n  CedraSignAndSubmitTransactionOutput,\n  UserResponse,\n  CedraSignTransactionOutputV1_1,\n  CedraSignTransactionInputV1_1,\n  CedraSignTransactionMethod,\n  CedraSignTransactionMethodV1_1,\n  NetworkInfo,\n  AccountInfo,\n  CedraSignMessageInput,\n  CedraSignMessageOutput,\n  CedraChangeNetworkOutput,\n  CedraSignInInput,\n  CedraSignInOutput,\n} from \"@cedra-labs/wallet-standard\";\nimport { CedraConnectWalletConfig } from \"@cedra-labs/wallet-adapter-plugin\";\n\nexport type {\n  NetworkInfo,\n  AccountInfo,\n  CedraSignAndSubmitTransactionOutput,\n  CedraSignTransactionOutputV1_1,\n  CedraSignMessageInput,\n  CedraSignMessageOutput,\n  CedraChangeNetworkOutput,\n} from \"@cedra-labs/wallet-standard\";\nexport type {\n  AccountAuthenticator,\n  AnyRawTransaction,\n  InputGenerateTransactionOptions,\n  PendingTransactionResponse,\n  InputSubmitTransactionData,\n  Network,\n  AnyPublicKey,\n  AccountAddress,\n} from \"@cedra-labs/ts-sdk\";\n\nimport { GA4 } from \"./ga\";\nimport {\n  WalletChangeNetworkError,\n  WalletAccountChangeError,\n  WalletAccountError,\n  WalletConnectionError,\n  WalletGetNetworkError,\n  WalletNetworkChangeError,\n  WalletNotConnectedError,\n  WalletNotReadyError,\n  WalletNotSelectedError,\n  WalletSignAndSubmitMessageError,\n  WalletSignMessageError,\n  WalletSignTransactionError,\n  WalletSignMessageAndVerifyError,\n  WalletDisconnectionError,\n  WalletSubmitTransactionError,\n  WalletNotSupportedMethod,\n  WalletNotFoundError,\n} from \"./error\";\nimport { ChainIdToAnsSupportedNetworkMap, WalletReadyState } from \"./constants\";\nimport { WALLET_ADAPTER_CORE_VERSION } from \"./version\";\nimport {\n  fetchDevnetChainId,\n  generalizedErrorMessage,\n  getCedraConfig,\n  handlePublishPackageTransaction,\n  isCedraNetwork,\n  isRedirectable,\n  removeLocalStorage,\n  setLocalStorage,\n} from \"./utils\";\nimport { cedraStandardSupportedWalletList } from \"./registry\";\nimport { getSDKWallets } from \"./sdkWallets\";\nimport {\n  AvailableWallets,\n  CedraStandardSupportedWallet,\n  InputTransactionData,\n} from \"./utils/types\";\n\n// An adapter wallet types is a wallet that is compatible with the wallet standard and the wallet adapter properties\nexport type AdapterWallet = CedraWallet & {\n  readyState?: WalletReadyState;\n};\n\n// An adapter not detected wallet types is a wallet that is compatible with the wallet standard but not detected\nexport type AdapterNotDetectedWallet = Omit<\n  AdapterWallet,\n  \"features\" | \"version\" | \"chains\" | \"accounts\"\n> & {\n  readyState: WalletReadyState.NotDetected;\n};\n\nexport interface DappConfig {\n  network: Network;\n  cedraApiKeys?: Partial<Record<Network, string>>;\n  cedraConnectDappId?: string;\n  cedraConnect?: Omit<CedraConnectWalletConfig, \"network\">;\n  /**\n   * @deprecated will be removed in a future version\n   */\n  mizuwallet?: {\n    manifestURL: string;\n    appId?: string;\n  };\n  msafeWalletConfig?: {\n    appId?: string;\n    appUrl?: string;\n  };\n}\n\nexport declare interface WalletCoreEvents {\n  connect(account: AccountInfo | null): void;\n  disconnect(): void;\n  standardWalletsAdded(wallets: AdapterWallet): void;\n  standardNotDetectedWalletAdded(wallets: AdapterNotDetectedWallet): void;\n  networkChange(network: NetworkInfo | null): void;\n  accountChange(account: AccountInfo | null): void;\n}\n\nexport type AdapterAccountInfo = Omit<AccountInfo, \"ansName\"> & {\n  // ansName is a read-only property on the standard AccountInfo type\n  ansName?: string;\n};\n\nexport class WalletCore extends EventEmitter<WalletCoreEvents> {\n  // Local private variable to hold the wallet that is currently connected\n  private _wallet: AdapterWallet | null = null;\n\n  // Local private variable to hold SDK wallets in the adapter\n  private readonly _sdkWallets: AdapterWallet[] = [];\n\n  // Local array that holds all the wallets that are AIP-62 standard compatible\n  private _standard_wallets: AdapterWallet[] = [];\n\n  // Local array that holds all the wallets that are AIP-62 standard compatible but are not installed on the user machine\n  private _standard_not_detected_wallets: AdapterNotDetectedWallet[] = [];\n\n  // Local private variable to hold the network that is currently connected\n  private _network: NetworkInfo | null = null;\n\n  // Local private variable to hold the wallet connected state\n  private _connected: boolean = false;\n\n  // Local private variable to hold the connecting state\n  private _connecting: boolean = false;\n\n  // Local private variable to hold the account that is currently connected\n  private _account: AdapterAccountInfo | null = null;\n\n  // JSON configuration for CedraConnect\n  private _dappConfig: DappConfig | undefined;\n\n  // Private array that holds all the Wallets a dapp decided to opt-in to\n  private _optInWallets: ReadonlyArray<AvailableWallets> = [];\n\n  // Local flag to disable the adapter telemetry tool\n  private _disableTelemetry: boolean = false;\n\n  // Google Analytics 4 module\n  private readonly ga4: GA4 | null = null;\n\n  constructor(\n    optInWallets?: ReadonlyArray<AvailableWallets>,\n    dappConfig?: DappConfig,\n    disableTelemetry?: boolean\n  ) {\n    super();\n    this._optInWallets = optInWallets || [];\n    this._dappConfig = dappConfig;\n    this._disableTelemetry = disableTelemetry ?? false;\n    this._sdkWallets = getSDKWallets(this._dappConfig);\n\n    // If disableTelemetry set to false (by default), start GA4\n    if (!this._disableTelemetry) {\n      this.ga4 = new GA4();\n    }\n    // Strategy to detect AIP-62 standard compatible extension wallets\n    this.fetchExtensionAIP62CedraWallets();\n    // Strategy to detect AIP-62 standard compatible SDK wallets.\n    // We separate the extension and sdk detection process so we dont refetch sdk wallets everytime a new\n    // extension wallet is detected\n    this.fetchSDKAIP62CedraWallets();\n    // Strategy to append not detected AIP-62 standard compatible extension wallets\n    this.appendNotDetectedStandardSupportedWallets();\n  }\n\n  private fetchExtensionAIP62CedraWallets(): void {\n    let { cedraWallets, on } = getCedraWallets();\n    this.setExtensionAIP62Wallets(cedraWallets);\n\n    if (typeof window === \"undefined\") return;\n    // Adds an event listener for new wallets that get registered after the dapp has been loaded,\n    // receiving an unsubscribe function, which it can later use to remove the listener\n    const that = this;\n    const removeRegisterListener = on(\"register\", function () {\n      let { cedraWallets } = getCedraWallets();\n      that.setExtensionAIP62Wallets(cedraWallets);\n    });\n\n    const removeUnregisterListener = on(\"unregister\", function () {\n      let { cedraWallets } = getCedraWallets();\n      that.setExtensionAIP62Wallets(cedraWallets);\n    });\n  }\n\n  /**\n   * Set AIP-62 extension wallets\n   *\n   * @param extensionwWallets\n   */\n  private setExtensionAIP62Wallets(\n    extensionwWallets: readonly CedraWallet[]\n  ): void {\n    extensionwWallets.map((wallet: AdapterWallet) => {\n      if (this.excludeWallet(wallet)) {\n        return;\n      }\n\n      // Remove optional duplications in the _all_wallets array\n      this._standard_wallets = this._standard_wallets.filter(\n        (item) => item.name !== wallet.name\n      );\n\n      const isValid = isWalletWithRequiredFeatureSet(wallet);\n      if (isValid) {\n        // check if we already have this wallet as a not detected wallet\n        const index = this._standard_not_detected_wallets.findIndex(\n          (notDetctedWallet) => notDetctedWallet.name == wallet.name\n        );\n        // if we do, remove it from the not detected wallets array as it is now become detected\n        if (index !== -1) {\n          this._standard_not_detected_wallets.splice(index, 1);\n        }\n\n        wallet.readyState = WalletReadyState.Installed;\n        this._standard_wallets.push(wallet);\n        this.emit(\"standardWalletsAdded\", wallet);\n      }\n    });\n  }\n\n  /**\n   * Set AIP-62 SDK wallets\n   */\n  private fetchSDKAIP62CedraWallets(): void {\n    this._sdkWallets.map((wallet: AdapterWallet) => {\n      if (this.excludeWallet(wallet)) {\n        return;\n      }\n      const isValid = isWalletWithRequiredFeatureSet(wallet);\n\n      if (isValid) {\n        wallet.readyState = WalletReadyState.Installed;\n        this._standard_wallets.push(wallet);\n      }\n    });\n  }\n\n  // Since we can't discover AIP-62 wallets that are not installed on the user machine,\n  // we hold a AIP-62 wallets registry to show on the wallet selector modal for the users.\n  // Append wallets from wallet standard support registry to the `_standard_not_detected_wallets` array\n  // when wallet is not installed on the user machine\n  private appendNotDetectedStandardSupportedWallets(): void {\n    // Loop over the registry map\n    cedraStandardSupportedWalletList.map((supportedWallet) => {\n      // Check if we already have this wallet as a detected AIP-62 wallet standard\n      const existingStandardWallet = this._standard_wallets.find(\n        (wallet) => wallet.name == supportedWallet.name\n      );\n      // If it is detected, it means the user has the wallet installed, so dont add it to the wallets array\n      if (existingStandardWallet) {\n        return;\n      }\n      // If AIP-62 wallet detected but it is excluded by the dapp, dont add it to the wallets array\n      if (this.excludeWallet(supportedWallet)) {\n        return;\n      }\n      // If AIP-62 wallet does not exist, append it to the wallet selector modal\n      // as an undetected wallet\n      if (!existingStandardWallet) {\n        this._standard_not_detected_wallets.push(supportedWallet);\n        this.emit(\"standardNotDetectedWalletAdded\", supportedWallet);\n      }\n    });\n  }\n\n  /**\n   * A function that excludes an AIP-62 compatible wallet the dapp doesnt want to include\n   *\n   * @param wallet AdapterWallet | AdapterNotDetectedWallet\n   * @returns boolean\n   */\n  excludeWallet(wallet: AdapterWallet | AdapterNotDetectedWallet): boolean {\n    // If _optInWallets is not empty, and does not include the provided wallet,\n    // return true to exclude the wallet, otherwise return false\n    if (\n      this._optInWallets.length > 0 &&\n      !this._optInWallets.includes(wallet.name as AvailableWallets)\n    ) {\n      return true;\n    }\n    return false;\n  }\n\n  private recordEvent(eventName: string, additionalInfo?: object): void {\n    this.ga4?.gtag(\"event\", `wallet_adapter_${eventName}`, {\n      wallet: this._wallet?.name,\n      network: this._network?.name,\n      network_url: this._network?.url,\n      adapter_core_version: WALLET_ADAPTER_CORE_VERSION,\n      send_to: process.env.GAID,\n      ...additionalInfo,\n    });\n  }\n\n  /**\n   * Helper function to ensure wallet exists\n   *\n   * @param wallet A wallet\n   */\n  private ensureWalletExists(\n    wallet: AdapterWallet | null\n  ): asserts wallet is AdapterWallet {\n    if (!wallet) {\n      throw new WalletNotConnectedError().name;\n    }\n    if (!(wallet.readyState === WalletReadyState.Installed))\n      throw new WalletNotReadyError(\"Wallet is not set\").name;\n  }\n\n  /**\n   * Helper function to ensure account exists\n   *\n   * @param account An account\n   */\n  private ensureAccountExists(\n    account: AccountInfo | null\n  ): asserts account is AccountInfo {\n    if (!account) {\n      throw new WalletAccountError(\"Account is not set\").name;\n    }\n  }\n\n  /**\n   * Queries and sets ANS name for the current connected wallet account\n   */\n  private async setAnsName(): Promise<void> {\n    if (this._network?.chainId && this._account) {\n      if (this._account.ansName) return;\n      // ANS supports only MAINNET or TESTNET\n      if (\n        !ChainIdToAnsSupportedNetworkMap[this._network.chainId] ||\n        !isCedraNetwork(this._network)\n      ) {\n        this._account.ansName = undefined;\n        return;\n      }\n\n      const cedraConfig = getCedraConfig(this._network, this._dappConfig);\n      const cedra = new Cedra(cedraConfig);\n      try {\n        const name = await cedra.ans.getPrimaryName({\n          address: this._account.address.toString(),\n        });\n        this._account.ansName = name;\n      } catch (error: any) {\n        console.log(`Error setting ANS name ${error}`);\n      }\n    }\n  }\n\n  /**\n   * Function to cleat wallet adapter data.\n   *\n   * - Removes current connected wallet state\n   * - Removes current connected account state\n   * - Removes current connected network state\n   * - Removes autoconnect local storage value\n   */\n  private clearData(): void {\n    this._connected = false;\n    this.setWallet(null);\n    this.setAccount(null);\n    this.setNetwork(null);\n    removeLocalStorage();\n  }\n\n  /**\n   * Sets the connected wallet\n   *\n   * @param wallet A wallet\n   */\n  setWallet(wallet: CedraWallet | null): void {\n    this._wallet = wallet;\n  }\n\n  /**\n   * Sets the connected account\n   *\n   * @param account An account\n   */\n  setAccount(account: AccountInfo | null): void {\n    this._account = account;\n  }\n\n  /**\n   * Sets the connected network\n   *\n   * @param network A network\n   */\n  setNetwork(network: NetworkInfo | null): void {\n    this._network = network;\n  }\n\n  /**\n   * Helper function to detect whether a wallet is connected\n   *\n   * @returns boolean\n   */\n  isConnected(): boolean {\n    return this._connected;\n  }\n\n  /**\n   * Getter to fetch all detected wallets\n   */\n  get wallets(): ReadonlyArray<CedraWallet> {\n    return this._standard_wallets;\n  }\n\n  get notDetectedWallets(): ReadonlyArray<AdapterNotDetectedWallet> {\n    return this._standard_not_detected_wallets;\n  }\n\n  /**\n   * Getter for the current connected wallet\n   *\n   * @return wallet info\n   * @throws WalletNotSelectedError\n   */\n  get wallet(): CedraWallet | null {\n    try {\n      if (!this._wallet) return null;\n      return this._wallet;\n    } catch (error: any) {\n      throw new WalletNotSelectedError(error).message;\n    }\n  }\n\n  /**\n   * Getter for the current connected account\n   *\n   * @return account info\n   * @throws WalletAccountError\n   */\n  get account(): AccountInfo | null {\n    try {\n      return this._account;\n    } catch (error: any) {\n      throw new WalletAccountError(error).message;\n    }\n  }\n\n  /**\n   * Getter for the current wallet network\n   *\n   * @return network info\n   * @throws WalletGetNetworkError\n   */\n  get network(): NetworkInfo | null {\n    try {\n      return this._network;\n    } catch (error: any) {\n      throw new WalletGetNetworkError(error).message;\n    }\n  }\n\n  /**\n   * Helper function to run some checks before we connect with a wallet.\n   *\n   * @param walletName. The wallet name we want to connect with.\n   */\n  async connect(walletName: string): Promise<void | string> {\n    // First, handle mobile case\n    // Check if we are in a redirectable view (i.e on mobile AND not in an in-app browser)\n    if (isRedirectable()) {\n      const selectedWallet = this._standard_not_detected_wallets.find(\n        (wallet: AdapterNotDetectedWallet) => wallet.name === walletName\n      );\n\n      if (selectedWallet) {\n        // If wallet has a deeplinkProvider property, use it\n        const uninstalledWallet =\n          selectedWallet as unknown as CedraStandardSupportedWallet;\n        if (uninstalledWallet.deeplinkProvider) {\n          const url = encodeURIComponent(window.location.href);\n          const location = uninstalledWallet.deeplinkProvider.concat(url);\n          window.location.href = location;\n          return;\n        }\n      }\n    }\n\n    // Checks the wallet exists in the detected wallets array\n    const allDetectedWallets = this._standard_wallets;\n\n    const selectedWallet = allDetectedWallets.find(\n      (wallet: AdapterWallet) => wallet.name === walletName\n    );\n\n    if (!selectedWallet) return;\n\n    // Check if wallet is already connected\n    if (this._connected && this._account) {\n      // if the selected wallet is already connected, we don't need to connect again\n      if (this._wallet?.name === walletName)\n        throw new WalletConnectionError(\n          `${walletName} wallet is already connected`\n        ).message;\n    }\n\n    await this.connectWallet(selectedWallet, async () => {\n      const response = await selectedWallet.features[\"cedra:connect\"].connect();\n      if (response.status === UserResponseStatus.REJECTED) {\n        throw new WalletConnectionError(\"User has rejected the request\")\n          .message;\n      }\n\n      return { account: response.args, output: undefined };\n    });\n  }\n\n  /**\n   * Signs into the wallet by connecting and signing an authentication messages.\n   *\n   * For more information, visit: https://siwa.cedra.dev\n   *\n   * @param args\n   * @param args.input The CedraSignInInput which defines how the SIWA Message should be constructed\n   * @param args.walletName The name of the wallet to sign into\n   * @returns The CedraSignInOutput which contains the account and signature information\n   */\n  async signIn(args: {\n    input: CedraSignInInput;\n    walletName: string;\n  }): Promise<CedraSignInOutput> {\n    const { input, walletName } = args;\n\n    const allDetectedWallets = this._standard_wallets;\n    const selectedWallet = allDetectedWallets.find(\n      (wallet: AdapterWallet) => wallet.name === walletName\n    );\n\n    if (!selectedWallet) {\n      throw new WalletNotFoundError(`Wallet ${walletName} not found`).message;\n    }\n\n    if (!selectedWallet.features[\"cedra:signIn\"]) {\n      throw new WalletNotSupportedMethod(\n        `cedra:signIn is not supported by ${walletName}`\n      ).message;\n    }\n\n    return await this.connectWallet(selectedWallet, async () => {\n      if (!selectedWallet.features[\"cedra:signIn\"]) {\n        throw new WalletNotSupportedMethod(\n          `cedra:signIn is not supported by ${selectedWallet.name}`\n        ).message;\n      }\n\n      const response =\n        await selectedWallet.features[\"cedra:signIn\"].signIn(input);\n      if (response.status === UserResponseStatus.REJECTED) {\n        throw new WalletConnectionError(\"User has rejected the request\")\n          .message;\n      }\n\n      return { account: response.args.account, output: response.args };\n    });\n  }\n\n  /**\n   * Connects a wallet to the dapp.\n   * On connect success, we set the current account and the network, and keeping the selected wallet\n   * name in LocalStorage to support autoConnect function.\n   *\n   * @param selectedWallet. The wallet we want to connect.\n   * @emit emits \"connect\" event\n   * @throws WalletConnectionError\n   */\n  private async connectWallet<T>(\n    selectedWallet: AdapterWallet,\n    onConnect: () => Promise<{ account: AccountInfo; output: T }>\n  ): Promise<T> {\n    try {\n      this._connecting = true;\n      this.setWallet(selectedWallet);\n      const { account, output } = await onConnect();\n      this.setAccount(account);\n      const network = await selectedWallet.features[\"cedra:network\"].network();\n      this.setNetwork(network);\n      await this.setAnsName();\n      setLocalStorage(selectedWallet.name);\n      this._connected = true;\n      this.recordEvent(\"wallet_connect\");\n      this.emit(\"connect\", account);\n      return output;\n    } catch (error: any) {\n      this.clearData();\n      const errMsg = generalizedErrorMessage(error);\n      throw new WalletConnectionError(errMsg).message;\n    } finally {\n      this._connecting = false;\n    }\n  }\n\n  /**\n   * Disconnect the current connected wallet. On success, we clear the\n   * current account, current network and LocalStorage data.\n   *\n   * @emit emits \"disconnect\" event\n   * @throws WalletDisconnectionError\n   */\n  async disconnect(): Promise<void> {\n    try {\n      this.ensureWalletExists(this._wallet);\n      await this._wallet.features[\"cedra:disconnect\"].disconnect();\n      this.clearData();\n      this.recordEvent(\"wallet_disconnect\");\n      this.emit(\"disconnect\");\n    } catch (error: any) {\n      const errMsg = generalizedErrorMessage(error);\n      throw new WalletDisconnectionError(errMsg).message;\n    }\n  }\n\n  /**\n   * Signs and submits a transaction to chain\n   *\n   * @param transactionInput InputTransactionData\n   * @returns CedraSignAndSubmitTransactionOutput\n   */\n  async signAndSubmitTransaction(\n    transactionInput: InputTransactionData\n  ): Promise<CedraSignAndSubmitTransactionOutput> {\n    try {\n      if (\"function\" in transactionInput.data) {\n        if (\n          transactionInput.data.function ===\n          \"0x1::account::rotate_authentication_key_call\"\n        ) {\n          throw new WalletSignAndSubmitMessageError(\"SCAM SITE DETECTED\")\n            .message;\n        }\n\n        if (\n          transactionInput.data.function === \"0x1::code::publish_package_txn\"\n        ) {\n          ({\n            metadataBytes: transactionInput.data.functionArguments[0],\n            byteCode: transactionInput.data.functionArguments[1],\n          } = handlePublishPackageTransaction(transactionInput));\n        }\n      }\n      this.ensureWalletExists(this._wallet);\n      this.ensureAccountExists(this._account);\n      this.recordEvent(\"sign_and_submit_transaction\");\n\n      if (this._wallet.features[\"cedra:signAndSubmitTransaction\"]) {\n        // check for backward compatibility. before version 1.1.0 the standard expected\n        // AnyRawTransaction input so the adapter built the transaction before sending it to the wallet\n        if (\n          this._wallet.features[\"cedra:signAndSubmitTransaction\"].version !==\n          \"1.1.0\"\n        ) {\n          const cedraConfig = getCedraConfig(this._network, this._dappConfig);\n\n          const cedra = new Cedra(cedraConfig);\n          const transaction = await cedra.transaction.build.simple({\n            sender: this._account.address.toString(),\n            data: transactionInput.data,\n            options: transactionInput.options,\n          });\n\n          type CedraSignAndSubmitTransactionV1Method = (\n            transaction: AnyRawTransaction\n          ) => Promise<UserResponse<CedraSignAndSubmitTransactionOutput>>;\n\n          const signAndSubmitTransactionMethod = this._wallet.features[\n            \"cedra:signAndSubmitTransaction\"\n          ]\n            .signAndSubmitTransaction as unknown as CedraSignAndSubmitTransactionV1Method;\n\n          const response = (await signAndSubmitTransactionMethod(\n            transaction\n          )) as UserResponse<CedraSignAndSubmitTransactionOutput>;\n\n          if (response.status === UserResponseStatus.REJECTED) {\n            throw new WalletConnectionError(\"User has rejected the request\")\n              .message;\n          }\n\n          return response.args;\n        }\n\n        const response = await this._wallet.features[\n          \"cedra:signAndSubmitTransaction\"\n        ].signAndSubmitTransaction({\n          payload: transactionInput.data,\n          gasUnitPrice: transactionInput.options?.gasUnitPrice,\n          maxGasAmount: transactionInput.options?.maxGasAmount,\n        });\n        if (response.status === UserResponseStatus.REJECTED) {\n          throw new WalletConnectionError(\"User has rejected the request\")\n            .message;\n        }\n        return response.args;\n      }\n\n      // If wallet does not support signAndSubmitTransaction\n      // the adapter will sign and submit it for the dapp.\n      const cedraConfig = getCedraConfig(this._network, this._dappConfig);\n      const cedra = new Cedra(cedraConfig);\n      const transaction = await cedra.transaction.build.simple({\n        sender: this._account.address,\n        data: transactionInput.data,\n        options: transactionInput.options,\n      });\n\n      const signTransactionResponse = await this.signTransaction({\n        transactionOrPayload: transaction,\n      });\n      const response = await this.submitTransaction({\n        transaction,\n        senderAuthenticator: signTransactionResponse.authenticator,\n      });\n      return { hash: response.hash };\n    } catch (error: any) {\n      const errMsg = generalizedErrorMessage(error);\n      throw new WalletSignAndSubmitMessageError(errMsg).message;\n    }\n  }\n\n  /**\n   * Signs a transaction\n   *\n   * This method supports 2 input types -\n   * 1. A raw transaction that was already built by the dapp,\n   * 2. A transaction data input as JSON. This is for the wallet to be able to simulate before signing\n   *\n   * @param transactionOrPayload AnyRawTransaction | InputTransactionData\n   * @param asFeePayer optional. A flag indicates to sign the transaction as the fee payer\n   * @param options optional. Transaction options\n   *\n   * @returns AccountAuthenticator\n   */\n  async signTransaction(args: {\n    transactionOrPayload: AnyRawTransaction | InputTransactionData;\n    asFeePayer?: boolean;\n  }): Promise<{\n    authenticator: AccountAuthenticator;\n    rawTransaction: Uint8Array;\n  }> {\n    const { transactionOrPayload, asFeePayer } = args;\n    /**\n     * All standard compatible wallets should support AnyRawTransaction for signTransaction version 1.0.0\n     * For standard signTransaction version 1.1.0, the standard expects a transaction input\n     *\n     * So, if the input is AnyRawTransaction, we can directly call the wallet's signTransaction method\n     *\n     *\n     * If the input is InputTransactionData, we need to\n     * 1. check if the wallet supports signTransaction version 1.1.0 - if so, we convert the input to the standard expected input\n     * 2. if it does not support signTransaction version 1.1.0, we convert it to a rawTransaction input and call the wallet's signTransaction method\n     */\n\n    try {\n      this.ensureWalletExists(this._wallet);\n      this.ensureAccountExists(this._account);\n      this.recordEvent(\"sign_transaction\");\n\n      // dapp sends a generated transaction (i.e AnyRawTransaction), which is supported by the wallet standard at signTransaction version 1.0.0\n      if (\"rawTransaction\" in transactionOrPayload) {\n        const response = (await this._wallet?.features[\n          \"cedra:signTransaction\"\n        ].signTransaction(\n          transactionOrPayload,\n          asFeePayer\n        )) as UserResponse<AccountAuthenticator>;\n        if (response.status === UserResponseStatus.REJECTED) {\n          throw new WalletConnectionError(\"User has rejected the request\")\n            .message;\n        }\n        return {\n          authenticator: response.args,\n          rawTransaction: transactionOrPayload.rawTransaction.bcsToBytes(),\n        };\n      } // dapp sends a transaction data input (i.e InputTransactionData), which is supported by the wallet standard at signTransaction version 1.1.0\n      else if (\n        this._wallet.features[\"cedra:signTransaction\"]?.version === \"1.1\"\n      ) {\n        // convert input to standard expected input\n        const signTransactionV1_1StandardInput: CedraSignTransactionInputV1_1 =\n          {\n            payload: transactionOrPayload.data,\n            expirationTimestamp:\n              transactionOrPayload.options?.expirationTimestamp,\n            expirationSecondsFromNow:\n              transactionOrPayload.options?.expirationSecondsFromNow,\n            gasUnitPrice: transactionOrPayload.options?.gasUnitPrice,\n            maxGasAmount: transactionOrPayload.options?.maxGasAmount,\n            sequenceNumber: transactionOrPayload.options?.accountSequenceNumber,\n            sender: transactionOrPayload.sender\n              ? { address: AccountAddress.from(transactionOrPayload.sender) }\n              : undefined,\n          };\n\n        const walletSignTransactionMethod = this._wallet?.features[\n          \"cedra:signTransaction\"\n        ].signTransaction as CedraSignTransactionMethod &\n          CedraSignTransactionMethodV1_1;\n\n        const response = (await walletSignTransactionMethod(\n          signTransactionV1_1StandardInput\n        )) as UserResponse<CedraSignTransactionOutputV1_1>;\n        if (response.status === UserResponseStatus.REJECTED) {\n          throw new WalletConnectionError(\"User has rejected the request\")\n            .message;\n        }\n        return {\n          authenticator: response.args.authenticator,\n          rawTransaction: response.args.rawTransaction.bcsToBytes(),\n        };\n      } else {\n        // dapp input is InputTransactionData but the wallet does not support it, so we convert it to a rawTransaction\n        const cedraConfig = getCedraConfig(this._network, this._dappConfig);\n        const cedra = new Cedra(cedraConfig);\n\n        const transaction = await cedra.transaction.build.simple({\n          sender: this._account.address,\n          data: transactionOrPayload.data,\n          options: transactionOrPayload.options,\n          withFeePayer: transactionOrPayload.withFeePayer,\n        });\n\n        const response = (await this._wallet?.features[\n          \"cedra:signTransaction\"\n        ].signTransaction(\n          transaction,\n          asFeePayer\n        )) as UserResponse<AccountAuthenticator>;\n        if (response.status === UserResponseStatus.REJECTED) {\n          throw new WalletConnectionError(\"User has rejected the request\")\n            .message;\n        }\n\n        return {\n          authenticator: response.args,\n          rawTransaction: transaction.bcsToBytes(),\n        };\n      }\n    } catch (error: any) {\n      const errMsg = generalizedErrorMessage(error);\n      throw new WalletSignTransactionError(errMsg).message;\n    }\n  }\n\n  /**\n   * Sign a message (doesnt submit to chain).\n   *\n   * @param message - CedraSignMessageInput\n   *\n   * @return response from the wallet's signMessage function\n   * @throws WalletSignMessageError\n   */\n  async signMessage(\n    message: CedraSignMessageInput\n  ): Promise<CedraSignMessageOutput> {\n    try {\n      this.ensureWalletExists(this._wallet);\n      this.recordEvent(\"sign_message\");\n\n      const response =\n        await this._wallet?.features[\"cedra:signMessage\"]?.signMessage(message);\n      if (response.status === UserResponseStatus.REJECTED) {\n        throw new WalletConnectionError(\"User has rejected the request\")\n          .message;\n      }\n      return response.args;\n    } catch (error: any) {\n      const errMsg = generalizedErrorMessage(error);\n      throw new WalletSignMessageError(errMsg).message;\n    }\n  }\n\n  /**\n   * Submits transaction to chain\n   *\n   * @param transaction - InputSubmitTransactionData\n   * @returns PendingTransactionResponse\n   */\n  async submitTransaction(\n    transaction: InputSubmitTransactionData\n  ): Promise<PendingTransactionResponse> {\n    // The standard does not support submitTransaction, so we use the adapter to submit the transaction\n    try {\n      this.ensureWalletExists(this._wallet);\n\n      const { additionalSignersAuthenticators } = transaction;\n      const transactionType =\n        additionalSignersAuthenticators !== undefined\n          ? \"multi-agent\"\n          : \"simple\";\n      this.recordEvent(\"submit_transaction\", {\n        transaction_type: transactionType,\n      });\n\n      const cedraConfig = getCedraConfig(this._network, this._dappConfig);\n      const cedra = new Cedra(cedraConfig);\n      if (additionalSignersAuthenticators !== undefined) {\n        const multiAgentTxn = {\n          ...transaction,\n          additionalSignersAuthenticators,\n        };\n        return cedra.transaction.submit.multiAgent(multiAgentTxn);\n      } else {\n        return cedra.transaction.submit.simple(transaction);\n      }\n    } catch (error: any) {\n      const errMsg = generalizedErrorMessage(error);\n      throw new WalletSubmitTransactionError(errMsg).message;\n    }\n  }\n\n  /**\n   Event for when account has changed on the wallet\n   @return the new account info\n   @throws WalletAccountChangeError\n   */\n  async onAccountChange(): Promise<void> {\n    try {\n      this.ensureWalletExists(this._wallet);\n      await this._wallet.features[\"cedra:onAccountChange\"]?.onAccountChange(\n        async (data: AccountInfo) => {\n          this.setAccount(data);\n          await this.setAnsName();\n          this.recordEvent(\"account_change\");\n          this.emit(\"accountChange\", this._account);\n        }\n      );\n    } catch (error: any) {\n      const errMsg = generalizedErrorMessage(error);\n      throw new WalletAccountChangeError(errMsg).message;\n    }\n  }\n\n  /**\n   Event for when network has changed on the wallet\n   @return the new network info\n   @throws WalletNetworkChangeError\n   */\n  async onNetworkChange(): Promise<void> {\n    try {\n      this.ensureWalletExists(this._wallet);\n      await this._wallet.features[\"cedra:onNetworkChange\"]?.onNetworkChange(\n        async (data: NetworkInfo) => {\n          this.setNetwork(data);\n          await this.setAnsName();\n          this.emit(\"networkChange\", this._network);\n        }\n      );\n    } catch (error: any) {\n      const errMsg = generalizedErrorMessage(error);\n      throw new WalletNetworkChangeError(errMsg).message;\n    }\n  }\n\n  /**\n   * Sends a change network request to the wallet to change the connected network\n   *\n   * @param network - Network\n   * @returns CedraChangeNetworkOutput\n   */\n  async changeNetwork(network: Network): Promise<CedraChangeNetworkOutput> {\n    try {\n      this.ensureWalletExists(this._wallet);\n      this.recordEvent(\"change_network_request\", {\n        from: this._network?.name,\n        to: network,\n      });\n      const chainId =\n        network === Network.DEVNET\n          ? await fetchDevnetChainId()\n          : NetworkToChainId[network];\n\n      const networkInfo: NetworkInfo = {\n        name: network,\n        chainId,\n      };\n\n      if (this._wallet.features[\"cedra:changeNetwork\"]) {\n        const response =\n          await this._wallet.features[\"cedra:changeNetwork\"].changeNetwork(\n            networkInfo\n          );\n        if (response.status === UserResponseStatus.REJECTED) {\n          throw new WalletConnectionError(\"User has rejected the request\")\n            .message;\n        }\n        return response.args;\n      }\n\n      throw new WalletChangeNetworkError(\n        `${this._wallet.name} does not support changing network request`\n      ).message;\n    } catch (error: any) {\n      const errMsg = generalizedErrorMessage(error);\n      throw new WalletChangeNetworkError(errMsg).message;\n    }\n  }\n\n  /**\n   * Signs a message and verifies the signer\n   * @param message - CedraSignMessageInput\n   * @returns boolean\n   */\n  async signMessageAndVerify(message: CedraSignMessageInput): Promise<boolean> {\n    try {\n      this.ensureWalletExists(this._wallet);\n      this.ensureAccountExists(this._account);\n      this.recordEvent(\"sign_message_and_verify\");\n\n      // sign the message\n      const response = (await this._wallet.features[\n        \"cedra:signMessage\"\n      ].signMessage(message)) as UserResponse<CedraSignMessageOutput>;\n\n      if (response.status === UserResponseStatus.REJECTED) {\n        throw new WalletConnectionError(\"Failed to sign a message\").message;\n      }\n\n      const cedraConfig = getCedraConfig(this._network, this._dappConfig);\n      const signingMessage = new TextEncoder().encode(\n        response.args.fullMessage\n      );\n      if (\"verifySignatureAsync\" in (this._account.publicKey as Object)) {\n        return await this._account.publicKey.verifySignatureAsync({\n          cedraConfig,\n          message: signingMessage,\n          signature: response.args.signature,\n          options: { throwErrorWithReason: true },\n        });\n      }\n      return this._account.publicKey.verifySignature({\n        message: signingMessage,\n        signature: response.args.signature,\n      });\n    } catch (error: any) {\n      const errMsg = generalizedErrorMessage(error);\n      throw new WalletSignMessageAndVerifyError(errMsg).message;\n    }\n  }\n}\n","export class GA4 {\n  readonly cedraGAID: string | undefined = process.env.GAID;\n\n  constructor() {\n    // Inject Cedra Google Analytics 4 script\n    this.injectGA(this.cedraGAID);\n  }\n\n  gtag(a: string, b: string | object, c?: object) {\n    let dataLayer = (window as any).dataLayer || [];\n    dataLayer.push(arguments);\n  }\n\n  private injectGA(gaID?: string) {\n    if (typeof window === \"undefined\") return;\n    if (!gaID) return;\n\n    const head = document.getElementsByTagName(\"head\")[0];\n\n    var myScript = document.createElement(\"script\");\n\n    myScript.setAttribute(\n      \"src\",\n      `https://www.googletagmanager.com/gtag/js?id=${gaID}`,\n    );\n\n    const that = this;\n    myScript.onload = function () {\n      that.gtag(\"js\", new Date());\n      that.gtag(\"config\", `${gaID}`, {\n        send_page_view: false,\n      });\n    };\n\n    head.insertBefore(myScript, head.children[1]);\n  }\n}\n","export class WalletError extends Error {\n  public error: any;\n\n  constructor(message?: string, error?: any) {\n    super(message);\n    this.error = error;\n  }\n}\n\nexport class WalletNotSelectedError extends WalletError {\n  name = \"WalletNotSelectedError\";\n}\n\nexport class WalletNotReadyError extends WalletError {\n  name = \"WalletNotReadyError\";\n}\n\nexport class WalletLoadError extends WalletError {\n  name = \"WalletLoadError\";\n}\n\nexport class WalletConfigError extends WalletError {\n  name = \"WalletConfigError\";\n}\n\nexport class WalletConnectionError extends WalletError {\n  name = \"WalletConnectionError\";\n}\n\nexport class WalletDisconnectedError extends WalletError {\n  name = \"WalletDisconnectedError\";\n}\n\nexport class WalletDisconnectionError extends WalletError {\n  name = \"WalletDisconnectionError\";\n}\n\nexport class WalletAccountError extends WalletError {\n  name = \"WalletAccountError\";\n}\nexport class WalletGetNetworkError extends WalletError {\n  name = \"WalletGetNetworkError\";\n}\n\nexport class WalletAccountChangeError extends WalletError {\n  name = \"WalletAccountChangeError\";\n}\n\nexport class WalletNetworkChangeError extends WalletError {\n  name = \"WalletNetworkChangeError\";\n}\n\nexport class WalletPublicKeyError extends WalletError {\n  name = \"WalletPublicKeyError\";\n}\n\nexport class WalletKeypairError extends WalletError {\n  name = \"WalletKeypairError\";\n}\n\nexport class WalletNotConnectedError extends WalletError {\n  name = \"WalletNotConnectedError\";\n}\n\nexport class WalletSendTransactionError extends WalletError {\n  name = \"WalletSendTransactionError\";\n}\n\nexport class WalletSignMessageError extends WalletError {\n  name = \"WalletSignMessageError\";\n}\n\nexport class WalletSignMessageAndVerifyError extends WalletError {\n  name = \"WalletSignMessageAndVerifyError\";\n}\n\nexport class WalletSignAndSubmitMessageError extends WalletError {\n  name = \"WalletSignAndSubmitMessageError\";\n}\n\nexport class WalletSignTransactionError extends WalletError {\n  name = \"WalletSignTransactionError\";\n}\n\nexport class WalletTimeoutError extends WalletError {\n  name = \"WalletTimeoutError\";\n}\n\nexport class WalletWindowBlockedError extends WalletError {\n  name = \"WalletWindowBlockedError\";\n}\n\nexport class WalletWindowClosedError extends WalletError {\n  name = \"WalletWindowClosedError\";\n}\n\nexport class WalletResponseError extends WalletError {\n  name = \"WalletResponseError\";\n}\n\nexport class WalletNotSupportedMethod extends WalletError {\n  name = \"WalletNotSupportedMethod\";\n}\n\nexport class WalletChangeNetworkError extends WalletError {\n  name = \"WalletChangeNetworkError\";\n}\n\nexport class WalletSubmitTransactionError extends WalletError {\n  name = \"WalletSubmitTransactionError\";\n}\n\nexport class WalletNotFoundError extends WalletError {\n  name = \"WalletNotFoundError\";\n}\n","export enum WalletReadyState {\n  /**\n   * Wallet can only be in one of two states - installed or not installed\n   * Installed: wallets are detected by the browser event listeners and means they are installed on the user's browser.\n   * NotDetected: wallets are not detected by the browser event listeners and means they are not installed on the user's browser.\n   */\n  Installed = \"Installed\",\n  NotDetected = \"NotDetected\",\n}\n\nexport enum NetworkName {\n  Mainnet = \"mainnet\",\n  Testnet = \"testnet\",\n  Devnet = \"devnet\",\n}\n\nexport const ChainIdToAnsSupportedNetworkMap: Record<string, string> = {\n  \"1\": \"mainnet\", // mainnet\n  \"2\": \"testnet\", // testnet\n};\n\n/** The base URL for all Cedra Connect wallets. */\nexport const CEDRA_CONNECT_BASE_URL = \"https://cedraconnect.app\";\n\n/** The URL to the Cedra Connect account page if the user is signed in to Cedra Connect. */\nexport const CEDRA_CONNECT_ACCOUNT_URL =\n  \"https://cedraconnect.app/dashboard/main-account\";\n","import {\n  Cedra,\n  CedraConfig,\n  Hex,\n  Network,\n  NetworkToNodeAPI,\n} from \"@cedra-labs/ts-sdk\";\nimport {\n  NetworkInfo,\n  NetworkInfo as StandardNetworkInfo,\n} from \"@cedra-labs/wallet-standard\";\n\nimport { DappConfig } from \"../WalletCore\";\nimport { WalletSignAndSubmitMessageError } from \"../error\";\nimport { InputTransactionData } from \"./types\";\n\nexport function isMobile(): boolean {\n  return /Mobile|iP(hone|od|ad)|Android|BlackBerry|IEMobile|Kindle|NetFront|Silk-Accelerated|(hpw|web)OS|Fennec|Minimo|Opera M(obi|ini)|Blazer|Dolfin|Dolphin|Skyfire|Zune/i.test(\n    navigator.userAgent,\n  );\n}\n\nexport function isInAppBrowser(): boolean {\n  const isIphone = /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(\n    navigator.userAgent,\n  );\n\n  const isAndroid = /(Android).*Version\\/[\\d.]+.*Chrome\\/[^\\s]+ Mobile/i.test(\n    navigator.userAgent,\n  );\n\n  return isIphone || isAndroid;\n}\n\nexport function isRedirectable(): boolean {\n  // SSR: return false\n  if (typeof navigator === \"undefined\" || !navigator) return false;\n\n  // if we are on mobile and NOT in a in-app browser we will redirect to a wallet app\n\n  return isMobile() && !isInAppBrowser();\n}\n\nexport function generalizedErrorMessage(error: any): string {\n  return typeof error === \"object\" && \"message\" in error\n    ? error.message\n    : error;\n}\n\n/**\n * Helper function to get CedraConfig that supports Cedra and Custom networks\n *\n * @param networkInfo\n * @param dappConfig\n * @returns CedraConfig\n */\nexport const getCedraConfig = (\n  networkInfo: NetworkInfo | null,\n  dappConfig: DappConfig | undefined,\n): CedraConfig => {\n  if (!networkInfo) {\n    throw new Error(\"Undefined network\");\n  }\n\n  if (isCedraNetwork(networkInfo)) {\n    const currentNetwork = convertNetwork(networkInfo);\n\n    if (isCedraLiveNetwork(currentNetwork)) {\n      const apiKey = dappConfig?.cedraApiKeys;\n      return new CedraConfig({\n        network: currentNetwork,\n        clientConfig: { API_KEY: apiKey ? apiKey[currentNetwork] : undefined },\n      });\n    }\n\n    return new CedraConfig({\n      network: currentNetwork,\n    });\n  }\n\n  const knownNetworks = {\n    okx: \"https://wallet.okx.com/fullnode/cedra/discover/rpc\",\n  };\n\n  if (networkInfo.url) {\n    const isKnownNetwork = Object.values(knownNetworks).includes(\n      networkInfo.url,\n    );\n\n    if (isKnownNetwork) {\n      return new CedraConfig({\n        network: Network.CUSTOM,\n        fullnode: networkInfo.url,\n      });\n    }\n  }\n\n  // Custom networks are not supported, please ensure that the wallet is returning the appropriate network Mainnet, Testnet, Devnet, Local\n  throw new Error(\n    `Invalid network, network ${networkInfo.name} not supported with Cedra wallet adapter to prevent user from using an unexpected network.`,\n  );\n};\n\n/**\n * Helper function to resolve if the current connected network is an Cedra network\n *\n * @param networkInfo\n * @returns boolean\n */\nexport const isCedraNetwork = (\n  networkInfo: NetworkInfo | StandardNetworkInfo | null,\n): boolean => {\n  if (!networkInfo) {\n    throw new Error(\"Undefined network\");\n  }\n  return NetworkToNodeAPI[networkInfo.name] !== undefined;\n};\n\nexport const isCedraLiveNetwork = (networkInfo: Network): boolean => {\n  return (\n    networkInfo === \"devnet\" ||\n    networkInfo === \"testnet\" ||\n    networkInfo === \"mainnet\"\n  );\n};\n\n/**\n * Helper function to fetch Devnet chain id\n */\nexport const fetchDevnetChainId = async (): Promise<number> => {\n  const cedra = new Cedra(); // default to devnet\n  return await cedra.getChainId();\n};\n\n/**\n * A helper function to handle the publish package transaction.\n * The Cedra SDK expects the metadataBytes and byteCode to be Uint8Array, but in case the arguments are passed in\n * as a string, this function converts the string to Uint8Array.\n */\nexport const handlePublishPackageTransaction = (\n  transactionInput: InputTransactionData,\n) => {\n  // convert the first argument, metadataBytes, to uint8array if is a string\n  let metadataBytes = transactionInput.data.functionArguments[0];\n  if (typeof metadataBytes === \"string\") {\n    metadataBytes = Hex.fromHexInput(metadataBytes).toUint8Array();\n  }\n\n  // convert the second argument, byteCode, to uint8array if is a string\n  let byteCode = transactionInput.data.functionArguments[1];\n  if (Array.isArray(byteCode)) {\n    byteCode = byteCode.map((byte) => {\n      if (typeof byte === \"string\") {\n        return Hex.fromHexInput(byte).toUint8Array();\n      }\n      return byte;\n    });\n  } else {\n    throw new WalletSignAndSubmitMessageError(\n      \"The bytecode argument must be an array.\",\n    ).message;\n  }\n\n  return { metadataBytes, byteCode };\n};\n\n// old => new\nexport function convertNetwork(networkInfo: NetworkInfo | null): Network {\n  switch (networkInfo?.name) {\n    case \"mainnet\" as Network:\n      return Network.MAINNET;\n    case \"testnet\" as Network:\n      return Network.TESTNET;\n    case \"devnet\" as Network:\n      return Network.DEVNET;\n    case \"local\" as Network:\n      return Network.LOCAL;\n    default:\n      throw new Error(\"Invalid Cedra network name\");\n  }\n}\n","const LOCAL_STORAGE_ITEM_KEY = \"CedraWalletName\";\n\nexport function setLocalStorage(walletName: string) {\n  localStorage.setItem(LOCAL_STORAGE_ITEM_KEY, walletName);\n}\n\nexport function removeLocalStorage() {\n  localStorage.removeItem(LOCAL_STORAGE_ITEM_KEY);\n}\n\nexport function getLocalStorage() {\n  localStorage.getItem(LOCAL_STORAGE_ITEM_KEY);\n}\n","import { WalletInfo } from \"./types\";\nimport { AdapterNotDetectedWallet, AdapterWallet } from \"../WalletCore\";\nimport { CEDRA_CONNECT_BASE_URL, WalletReadyState } from \"../constants\";\nimport { isRedirectable } from \"./helpers\";\n\n/**\n * A function that will partition the provided wallets into two list  `defaultWallets` and `moreWallets`.\n * By default, the wallets will be partitioned by whether or not they are installed or loadable.\n * You can pass your own partition function if you wish to customize this behavior.\n */\nexport function partitionWallets(\n  wallets: ReadonlyArray<AdapterWallet | AdapterNotDetectedWallet>,\n  partitionFunction: (\n    wallet: AdapterWallet | AdapterNotDetectedWallet,\n  ) => boolean = isInstalledOrLoadable,\n) {\n  const defaultWallets: Array<AdapterWallet> = [];\n  const moreWallets: Array<AdapterNotDetectedWallet> = [];\n\n  for (const wallet of wallets) {\n    if (partitionFunction(wallet)) defaultWallets.push(wallet as AdapterWallet);\n    else moreWallets.push(wallet as AdapterNotDetectedWallet);\n  }\n\n  return { defaultWallets, moreWallets };\n}\n\n/** Returns true if the wallet is installed or loadable. */\nexport function isInstalledOrLoadable(\n  wallet: AdapterWallet | AdapterNotDetectedWallet,\n) {\n  return wallet.readyState === WalletReadyState.Installed;\n}\n\n/**\n * Returns true if the user is on desktop and the provided wallet requires installation of a browser extension.\n * This can be used to decide whether to show a \"Connect\" button or \"Install\" link in the UI.\n */\nexport function isInstallRequired(\n  wallet: AdapterWallet | AdapterNotDetectedWallet,\n) {\n  const isWalletReady = isInstalledOrLoadable(wallet);\n  const isMobile = !isWalletReady && isRedirectable();\n\n  return !isMobile && !isWalletReady;\n}\n\n/** Truncates the provided wallet address at the middle with an ellipsis. */\nexport function truncateAddress(address: string | undefined) {\n  if (!address) return;\n  return `${address.slice(0, 6)}...${address.slice(-5)}`;\n}\n\n/** Returns `true` if the provided wallet is an Cedra Connect wallet. */\nexport function isCedraConnectWallet(wallet: WalletInfo | AdapterWallet) {\n  if (!wallet.url) return false;\n  return wallet.url.startsWith(CEDRA_CONNECT_BASE_URL);\n}\n\n/**\n * Partitions the `wallets` array so that Cedra Connect wallets are grouped separately from the rest.\n * Cedra Connect is a web wallet that uses social login to create accounts on the blockchain.\n */\nexport function getCedraConnectWallets(\n  wallets: ReadonlyArray<AdapterWallet | AdapterNotDetectedWallet>,\n) {\n  const { defaultWallets, moreWallets } = partitionWallets(\n    wallets,\n    isCedraConnectWallet,\n  );\n  return { cedraConnectWallets: defaultWallets, otherWallets: moreWallets };\n}\n\nexport interface WalletSortingOptions {\n  /** An optional function for sorting Cedra Connect wallets. */\n  sortCedraConnectWallets?: (a: AdapterWallet, b: AdapterWallet) => number;\n  /** An optional function for sorting wallets that are currently installed or loadable. */\n  sortAvailableWallets?: (\n    a: AdapterWallet | AdapterNotDetectedWallet,\n    b: AdapterWallet | AdapterNotDetectedWallet,\n  ) => number;\n  /** An optional function for sorting wallets that are NOT currently installed or loadable. */\n  sortInstallableWallets?: (\n    a: AdapterWallet | AdapterNotDetectedWallet,\n    b: AdapterWallet | AdapterNotDetectedWallet,\n  ) => number;\n}\n\n/**\n * Partitions the `wallets` array into three distinct groups:\n *\n * `cedraConnectWallets` - Wallets that use social login to create accounts on\n * the blockchain via Cedra Connect.\n *\n * `availableWallets` - Wallets that are currently installed or loadable by the client.\n *\n * `installableWallets` - Wallets that are NOT current installed or loadable and\n * require the client to install a browser extension first.\n *\n * Additionally, these wallet groups can be sorted by passing sort functions via the `options` argument.\n */\nexport function groupAndSortWallets(\n  wallets: ReadonlyArray<AdapterWallet | AdapterNotDetectedWallet>,\n  options?: WalletSortingOptions,\n) {\n  const { cedraConnectWallets, otherWallets } = getCedraConnectWallets(wallets);\n  const { defaultWallets, moreWallets } = partitionWallets(otherWallets);\n\n  if (options?.sortCedraConnectWallets) {\n    cedraConnectWallets.sort(options.sortCedraConnectWallets);\n  }\n  if (options?.sortAvailableWallets) {\n    defaultWallets.sort(options.sortAvailableWallets);\n  }\n  if (options?.sortInstallableWallets) {\n    moreWallets.sort(options.sortInstallableWallets);\n  }\n\n  return {\n    /** Wallets that use social login to create an account on the blockchain */\n    cedraConnectWallets,\n    /** Wallets that are currently installed or loadable. */\n    availableWallets: defaultWallets,\n    /** Wallets that are NOT currently installed or loadable. */\n    installableWallets: moreWallets,\n  };\n}\n","import { WalletReadyState } from \"./constants\";\nimport { CedraStandardSupportedWallet } from \"./utils/types\";\n\n/**\n * Registry of AIP-62 wallet standard supported wallets.\n * This list is used to show supported wallets even if they are not installed on the user machine.\n *\n * AIP-62 compatible wallets are required to add their wallet info here if they want to be detected by the adapter\n *\n * @param name - The name of your wallet cast to WalletName (Ex. \"Nightly\" as WalletName<\"Nightly\">)\n * @param url - The link to your chrome extension or main website where new users can create an account with your wallet.\n * @param icon - An icon for your wallet. Can be one of 4 data types. Be sure to follow the below format exactly (including the literal \",\" after base64).\n *        Format: `data:image/${\"svg+xml\" | \"webp\" | \"png\" | \"gif\"};base64,${string}`\n *        Note: ${...} data in the above format should be replaced. Other characters are literals (ex. \";\")\n * @param deeplinkProvider optional - An optional deeplink provider for the wallet. If the wallet is not installed, we can redirect the user to the wallet's deeplink provider\n * @example \"https://myWallet.app/explore?link=\"\n */\nexport const cedraStandardSupportedWalletList: Array<CedraStandardSupportedWallet> =\n  [\n    {\n      name: \"Nightly\",\n      url: \"https://nightly.app/\",\n      icon: \"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4NCjwhLS0gR2VuZXJhdG9yOiBBZG9iZSBJbGx1c3RyYXRvciAyOC4wLjAsIFNWRyBFeHBvcnQgUGx1Zy1JbiAuIFNWRyBWZXJzaW9uOiA2LjAwIEJ1aWxkIDApICAtLT4NCjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iV2Fyc3R3YV8xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4PSIwcHgiIHk9IjBweCINCgkgdmlld0JveD0iMCAwIDg1MS41IDg1MS41IiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCA4NTEuNSA4NTEuNTsiIHhtbDpzcGFjZT0icHJlc2VydmUiPg0KPHN0eWxlIHR5cGU9InRleHQvY3NzIj4NCgkuc3Qwe2ZpbGw6IzYwNjdGOTt9DQoJLnN0MXtmaWxsOiNGN0Y3Rjc7fQ0KPC9zdHlsZT4NCjxnPg0KCTxnIGlkPSJXYXJzdHdhXzJfMDAwMDAwMTQ2MDk2NTQyNTMxODA5NDY0NjAwMDAwMDg2NDc4NTIwMDIxMTY5MTg2ODhfIj4NCgkJPHBhdGggY2xhc3M9InN0MCIgZD0iTTEyNCwwaDYwMy42YzY4LjUsMCwxMjQsNTUuNSwxMjQsMTI0djYwMy42YzAsNjguNS01NS41LDEyNC0xMjQsMTI0SDEyNGMtNjguNSwwLTEyNC01NS41LTEyNC0xMjRWMTI0DQoJCQlDMCw1NS41LDU1LjUsMCwxMjQsMHoiLz4NCgk8L2c+DQoJPGcgaWQ9IldhcnN0d2FfMyI+DQoJCTxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik02MjMuNSwxNzAuM2MtMzcuNCw1Mi4yLTg0LjIsODguNC0xMzkuNSwxMTIuNmMtMTkuMi01LjMtMzguOS04LTU4LjMtNy44Yy0xOS40LTAuMi0zOS4xLDIuNi01OC4zLDcuOA0KCQkJYy01NS4zLTI0LjMtMTAyLjEtNjAuMy0xMzkuNS0xMTIuNmMtMTEuMywyOC40LTU0LjgsMTI2LjQtMi42LDI2My40YzAsMC0xNi43LDcxLjUsMTQsMTMyLjljMCwwLDQ0LjQtMjAuMSw3OS43LDguMg0KCQkJYzM2LjksMjkuOSwyNS4xLDU4LjcsNTEuMSw4My41YzIyLjQsMjIuOSw1NS43LDIyLjksNTUuNywyMi45czMzLjMsMCw1NS43LTIyLjhjMjYtMjQuNywxNC4zLTUzLjUsNTEuMS04My41DQoJCQljMzUuMi0yOC4zLDc5LjctOC4yLDc5LjctOC4yYzMwLjYtNjEuNCwxNC0xMzIuOSwxNC0xMzIuOUM2NzguMywyOTYuNyw2MzQuOSwxOTguNyw2MjMuNSwxNzAuM3ogTTI1My4xLDQxNC44DQoJCQljLTI4LjQtNTguMy0zNi4yLTEzOC4zLTE4LjMtMjAxLjVjMjMuNyw2MCw1NS45LDg2LjksOTQuMiwxMTUuM0MzMTIuOCwzNjIuMywyODIuMywzOTQuMSwyNTMuMSw0MTQuOHogTTMzNC44LDUxNy41DQoJCQljLTIyLjQtOS45LTI3LjEtMjkuNC0yNy4xLTI5LjRjMzAuNS0xOS4yLDc1LjQtNC41LDc2LjgsNDAuOUMzNjAuOSw1MTQuNywzNTMsNTI1LjQsMzM0LjgsNTE3LjV6IE00MjUuNyw2NzguNw0KCQkJYy0xNiwwLTI5LTExLjUtMjktMjUuNnMxMy0yNS42LDI5LTI1LjZzMjksMTEuNSwyOSwyNS42QzQ1NC43LDY2Ny4zLDQ0MS43LDY3OC43LDQyNS43LDY3OC43eiBNNTE2LjcsNTE3LjUNCgkJCWMtMTguMiw4LTI2LTIuOC00OS43LDExLjVjMS41LTQ1LjQsNDYuMi02MC4xLDc2LjgtNDAuOUM1NDMuOCw0ODgsNTM5LDUwNy42LDUxNi43LDUxNy41eiBNNTk4LjMsNDE0LjgNCgkJCWMtMjkuMS0yMC43LTU5LjctNTIuNC03Ni04Ni4yYzM4LjMtMjguNCw3MC42LTU1LjQsOTQuMi0xMTUuM0M2MzQuNiwyNzYuNSw2MjYuOCwzNTYuNiw1OTguMyw0MTQuOHoiLz4NCgk8L2c+DQo8L2c+DQo8L3N2Zz4NCg==\",\n      readyState: WalletReadyState.NotDetected,\n      isAIP62Standard: true,\n      deeplinkProvider: \"nightly://v1?network=cedra&url=\",\n    },\n\n    {\n      name: \"Zedra\",\n      url: \"https://chromewebstore.google.com/detail/zedra-wallet/pbeefngmcchkcibdodceimammkigfanl\",\n      icon: \"data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyBpZD0iTGF5ZXJfMiIgZGF0YS1uYW1lPSJMYXllciAyIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDgwIDEwODAiPgogIDxkZWZzPgogICAgPHN0eWxlPgogICAgICAuY2xzLTEgewogICAgICAgIGZpbGw6ICNiOGZmZGU7CiAgICAgIH0KICAgIDwvc3R5bGU+CiAgPC9kZWZzPgogIDxnIGlkPSJMYXllcl8xLTIiIGRhdGEtbmFtZT0iTGF5ZXIgMSI+CiAgICA8cmVjdCBjbGFzcz0iY2xzLTEiIHdpZHRoPSIxMDgwIiBoZWlnaHQ9IjEwODAiIHJ4PSIxMjAuNTQiIHJ5PSIxMjAuNTQiLz4KICAgIDxnPgogICAgICA8cGF0aCBkPSJtMzIyLjQ3LDIxOS4xMWgzNTMuNDdjMTMuMzgsMCwyNS42Miw3LjUxLDMxLjY5LDE5LjQzbDExMC43OSwyMTcuNjljNi43NiwxMy4yOCw0LjUyLDI5LjM3LTUuNjEsNDAuM2wtMTE5LjU0LDEyOWMtMTMuNDYsMTQuNTMtMzYuMiwxNS4yNi01MC41NywxLjYybC03Ny41Ni03My42NGMtMTQuNDYtMTMuNzMtMTQuOC0zNi42Ni0uNzctNTAuODJsNDIuOTYtNDMuMzVjMjIuMjgtMjIuNDgsNi4yOS02MC42OS0yNS4zNi02MC41OWwtMjU5LjQuNzljLTE5LjY4LjA2LTM1LjY3LTE1Ljg4LTM1LjY3LTM1LjU2di0xMDkuMzFjMC0xOS42NCwxNS45Mi0zNS41NiwzNS41Ni0zNS41NloiLz4KICAgICAgPHBhdGggZD0ibTc1Ny41Myw4NjAuODloLTM1My40N2MtMTMuMzgsMC0yNS42Mi03LjUxLTMxLjY5LTE5LjQzbC0xMTAuNzktMjE3LjY5Yy02Ljc2LTEzLjI4LTQuNTItMjkuMzcsNS42MS00MC4zbDExOS41NC0xMjljMTMuNDYtMTQuNTMsMzYuMi0xNS4yNiw1MC41Ny0xLjYybDc3LjU2LDczLjY0YzE0LjQ2LDEzLjczLDE0LjgsMzYuNjYuNzcsNTAuODJsLTQyLjk2LDQzLjM1Yy0yMi4yOCwyMi40OC02LjI5LDYwLjY5LDI1LjM2LDYwLjU5bDI1OS40LS43OWMxOS42OC0uMDYsMzUuNjcsMTUuODgsMzUuNjcsMzUuNTZ2MTA5LjMxYzAsMTkuNjQtMTUuOTIsMzUuNTYtMzUuNTYsMzUuNTZaIi8+CiAgICA8L2c+CiAgPC9nPgo8L3N2Zz4=\",\n      readyState: WalletReadyState.NotDetected,\n      isAIP62Standard: true,\n      deeplinkProvider: \"https://zedra.app/\",\n    }\n  ];\n  \n","import {\n  CedraConnectAppleWallet,\n  CedraConnectGoogleWallet,\n} from \"@cedra-labs/wallet-adapter-plugin\";\nimport { Network } from \"@cedra-labs/ts-sdk\";\n// import { DevTWallet, TWallet } from \"@cedra-labs/cedra-wallet-adapter\";\n// import { MSafeWallet } from \"./msafeWallet.ts\";\nimport { DappConfig, AdapterWallet } from \"./WalletCore\";\n\nexport function getSDKWallets(dappConfig?: DappConfig) {\n  const sdkWallets: AdapterWallet[] = [];\n\n  // Need to check window is defined for CedraConnect\n  if (typeof window !== \"undefined\") {\n    sdkWallets.push(\n      new CedraConnectGoogleWallet({\n        network: dappConfig?.network,\n        dappId: dappConfig?.cedraConnectDappId,\n        ...dappConfig?.cedraConnect,\n      }),\n      new CedraConnectAppleWallet({\n        network: dappConfig?.network,\n        dappId: dappConfig?.cedraConnectDappId,\n        ...dappConfig?.cedraConnect,\n      }),\n    );\n  }\n\n  // Push production wallet if env is production, otherwise use dev wallet\n  if (dappConfig?.network === Network.MAINNET) {\n    // TODO twallet uses @cedra-labs/wallet-standard at version 0.0.11 while adapter uses\n    // a newer version (0.1.0) - this causes type mismatch. We should figure out how to handle it.\n    // sdkWallets.push(new TWallet() as any);\n  } else {\n    // sdkWallets.push(new DevTWallet() as any);\n  }\n\n  // if (dappConfig?.network) {\n  //   sdkWallets.push(\n  //     new MSafeWallet({\n  //       ...dappConfig?.msafeWalletConfig,\n  //       network: dappConfig.network,\n  //     })\n  //   );\n  // }\n\n  // Add new SDK wallet plugins (ones that should be installed as packages) here:\n  // Ex. sdkWallets.push(new YourSDKWallet(dappConfig))\n\n  return sdkWallets;\n}\n"]}