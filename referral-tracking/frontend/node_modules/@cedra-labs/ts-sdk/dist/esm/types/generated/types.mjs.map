{"version":3,"sources":["../../../../src/types/generated/types.ts"],"sourcesContent":["export type Maybe<T> = T | null;\nexport type InputMaybe<T> = Maybe<T>;\nexport type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };\nexport type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };\nexport type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };\nexport type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };\nexport type Incremental<T> = T | { [P in keyof T]?: P extends \" $fragmentName\" | \"__typename\" ? T[P] : never };\n/** All built-in and custom scalars, mapped to their actual values */\nexport type Scalars = {\n  ID: { input: string; output: string };\n  String: { input: string; output: string };\n  Boolean: { input: boolean; output: boolean };\n  Int: { input: number; output: number };\n  Float: { input: number; output: number };\n  bigint: { input: any; output: any };\n  bytea: { input: any; output: any };\n  jsonb: { input: any; output: any };\n  numeric: { input: any; output: any };\n  timestamp: { input: any; output: any };\n};\n\n/** Boolean expression to compare columns of type \"Boolean\". All fields are combined with logical 'AND'. */\nexport type BooleanComparisonExp = {\n  _eq?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  _gt?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  _gte?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  _in?: InputMaybe<Array<Scalars[\"Boolean\"][\"input\"]>>;\n  _is_null?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  _lt?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  _lte?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  _neq?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  _nin?: InputMaybe<Array<Scalars[\"Boolean\"][\"input\"]>>;\n};\n\n/** Boolean expression to compare columns of type \"Int\". All fields are combined with logical 'AND'. */\nexport type IntComparisonExp = {\n  _eq?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  _gt?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  _gte?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  _in?: InputMaybe<Array<Scalars[\"Int\"][\"input\"]>>;\n  _is_null?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  _lt?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  _lte?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  _neq?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  _nin?: InputMaybe<Array<Scalars[\"Int\"][\"input\"]>>;\n};\n\n/** Boolean expression to compare columns of type \"String\". All fields are combined with logical 'AND'. */\nexport type StringComparisonExp = {\n  _eq?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  _gt?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  _gte?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  /** does the column match the given case-insensitive pattern */\n  _ilike?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  _in?: InputMaybe<Array<Scalars[\"String\"][\"input\"]>>;\n  /** does the column match the given POSIX regular expression, case insensitive */\n  _iregex?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  _is_null?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  /** does the column match the given pattern */\n  _like?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  _lt?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  _lte?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  _neq?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  /** does the column NOT match the given case-insensitive pattern */\n  _nilike?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  _nin?: InputMaybe<Array<Scalars[\"String\"][\"input\"]>>;\n  /** does the column NOT match the given POSIX regular expression, case insensitive */\n  _niregex?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  /** does the column NOT match the given pattern */\n  _nlike?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  /** does the column NOT match the given POSIX regular expression, case sensitive */\n  _nregex?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  /** does the column NOT match the given SQL regular expression */\n  _nsimilar?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  /** does the column match the given POSIX regular expression, case sensitive */\n  _regex?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  /** does the column match the given SQL regular expression */\n  _similar?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** columns and relationships of \"account_transactions\" */\nexport type AccountTransactions = {\n  account_address: Scalars[\"String\"][\"output\"];\n  /** fetch data from the table: \"delegated_staking_activities\" */\n  delegated_staking_activities: Array<DelegatedStakingActivities>;\n  /** fetch aggregated fields from the table: \"delegated_staking_activities\" */\n  delegated_staking_activities_aggregate: DelegatedStakingActivitiesAggregate;\n  /** fetch data from the table: \"fungible_asset_activities\" */\n  fungible_asset_activities: Array<FungibleAssetActivities>;\n  /** fetch aggregated fields from the table: \"fungible_asset_activities\" */\n  fungible_asset_activities_aggregate: FungibleAssetActivitiesAggregate;\n  inserted_at: Scalars[\"timestamp\"][\"output\"];\n  /** fetch data from the table: \"token_activities_v2\" */\n  token_activities_v2: Array<TokenActivitiesV2>;\n  /** fetch aggregated fields from the table: \"token_activities_v2\" */\n  token_activities_v2_aggregate: TokenActivitiesV2Aggregate;\n  transaction_version: Scalars[\"bigint\"][\"output\"];\n  /** An object relationship */\n  user_transaction?: Maybe<UserTransactions>;\n};\n\n/** columns and relationships of \"account_transactions\" */\nexport type AccountTransactionsDelegatedStakingActivitiesArgs = {\n  distinct_on?: InputMaybe<Array<DelegatedStakingActivitiesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<DelegatedStakingActivitiesOrderBy>>;\n  where?: InputMaybe<DelegatedStakingActivitiesBoolExp>;\n};\n\n/** columns and relationships of \"account_transactions\" */\nexport type AccountTransactionsDelegatedStakingActivitiesAggregateArgs = {\n  distinct_on?: InputMaybe<Array<DelegatedStakingActivitiesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<DelegatedStakingActivitiesOrderBy>>;\n  where?: InputMaybe<DelegatedStakingActivitiesBoolExp>;\n};\n\n/** columns and relationships of \"account_transactions\" */\nexport type AccountTransactionsFungibleAssetActivitiesArgs = {\n  distinct_on?: InputMaybe<Array<FungibleAssetActivitiesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<FungibleAssetActivitiesOrderBy>>;\n  where?: InputMaybe<FungibleAssetActivitiesBoolExp>;\n};\n\n/** columns and relationships of \"account_transactions\" */\nexport type AccountTransactionsFungibleAssetActivitiesAggregateArgs = {\n  distinct_on?: InputMaybe<Array<FungibleAssetActivitiesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<FungibleAssetActivitiesOrderBy>>;\n  where?: InputMaybe<FungibleAssetActivitiesBoolExp>;\n};\n\n/** columns and relationships of \"account_transactions\" */\nexport type AccountTransactionsTokenActivitiesV2Args = {\n  distinct_on?: InputMaybe<Array<TokenActivitiesV2SelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<TokenActivitiesV2OrderBy>>;\n  where?: InputMaybe<TokenActivitiesV2BoolExp>;\n};\n\n/** columns and relationships of \"account_transactions\" */\nexport type AccountTransactionsTokenActivitiesV2AggregateArgs = {\n  distinct_on?: InputMaybe<Array<TokenActivitiesV2SelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<TokenActivitiesV2OrderBy>>;\n  where?: InputMaybe<TokenActivitiesV2BoolExp>;\n};\n\n/** aggregated selection of \"account_transactions\" */\nexport type AccountTransactionsAggregate = {\n  aggregate?: Maybe<AccountTransactionsAggregateFields>;\n  nodes: Array<AccountTransactions>;\n};\n\n/** aggregate fields of \"account_transactions\" */\nexport type AccountTransactionsAggregateFields = {\n  avg?: Maybe<AccountTransactionsAvgFields>;\n  count: Scalars[\"Int\"][\"output\"];\n  max?: Maybe<AccountTransactionsMaxFields>;\n  min?: Maybe<AccountTransactionsMinFields>;\n  stddev?: Maybe<AccountTransactionsStddevFields>;\n  stddev_pop?: Maybe<AccountTransactionsStddevPopFields>;\n  stddev_samp?: Maybe<AccountTransactionsStddevSampFields>;\n  sum?: Maybe<AccountTransactionsSumFields>;\n  var_pop?: Maybe<AccountTransactionsVarPopFields>;\n  var_samp?: Maybe<AccountTransactionsVarSampFields>;\n  variance?: Maybe<AccountTransactionsVarianceFields>;\n};\n\n/** aggregate fields of \"account_transactions\" */\nexport type AccountTransactionsAggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<AccountTransactionsSelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** aggregate avg on columns */\nexport type AccountTransactionsAvgFields = {\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Boolean expression to filter rows from the table \"account_transactions\". All fields are combined with a logical 'AND'. */\nexport type AccountTransactionsBoolExp = {\n  _and?: InputMaybe<Array<AccountTransactionsBoolExp>>;\n  _not?: InputMaybe<AccountTransactionsBoolExp>;\n  _or?: InputMaybe<Array<AccountTransactionsBoolExp>>;\n  account_address?: InputMaybe<StringComparisonExp>;\n  delegated_staking_activities?: InputMaybe<DelegatedStakingActivitiesBoolExp>;\n  delegated_staking_activities_aggregate?: InputMaybe<DelegatedStakingActivitiesAggregateBoolExp>;\n  fungible_asset_activities?: InputMaybe<FungibleAssetActivitiesBoolExp>;\n  fungible_asset_activities_aggregate?: InputMaybe<FungibleAssetActivitiesAggregateBoolExp>;\n  inserted_at?: InputMaybe<TimestampComparisonExp>;\n  token_activities_v2?: InputMaybe<TokenActivitiesV2BoolExp>;\n  token_activities_v2_aggregate?: InputMaybe<TokenActivitiesV2AggregateBoolExp>;\n  transaction_version?: InputMaybe<BigintComparisonExp>;\n  user_transaction?: InputMaybe<UserTransactionsBoolExp>;\n};\n\n/** unique or primary key constraints on table \"account_transactions\" */\nexport enum AccountTransactionsConstraint {\n  /** unique or primary key constraint on columns \"account_address\", \"transaction_version\" */\n  AccountTransactionsPkey = \"account_transactions_pkey\",\n}\n\n/** input type for incrementing numeric columns in table \"account_transactions\" */\nexport type AccountTransactionsIncInput = {\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** input type for inserting data into table \"account_transactions\" */\nexport type AccountTransactionsInsertInput = {\n  account_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  delegated_staking_activities?: InputMaybe<DelegatedStakingActivitiesArrRelInsertInput>;\n  fungible_asset_activities?: InputMaybe<FungibleAssetActivitiesArrRelInsertInput>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  token_activities_v2?: InputMaybe<TokenActivitiesV2ArrRelInsertInput>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  user_transaction?: InputMaybe<UserTransactionsObjRelInsertInput>;\n};\n\n/** aggregate max on columns */\nexport type AccountTransactionsMaxFields = {\n  account_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** aggregate min on columns */\nexport type AccountTransactionsMinFields = {\n  account_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** response of any mutation on the table \"account_transactions\" */\nexport type AccountTransactionsMutationResponse = {\n  /** number of rows affected by the mutation */\n  affected_rows: Scalars[\"Int\"][\"output\"];\n  /** data from the rows affected by the mutation */\n  returning: Array<AccountTransactions>;\n};\n\n/** on_conflict condition type for table \"account_transactions\" */\nexport type AccountTransactionsOnConflict = {\n  constraint: AccountTransactionsConstraint;\n  update_columns?: Array<AccountTransactionsUpdateColumn>;\n  where?: InputMaybe<AccountTransactionsBoolExp>;\n};\n\n/** Ordering options when selecting data from \"account_transactions\". */\nexport type AccountTransactionsOrderBy = {\n  account_address?: InputMaybe<OrderBy>;\n  delegated_staking_activities_aggregate?: InputMaybe<DelegatedStakingActivitiesAggregateOrderBy>;\n  fungible_asset_activities_aggregate?: InputMaybe<FungibleAssetActivitiesAggregateOrderBy>;\n  inserted_at?: InputMaybe<OrderBy>;\n  token_activities_v2_aggregate?: InputMaybe<TokenActivitiesV2AggregateOrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n  user_transaction?: InputMaybe<UserTransactionsOrderBy>;\n};\n\n/** primary key columns input for table: account_transactions */\nexport type AccountTransactionsPkColumnsInput = {\n  account_address: Scalars[\"String\"][\"input\"];\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\n/** select columns of table \"account_transactions\" */\nexport enum AccountTransactionsSelectColumn {\n  /** column name */\n  AccountAddress = \"account_address\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  TransactionVersion = \"transaction_version\",\n}\n\n/** input type for updating data in table \"account_transactions\" */\nexport type AccountTransactionsSetInput = {\n  account_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** aggregate stddev on columns */\nexport type AccountTransactionsStddevFields = {\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_pop on columns */\nexport type AccountTransactionsStddevPopFields = {\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_samp on columns */\nexport type AccountTransactionsStddevSampFields = {\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Streaming cursor of the table \"account_transactions\" */\nexport type AccountTransactionsStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: AccountTransactionsStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type AccountTransactionsStreamCursorValueInput = {\n  account_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** aggregate sum on columns */\nexport type AccountTransactionsSumFields = {\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** update columns of table \"account_transactions\" */\nexport enum AccountTransactionsUpdateColumn {\n  /** column name */\n  AccountAddress = \"account_address\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  TransactionVersion = \"transaction_version\",\n}\n\nexport type AccountTransactionsUpdates = {\n  /** increments the numeric columns with given value of the filtered values */\n  _inc?: InputMaybe<AccountTransactionsIncInput>;\n  /** sets the columns of the filtered rows to the given values */\n  _set?: InputMaybe<AccountTransactionsSetInput>;\n  /** filter the rows which have to be updated */\n  where: AccountTransactionsBoolExp;\n};\n\n/** aggregate var_pop on columns */\nexport type AccountTransactionsVarPopFields = {\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate var_samp on columns */\nexport type AccountTransactionsVarSampFields = {\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate variance on columns */\nexport type AccountTransactionsVarianceFields = {\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** columns and relationships of \"address_events_summary\" */\nexport type AddressEventsSummary = {\n  account_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  /** An object relationship */\n  block_metadata?: Maybe<BlockMetadataTransactions>;\n  min_block_height?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  num_distinct_versions?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** aggregated selection of \"address_events_summary\" */\nexport type AddressEventsSummaryAggregate = {\n  aggregate?: Maybe<AddressEventsSummaryAggregateFields>;\n  nodes: Array<AddressEventsSummary>;\n};\n\n/** aggregate fields of \"address_events_summary\" */\nexport type AddressEventsSummaryAggregateFields = {\n  avg?: Maybe<AddressEventsSummaryAvgFields>;\n  count: Scalars[\"Int\"][\"output\"];\n  max?: Maybe<AddressEventsSummaryMaxFields>;\n  min?: Maybe<AddressEventsSummaryMinFields>;\n  stddev?: Maybe<AddressEventsSummaryStddevFields>;\n  stddev_pop?: Maybe<AddressEventsSummaryStddevPopFields>;\n  stddev_samp?: Maybe<AddressEventsSummaryStddevSampFields>;\n  sum?: Maybe<AddressEventsSummarySumFields>;\n  var_pop?: Maybe<AddressEventsSummaryVarPopFields>;\n  var_samp?: Maybe<AddressEventsSummaryVarSampFields>;\n  variance?: Maybe<AddressEventsSummaryVarianceFields>;\n};\n\n/** aggregate fields of \"address_events_summary\" */\nexport type AddressEventsSummaryAggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<AddressEventsSummarySelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** aggregate avg on columns */\nexport type AddressEventsSummaryAvgFields = {\n  min_block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  num_distinct_versions?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Boolean expression to filter rows from the table \"address_events_summary\". All fields are combined with a logical 'AND'. */\nexport type AddressEventsSummaryBoolExp = {\n  _and?: InputMaybe<Array<AddressEventsSummaryBoolExp>>;\n  _not?: InputMaybe<AddressEventsSummaryBoolExp>;\n  _or?: InputMaybe<Array<AddressEventsSummaryBoolExp>>;\n  account_address?: InputMaybe<StringComparisonExp>;\n  block_metadata?: InputMaybe<BlockMetadataTransactionsBoolExp>;\n  min_block_height?: InputMaybe<BigintComparisonExp>;\n  num_distinct_versions?: InputMaybe<BigintComparisonExp>;\n};\n\n/** aggregate max on columns */\nexport type AddressEventsSummaryMaxFields = {\n  account_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  min_block_height?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  num_distinct_versions?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** aggregate min on columns */\nexport type AddressEventsSummaryMinFields = {\n  account_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  min_block_height?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  num_distinct_versions?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** Ordering options when selecting data from \"address_events_summary\". */\nexport type AddressEventsSummaryOrderBy = {\n  account_address?: InputMaybe<OrderBy>;\n  block_metadata?: InputMaybe<BlockMetadataTransactionsOrderBy>;\n  min_block_height?: InputMaybe<OrderBy>;\n  num_distinct_versions?: InputMaybe<OrderBy>;\n};\n\n/** select columns of table \"address_events_summary\" */\nexport enum AddressEventsSummarySelectColumn {\n  /** column name */\n  AccountAddress = \"account_address\",\n  /** column name */\n  MinBlockHeight = \"min_block_height\",\n  /** column name */\n  NumDistinctVersions = \"num_distinct_versions\",\n}\n\n/** aggregate stddev on columns */\nexport type AddressEventsSummaryStddevFields = {\n  min_block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  num_distinct_versions?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_pop on columns */\nexport type AddressEventsSummaryStddevPopFields = {\n  min_block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  num_distinct_versions?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_samp on columns */\nexport type AddressEventsSummaryStddevSampFields = {\n  min_block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  num_distinct_versions?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Streaming cursor of the table \"address_events_summary\" */\nexport type AddressEventsSummaryStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: AddressEventsSummaryStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type AddressEventsSummaryStreamCursorValueInput = {\n  account_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  min_block_height?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  num_distinct_versions?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** aggregate sum on columns */\nexport type AddressEventsSummarySumFields = {\n  min_block_height?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  num_distinct_versions?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** aggregate var_pop on columns */\nexport type AddressEventsSummaryVarPopFields = {\n  min_block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  num_distinct_versions?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate var_samp on columns */\nexport type AddressEventsSummaryVarSampFields = {\n  min_block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  num_distinct_versions?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate variance on columns */\nexport type AddressEventsSummaryVarianceFields = {\n  min_block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  num_distinct_versions?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** columns and relationships of \"address_version_from_events\" */\nexport type AddressVersionFromEvents = {\n  account_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  /** fetch data from the table: \"delegated_staking_activities\" */\n  delegated_staking_activities: Array<DelegatedStakingActivities>;\n  /** fetch aggregated fields from the table: \"delegated_staking_activities\" */\n  delegated_staking_activities_aggregate: DelegatedStakingActivitiesAggregate;\n  /** fetch data from the table: \"token_activities_v2\" */\n  token_activities_v2: Array<TokenActivitiesV2>;\n  /** fetch aggregated fields from the table: \"token_activities_v2\" */\n  token_activities_v2_aggregate: TokenActivitiesV2Aggregate;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** columns and relationships of \"address_version_from_events\" */\nexport type AddressVersionFromEventsDelegatedStakingActivitiesArgs = {\n  distinct_on?: InputMaybe<Array<DelegatedStakingActivitiesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<DelegatedStakingActivitiesOrderBy>>;\n  where?: InputMaybe<DelegatedStakingActivitiesBoolExp>;\n};\n\n/** columns and relationships of \"address_version_from_events\" */\nexport type AddressVersionFromEventsDelegatedStakingActivitiesAggregateArgs = {\n  distinct_on?: InputMaybe<Array<DelegatedStakingActivitiesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<DelegatedStakingActivitiesOrderBy>>;\n  where?: InputMaybe<DelegatedStakingActivitiesBoolExp>;\n};\n\n/** columns and relationships of \"address_version_from_events\" */\nexport type AddressVersionFromEventsTokenActivitiesV2Args = {\n  distinct_on?: InputMaybe<Array<TokenActivitiesV2SelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<TokenActivitiesV2OrderBy>>;\n  where?: InputMaybe<TokenActivitiesV2BoolExp>;\n};\n\n/** columns and relationships of \"address_version_from_events\" */\nexport type AddressVersionFromEventsTokenActivitiesV2AggregateArgs = {\n  distinct_on?: InputMaybe<Array<TokenActivitiesV2SelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<TokenActivitiesV2OrderBy>>;\n  where?: InputMaybe<TokenActivitiesV2BoolExp>;\n};\n\n/** aggregated selection of \"address_version_from_events\" */\nexport type AddressVersionFromEventsAggregate = {\n  aggregate?: Maybe<AddressVersionFromEventsAggregateFields>;\n  nodes: Array<AddressVersionFromEvents>;\n};\n\n/** aggregate fields of \"address_version_from_events\" */\nexport type AddressVersionFromEventsAggregateFields = {\n  avg?: Maybe<AddressVersionFromEventsAvgFields>;\n  count: Scalars[\"Int\"][\"output\"];\n  max?: Maybe<AddressVersionFromEventsMaxFields>;\n  min?: Maybe<AddressVersionFromEventsMinFields>;\n  stddev?: Maybe<AddressVersionFromEventsStddevFields>;\n  stddev_pop?: Maybe<AddressVersionFromEventsStddevPopFields>;\n  stddev_samp?: Maybe<AddressVersionFromEventsStddevSampFields>;\n  sum?: Maybe<AddressVersionFromEventsSumFields>;\n  var_pop?: Maybe<AddressVersionFromEventsVarPopFields>;\n  var_samp?: Maybe<AddressVersionFromEventsVarSampFields>;\n  variance?: Maybe<AddressVersionFromEventsVarianceFields>;\n};\n\n/** aggregate fields of \"address_version_from_events\" */\nexport type AddressVersionFromEventsAggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<AddressVersionFromEventsSelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** aggregate avg on columns */\nexport type AddressVersionFromEventsAvgFields = {\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Boolean expression to filter rows from the table \"address_version_from_events\". All fields are combined with a logical 'AND'. */\nexport type AddressVersionFromEventsBoolExp = {\n  _and?: InputMaybe<Array<AddressVersionFromEventsBoolExp>>;\n  _not?: InputMaybe<AddressVersionFromEventsBoolExp>;\n  _or?: InputMaybe<Array<AddressVersionFromEventsBoolExp>>;\n  account_address?: InputMaybe<StringComparisonExp>;\n  delegated_staking_activities?: InputMaybe<DelegatedStakingActivitiesBoolExp>;\n  delegated_staking_activities_aggregate?: InputMaybe<DelegatedStakingActivitiesAggregateBoolExp>;\n  token_activities_v2?: InputMaybe<TokenActivitiesV2BoolExp>;\n  token_activities_v2_aggregate?: InputMaybe<TokenActivitiesV2AggregateBoolExp>;\n  transaction_version?: InputMaybe<BigintComparisonExp>;\n};\n\n/** aggregate max on columns */\nexport type AddressVersionFromEventsMaxFields = {\n  account_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** aggregate min on columns */\nexport type AddressVersionFromEventsMinFields = {\n  account_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** Ordering options when selecting data from \"address_version_from_events\". */\nexport type AddressVersionFromEventsOrderBy = {\n  account_address?: InputMaybe<OrderBy>;\n  delegated_staking_activities_aggregate?: InputMaybe<DelegatedStakingActivitiesAggregateOrderBy>;\n  token_activities_v2_aggregate?: InputMaybe<TokenActivitiesV2AggregateOrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n};\n\n/** select columns of table \"address_version_from_events\" */\nexport enum AddressVersionFromEventsSelectColumn {\n  /** column name */\n  AccountAddress = \"account_address\",\n  /** column name */\n  TransactionVersion = \"transaction_version\",\n}\n\n/** aggregate stddev on columns */\nexport type AddressVersionFromEventsStddevFields = {\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_pop on columns */\nexport type AddressVersionFromEventsStddevPopFields = {\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_samp on columns */\nexport type AddressVersionFromEventsStddevSampFields = {\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Streaming cursor of the table \"address_version_from_events\" */\nexport type AddressVersionFromEventsStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: AddressVersionFromEventsStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type AddressVersionFromEventsStreamCursorValueInput = {\n  account_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** aggregate sum on columns */\nexport type AddressVersionFromEventsSumFields = {\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** aggregate var_pop on columns */\nexport type AddressVersionFromEventsVarPopFields = {\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate var_samp on columns */\nexport type AddressVersionFromEventsVarSampFields = {\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate variance on columns */\nexport type AddressVersionFromEventsVarianceFields = {\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** columns and relationships of \"address_version_from_move_resources\" */\nexport type AddressVersionFromMoveResources = {\n  address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** aggregated selection of \"address_version_from_move_resources\" */\nexport type AddressVersionFromMoveResourcesAggregate = {\n  aggregate?: Maybe<AddressVersionFromMoveResourcesAggregateFields>;\n  nodes: Array<AddressVersionFromMoveResources>;\n};\n\n/** aggregate fields of \"address_version_from_move_resources\" */\nexport type AddressVersionFromMoveResourcesAggregateFields = {\n  avg?: Maybe<AddressVersionFromMoveResourcesAvgFields>;\n  count: Scalars[\"Int\"][\"output\"];\n  max?: Maybe<AddressVersionFromMoveResourcesMaxFields>;\n  min?: Maybe<AddressVersionFromMoveResourcesMinFields>;\n  stddev?: Maybe<AddressVersionFromMoveResourcesStddevFields>;\n  stddev_pop?: Maybe<AddressVersionFromMoveResourcesStddevPopFields>;\n  stddev_samp?: Maybe<AddressVersionFromMoveResourcesStddevSampFields>;\n  sum?: Maybe<AddressVersionFromMoveResourcesSumFields>;\n  var_pop?: Maybe<AddressVersionFromMoveResourcesVarPopFields>;\n  var_samp?: Maybe<AddressVersionFromMoveResourcesVarSampFields>;\n  variance?: Maybe<AddressVersionFromMoveResourcesVarianceFields>;\n};\n\n/** aggregate fields of \"address_version_from_move_resources\" */\nexport type AddressVersionFromMoveResourcesAggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<AddressVersionFromMoveResourcesSelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** aggregate avg on columns */\nexport type AddressVersionFromMoveResourcesAvgFields = {\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Boolean expression to filter rows from the table \"address_version_from_move_resources\". All fields are combined with a logical 'AND'. */\nexport type AddressVersionFromMoveResourcesBoolExp = {\n  _and?: InputMaybe<Array<AddressVersionFromMoveResourcesBoolExp>>;\n  _not?: InputMaybe<AddressVersionFromMoveResourcesBoolExp>;\n  _or?: InputMaybe<Array<AddressVersionFromMoveResourcesBoolExp>>;\n  address?: InputMaybe<StringComparisonExp>;\n  transaction_version?: InputMaybe<BigintComparisonExp>;\n};\n\n/** aggregate max on columns */\nexport type AddressVersionFromMoveResourcesMaxFields = {\n  address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** aggregate min on columns */\nexport type AddressVersionFromMoveResourcesMinFields = {\n  address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** Ordering options when selecting data from \"address_version_from_move_resources\". */\nexport type AddressVersionFromMoveResourcesOrderBy = {\n  address?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n};\n\n/** select columns of table \"address_version_from_move_resources\" */\nexport enum AddressVersionFromMoveResourcesSelectColumn {\n  /** column name */\n  Address = \"address\",\n  /** column name */\n  TransactionVersion = \"transaction_version\",\n}\n\n/** aggregate stddev on columns */\nexport type AddressVersionFromMoveResourcesStddevFields = {\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_pop on columns */\nexport type AddressVersionFromMoveResourcesStddevPopFields = {\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_samp on columns */\nexport type AddressVersionFromMoveResourcesStddevSampFields = {\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Streaming cursor of the table \"address_version_from_move_resources\" */\nexport type AddressVersionFromMoveResourcesStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: AddressVersionFromMoveResourcesStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type AddressVersionFromMoveResourcesStreamCursorValueInput = {\n  address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** aggregate sum on columns */\nexport type AddressVersionFromMoveResourcesSumFields = {\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** aggregate var_pop on columns */\nexport type AddressVersionFromMoveResourcesVarPopFields = {\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate var_samp on columns */\nexport type AddressVersionFromMoveResourcesVarSampFields = {\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate variance on columns */\nexport type AddressVersionFromMoveResourcesVarianceFields = {\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** columns and relationships of \"ans_lookup\" */\nexport type AnsLookup = {\n  domain: Scalars[\"String\"][\"output\"];\n  expiration_timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  inserted_at: Scalars[\"timestamp\"][\"output\"];\n  is_deleted: Scalars[\"Boolean\"][\"output\"];\n  registered_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  subdomain: Scalars[\"String\"][\"output\"];\n  token_name: Scalars[\"String\"][\"output\"];\n  transaction_version: Scalars[\"bigint\"][\"output\"];\n  write_set_change_index: Scalars[\"bigint\"][\"output\"];\n};\n\n/** aggregated selection of \"ans_lookup\" */\nexport type AnsLookupAggregate = {\n  aggregate?: Maybe<AnsLookupAggregateFields>;\n  nodes: Array<AnsLookup>;\n};\n\n/** aggregate fields of \"ans_lookup\" */\nexport type AnsLookupAggregateFields = {\n  avg?: Maybe<AnsLookupAvgFields>;\n  count: Scalars[\"Int\"][\"output\"];\n  max?: Maybe<AnsLookupMaxFields>;\n  min?: Maybe<AnsLookupMinFields>;\n  stddev?: Maybe<AnsLookupStddevFields>;\n  stddev_pop?: Maybe<AnsLookupStddevPopFields>;\n  stddev_samp?: Maybe<AnsLookupStddevSampFields>;\n  sum?: Maybe<AnsLookupSumFields>;\n  var_pop?: Maybe<AnsLookupVarPopFields>;\n  var_samp?: Maybe<AnsLookupVarSampFields>;\n  variance?: Maybe<AnsLookupVarianceFields>;\n};\n\n/** aggregate fields of \"ans_lookup\" */\nexport type AnsLookupAggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<AnsLookupSelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** aggregate avg on columns */\nexport type AnsLookupAvgFields = {\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Boolean expression to filter rows from the table \"ans_lookup\". All fields are combined with a logical 'AND'. */\nexport type AnsLookupBoolExp = {\n  _and?: InputMaybe<Array<AnsLookupBoolExp>>;\n  _not?: InputMaybe<AnsLookupBoolExp>;\n  _or?: InputMaybe<Array<AnsLookupBoolExp>>;\n  domain?: InputMaybe<StringComparisonExp>;\n  expiration_timestamp?: InputMaybe<TimestampComparisonExp>;\n  inserted_at?: InputMaybe<TimestampComparisonExp>;\n  is_deleted?: InputMaybe<BooleanComparisonExp>;\n  registered_address?: InputMaybe<StringComparisonExp>;\n  subdomain?: InputMaybe<StringComparisonExp>;\n  token_name?: InputMaybe<StringComparisonExp>;\n  transaction_version?: InputMaybe<BigintComparisonExp>;\n  write_set_change_index?: InputMaybe<BigintComparisonExp>;\n};\n\n/** unique or primary key constraints on table \"ans_lookup\" */\nexport enum AnsLookupConstraint {\n  /** unique or primary key constraint on columns \"write_set_change_index\", \"transaction_version\" */\n  AnsLookupPkey = \"ans_lookup_pkey\",\n}\n\n/** input type for incrementing numeric columns in table \"ans_lookup\" */\nexport type AnsLookupIncInput = {\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  write_set_change_index?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** input type for inserting data into table \"ans_lookup\" */\nexport type AnsLookupInsertInput = {\n  domain?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  expiration_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  is_deleted?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  registered_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  subdomain?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  write_set_change_index?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** aggregate max on columns */\nexport type AnsLookupMaxFields = {\n  domain?: Maybe<Scalars[\"String\"][\"output\"]>;\n  expiration_timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  registered_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  subdomain?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_name?: Maybe<Scalars[\"String\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** aggregate min on columns */\nexport type AnsLookupMinFields = {\n  domain?: Maybe<Scalars[\"String\"][\"output\"]>;\n  expiration_timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  registered_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  subdomain?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_name?: Maybe<Scalars[\"String\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** response of any mutation on the table \"ans_lookup\" */\nexport type AnsLookupMutationResponse = {\n  /** number of rows affected by the mutation */\n  affected_rows: Scalars[\"Int\"][\"output\"];\n  /** data from the rows affected by the mutation */\n  returning: Array<AnsLookup>;\n};\n\n/** on_conflict condition type for table \"ans_lookup\" */\nexport type AnsLookupOnConflict = {\n  constraint: AnsLookupConstraint;\n  update_columns?: Array<AnsLookupUpdateColumn>;\n  where?: InputMaybe<AnsLookupBoolExp>;\n};\n\n/** Ordering options when selecting data from \"ans_lookup\". */\nexport type AnsLookupOrderBy = {\n  domain?: InputMaybe<OrderBy>;\n  expiration_timestamp?: InputMaybe<OrderBy>;\n  inserted_at?: InputMaybe<OrderBy>;\n  is_deleted?: InputMaybe<OrderBy>;\n  registered_address?: InputMaybe<OrderBy>;\n  subdomain?: InputMaybe<OrderBy>;\n  token_name?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n  write_set_change_index?: InputMaybe<OrderBy>;\n};\n\n/** primary key columns input for table: ans_lookup */\nexport type AnsLookupPkColumnsInput = {\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n  write_set_change_index: Scalars[\"bigint\"][\"input\"];\n};\n\n/** select columns of table \"ans_lookup\" */\nexport enum AnsLookupSelectColumn {\n  /** column name */\n  Domain = \"domain\",\n  /** column name */\n  ExpirationTimestamp = \"expiration_timestamp\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  IsDeleted = \"is_deleted\",\n  /** column name */\n  RegisteredAddress = \"registered_address\",\n  /** column name */\n  Subdomain = \"subdomain\",\n  /** column name */\n  TokenName = \"token_name\",\n  /** column name */\n  TransactionVersion = \"transaction_version\",\n  /** column name */\n  WriteSetChangeIndex = \"write_set_change_index\",\n}\n\n/** input type for updating data in table \"ans_lookup\" */\nexport type AnsLookupSetInput = {\n  domain?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  expiration_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  is_deleted?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  registered_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  subdomain?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  write_set_change_index?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** aggregate stddev on columns */\nexport type AnsLookupStddevFields = {\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_pop on columns */\nexport type AnsLookupStddevPopFields = {\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_samp on columns */\nexport type AnsLookupStddevSampFields = {\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Streaming cursor of the table \"ans_lookup\" */\nexport type AnsLookupStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: AnsLookupStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type AnsLookupStreamCursorValueInput = {\n  domain?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  expiration_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  is_deleted?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  registered_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  subdomain?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  write_set_change_index?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** aggregate sum on columns */\nexport type AnsLookupSumFields = {\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** update columns of table \"ans_lookup\" */\nexport enum AnsLookupUpdateColumn {\n  /** column name */\n  Domain = \"domain\",\n  /** column name */\n  ExpirationTimestamp = \"expiration_timestamp\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  IsDeleted = \"is_deleted\",\n  /** column name */\n  RegisteredAddress = \"registered_address\",\n  /** column name */\n  Subdomain = \"subdomain\",\n  /** column name */\n  TokenName = \"token_name\",\n  /** column name */\n  TransactionVersion = \"transaction_version\",\n  /** column name */\n  WriteSetChangeIndex = \"write_set_change_index\",\n}\n\nexport type AnsLookupUpdates = {\n  /** increments the numeric columns with given value of the filtered values */\n  _inc?: InputMaybe<AnsLookupIncInput>;\n  /** sets the columns of the filtered rows to the given values */\n  _set?: InputMaybe<AnsLookupSetInput>;\n  /** filter the rows which have to be updated */\n  where: AnsLookupBoolExp;\n};\n\n/** columns and relationships of \"ans_lookup_v2\" */\nexport type AnsLookupV2 = {\n  domain: Scalars[\"String\"][\"output\"];\n  expiration_timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  inserted_at: Scalars[\"timestamp\"][\"output\"];\n  is_deleted: Scalars[\"Boolean\"][\"output\"];\n  registered_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  subdomain: Scalars[\"String\"][\"output\"];\n  subdomain_expiration_policy?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  token_name: Scalars[\"String\"][\"output\"];\n  token_standard: Scalars[\"String\"][\"output\"];\n  transaction_version: Scalars[\"bigint\"][\"output\"];\n  write_set_change_index: Scalars[\"bigint\"][\"output\"];\n};\n\n/** aggregated selection of \"ans_lookup_v2\" */\nexport type AnsLookupV2Aggregate = {\n  aggregate?: Maybe<AnsLookupV2AggregateFields>;\n  nodes: Array<AnsLookupV2>;\n};\n\n/** aggregate fields of \"ans_lookup_v2\" */\nexport type AnsLookupV2AggregateFields = {\n  avg?: Maybe<AnsLookupV2AvgFields>;\n  count: Scalars[\"Int\"][\"output\"];\n  max?: Maybe<AnsLookupV2MaxFields>;\n  min?: Maybe<AnsLookupV2MinFields>;\n  stddev?: Maybe<AnsLookupV2StddevFields>;\n  stddev_pop?: Maybe<AnsLookupV2StddevPopFields>;\n  stddev_samp?: Maybe<AnsLookupV2StddevSampFields>;\n  sum?: Maybe<AnsLookupV2SumFields>;\n  var_pop?: Maybe<AnsLookupV2VarPopFields>;\n  var_samp?: Maybe<AnsLookupV2VarSampFields>;\n  variance?: Maybe<AnsLookupV2VarianceFields>;\n};\n\n/** aggregate fields of \"ans_lookup_v2\" */\nexport type AnsLookupV2AggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<AnsLookupV2SelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** aggregate avg on columns */\nexport type AnsLookupV2AvgFields = {\n  subdomain_expiration_policy?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Boolean expression to filter rows from the table \"ans_lookup_v2\". All fields are combined with a logical 'AND'. */\nexport type AnsLookupV2BoolExp = {\n  _and?: InputMaybe<Array<AnsLookupV2BoolExp>>;\n  _not?: InputMaybe<AnsLookupV2BoolExp>;\n  _or?: InputMaybe<Array<AnsLookupV2BoolExp>>;\n  domain?: InputMaybe<StringComparisonExp>;\n  expiration_timestamp?: InputMaybe<TimestampComparisonExp>;\n  inserted_at?: InputMaybe<TimestampComparisonExp>;\n  is_deleted?: InputMaybe<BooleanComparisonExp>;\n  registered_address?: InputMaybe<StringComparisonExp>;\n  subdomain?: InputMaybe<StringComparisonExp>;\n  subdomain_expiration_policy?: InputMaybe<BigintComparisonExp>;\n  token_name?: InputMaybe<StringComparisonExp>;\n  token_standard?: InputMaybe<StringComparisonExp>;\n  transaction_version?: InputMaybe<BigintComparisonExp>;\n  write_set_change_index?: InputMaybe<BigintComparisonExp>;\n};\n\n/** unique or primary key constraints on table \"ans_lookup_v2\" */\nexport enum AnsLookupV2Constraint {\n  /** unique or primary key constraint on columns \"write_set_change_index\", \"transaction_version\" */\n  AnsLookupV2Pkey = \"ans_lookup_v2_pkey\",\n}\n\n/** input type for incrementing numeric columns in table \"ans_lookup_v2\" */\nexport type AnsLookupV2IncInput = {\n  subdomain_expiration_policy?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  write_set_change_index?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** input type for inserting data into table \"ans_lookup_v2\" */\nexport type AnsLookupV2InsertInput = {\n  domain?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  expiration_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  is_deleted?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  registered_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  subdomain?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  subdomain_expiration_policy?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  token_name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_standard?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  write_set_change_index?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** aggregate max on columns */\nexport type AnsLookupV2MaxFields = {\n  domain?: Maybe<Scalars[\"String\"][\"output\"]>;\n  expiration_timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  registered_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  subdomain?: Maybe<Scalars[\"String\"][\"output\"]>;\n  subdomain_expiration_policy?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  token_name?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_standard?: Maybe<Scalars[\"String\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** aggregate min on columns */\nexport type AnsLookupV2MinFields = {\n  domain?: Maybe<Scalars[\"String\"][\"output\"]>;\n  expiration_timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  registered_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  subdomain?: Maybe<Scalars[\"String\"][\"output\"]>;\n  subdomain_expiration_policy?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  token_name?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_standard?: Maybe<Scalars[\"String\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** response of any mutation on the table \"ans_lookup_v2\" */\nexport type AnsLookupV2MutationResponse = {\n  /** number of rows affected by the mutation */\n  affected_rows: Scalars[\"Int\"][\"output\"];\n  /** data from the rows affected by the mutation */\n  returning: Array<AnsLookupV2>;\n};\n\n/** on_conflict condition type for table \"ans_lookup_v2\" */\nexport type AnsLookupV2OnConflict = {\n  constraint: AnsLookupV2Constraint;\n  update_columns?: Array<AnsLookupV2UpdateColumn>;\n  where?: InputMaybe<AnsLookupV2BoolExp>;\n};\n\n/** Ordering options when selecting data from \"ans_lookup_v2\". */\nexport type AnsLookupV2OrderBy = {\n  domain?: InputMaybe<OrderBy>;\n  expiration_timestamp?: InputMaybe<OrderBy>;\n  inserted_at?: InputMaybe<OrderBy>;\n  is_deleted?: InputMaybe<OrderBy>;\n  registered_address?: InputMaybe<OrderBy>;\n  subdomain?: InputMaybe<OrderBy>;\n  subdomain_expiration_policy?: InputMaybe<OrderBy>;\n  token_name?: InputMaybe<OrderBy>;\n  token_standard?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n  write_set_change_index?: InputMaybe<OrderBy>;\n};\n\n/** primary key columns input for table: ans_lookup_v2 */\nexport type AnsLookupV2PkColumnsInput = {\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n  write_set_change_index: Scalars[\"bigint\"][\"input\"];\n};\n\n/** select columns of table \"ans_lookup_v2\" */\nexport enum AnsLookupV2SelectColumn {\n  /** column name */\n  Domain = \"domain\",\n  /** column name */\n  ExpirationTimestamp = \"expiration_timestamp\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  IsDeleted = \"is_deleted\",\n  /** column name */\n  RegisteredAddress = \"registered_address\",\n  /** column name */\n  Subdomain = \"subdomain\",\n  /** column name */\n  SubdomainExpirationPolicy = \"subdomain_expiration_policy\",\n  /** column name */\n  TokenName = \"token_name\",\n  /** column name */\n  TokenStandard = \"token_standard\",\n  /** column name */\n  TransactionVersion = \"transaction_version\",\n  /** column name */\n  WriteSetChangeIndex = \"write_set_change_index\",\n}\n\n/** input type for updating data in table \"ans_lookup_v2\" */\nexport type AnsLookupV2SetInput = {\n  domain?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  expiration_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  is_deleted?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  registered_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  subdomain?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  subdomain_expiration_policy?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  token_name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_standard?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  write_set_change_index?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** aggregate stddev on columns */\nexport type AnsLookupV2StddevFields = {\n  subdomain_expiration_policy?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_pop on columns */\nexport type AnsLookupV2StddevPopFields = {\n  subdomain_expiration_policy?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_samp on columns */\nexport type AnsLookupV2StddevSampFields = {\n  subdomain_expiration_policy?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Streaming cursor of the table \"ans_lookup_v2\" */\nexport type AnsLookupV2StreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: AnsLookupV2StreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type AnsLookupV2StreamCursorValueInput = {\n  domain?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  expiration_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  is_deleted?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  registered_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  subdomain?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  subdomain_expiration_policy?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  token_name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_standard?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  write_set_change_index?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** aggregate sum on columns */\nexport type AnsLookupV2SumFields = {\n  subdomain_expiration_policy?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** update columns of table \"ans_lookup_v2\" */\nexport enum AnsLookupV2UpdateColumn {\n  /** column name */\n  Domain = \"domain\",\n  /** column name */\n  ExpirationTimestamp = \"expiration_timestamp\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  IsDeleted = \"is_deleted\",\n  /** column name */\n  RegisteredAddress = \"registered_address\",\n  /** column name */\n  Subdomain = \"subdomain\",\n  /** column name */\n  SubdomainExpirationPolicy = \"subdomain_expiration_policy\",\n  /** column name */\n  TokenName = \"token_name\",\n  /** column name */\n  TokenStandard = \"token_standard\",\n  /** column name */\n  TransactionVersion = \"transaction_version\",\n  /** column name */\n  WriteSetChangeIndex = \"write_set_change_index\",\n}\n\nexport type AnsLookupV2Updates = {\n  /** increments the numeric columns with given value of the filtered values */\n  _inc?: InputMaybe<AnsLookupV2IncInput>;\n  /** sets the columns of the filtered rows to the given values */\n  _set?: InputMaybe<AnsLookupV2SetInput>;\n  /** filter the rows which have to be updated */\n  where: AnsLookupV2BoolExp;\n};\n\n/** aggregate var_pop on columns */\nexport type AnsLookupV2VarPopFields = {\n  subdomain_expiration_policy?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate var_samp on columns */\nexport type AnsLookupV2VarSampFields = {\n  subdomain_expiration_policy?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate variance on columns */\nexport type AnsLookupV2VarianceFields = {\n  subdomain_expiration_policy?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate var_pop on columns */\nexport type AnsLookupVarPopFields = {\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate var_samp on columns */\nexport type AnsLookupVarSampFields = {\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate variance on columns */\nexport type AnsLookupVarianceFields = {\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** columns and relationships of \"ans_primary_name\" */\nexport type AnsPrimaryName = {\n  domain?: Maybe<Scalars[\"String\"][\"output\"]>;\n  inserted_at: Scalars[\"timestamp\"][\"output\"];\n  is_deleted: Scalars[\"Boolean\"][\"output\"];\n  registered_address: Scalars[\"String\"][\"output\"];\n  subdomain?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_name?: Maybe<Scalars[\"String\"][\"output\"]>;\n  transaction_version: Scalars[\"bigint\"][\"output\"];\n  write_set_change_index: Scalars[\"bigint\"][\"output\"];\n};\n\n/** aggregated selection of \"ans_primary_name\" */\nexport type AnsPrimaryNameAggregate = {\n  aggregate?: Maybe<AnsPrimaryNameAggregateFields>;\n  nodes: Array<AnsPrimaryName>;\n};\n\n/** aggregate fields of \"ans_primary_name\" */\nexport type AnsPrimaryNameAggregateFields = {\n  avg?: Maybe<AnsPrimaryNameAvgFields>;\n  count: Scalars[\"Int\"][\"output\"];\n  max?: Maybe<AnsPrimaryNameMaxFields>;\n  min?: Maybe<AnsPrimaryNameMinFields>;\n  stddev?: Maybe<AnsPrimaryNameStddevFields>;\n  stddev_pop?: Maybe<AnsPrimaryNameStddevPopFields>;\n  stddev_samp?: Maybe<AnsPrimaryNameStddevSampFields>;\n  sum?: Maybe<AnsPrimaryNameSumFields>;\n  var_pop?: Maybe<AnsPrimaryNameVarPopFields>;\n  var_samp?: Maybe<AnsPrimaryNameVarSampFields>;\n  variance?: Maybe<AnsPrimaryNameVarianceFields>;\n};\n\n/** aggregate fields of \"ans_primary_name\" */\nexport type AnsPrimaryNameAggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<AnsPrimaryNameSelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** aggregate avg on columns */\nexport type AnsPrimaryNameAvgFields = {\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Boolean expression to filter rows from the table \"ans_primary_name\". All fields are combined with a logical 'AND'. */\nexport type AnsPrimaryNameBoolExp = {\n  _and?: InputMaybe<Array<AnsPrimaryNameBoolExp>>;\n  _not?: InputMaybe<AnsPrimaryNameBoolExp>;\n  _or?: InputMaybe<Array<AnsPrimaryNameBoolExp>>;\n  domain?: InputMaybe<StringComparisonExp>;\n  inserted_at?: InputMaybe<TimestampComparisonExp>;\n  is_deleted?: InputMaybe<BooleanComparisonExp>;\n  registered_address?: InputMaybe<StringComparisonExp>;\n  subdomain?: InputMaybe<StringComparisonExp>;\n  token_name?: InputMaybe<StringComparisonExp>;\n  transaction_version?: InputMaybe<BigintComparisonExp>;\n  write_set_change_index?: InputMaybe<BigintComparisonExp>;\n};\n\n/** unique or primary key constraints on table \"ans_primary_name\" */\nexport enum AnsPrimaryNameConstraint {\n  /** unique or primary key constraint on columns \"write_set_change_index\", \"transaction_version\" */\n  AnsPrimaryNamePkey = \"ans_primary_name_pkey\",\n}\n\n/** input type for incrementing numeric columns in table \"ans_primary_name\" */\nexport type AnsPrimaryNameIncInput = {\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  write_set_change_index?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** input type for inserting data into table \"ans_primary_name\" */\nexport type AnsPrimaryNameInsertInput = {\n  domain?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  is_deleted?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  registered_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  subdomain?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  write_set_change_index?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** aggregate max on columns */\nexport type AnsPrimaryNameMaxFields = {\n  domain?: Maybe<Scalars[\"String\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  registered_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  subdomain?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_name?: Maybe<Scalars[\"String\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** aggregate min on columns */\nexport type AnsPrimaryNameMinFields = {\n  domain?: Maybe<Scalars[\"String\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  registered_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  subdomain?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_name?: Maybe<Scalars[\"String\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** response of any mutation on the table \"ans_primary_name\" */\nexport type AnsPrimaryNameMutationResponse = {\n  /** number of rows affected by the mutation */\n  affected_rows: Scalars[\"Int\"][\"output\"];\n  /** data from the rows affected by the mutation */\n  returning: Array<AnsPrimaryName>;\n};\n\n/** on_conflict condition type for table \"ans_primary_name\" */\nexport type AnsPrimaryNameOnConflict = {\n  constraint: AnsPrimaryNameConstraint;\n  update_columns?: Array<AnsPrimaryNameUpdateColumn>;\n  where?: InputMaybe<AnsPrimaryNameBoolExp>;\n};\n\n/** Ordering options when selecting data from \"ans_primary_name\". */\nexport type AnsPrimaryNameOrderBy = {\n  domain?: InputMaybe<OrderBy>;\n  inserted_at?: InputMaybe<OrderBy>;\n  is_deleted?: InputMaybe<OrderBy>;\n  registered_address?: InputMaybe<OrderBy>;\n  subdomain?: InputMaybe<OrderBy>;\n  token_name?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n  write_set_change_index?: InputMaybe<OrderBy>;\n};\n\n/** primary key columns input for table: ans_primary_name */\nexport type AnsPrimaryNamePkColumnsInput = {\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n  write_set_change_index: Scalars[\"bigint\"][\"input\"];\n};\n\n/** select columns of table \"ans_primary_name\" */\nexport enum AnsPrimaryNameSelectColumn {\n  /** column name */\n  Domain = \"domain\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  IsDeleted = \"is_deleted\",\n  /** column name */\n  RegisteredAddress = \"registered_address\",\n  /** column name */\n  Subdomain = \"subdomain\",\n  /** column name */\n  TokenName = \"token_name\",\n  /** column name */\n  TransactionVersion = \"transaction_version\",\n  /** column name */\n  WriteSetChangeIndex = \"write_set_change_index\",\n}\n\n/** input type for updating data in table \"ans_primary_name\" */\nexport type AnsPrimaryNameSetInput = {\n  domain?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  is_deleted?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  registered_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  subdomain?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  write_set_change_index?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** aggregate stddev on columns */\nexport type AnsPrimaryNameStddevFields = {\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_pop on columns */\nexport type AnsPrimaryNameStddevPopFields = {\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_samp on columns */\nexport type AnsPrimaryNameStddevSampFields = {\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Streaming cursor of the table \"ans_primary_name\" */\nexport type AnsPrimaryNameStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: AnsPrimaryNameStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type AnsPrimaryNameStreamCursorValueInput = {\n  domain?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  is_deleted?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  registered_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  subdomain?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  write_set_change_index?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** aggregate sum on columns */\nexport type AnsPrimaryNameSumFields = {\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** update columns of table \"ans_primary_name\" */\nexport enum AnsPrimaryNameUpdateColumn {\n  /** column name */\n  Domain = \"domain\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  IsDeleted = \"is_deleted\",\n  /** column name */\n  RegisteredAddress = \"registered_address\",\n  /** column name */\n  Subdomain = \"subdomain\",\n  /** column name */\n  TokenName = \"token_name\",\n  /** column name */\n  TransactionVersion = \"transaction_version\",\n  /** column name */\n  WriteSetChangeIndex = \"write_set_change_index\",\n}\n\nexport type AnsPrimaryNameUpdates = {\n  /** increments the numeric columns with given value of the filtered values */\n  _inc?: InputMaybe<AnsPrimaryNameIncInput>;\n  /** sets the columns of the filtered rows to the given values */\n  _set?: InputMaybe<AnsPrimaryNameSetInput>;\n  /** filter the rows which have to be updated */\n  where: AnsPrimaryNameBoolExp;\n};\n\n/** columns and relationships of \"ans_primary_name_v2\" */\nexport type AnsPrimaryNameV2 = {\n  domain?: Maybe<Scalars[\"String\"][\"output\"]>;\n  inserted_at: Scalars[\"timestamp\"][\"output\"];\n  is_deleted: Scalars[\"Boolean\"][\"output\"];\n  registered_address: Scalars[\"String\"][\"output\"];\n  subdomain?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_name?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_standard: Scalars[\"String\"][\"output\"];\n  transaction_version: Scalars[\"bigint\"][\"output\"];\n  write_set_change_index: Scalars[\"bigint\"][\"output\"];\n};\n\n/** aggregated selection of \"ans_primary_name_v2\" */\nexport type AnsPrimaryNameV2Aggregate = {\n  aggregate?: Maybe<AnsPrimaryNameV2AggregateFields>;\n  nodes: Array<AnsPrimaryNameV2>;\n};\n\n/** aggregate fields of \"ans_primary_name_v2\" */\nexport type AnsPrimaryNameV2AggregateFields = {\n  avg?: Maybe<AnsPrimaryNameV2AvgFields>;\n  count: Scalars[\"Int\"][\"output\"];\n  max?: Maybe<AnsPrimaryNameV2MaxFields>;\n  min?: Maybe<AnsPrimaryNameV2MinFields>;\n  stddev?: Maybe<AnsPrimaryNameV2StddevFields>;\n  stddev_pop?: Maybe<AnsPrimaryNameV2StddevPopFields>;\n  stddev_samp?: Maybe<AnsPrimaryNameV2StddevSampFields>;\n  sum?: Maybe<AnsPrimaryNameV2SumFields>;\n  var_pop?: Maybe<AnsPrimaryNameV2VarPopFields>;\n  var_samp?: Maybe<AnsPrimaryNameV2VarSampFields>;\n  variance?: Maybe<AnsPrimaryNameV2VarianceFields>;\n};\n\n/** aggregate fields of \"ans_primary_name_v2\" */\nexport type AnsPrimaryNameV2AggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<AnsPrimaryNameV2SelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** aggregate avg on columns */\nexport type AnsPrimaryNameV2AvgFields = {\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Boolean expression to filter rows from the table \"ans_primary_name_v2\". All fields are combined with a logical 'AND'. */\nexport type AnsPrimaryNameV2BoolExp = {\n  _and?: InputMaybe<Array<AnsPrimaryNameV2BoolExp>>;\n  _not?: InputMaybe<AnsPrimaryNameV2BoolExp>;\n  _or?: InputMaybe<Array<AnsPrimaryNameV2BoolExp>>;\n  domain?: InputMaybe<StringComparisonExp>;\n  inserted_at?: InputMaybe<TimestampComparisonExp>;\n  is_deleted?: InputMaybe<BooleanComparisonExp>;\n  registered_address?: InputMaybe<StringComparisonExp>;\n  subdomain?: InputMaybe<StringComparisonExp>;\n  token_name?: InputMaybe<StringComparisonExp>;\n  token_standard?: InputMaybe<StringComparisonExp>;\n  transaction_version?: InputMaybe<BigintComparisonExp>;\n  write_set_change_index?: InputMaybe<BigintComparisonExp>;\n};\n\n/** unique or primary key constraints on table \"ans_primary_name_v2\" */\nexport enum AnsPrimaryNameV2Constraint {\n  /** unique or primary key constraint on columns \"write_set_change_index\", \"transaction_version\" */\n  AnsPrimaryNameV2Pkey = \"ans_primary_name_v2_pkey\",\n}\n\n/** input type for incrementing numeric columns in table \"ans_primary_name_v2\" */\nexport type AnsPrimaryNameV2IncInput = {\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  write_set_change_index?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** input type for inserting data into table \"ans_primary_name_v2\" */\nexport type AnsPrimaryNameV2InsertInput = {\n  domain?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  is_deleted?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  registered_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  subdomain?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_standard?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  write_set_change_index?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** aggregate max on columns */\nexport type AnsPrimaryNameV2MaxFields = {\n  domain?: Maybe<Scalars[\"String\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  registered_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  subdomain?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_name?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_standard?: Maybe<Scalars[\"String\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** aggregate min on columns */\nexport type AnsPrimaryNameV2MinFields = {\n  domain?: Maybe<Scalars[\"String\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  registered_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  subdomain?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_name?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_standard?: Maybe<Scalars[\"String\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** response of any mutation on the table \"ans_primary_name_v2\" */\nexport type AnsPrimaryNameV2MutationResponse = {\n  /** number of rows affected by the mutation */\n  affected_rows: Scalars[\"Int\"][\"output\"];\n  /** data from the rows affected by the mutation */\n  returning: Array<AnsPrimaryNameV2>;\n};\n\n/** on_conflict condition type for table \"ans_primary_name_v2\" */\nexport type AnsPrimaryNameV2OnConflict = {\n  constraint: AnsPrimaryNameV2Constraint;\n  update_columns?: Array<AnsPrimaryNameV2UpdateColumn>;\n  where?: InputMaybe<AnsPrimaryNameV2BoolExp>;\n};\n\n/** Ordering options when selecting data from \"ans_primary_name_v2\". */\nexport type AnsPrimaryNameV2OrderBy = {\n  domain?: InputMaybe<OrderBy>;\n  inserted_at?: InputMaybe<OrderBy>;\n  is_deleted?: InputMaybe<OrderBy>;\n  registered_address?: InputMaybe<OrderBy>;\n  subdomain?: InputMaybe<OrderBy>;\n  token_name?: InputMaybe<OrderBy>;\n  token_standard?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n  write_set_change_index?: InputMaybe<OrderBy>;\n};\n\n/** primary key columns input for table: ans_primary_name_v2 */\nexport type AnsPrimaryNameV2PkColumnsInput = {\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n  write_set_change_index: Scalars[\"bigint\"][\"input\"];\n};\n\n/** select columns of table \"ans_primary_name_v2\" */\nexport enum AnsPrimaryNameV2SelectColumn {\n  /** column name */\n  Domain = \"domain\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  IsDeleted = \"is_deleted\",\n  /** column name */\n  RegisteredAddress = \"registered_address\",\n  /** column name */\n  Subdomain = \"subdomain\",\n  /** column name */\n  TokenName = \"token_name\",\n  /** column name */\n  TokenStandard = \"token_standard\",\n  /** column name */\n  TransactionVersion = \"transaction_version\",\n  /** column name */\n  WriteSetChangeIndex = \"write_set_change_index\",\n}\n\n/** input type for updating data in table \"ans_primary_name_v2\" */\nexport type AnsPrimaryNameV2SetInput = {\n  domain?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  is_deleted?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  registered_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  subdomain?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_standard?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  write_set_change_index?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** aggregate stddev on columns */\nexport type AnsPrimaryNameV2StddevFields = {\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_pop on columns */\nexport type AnsPrimaryNameV2StddevPopFields = {\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_samp on columns */\nexport type AnsPrimaryNameV2StddevSampFields = {\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Streaming cursor of the table \"ans_primary_name_v2\" */\nexport type AnsPrimaryNameV2StreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: AnsPrimaryNameV2StreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type AnsPrimaryNameV2StreamCursorValueInput = {\n  domain?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  is_deleted?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  registered_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  subdomain?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_standard?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  write_set_change_index?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** aggregate sum on columns */\nexport type AnsPrimaryNameV2SumFields = {\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** update columns of table \"ans_primary_name_v2\" */\nexport enum AnsPrimaryNameV2UpdateColumn {\n  /** column name */\n  Domain = \"domain\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  IsDeleted = \"is_deleted\",\n  /** column name */\n  RegisteredAddress = \"registered_address\",\n  /** column name */\n  Subdomain = \"subdomain\",\n  /** column name */\n  TokenName = \"token_name\",\n  /** column name */\n  TokenStandard = \"token_standard\",\n  /** column name */\n  TransactionVersion = \"transaction_version\",\n  /** column name */\n  WriteSetChangeIndex = \"write_set_change_index\",\n}\n\nexport type AnsPrimaryNameV2Updates = {\n  /** increments the numeric columns with given value of the filtered values */\n  _inc?: InputMaybe<AnsPrimaryNameV2IncInput>;\n  /** sets the columns of the filtered rows to the given values */\n  _set?: InputMaybe<AnsPrimaryNameV2SetInput>;\n  /** filter the rows which have to be updated */\n  where: AnsPrimaryNameV2BoolExp;\n};\n\n/** aggregate var_pop on columns */\nexport type AnsPrimaryNameV2VarPopFields = {\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate var_samp on columns */\nexport type AnsPrimaryNameV2VarSampFields = {\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate variance on columns */\nexport type AnsPrimaryNameV2VarianceFields = {\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate var_pop on columns */\nexport type AnsPrimaryNameVarPopFields = {\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate var_samp on columns */\nexport type AnsPrimaryNameVarSampFields = {\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate variance on columns */\nexport type AnsPrimaryNameVarianceFields = {\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** columns and relationships of \"auth_key_account_addresses\" */\nexport type AuthKeyAccountAddresses = {\n  account_address: Scalars[\"String\"][\"output\"];\n  auth_key: Scalars[\"String\"][\"output\"];\n  is_auth_key_used: Scalars[\"Boolean\"][\"output\"];\n  last_transaction_version: Scalars[\"bigint\"][\"output\"];\n};\n\n/** aggregated selection of \"auth_key_account_addresses\" */\nexport type AuthKeyAccountAddressesAggregate = {\n  aggregate?: Maybe<AuthKeyAccountAddressesAggregateFields>;\n  nodes: Array<AuthKeyAccountAddresses>;\n};\n\n/** aggregate fields of \"auth_key_account_addresses\" */\nexport type AuthKeyAccountAddressesAggregateFields = {\n  avg?: Maybe<AuthKeyAccountAddressesAvgFields>;\n  count: Scalars[\"Int\"][\"output\"];\n  max?: Maybe<AuthKeyAccountAddressesMaxFields>;\n  min?: Maybe<AuthKeyAccountAddressesMinFields>;\n  stddev?: Maybe<AuthKeyAccountAddressesStddevFields>;\n  stddev_pop?: Maybe<AuthKeyAccountAddressesStddevPopFields>;\n  stddev_samp?: Maybe<AuthKeyAccountAddressesStddevSampFields>;\n  sum?: Maybe<AuthKeyAccountAddressesSumFields>;\n  var_pop?: Maybe<AuthKeyAccountAddressesVarPopFields>;\n  var_samp?: Maybe<AuthKeyAccountAddressesVarSampFields>;\n  variance?: Maybe<AuthKeyAccountAddressesVarianceFields>;\n};\n\n/** aggregate fields of \"auth_key_account_addresses\" */\nexport type AuthKeyAccountAddressesAggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<AuthKeyAccountAddressesSelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** aggregate avg on columns */\nexport type AuthKeyAccountAddressesAvgFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Boolean expression to filter rows from the table \"auth_key_account_addresses\". All fields are combined with a logical 'AND'. */\nexport type AuthKeyAccountAddressesBoolExp = {\n  _and?: InputMaybe<Array<AuthKeyAccountAddressesBoolExp>>;\n  _not?: InputMaybe<AuthKeyAccountAddressesBoolExp>;\n  _or?: InputMaybe<Array<AuthKeyAccountAddressesBoolExp>>;\n  account_address?: InputMaybe<StringComparisonExp>;\n  auth_key?: InputMaybe<StringComparisonExp>;\n  is_auth_key_used?: InputMaybe<BooleanComparisonExp>;\n  last_transaction_version?: InputMaybe<BigintComparisonExp>;\n};\n\n/** unique or primary key constraints on table \"auth_key_account_addresses\" */\nexport enum AuthKeyAccountAddressesConstraint {\n  /** unique or primary key constraint on columns \"account_address\" */\n  AuthKeyAccountAddressesPkey = \"auth_key_account_addresses_pkey\",\n}\n\n/** input type for incrementing numeric columns in table \"auth_key_account_addresses\" */\nexport type AuthKeyAccountAddressesIncInput = {\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** input type for inserting data into table \"auth_key_account_addresses\" */\nexport type AuthKeyAccountAddressesInsertInput = {\n  account_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  auth_key?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  is_auth_key_used?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** aggregate max on columns */\nexport type AuthKeyAccountAddressesMaxFields = {\n  account_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  auth_key?: Maybe<Scalars[\"String\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** aggregate min on columns */\nexport type AuthKeyAccountAddressesMinFields = {\n  account_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  auth_key?: Maybe<Scalars[\"String\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** response of any mutation on the table \"auth_key_account_addresses\" */\nexport type AuthKeyAccountAddressesMutationResponse = {\n  /** number of rows affected by the mutation */\n  affected_rows: Scalars[\"Int\"][\"output\"];\n  /** data from the rows affected by the mutation */\n  returning: Array<AuthKeyAccountAddresses>;\n};\n\n/** on_conflict condition type for table \"auth_key_account_addresses\" */\nexport type AuthKeyAccountAddressesOnConflict = {\n  constraint: AuthKeyAccountAddressesConstraint;\n  update_columns?: Array<AuthKeyAccountAddressesUpdateColumn>;\n  where?: InputMaybe<AuthKeyAccountAddressesBoolExp>;\n};\n\n/** Ordering options when selecting data from \"auth_key_account_addresses\". */\nexport type AuthKeyAccountAddressesOrderBy = {\n  account_address?: InputMaybe<OrderBy>;\n  auth_key?: InputMaybe<OrderBy>;\n  is_auth_key_used?: InputMaybe<OrderBy>;\n  last_transaction_version?: InputMaybe<OrderBy>;\n};\n\n/** primary key columns input for table: auth_key_account_addresses */\nexport type AuthKeyAccountAddressesPkColumnsInput = {\n  account_address: Scalars[\"String\"][\"input\"];\n};\n\n/** select columns of table \"auth_key_account_addresses\" */\nexport enum AuthKeyAccountAddressesSelectColumn {\n  /** column name */\n  AccountAddress = \"account_address\",\n  /** column name */\n  AuthKey = \"auth_key\",\n  /** column name */\n  IsAuthKeyUsed = \"is_auth_key_used\",\n  /** column name */\n  LastTransactionVersion = \"last_transaction_version\",\n}\n\n/** input type for updating data in table \"auth_key_account_addresses\" */\nexport type AuthKeyAccountAddressesSetInput = {\n  account_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  auth_key?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  is_auth_key_used?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** aggregate stddev on columns */\nexport type AuthKeyAccountAddressesStddevFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_pop on columns */\nexport type AuthKeyAccountAddressesStddevPopFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_samp on columns */\nexport type AuthKeyAccountAddressesStddevSampFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Streaming cursor of the table \"auth_key_account_addresses\" */\nexport type AuthKeyAccountAddressesStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: AuthKeyAccountAddressesStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type AuthKeyAccountAddressesStreamCursorValueInput = {\n  account_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  auth_key?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  is_auth_key_used?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** aggregate sum on columns */\nexport type AuthKeyAccountAddressesSumFields = {\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** update columns of table \"auth_key_account_addresses\" */\nexport enum AuthKeyAccountAddressesUpdateColumn {\n  /** column name */\n  AccountAddress = \"account_address\",\n  /** column name */\n  AuthKey = \"auth_key\",\n  /** column name */\n  IsAuthKeyUsed = \"is_auth_key_used\",\n  /** column name */\n  LastTransactionVersion = \"last_transaction_version\",\n}\n\nexport type AuthKeyAccountAddressesUpdates = {\n  /** increments the numeric columns with given value of the filtered values */\n  _inc?: InputMaybe<AuthKeyAccountAddressesIncInput>;\n  /** sets the columns of the filtered rows to the given values */\n  _set?: InputMaybe<AuthKeyAccountAddressesSetInput>;\n  /** filter the rows which have to be updated */\n  where: AuthKeyAccountAddressesBoolExp;\n};\n\n/** aggregate var_pop on columns */\nexport type AuthKeyAccountAddressesVarPopFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate var_samp on columns */\nexport type AuthKeyAccountAddressesVarSampFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate variance on columns */\nexport type AuthKeyAccountAddressesVarianceFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Boolean expression to compare columns of type \"bigint\". All fields are combined with logical 'AND'. */\nexport type BigintComparisonExp = {\n  _eq?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  _gt?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  _gte?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  _in?: InputMaybe<Array<Scalars[\"bigint\"][\"input\"]>>;\n  _is_null?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  _lt?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  _lte?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  _neq?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  _nin?: InputMaybe<Array<Scalars[\"bigint\"][\"input\"]>>;\n};\n\n/** columns and relationships of \"block_metadata_transactions\" */\nexport type BlockMetadataTransactions = {\n  block_height: Scalars[\"bigint\"][\"output\"];\n  epoch: Scalars[\"bigint\"][\"output\"];\n  failed_proposer_indices: Scalars[\"jsonb\"][\"output\"];\n  id: Scalars[\"String\"][\"output\"];\n  inserted_at: Scalars[\"timestamp\"][\"output\"];\n  previous_block_votes_bitvec: Scalars[\"jsonb\"][\"output\"];\n  proposer: Scalars[\"String\"][\"output\"];\n  round: Scalars[\"bigint\"][\"output\"];\n  timestamp: Scalars[\"timestamp\"][\"output\"];\n  version: Scalars[\"bigint\"][\"output\"];\n};\n\n/** columns and relationships of \"block_metadata_transactions\" */\nexport type BlockMetadataTransactionsFailedProposerIndicesArgs = {\n  path?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** columns and relationships of \"block_metadata_transactions\" */\nexport type BlockMetadataTransactionsPreviousBlockVotesBitvecArgs = {\n  path?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregated selection of \"block_metadata_transactions\" */\nexport type BlockMetadataTransactionsAggregate = {\n  aggregate?: Maybe<BlockMetadataTransactionsAggregateFields>;\n  nodes: Array<BlockMetadataTransactions>;\n};\n\n/** aggregate fields of \"block_metadata_transactions\" */\nexport type BlockMetadataTransactionsAggregateFields = {\n  avg?: Maybe<BlockMetadataTransactionsAvgFields>;\n  count: Scalars[\"Int\"][\"output\"];\n  max?: Maybe<BlockMetadataTransactionsMaxFields>;\n  min?: Maybe<BlockMetadataTransactionsMinFields>;\n  stddev?: Maybe<BlockMetadataTransactionsStddevFields>;\n  stddev_pop?: Maybe<BlockMetadataTransactionsStddevPopFields>;\n  stddev_samp?: Maybe<BlockMetadataTransactionsStddevSampFields>;\n  sum?: Maybe<BlockMetadataTransactionsSumFields>;\n  var_pop?: Maybe<BlockMetadataTransactionsVarPopFields>;\n  var_samp?: Maybe<BlockMetadataTransactionsVarSampFields>;\n  variance?: Maybe<BlockMetadataTransactionsVarianceFields>;\n};\n\n/** aggregate fields of \"block_metadata_transactions\" */\nexport type BlockMetadataTransactionsAggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<BlockMetadataTransactionsSelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** append existing jsonb value of filtered columns with new jsonb value */\nexport type BlockMetadataTransactionsAppendInput = {\n  failed_proposer_indices?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  previous_block_votes_bitvec?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n};\n\n/** aggregate avg on columns */\nexport type BlockMetadataTransactionsAvgFields = {\n  block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  epoch?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  round?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Boolean expression to filter rows from the table \"block_metadata_transactions\". All fields are combined with a logical 'AND'. */\nexport type BlockMetadataTransactionsBoolExp = {\n  _and?: InputMaybe<Array<BlockMetadataTransactionsBoolExp>>;\n  _not?: InputMaybe<BlockMetadataTransactionsBoolExp>;\n  _or?: InputMaybe<Array<BlockMetadataTransactionsBoolExp>>;\n  block_height?: InputMaybe<BigintComparisonExp>;\n  epoch?: InputMaybe<BigintComparisonExp>;\n  failed_proposer_indices?: InputMaybe<JsonbComparisonExp>;\n  id?: InputMaybe<StringComparisonExp>;\n  inserted_at?: InputMaybe<TimestampComparisonExp>;\n  previous_block_votes_bitvec?: InputMaybe<JsonbComparisonExp>;\n  proposer?: InputMaybe<StringComparisonExp>;\n  round?: InputMaybe<BigintComparisonExp>;\n  timestamp?: InputMaybe<TimestampComparisonExp>;\n  version?: InputMaybe<BigintComparisonExp>;\n};\n\n/** unique or primary key constraints on table \"block_metadata_transactions\" */\nexport enum BlockMetadataTransactionsConstraint {\n  /** unique or primary key constraint on columns \"block_height\" */\n  BlockMetadataTransactionsBlockHeightKey = \"block_metadata_transactions_block_height_key\",\n  /** unique or primary key constraint on columns \"version\" */\n  BlockMetadataTransactionsPkey = \"block_metadata_transactions_pkey\",\n}\n\n/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */\nexport type BlockMetadataTransactionsDeleteAtPathInput = {\n  failed_proposer_indices?: InputMaybe<Array<Scalars[\"String\"][\"input\"]>>;\n  previous_block_votes_bitvec?: InputMaybe<Array<Scalars[\"String\"][\"input\"]>>;\n};\n\n/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */\nexport type BlockMetadataTransactionsDeleteElemInput = {\n  failed_proposer_indices?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  previous_block_votes_bitvec?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n};\n\n/** delete key/value pair or string element. key/value pairs are matched based on their key value */\nexport type BlockMetadataTransactionsDeleteKeyInput = {\n  failed_proposer_indices?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  previous_block_votes_bitvec?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** input type for incrementing numeric columns in table \"block_metadata_transactions\" */\nexport type BlockMetadataTransactionsIncInput = {\n  block_height?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  epoch?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  round?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** input type for inserting data into table \"block_metadata_transactions\" */\nexport type BlockMetadataTransactionsInsertInput = {\n  block_height?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  epoch?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  failed_proposer_indices?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  id?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  previous_block_votes_bitvec?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  proposer?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  round?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** aggregate max on columns */\nexport type BlockMetadataTransactionsMaxFields = {\n  block_height?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  epoch?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  id?: Maybe<Scalars[\"String\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  proposer?: Maybe<Scalars[\"String\"][\"output\"]>;\n  round?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** aggregate min on columns */\nexport type BlockMetadataTransactionsMinFields = {\n  block_height?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  epoch?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  id?: Maybe<Scalars[\"String\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  proposer?: Maybe<Scalars[\"String\"][\"output\"]>;\n  round?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** response of any mutation on the table \"block_metadata_transactions\" */\nexport type BlockMetadataTransactionsMutationResponse = {\n  /** number of rows affected by the mutation */\n  affected_rows: Scalars[\"Int\"][\"output\"];\n  /** data from the rows affected by the mutation */\n  returning: Array<BlockMetadataTransactions>;\n};\n\n/** on_conflict condition type for table \"block_metadata_transactions\" */\nexport type BlockMetadataTransactionsOnConflict = {\n  constraint: BlockMetadataTransactionsConstraint;\n  update_columns?: Array<BlockMetadataTransactionsUpdateColumn>;\n  where?: InputMaybe<BlockMetadataTransactionsBoolExp>;\n};\n\n/** Ordering options when selecting data from \"block_metadata_transactions\". */\nexport type BlockMetadataTransactionsOrderBy = {\n  block_height?: InputMaybe<OrderBy>;\n  epoch?: InputMaybe<OrderBy>;\n  failed_proposer_indices?: InputMaybe<OrderBy>;\n  id?: InputMaybe<OrderBy>;\n  inserted_at?: InputMaybe<OrderBy>;\n  previous_block_votes_bitvec?: InputMaybe<OrderBy>;\n  proposer?: InputMaybe<OrderBy>;\n  round?: InputMaybe<OrderBy>;\n  timestamp?: InputMaybe<OrderBy>;\n  version?: InputMaybe<OrderBy>;\n};\n\n/** primary key columns input for table: block_metadata_transactions */\nexport type BlockMetadataTransactionsPkColumnsInput = {\n  version: Scalars[\"bigint\"][\"input\"];\n};\n\n/** prepend existing jsonb value of filtered columns with new jsonb value */\nexport type BlockMetadataTransactionsPrependInput = {\n  failed_proposer_indices?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  previous_block_votes_bitvec?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n};\n\n/** select columns of table \"block_metadata_transactions\" */\nexport enum BlockMetadataTransactionsSelectColumn {\n  /** column name */\n  BlockHeight = \"block_height\",\n  /** column name */\n  Epoch = \"epoch\",\n  /** column name */\n  FailedProposerIndices = \"failed_proposer_indices\",\n  /** column name */\n  Id = \"id\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  PreviousBlockVotesBitvec = \"previous_block_votes_bitvec\",\n  /** column name */\n  Proposer = \"proposer\",\n  /** column name */\n  Round = \"round\",\n  /** column name */\n  Timestamp = \"timestamp\",\n  /** column name */\n  Version = \"version\",\n}\n\n/** input type for updating data in table \"block_metadata_transactions\" */\nexport type BlockMetadataTransactionsSetInput = {\n  block_height?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  epoch?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  failed_proposer_indices?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  id?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  previous_block_votes_bitvec?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  proposer?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  round?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** aggregate stddev on columns */\nexport type BlockMetadataTransactionsStddevFields = {\n  block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  epoch?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  round?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_pop on columns */\nexport type BlockMetadataTransactionsStddevPopFields = {\n  block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  epoch?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  round?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_samp on columns */\nexport type BlockMetadataTransactionsStddevSampFields = {\n  block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  epoch?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  round?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Streaming cursor of the table \"block_metadata_transactions\" */\nexport type BlockMetadataTransactionsStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: BlockMetadataTransactionsStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type BlockMetadataTransactionsStreamCursorValueInput = {\n  block_height?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  epoch?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  failed_proposer_indices?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  id?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  previous_block_votes_bitvec?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  proposer?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  round?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** aggregate sum on columns */\nexport type BlockMetadataTransactionsSumFields = {\n  block_height?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  epoch?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  round?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** update columns of table \"block_metadata_transactions\" */\nexport enum BlockMetadataTransactionsUpdateColumn {\n  /** column name */\n  BlockHeight = \"block_height\",\n  /** column name */\n  Epoch = \"epoch\",\n  /** column name */\n  FailedProposerIndices = \"failed_proposer_indices\",\n  /** column name */\n  Id = \"id\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  PreviousBlockVotesBitvec = \"previous_block_votes_bitvec\",\n  /** column name */\n  Proposer = \"proposer\",\n  /** column name */\n  Round = \"round\",\n  /** column name */\n  Timestamp = \"timestamp\",\n  /** column name */\n  Version = \"version\",\n}\n\nexport type BlockMetadataTransactionsUpdates = {\n  /** append existing jsonb value of filtered columns with new jsonb value */\n  _append?: InputMaybe<BlockMetadataTransactionsAppendInput>;\n  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */\n  _delete_at_path?: InputMaybe<BlockMetadataTransactionsDeleteAtPathInput>;\n  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */\n  _delete_elem?: InputMaybe<BlockMetadataTransactionsDeleteElemInput>;\n  /** delete key/value pair or string element. key/value pairs are matched based on their key value */\n  _delete_key?: InputMaybe<BlockMetadataTransactionsDeleteKeyInput>;\n  /** increments the numeric columns with given value of the filtered values */\n  _inc?: InputMaybe<BlockMetadataTransactionsIncInput>;\n  /** prepend existing jsonb value of filtered columns with new jsonb value */\n  _prepend?: InputMaybe<BlockMetadataTransactionsPrependInput>;\n  /** sets the columns of the filtered rows to the given values */\n  _set?: InputMaybe<BlockMetadataTransactionsSetInput>;\n  /** filter the rows which have to be updated */\n  where: BlockMetadataTransactionsBoolExp;\n};\n\n/** aggregate var_pop on columns */\nexport type BlockMetadataTransactionsVarPopFields = {\n  block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  epoch?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  round?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate var_samp on columns */\nexport type BlockMetadataTransactionsVarSampFields = {\n  block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  epoch?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  round?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate variance on columns */\nexport type BlockMetadataTransactionsVarianceFields = {\n  block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  epoch?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  round?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Boolean expression to compare columns of type \"bytea\". All fields are combined with logical 'AND'. */\nexport type ByteaComparisonExp = {\n  _eq?: InputMaybe<Scalars[\"bytea\"][\"input\"]>;\n  _gt?: InputMaybe<Scalars[\"bytea\"][\"input\"]>;\n  _gte?: InputMaybe<Scalars[\"bytea\"][\"input\"]>;\n  _in?: InputMaybe<Array<Scalars[\"bytea\"][\"input\"]>>;\n  _is_null?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  _lt?: InputMaybe<Scalars[\"bytea\"][\"input\"]>;\n  _lte?: InputMaybe<Scalars[\"bytea\"][\"input\"]>;\n  _neq?: InputMaybe<Scalars[\"bytea\"][\"input\"]>;\n  _nin?: InputMaybe<Array<Scalars[\"bytea\"][\"input\"]>>;\n};\n\n/** columns and relationships of \"coin_activities\" */\nexport type CoinActivities = {\n  activity_type: Scalars[\"String\"][\"output\"];\n  amount: Scalars[\"numeric\"][\"output\"];\n  block_height: Scalars[\"bigint\"][\"output\"];\n  coin_type: Scalars[\"String\"][\"output\"];\n  entry_function_id_str?: Maybe<Scalars[\"String\"][\"output\"]>;\n  event_account_address: Scalars[\"String\"][\"output\"];\n  event_creation_number: Scalars[\"bigint\"][\"output\"];\n  event_index?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  event_sequence_number: Scalars[\"bigint\"][\"output\"];\n  gas_fee_payer_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  inserted_at: Scalars[\"timestamp\"][\"output\"];\n  is_gas_fee: Scalars[\"Boolean\"][\"output\"];\n  is_transaction_success: Scalars[\"Boolean\"][\"output\"];\n  owner_address: Scalars[\"String\"][\"output\"];\n  storage_refund_amount: Scalars[\"numeric\"][\"output\"];\n  transaction_timestamp: Scalars[\"timestamp\"][\"output\"];\n  transaction_version: Scalars[\"bigint\"][\"output\"];\n};\n\n/** aggregated selection of \"coin_activities\" */\nexport type CoinActivitiesAggregate = {\n  aggregate?: Maybe<CoinActivitiesAggregateFields>;\n  nodes: Array<CoinActivities>;\n};\n\n/** aggregate fields of \"coin_activities\" */\nexport type CoinActivitiesAggregateFields = {\n  avg?: Maybe<CoinActivitiesAvgFields>;\n  count: Scalars[\"Int\"][\"output\"];\n  max?: Maybe<CoinActivitiesMaxFields>;\n  min?: Maybe<CoinActivitiesMinFields>;\n  stddev?: Maybe<CoinActivitiesStddevFields>;\n  stddev_pop?: Maybe<CoinActivitiesStddevPopFields>;\n  stddev_samp?: Maybe<CoinActivitiesStddevSampFields>;\n  sum?: Maybe<CoinActivitiesSumFields>;\n  var_pop?: Maybe<CoinActivitiesVarPopFields>;\n  var_samp?: Maybe<CoinActivitiesVarSampFields>;\n  variance?: Maybe<CoinActivitiesVarianceFields>;\n};\n\n/** aggregate fields of \"coin_activities\" */\nexport type CoinActivitiesAggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<CoinActivitiesSelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** aggregate avg on columns */\nexport type CoinActivitiesAvgFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  event_creation_number?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  event_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  event_sequence_number?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  storage_refund_amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Boolean expression to filter rows from the table \"coin_activities\". All fields are combined with a logical 'AND'. */\nexport type CoinActivitiesBoolExp = {\n  _and?: InputMaybe<Array<CoinActivitiesBoolExp>>;\n  _not?: InputMaybe<CoinActivitiesBoolExp>;\n  _or?: InputMaybe<Array<CoinActivitiesBoolExp>>;\n  activity_type?: InputMaybe<StringComparisonExp>;\n  amount?: InputMaybe<NumericComparisonExp>;\n  block_height?: InputMaybe<BigintComparisonExp>;\n  coin_type?: InputMaybe<StringComparisonExp>;\n  entry_function_id_str?: InputMaybe<StringComparisonExp>;\n  event_account_address?: InputMaybe<StringComparisonExp>;\n  event_creation_number?: InputMaybe<BigintComparisonExp>;\n  event_index?: InputMaybe<BigintComparisonExp>;\n  event_sequence_number?: InputMaybe<BigintComparisonExp>;\n  gas_fee_payer_address?: InputMaybe<StringComparisonExp>;\n  inserted_at?: InputMaybe<TimestampComparisonExp>;\n  is_gas_fee?: InputMaybe<BooleanComparisonExp>;\n  is_transaction_success?: InputMaybe<BooleanComparisonExp>;\n  owner_address?: InputMaybe<StringComparisonExp>;\n  storage_refund_amount?: InputMaybe<NumericComparisonExp>;\n  transaction_timestamp?: InputMaybe<TimestampComparisonExp>;\n  transaction_version?: InputMaybe<BigintComparisonExp>;\n};\n\n/** unique or primary key constraints on table \"coin_activities\" */\nexport enum CoinActivitiesConstraint {\n  /** unique or primary key constraint on columns \"event_sequence_number\", \"event_creation_number\", \"transaction_version\", \"event_account_address\" */\n  CoinActivitiesPkey = \"coin_activities_pkey\",\n}\n\n/** input type for incrementing numeric columns in table \"coin_activities\" */\nexport type CoinActivitiesIncInput = {\n  amount?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  block_height?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  event_creation_number?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  event_index?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  event_sequence_number?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  storage_refund_amount?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** input type for inserting data into table \"coin_activities\" */\nexport type CoinActivitiesInsertInput = {\n  activity_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  amount?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  block_height?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  coin_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  entry_function_id_str?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  event_account_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  event_creation_number?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  event_index?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  event_sequence_number?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  gas_fee_payer_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  is_gas_fee?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  is_transaction_success?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  owner_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  storage_refund_amount?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** aggregate max on columns */\nexport type CoinActivitiesMaxFields = {\n  activity_type?: Maybe<Scalars[\"String\"][\"output\"]>;\n  amount?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  block_height?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  coin_type?: Maybe<Scalars[\"String\"][\"output\"]>;\n  entry_function_id_str?: Maybe<Scalars[\"String\"][\"output\"]>;\n  event_account_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  event_creation_number?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  event_index?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  event_sequence_number?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  gas_fee_payer_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  owner_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  storage_refund_amount?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  transaction_timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** aggregate min on columns */\nexport type CoinActivitiesMinFields = {\n  activity_type?: Maybe<Scalars[\"String\"][\"output\"]>;\n  amount?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  block_height?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  coin_type?: Maybe<Scalars[\"String\"][\"output\"]>;\n  entry_function_id_str?: Maybe<Scalars[\"String\"][\"output\"]>;\n  event_account_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  event_creation_number?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  event_index?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  event_sequence_number?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  gas_fee_payer_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  owner_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  storage_refund_amount?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  transaction_timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** response of any mutation on the table \"coin_activities\" */\nexport type CoinActivitiesMutationResponse = {\n  /** number of rows affected by the mutation */\n  affected_rows: Scalars[\"Int\"][\"output\"];\n  /** data from the rows affected by the mutation */\n  returning: Array<CoinActivities>;\n};\n\n/** on_conflict condition type for table \"coin_activities\" */\nexport type CoinActivitiesOnConflict = {\n  constraint: CoinActivitiesConstraint;\n  update_columns?: Array<CoinActivitiesUpdateColumn>;\n  where?: InputMaybe<CoinActivitiesBoolExp>;\n};\n\n/** Ordering options when selecting data from \"coin_activities\". */\nexport type CoinActivitiesOrderBy = {\n  activity_type?: InputMaybe<OrderBy>;\n  amount?: InputMaybe<OrderBy>;\n  block_height?: InputMaybe<OrderBy>;\n  coin_type?: InputMaybe<OrderBy>;\n  entry_function_id_str?: InputMaybe<OrderBy>;\n  event_account_address?: InputMaybe<OrderBy>;\n  event_creation_number?: InputMaybe<OrderBy>;\n  event_index?: InputMaybe<OrderBy>;\n  event_sequence_number?: InputMaybe<OrderBy>;\n  gas_fee_payer_address?: InputMaybe<OrderBy>;\n  inserted_at?: InputMaybe<OrderBy>;\n  is_gas_fee?: InputMaybe<OrderBy>;\n  is_transaction_success?: InputMaybe<OrderBy>;\n  owner_address?: InputMaybe<OrderBy>;\n  storage_refund_amount?: InputMaybe<OrderBy>;\n  transaction_timestamp?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n};\n\n/** primary key columns input for table: coin_activities */\nexport type CoinActivitiesPkColumnsInput = {\n  event_account_address: Scalars[\"String\"][\"input\"];\n  event_creation_number: Scalars[\"bigint\"][\"input\"];\n  event_sequence_number: Scalars[\"bigint\"][\"input\"];\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\n/** select columns of table \"coin_activities\" */\nexport enum CoinActivitiesSelectColumn {\n  /** column name */\n  ActivityType = \"activity_type\",\n  /** column name */\n  Amount = \"amount\",\n  /** column name */\n  BlockHeight = \"block_height\",\n  /** column name */\n  CoinType = \"coin_type\",\n  /** column name */\n  EntryFunctionIdStr = \"entry_function_id_str\",\n  /** column name */\n  EventAccountAddress = \"event_account_address\",\n  /** column name */\n  EventCreationNumber = \"event_creation_number\",\n  /** column name */\n  EventIndex = \"event_index\",\n  /** column name */\n  EventSequenceNumber = \"event_sequence_number\",\n  /** column name */\n  GasFeePayerAddress = \"gas_fee_payer_address\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  IsGasFee = \"is_gas_fee\",\n  /** column name */\n  IsTransactionSuccess = \"is_transaction_success\",\n  /** column name */\n  OwnerAddress = \"owner_address\",\n  /** column name */\n  StorageRefundAmount = \"storage_refund_amount\",\n  /** column name */\n  TransactionTimestamp = \"transaction_timestamp\",\n  /** column name */\n  TransactionVersion = \"transaction_version\",\n}\n\n/** input type for updating data in table \"coin_activities\" */\nexport type CoinActivitiesSetInput = {\n  activity_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  amount?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  block_height?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  coin_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  entry_function_id_str?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  event_account_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  event_creation_number?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  event_index?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  event_sequence_number?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  gas_fee_payer_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  is_gas_fee?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  is_transaction_success?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  owner_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  storage_refund_amount?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** aggregate stddev on columns */\nexport type CoinActivitiesStddevFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  event_creation_number?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  event_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  event_sequence_number?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  storage_refund_amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_pop on columns */\nexport type CoinActivitiesStddevPopFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  event_creation_number?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  event_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  event_sequence_number?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  storage_refund_amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_samp on columns */\nexport type CoinActivitiesStddevSampFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  event_creation_number?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  event_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  event_sequence_number?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  storage_refund_amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Streaming cursor of the table \"coin_activities\" */\nexport type CoinActivitiesStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: CoinActivitiesStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type CoinActivitiesStreamCursorValueInput = {\n  activity_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  amount?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  block_height?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  coin_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  entry_function_id_str?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  event_account_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  event_creation_number?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  event_index?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  event_sequence_number?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  gas_fee_payer_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  is_gas_fee?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  is_transaction_success?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  owner_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  storage_refund_amount?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** aggregate sum on columns */\nexport type CoinActivitiesSumFields = {\n  amount?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  block_height?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  event_creation_number?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  event_index?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  event_sequence_number?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  storage_refund_amount?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** update columns of table \"coin_activities\" */\nexport enum CoinActivitiesUpdateColumn {\n  /** column name */\n  ActivityType = \"activity_type\",\n  /** column name */\n  Amount = \"amount\",\n  /** column name */\n  BlockHeight = \"block_height\",\n  /** column name */\n  CoinType = \"coin_type\",\n  /** column name */\n  EntryFunctionIdStr = \"entry_function_id_str\",\n  /** column name */\n  EventAccountAddress = \"event_account_address\",\n  /** column name */\n  EventCreationNumber = \"event_creation_number\",\n  /** column name */\n  EventIndex = \"event_index\",\n  /** column name */\n  EventSequenceNumber = \"event_sequence_number\",\n  /** column name */\n  GasFeePayerAddress = \"gas_fee_payer_address\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  IsGasFee = \"is_gas_fee\",\n  /** column name */\n  IsTransactionSuccess = \"is_transaction_success\",\n  /** column name */\n  OwnerAddress = \"owner_address\",\n  /** column name */\n  StorageRefundAmount = \"storage_refund_amount\",\n  /** column name */\n  TransactionTimestamp = \"transaction_timestamp\",\n  /** column name */\n  TransactionVersion = \"transaction_version\",\n}\n\nexport type CoinActivitiesUpdates = {\n  /** increments the numeric columns with given value of the filtered values */\n  _inc?: InputMaybe<CoinActivitiesIncInput>;\n  /** sets the columns of the filtered rows to the given values */\n  _set?: InputMaybe<CoinActivitiesSetInput>;\n  /** filter the rows which have to be updated */\n  where: CoinActivitiesBoolExp;\n};\n\n/** aggregate var_pop on columns */\nexport type CoinActivitiesVarPopFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  event_creation_number?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  event_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  event_sequence_number?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  storage_refund_amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate var_samp on columns */\nexport type CoinActivitiesVarSampFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  event_creation_number?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  event_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  event_sequence_number?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  storage_refund_amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate variance on columns */\nexport type CoinActivitiesVarianceFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  event_creation_number?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  event_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  event_sequence_number?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  storage_refund_amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** columns and relationships of \"coin_balances\" */\nexport type CoinBalances = {\n  amount: Scalars[\"numeric\"][\"output\"];\n  coin_type: Scalars[\"String\"][\"output\"];\n  coin_type_hash: Scalars[\"String\"][\"output\"];\n  inserted_at: Scalars[\"timestamp\"][\"output\"];\n  owner_address: Scalars[\"String\"][\"output\"];\n  transaction_timestamp: Scalars[\"timestamp\"][\"output\"];\n  transaction_version: Scalars[\"bigint\"][\"output\"];\n};\n\n/** aggregated selection of \"coin_balances\" */\nexport type CoinBalancesAggregate = {\n  aggregate?: Maybe<CoinBalancesAggregateFields>;\n  nodes: Array<CoinBalances>;\n};\n\n/** aggregate fields of \"coin_balances\" */\nexport type CoinBalancesAggregateFields = {\n  avg?: Maybe<CoinBalancesAvgFields>;\n  count: Scalars[\"Int\"][\"output\"];\n  max?: Maybe<CoinBalancesMaxFields>;\n  min?: Maybe<CoinBalancesMinFields>;\n  stddev?: Maybe<CoinBalancesStddevFields>;\n  stddev_pop?: Maybe<CoinBalancesStddevPopFields>;\n  stddev_samp?: Maybe<CoinBalancesStddevSampFields>;\n  sum?: Maybe<CoinBalancesSumFields>;\n  var_pop?: Maybe<CoinBalancesVarPopFields>;\n  var_samp?: Maybe<CoinBalancesVarSampFields>;\n  variance?: Maybe<CoinBalancesVarianceFields>;\n};\n\n/** aggregate fields of \"coin_balances\" */\nexport type CoinBalancesAggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<CoinBalancesSelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** aggregate avg on columns */\nexport type CoinBalancesAvgFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Boolean expression to filter rows from the table \"coin_balances\". All fields are combined with a logical 'AND'. */\nexport type CoinBalancesBoolExp = {\n  _and?: InputMaybe<Array<CoinBalancesBoolExp>>;\n  _not?: InputMaybe<CoinBalancesBoolExp>;\n  _or?: InputMaybe<Array<CoinBalancesBoolExp>>;\n  amount?: InputMaybe<NumericComparisonExp>;\n  coin_type?: InputMaybe<StringComparisonExp>;\n  coin_type_hash?: InputMaybe<StringComparisonExp>;\n  inserted_at?: InputMaybe<TimestampComparisonExp>;\n  owner_address?: InputMaybe<StringComparisonExp>;\n  transaction_timestamp?: InputMaybe<TimestampComparisonExp>;\n  transaction_version?: InputMaybe<BigintComparisonExp>;\n};\n\n/** unique or primary key constraints on table \"coin_balances\" */\nexport enum CoinBalancesConstraint {\n  /** unique or primary key constraint on columns \"coin_type_hash\", \"owner_address\", \"transaction_version\" */\n  CoinBalancesPkey = \"coin_balances_pkey\",\n}\n\n/** input type for incrementing numeric columns in table \"coin_balances\" */\nexport type CoinBalancesIncInput = {\n  amount?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** input type for inserting data into table \"coin_balances\" */\nexport type CoinBalancesInsertInput = {\n  amount?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  coin_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  coin_type_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  owner_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** aggregate max on columns */\nexport type CoinBalancesMaxFields = {\n  amount?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  coin_type?: Maybe<Scalars[\"String\"][\"output\"]>;\n  coin_type_hash?: Maybe<Scalars[\"String\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  owner_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  transaction_timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** aggregate min on columns */\nexport type CoinBalancesMinFields = {\n  amount?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  coin_type?: Maybe<Scalars[\"String\"][\"output\"]>;\n  coin_type_hash?: Maybe<Scalars[\"String\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  owner_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  transaction_timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** response of any mutation on the table \"coin_balances\" */\nexport type CoinBalancesMutationResponse = {\n  /** number of rows affected by the mutation */\n  affected_rows: Scalars[\"Int\"][\"output\"];\n  /** data from the rows affected by the mutation */\n  returning: Array<CoinBalances>;\n};\n\n/** on_conflict condition type for table \"coin_balances\" */\nexport type CoinBalancesOnConflict = {\n  constraint: CoinBalancesConstraint;\n  update_columns?: Array<CoinBalancesUpdateColumn>;\n  where?: InputMaybe<CoinBalancesBoolExp>;\n};\n\n/** Ordering options when selecting data from \"coin_balances\". */\nexport type CoinBalancesOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  coin_type?: InputMaybe<OrderBy>;\n  coin_type_hash?: InputMaybe<OrderBy>;\n  inserted_at?: InputMaybe<OrderBy>;\n  owner_address?: InputMaybe<OrderBy>;\n  transaction_timestamp?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n};\n\n/** primary key columns input for table: coin_balances */\nexport type CoinBalancesPkColumnsInput = {\n  coin_type_hash: Scalars[\"String\"][\"input\"];\n  owner_address: Scalars[\"String\"][\"input\"];\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\n/** select columns of table \"coin_balances\" */\nexport enum CoinBalancesSelectColumn {\n  /** column name */\n  Amount = \"amount\",\n  /** column name */\n  CoinType = \"coin_type\",\n  /** column name */\n  CoinTypeHash = \"coin_type_hash\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  OwnerAddress = \"owner_address\",\n  /** column name */\n  TransactionTimestamp = \"transaction_timestamp\",\n  /** column name */\n  TransactionVersion = \"transaction_version\",\n}\n\n/** input type for updating data in table \"coin_balances\" */\nexport type CoinBalancesSetInput = {\n  amount?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  coin_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  coin_type_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  owner_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** aggregate stddev on columns */\nexport type CoinBalancesStddevFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_pop on columns */\nexport type CoinBalancesStddevPopFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_samp on columns */\nexport type CoinBalancesStddevSampFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Streaming cursor of the table \"coin_balances\" */\nexport type CoinBalancesStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: CoinBalancesStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type CoinBalancesStreamCursorValueInput = {\n  amount?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  coin_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  coin_type_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  owner_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** aggregate sum on columns */\nexport type CoinBalancesSumFields = {\n  amount?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** update columns of table \"coin_balances\" */\nexport enum CoinBalancesUpdateColumn {\n  /** column name */\n  Amount = \"amount\",\n  /** column name */\n  CoinType = \"coin_type\",\n  /** column name */\n  CoinTypeHash = \"coin_type_hash\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  OwnerAddress = \"owner_address\",\n  /** column name */\n  TransactionTimestamp = \"transaction_timestamp\",\n  /** column name */\n  TransactionVersion = \"transaction_version\",\n}\n\nexport type CoinBalancesUpdates = {\n  /** increments the numeric columns with given value of the filtered values */\n  _inc?: InputMaybe<CoinBalancesIncInput>;\n  /** sets the columns of the filtered rows to the given values */\n  _set?: InputMaybe<CoinBalancesSetInput>;\n  /** filter the rows which have to be updated */\n  where: CoinBalancesBoolExp;\n};\n\n/** aggregate var_pop on columns */\nexport type CoinBalancesVarPopFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate var_samp on columns */\nexport type CoinBalancesVarSampFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate variance on columns */\nexport type CoinBalancesVarianceFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** columns and relationships of \"coin_infos\" */\nexport type CoinInfos = {\n  coin_type: Scalars[\"String\"][\"output\"];\n  coin_type_hash: Scalars[\"String\"][\"output\"];\n  creator_address: Scalars[\"String\"][\"output\"];\n  decimals: Scalars[\"Int\"][\"output\"];\n  inserted_at: Scalars[\"timestamp\"][\"output\"];\n  name: Scalars[\"String\"][\"output\"];\n  supply_aggregator_table_handle?: Maybe<Scalars[\"String\"][\"output\"]>;\n  supply_aggregator_table_key?: Maybe<Scalars[\"String\"][\"output\"]>;\n  symbol: Scalars[\"String\"][\"output\"];\n  transaction_created_timestamp: Scalars[\"timestamp\"][\"output\"];\n  transaction_version_created: Scalars[\"bigint\"][\"output\"];\n};\n\n/** aggregated selection of \"coin_infos\" */\nexport type CoinInfosAggregate = {\n  aggregate?: Maybe<CoinInfosAggregateFields>;\n  nodes: Array<CoinInfos>;\n};\n\n/** aggregate fields of \"coin_infos\" */\nexport type CoinInfosAggregateFields = {\n  avg?: Maybe<CoinInfosAvgFields>;\n  count: Scalars[\"Int\"][\"output\"];\n  max?: Maybe<CoinInfosMaxFields>;\n  min?: Maybe<CoinInfosMinFields>;\n  stddev?: Maybe<CoinInfosStddevFields>;\n  stddev_pop?: Maybe<CoinInfosStddevPopFields>;\n  stddev_samp?: Maybe<CoinInfosStddevSampFields>;\n  sum?: Maybe<CoinInfosSumFields>;\n  var_pop?: Maybe<CoinInfosVarPopFields>;\n  var_samp?: Maybe<CoinInfosVarSampFields>;\n  variance?: Maybe<CoinInfosVarianceFields>;\n};\n\n/** aggregate fields of \"coin_infos\" */\nexport type CoinInfosAggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<CoinInfosSelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** aggregate avg on columns */\nexport type CoinInfosAvgFields = {\n  decimals?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version_created?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Boolean expression to filter rows from the table \"coin_infos\". All fields are combined with a logical 'AND'. */\nexport type CoinInfosBoolExp = {\n  _and?: InputMaybe<Array<CoinInfosBoolExp>>;\n  _not?: InputMaybe<CoinInfosBoolExp>;\n  _or?: InputMaybe<Array<CoinInfosBoolExp>>;\n  coin_type?: InputMaybe<StringComparisonExp>;\n  coin_type_hash?: InputMaybe<StringComparisonExp>;\n  creator_address?: InputMaybe<StringComparisonExp>;\n  decimals?: InputMaybe<IntComparisonExp>;\n  inserted_at?: InputMaybe<TimestampComparisonExp>;\n  name?: InputMaybe<StringComparisonExp>;\n  supply_aggregator_table_handle?: InputMaybe<StringComparisonExp>;\n  supply_aggregator_table_key?: InputMaybe<StringComparisonExp>;\n  symbol?: InputMaybe<StringComparisonExp>;\n  transaction_created_timestamp?: InputMaybe<TimestampComparisonExp>;\n  transaction_version_created?: InputMaybe<BigintComparisonExp>;\n};\n\n/** unique or primary key constraints on table \"coin_infos\" */\nexport enum CoinInfosConstraint {\n  /** unique or primary key constraint on columns \"coin_type_hash\" */\n  CoinInfosPkey = \"coin_infos_pkey\",\n}\n\n/** input type for incrementing numeric columns in table \"coin_infos\" */\nexport type CoinInfosIncInput = {\n  decimals?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  transaction_version_created?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** input type for inserting data into table \"coin_infos\" */\nexport type CoinInfosInsertInput = {\n  coin_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  coin_type_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  creator_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  decimals?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  supply_aggregator_table_handle?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  supply_aggregator_table_key?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  symbol?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  transaction_created_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  transaction_version_created?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** aggregate max on columns */\nexport type CoinInfosMaxFields = {\n  coin_type?: Maybe<Scalars[\"String\"][\"output\"]>;\n  coin_type_hash?: Maybe<Scalars[\"String\"][\"output\"]>;\n  creator_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  decimals?: Maybe<Scalars[\"Int\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  name?: Maybe<Scalars[\"String\"][\"output\"]>;\n  supply_aggregator_table_handle?: Maybe<Scalars[\"String\"][\"output\"]>;\n  supply_aggregator_table_key?: Maybe<Scalars[\"String\"][\"output\"]>;\n  symbol?: Maybe<Scalars[\"String\"][\"output\"]>;\n  transaction_created_timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  transaction_version_created?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** aggregate min on columns */\nexport type CoinInfosMinFields = {\n  coin_type?: Maybe<Scalars[\"String\"][\"output\"]>;\n  coin_type_hash?: Maybe<Scalars[\"String\"][\"output\"]>;\n  creator_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  decimals?: Maybe<Scalars[\"Int\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  name?: Maybe<Scalars[\"String\"][\"output\"]>;\n  supply_aggregator_table_handle?: Maybe<Scalars[\"String\"][\"output\"]>;\n  supply_aggregator_table_key?: Maybe<Scalars[\"String\"][\"output\"]>;\n  symbol?: Maybe<Scalars[\"String\"][\"output\"]>;\n  transaction_created_timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  transaction_version_created?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** response of any mutation on the table \"coin_infos\" */\nexport type CoinInfosMutationResponse = {\n  /** number of rows affected by the mutation */\n  affected_rows: Scalars[\"Int\"][\"output\"];\n  /** data from the rows affected by the mutation */\n  returning: Array<CoinInfos>;\n};\n\n/** on_conflict condition type for table \"coin_infos\" */\nexport type CoinInfosOnConflict = {\n  constraint: CoinInfosConstraint;\n  update_columns?: Array<CoinInfosUpdateColumn>;\n  where?: InputMaybe<CoinInfosBoolExp>;\n};\n\n/** Ordering options when selecting data from \"coin_infos\". */\nexport type CoinInfosOrderBy = {\n  coin_type?: InputMaybe<OrderBy>;\n  coin_type_hash?: InputMaybe<OrderBy>;\n  creator_address?: InputMaybe<OrderBy>;\n  decimals?: InputMaybe<OrderBy>;\n  inserted_at?: InputMaybe<OrderBy>;\n  name?: InputMaybe<OrderBy>;\n  supply_aggregator_table_handle?: InputMaybe<OrderBy>;\n  supply_aggregator_table_key?: InputMaybe<OrderBy>;\n  symbol?: InputMaybe<OrderBy>;\n  transaction_created_timestamp?: InputMaybe<OrderBy>;\n  transaction_version_created?: InputMaybe<OrderBy>;\n};\n\n/** primary key columns input for table: coin_infos */\nexport type CoinInfosPkColumnsInput = {\n  coin_type_hash: Scalars[\"String\"][\"input\"];\n};\n\n/** select columns of table \"coin_infos\" */\nexport enum CoinInfosSelectColumn {\n  /** column name */\n  CoinType = \"coin_type\",\n  /** column name */\n  CoinTypeHash = \"coin_type_hash\",\n  /** column name */\n  CreatorAddress = \"creator_address\",\n  /** column name */\n  Decimals = \"decimals\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  Name = \"name\",\n  /** column name */\n  SupplyAggregatorTableHandle = \"supply_aggregator_table_handle\",\n  /** column name */\n  SupplyAggregatorTableKey = \"supply_aggregator_table_key\",\n  /** column name */\n  Symbol = \"symbol\",\n  /** column name */\n  TransactionCreatedTimestamp = \"transaction_created_timestamp\",\n  /** column name */\n  TransactionVersionCreated = \"transaction_version_created\",\n}\n\n/** input type for updating data in table \"coin_infos\" */\nexport type CoinInfosSetInput = {\n  coin_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  coin_type_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  creator_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  decimals?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  supply_aggregator_table_handle?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  supply_aggregator_table_key?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  symbol?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  transaction_created_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  transaction_version_created?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** aggregate stddev on columns */\nexport type CoinInfosStddevFields = {\n  decimals?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version_created?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_pop on columns */\nexport type CoinInfosStddevPopFields = {\n  decimals?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version_created?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_samp on columns */\nexport type CoinInfosStddevSampFields = {\n  decimals?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version_created?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Streaming cursor of the table \"coin_infos\" */\nexport type CoinInfosStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: CoinInfosStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type CoinInfosStreamCursorValueInput = {\n  coin_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  coin_type_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  creator_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  decimals?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  supply_aggregator_table_handle?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  supply_aggregator_table_key?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  symbol?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  transaction_created_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  transaction_version_created?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** aggregate sum on columns */\nexport type CoinInfosSumFields = {\n  decimals?: Maybe<Scalars[\"Int\"][\"output\"]>;\n  transaction_version_created?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** update columns of table \"coin_infos\" */\nexport enum CoinInfosUpdateColumn {\n  /** column name */\n  CoinType = \"coin_type\",\n  /** column name */\n  CoinTypeHash = \"coin_type_hash\",\n  /** column name */\n  CreatorAddress = \"creator_address\",\n  /** column name */\n  Decimals = \"decimals\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  Name = \"name\",\n  /** column name */\n  SupplyAggregatorTableHandle = \"supply_aggregator_table_handle\",\n  /** column name */\n  SupplyAggregatorTableKey = \"supply_aggregator_table_key\",\n  /** column name */\n  Symbol = \"symbol\",\n  /** column name */\n  TransactionCreatedTimestamp = \"transaction_created_timestamp\",\n  /** column name */\n  TransactionVersionCreated = \"transaction_version_created\",\n}\n\nexport type CoinInfosUpdates = {\n  /** increments the numeric columns with given value of the filtered values */\n  _inc?: InputMaybe<CoinInfosIncInput>;\n  /** sets the columns of the filtered rows to the given values */\n  _set?: InputMaybe<CoinInfosSetInput>;\n  /** filter the rows which have to be updated */\n  where: CoinInfosBoolExp;\n};\n\n/** aggregate var_pop on columns */\nexport type CoinInfosVarPopFields = {\n  decimals?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version_created?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate var_samp on columns */\nexport type CoinInfosVarSampFields = {\n  decimals?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version_created?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate variance on columns */\nexport type CoinInfosVarianceFields = {\n  decimals?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version_created?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** columns and relationships of \"coin_supply\" */\nexport type CoinSupply = {\n  coin_type: Scalars[\"String\"][\"output\"];\n  coin_type_hash: Scalars[\"String\"][\"output\"];\n  inserted_at: Scalars[\"timestamp\"][\"output\"];\n  supply: Scalars[\"numeric\"][\"output\"];\n  transaction_epoch: Scalars[\"bigint\"][\"output\"];\n  transaction_timestamp: Scalars[\"timestamp\"][\"output\"];\n  transaction_version: Scalars[\"bigint\"][\"output\"];\n};\n\n/** aggregated selection of \"coin_supply\" */\nexport type CoinSupplyAggregate = {\n  aggregate?: Maybe<CoinSupplyAggregateFields>;\n  nodes: Array<CoinSupply>;\n};\n\n/** aggregate fields of \"coin_supply\" */\nexport type CoinSupplyAggregateFields = {\n  avg?: Maybe<CoinSupplyAvgFields>;\n  count: Scalars[\"Int\"][\"output\"];\n  max?: Maybe<CoinSupplyMaxFields>;\n  min?: Maybe<CoinSupplyMinFields>;\n  stddev?: Maybe<CoinSupplyStddevFields>;\n  stddev_pop?: Maybe<CoinSupplyStddevPopFields>;\n  stddev_samp?: Maybe<CoinSupplyStddevSampFields>;\n  sum?: Maybe<CoinSupplySumFields>;\n  var_pop?: Maybe<CoinSupplyVarPopFields>;\n  var_samp?: Maybe<CoinSupplyVarSampFields>;\n  variance?: Maybe<CoinSupplyVarianceFields>;\n};\n\n/** aggregate fields of \"coin_supply\" */\nexport type CoinSupplyAggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<CoinSupplySelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** aggregate avg on columns */\nexport type CoinSupplyAvgFields = {\n  supply?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_epoch?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Boolean expression to filter rows from the table \"coin_supply\". All fields are combined with a logical 'AND'. */\nexport type CoinSupplyBoolExp = {\n  _and?: InputMaybe<Array<CoinSupplyBoolExp>>;\n  _not?: InputMaybe<CoinSupplyBoolExp>;\n  _or?: InputMaybe<Array<CoinSupplyBoolExp>>;\n  coin_type?: InputMaybe<StringComparisonExp>;\n  coin_type_hash?: InputMaybe<StringComparisonExp>;\n  inserted_at?: InputMaybe<TimestampComparisonExp>;\n  supply?: InputMaybe<NumericComparisonExp>;\n  transaction_epoch?: InputMaybe<BigintComparisonExp>;\n  transaction_timestamp?: InputMaybe<TimestampComparisonExp>;\n  transaction_version?: InputMaybe<BigintComparisonExp>;\n};\n\n/** unique or primary key constraints on table \"coin_supply\" */\nexport enum CoinSupplyConstraint {\n  /** unique or primary key constraint on columns \"coin_type_hash\", \"transaction_version\" */\n  CoinSupplyPkey = \"coin_supply_pkey\",\n}\n\n/** input type for incrementing numeric columns in table \"coin_supply\" */\nexport type CoinSupplyIncInput = {\n  supply?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  transaction_epoch?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** input type for inserting data into table \"coin_supply\" */\nexport type CoinSupplyInsertInput = {\n  coin_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  coin_type_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  supply?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  transaction_epoch?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** aggregate max on columns */\nexport type CoinSupplyMaxFields = {\n  coin_type?: Maybe<Scalars[\"String\"][\"output\"]>;\n  coin_type_hash?: Maybe<Scalars[\"String\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  supply?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  transaction_epoch?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  transaction_timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** aggregate min on columns */\nexport type CoinSupplyMinFields = {\n  coin_type?: Maybe<Scalars[\"String\"][\"output\"]>;\n  coin_type_hash?: Maybe<Scalars[\"String\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  supply?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  transaction_epoch?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  transaction_timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** response of any mutation on the table \"coin_supply\" */\nexport type CoinSupplyMutationResponse = {\n  /** number of rows affected by the mutation */\n  affected_rows: Scalars[\"Int\"][\"output\"];\n  /** data from the rows affected by the mutation */\n  returning: Array<CoinSupply>;\n};\n\n/** on_conflict condition type for table \"coin_supply\" */\nexport type CoinSupplyOnConflict = {\n  constraint: CoinSupplyConstraint;\n  update_columns?: Array<CoinSupplyUpdateColumn>;\n  where?: InputMaybe<CoinSupplyBoolExp>;\n};\n\n/** Ordering options when selecting data from \"coin_supply\". */\nexport type CoinSupplyOrderBy = {\n  coin_type?: InputMaybe<OrderBy>;\n  coin_type_hash?: InputMaybe<OrderBy>;\n  inserted_at?: InputMaybe<OrderBy>;\n  supply?: InputMaybe<OrderBy>;\n  transaction_epoch?: InputMaybe<OrderBy>;\n  transaction_timestamp?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n};\n\n/** primary key columns input for table: coin_supply */\nexport type CoinSupplyPkColumnsInput = {\n  coin_type_hash: Scalars[\"String\"][\"input\"];\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\n/** select columns of table \"coin_supply\" */\nexport enum CoinSupplySelectColumn {\n  /** column name */\n  CoinType = \"coin_type\",\n  /** column name */\n  CoinTypeHash = \"coin_type_hash\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  Supply = \"supply\",\n  /** column name */\n  TransactionEpoch = \"transaction_epoch\",\n  /** column name */\n  TransactionTimestamp = \"transaction_timestamp\",\n  /** column name */\n  TransactionVersion = \"transaction_version\",\n}\n\n/** input type for updating data in table \"coin_supply\" */\nexport type CoinSupplySetInput = {\n  coin_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  coin_type_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  supply?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  transaction_epoch?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** aggregate stddev on columns */\nexport type CoinSupplyStddevFields = {\n  supply?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_epoch?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_pop on columns */\nexport type CoinSupplyStddevPopFields = {\n  supply?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_epoch?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_samp on columns */\nexport type CoinSupplyStddevSampFields = {\n  supply?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_epoch?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Streaming cursor of the table \"coin_supply\" */\nexport type CoinSupplyStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: CoinSupplyStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type CoinSupplyStreamCursorValueInput = {\n  coin_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  coin_type_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  supply?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  transaction_epoch?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** aggregate sum on columns */\nexport type CoinSupplySumFields = {\n  supply?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  transaction_epoch?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** update columns of table \"coin_supply\" */\nexport enum CoinSupplyUpdateColumn {\n  /** column name */\n  CoinType = \"coin_type\",\n  /** column name */\n  CoinTypeHash = \"coin_type_hash\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  Supply = \"supply\",\n  /** column name */\n  TransactionEpoch = \"transaction_epoch\",\n  /** column name */\n  TransactionTimestamp = \"transaction_timestamp\",\n  /** column name */\n  TransactionVersion = \"transaction_version\",\n}\n\nexport type CoinSupplyUpdates = {\n  /** increments the numeric columns with given value of the filtered values */\n  _inc?: InputMaybe<CoinSupplyIncInput>;\n  /** sets the columns of the filtered rows to the given values */\n  _set?: InputMaybe<CoinSupplySetInput>;\n  /** filter the rows which have to be updated */\n  where: CoinSupplyBoolExp;\n};\n\n/** aggregate var_pop on columns */\nexport type CoinSupplyVarPopFields = {\n  supply?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_epoch?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate var_samp on columns */\nexport type CoinSupplyVarSampFields = {\n  supply?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_epoch?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate variance on columns */\nexport type CoinSupplyVarianceFields = {\n  supply?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_epoch?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** columns and relationships of \"collection_datas\" */\nexport type CollectionDatas = {\n  collection_data_id_hash: Scalars[\"String\"][\"output\"];\n  collection_name: Scalars[\"String\"][\"output\"];\n  creator_address: Scalars[\"String\"][\"output\"];\n  description: Scalars[\"String\"][\"output\"];\n  description_mutable: Scalars[\"Boolean\"][\"output\"];\n  inserted_at: Scalars[\"timestamp\"][\"output\"];\n  maximum: Scalars[\"numeric\"][\"output\"];\n  maximum_mutable: Scalars[\"Boolean\"][\"output\"];\n  metadata_uri: Scalars[\"String\"][\"output\"];\n  supply: Scalars[\"numeric\"][\"output\"];\n  table_handle: Scalars[\"String\"][\"output\"];\n  transaction_timestamp: Scalars[\"timestamp\"][\"output\"];\n  transaction_version: Scalars[\"bigint\"][\"output\"];\n  uri_mutable: Scalars[\"Boolean\"][\"output\"];\n};\n\n/** aggregated selection of \"collection_datas\" */\nexport type CollectionDatasAggregate = {\n  aggregate?: Maybe<CollectionDatasAggregateFields>;\n  nodes: Array<CollectionDatas>;\n};\n\n/** aggregate fields of \"collection_datas\" */\nexport type CollectionDatasAggregateFields = {\n  avg?: Maybe<CollectionDatasAvgFields>;\n  count: Scalars[\"Int\"][\"output\"];\n  max?: Maybe<CollectionDatasMaxFields>;\n  min?: Maybe<CollectionDatasMinFields>;\n  stddev?: Maybe<CollectionDatasStddevFields>;\n  stddev_pop?: Maybe<CollectionDatasStddevPopFields>;\n  stddev_samp?: Maybe<CollectionDatasStddevSampFields>;\n  sum?: Maybe<CollectionDatasSumFields>;\n  var_pop?: Maybe<CollectionDatasVarPopFields>;\n  var_samp?: Maybe<CollectionDatasVarSampFields>;\n  variance?: Maybe<CollectionDatasVarianceFields>;\n};\n\n/** aggregate fields of \"collection_datas\" */\nexport type CollectionDatasAggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<CollectionDatasSelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** aggregate avg on columns */\nexport type CollectionDatasAvgFields = {\n  maximum?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  supply?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Boolean expression to filter rows from the table \"collection_datas\". All fields are combined with a logical 'AND'. */\nexport type CollectionDatasBoolExp = {\n  _and?: InputMaybe<Array<CollectionDatasBoolExp>>;\n  _not?: InputMaybe<CollectionDatasBoolExp>;\n  _or?: InputMaybe<Array<CollectionDatasBoolExp>>;\n  collection_data_id_hash?: InputMaybe<StringComparisonExp>;\n  collection_name?: InputMaybe<StringComparisonExp>;\n  creator_address?: InputMaybe<StringComparisonExp>;\n  description?: InputMaybe<StringComparisonExp>;\n  description_mutable?: InputMaybe<BooleanComparisonExp>;\n  inserted_at?: InputMaybe<TimestampComparisonExp>;\n  maximum?: InputMaybe<NumericComparisonExp>;\n  maximum_mutable?: InputMaybe<BooleanComparisonExp>;\n  metadata_uri?: InputMaybe<StringComparisonExp>;\n  supply?: InputMaybe<NumericComparisonExp>;\n  table_handle?: InputMaybe<StringComparisonExp>;\n  transaction_timestamp?: InputMaybe<TimestampComparisonExp>;\n  transaction_version?: InputMaybe<BigintComparisonExp>;\n  uri_mutable?: InputMaybe<BooleanComparisonExp>;\n};\n\n/** unique or primary key constraints on table \"collection_datas\" */\nexport enum CollectionDatasConstraint {\n  /** unique or primary key constraint on columns \"collection_data_id_hash\", \"transaction_version\" */\n  CollectionDatasPkey = \"collection_datas_pkey\",\n}\n\n/** input type for incrementing numeric columns in table \"collection_datas\" */\nexport type CollectionDatasIncInput = {\n  maximum?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  supply?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** input type for inserting data into table \"collection_datas\" */\nexport type CollectionDatasInsertInput = {\n  collection_data_id_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  collection_name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  creator_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  description?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  description_mutable?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  maximum?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  maximum_mutable?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  metadata_uri?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  supply?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  table_handle?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  uri_mutable?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** aggregate max on columns */\nexport type CollectionDatasMaxFields = {\n  collection_data_id_hash?: Maybe<Scalars[\"String\"][\"output\"]>;\n  collection_name?: Maybe<Scalars[\"String\"][\"output\"]>;\n  creator_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  description?: Maybe<Scalars[\"String\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  maximum?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  metadata_uri?: Maybe<Scalars[\"String\"][\"output\"]>;\n  supply?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  table_handle?: Maybe<Scalars[\"String\"][\"output\"]>;\n  transaction_timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** aggregate min on columns */\nexport type CollectionDatasMinFields = {\n  collection_data_id_hash?: Maybe<Scalars[\"String\"][\"output\"]>;\n  collection_name?: Maybe<Scalars[\"String\"][\"output\"]>;\n  creator_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  description?: Maybe<Scalars[\"String\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  maximum?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  metadata_uri?: Maybe<Scalars[\"String\"][\"output\"]>;\n  supply?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  table_handle?: Maybe<Scalars[\"String\"][\"output\"]>;\n  transaction_timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** response of any mutation on the table \"collection_datas\" */\nexport type CollectionDatasMutationResponse = {\n  /** number of rows affected by the mutation */\n  affected_rows: Scalars[\"Int\"][\"output\"];\n  /** data from the rows affected by the mutation */\n  returning: Array<CollectionDatas>;\n};\n\n/** on_conflict condition type for table \"collection_datas\" */\nexport type CollectionDatasOnConflict = {\n  constraint: CollectionDatasConstraint;\n  update_columns?: Array<CollectionDatasUpdateColumn>;\n  where?: InputMaybe<CollectionDatasBoolExp>;\n};\n\n/** Ordering options when selecting data from \"collection_datas\". */\nexport type CollectionDatasOrderBy = {\n  collection_data_id_hash?: InputMaybe<OrderBy>;\n  collection_name?: InputMaybe<OrderBy>;\n  creator_address?: InputMaybe<OrderBy>;\n  description?: InputMaybe<OrderBy>;\n  description_mutable?: InputMaybe<OrderBy>;\n  inserted_at?: InputMaybe<OrderBy>;\n  maximum?: InputMaybe<OrderBy>;\n  maximum_mutable?: InputMaybe<OrderBy>;\n  metadata_uri?: InputMaybe<OrderBy>;\n  supply?: InputMaybe<OrderBy>;\n  table_handle?: InputMaybe<OrderBy>;\n  transaction_timestamp?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n  uri_mutable?: InputMaybe<OrderBy>;\n};\n\n/** primary key columns input for table: collection_datas */\nexport type CollectionDatasPkColumnsInput = {\n  collection_data_id_hash: Scalars[\"String\"][\"input\"];\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\n/** select columns of table \"collection_datas\" */\nexport enum CollectionDatasSelectColumn {\n  /** column name */\n  CollectionDataIdHash = \"collection_data_id_hash\",\n  /** column name */\n  CollectionName = \"collection_name\",\n  /** column name */\n  CreatorAddress = \"creator_address\",\n  /** column name */\n  Description = \"description\",\n  /** column name */\n  DescriptionMutable = \"description_mutable\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  Maximum = \"maximum\",\n  /** column name */\n  MaximumMutable = \"maximum_mutable\",\n  /** column name */\n  MetadataUri = \"metadata_uri\",\n  /** column name */\n  Supply = \"supply\",\n  /** column name */\n  TableHandle = \"table_handle\",\n  /** column name */\n  TransactionTimestamp = \"transaction_timestamp\",\n  /** column name */\n  TransactionVersion = \"transaction_version\",\n  /** column name */\n  UriMutable = \"uri_mutable\",\n}\n\n/** input type for updating data in table \"collection_datas\" */\nexport type CollectionDatasSetInput = {\n  collection_data_id_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  collection_name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  creator_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  description?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  description_mutable?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  maximum?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  maximum_mutable?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  metadata_uri?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  supply?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  table_handle?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  uri_mutable?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** aggregate stddev on columns */\nexport type CollectionDatasStddevFields = {\n  maximum?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  supply?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_pop on columns */\nexport type CollectionDatasStddevPopFields = {\n  maximum?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  supply?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_samp on columns */\nexport type CollectionDatasStddevSampFields = {\n  maximum?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  supply?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Streaming cursor of the table \"collection_datas\" */\nexport type CollectionDatasStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: CollectionDatasStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type CollectionDatasStreamCursorValueInput = {\n  collection_data_id_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  collection_name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  creator_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  description?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  description_mutable?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  maximum?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  maximum_mutable?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  metadata_uri?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  supply?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  table_handle?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  uri_mutable?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** aggregate sum on columns */\nexport type CollectionDatasSumFields = {\n  maximum?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  supply?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** update columns of table \"collection_datas\" */\nexport enum CollectionDatasUpdateColumn {\n  /** column name */\n  CollectionDataIdHash = \"collection_data_id_hash\",\n  /** column name */\n  CollectionName = \"collection_name\",\n  /** column name */\n  CreatorAddress = \"creator_address\",\n  /** column name */\n  Description = \"description\",\n  /** column name */\n  DescriptionMutable = \"description_mutable\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  Maximum = \"maximum\",\n  /** column name */\n  MaximumMutable = \"maximum_mutable\",\n  /** column name */\n  MetadataUri = \"metadata_uri\",\n  /** column name */\n  Supply = \"supply\",\n  /** column name */\n  TableHandle = \"table_handle\",\n  /** column name */\n  TransactionTimestamp = \"transaction_timestamp\",\n  /** column name */\n  TransactionVersion = \"transaction_version\",\n  /** column name */\n  UriMutable = \"uri_mutable\",\n}\n\nexport type CollectionDatasUpdates = {\n  /** increments the numeric columns with given value of the filtered values */\n  _inc?: InputMaybe<CollectionDatasIncInput>;\n  /** sets the columns of the filtered rows to the given values */\n  _set?: InputMaybe<CollectionDatasSetInput>;\n  /** filter the rows which have to be updated */\n  where: CollectionDatasBoolExp;\n};\n\n/** aggregate var_pop on columns */\nexport type CollectionDatasVarPopFields = {\n  maximum?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  supply?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate var_samp on columns */\nexport type CollectionDatasVarSampFields = {\n  maximum?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  supply?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate variance on columns */\nexport type CollectionDatasVarianceFields = {\n  maximum?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  supply?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** columns and relationships of \"collections_v2\" */\nexport type CollectionsV2 = {\n  collection_id: Scalars[\"String\"][\"output\"];\n  collection_name: Scalars[\"String\"][\"output\"];\n  collection_properties?: Maybe<Scalars[\"jsonb\"][\"output\"]>;\n  creator_address: Scalars[\"String\"][\"output\"];\n  current_supply: Scalars[\"numeric\"][\"output\"];\n  description: Scalars[\"String\"][\"output\"];\n  inserted_at: Scalars[\"timestamp\"][\"output\"];\n  max_supply?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  mutable_description?: Maybe<Scalars[\"Boolean\"][\"output\"]>;\n  mutable_uri?: Maybe<Scalars[\"Boolean\"][\"output\"]>;\n  table_handle_v1?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_standard: Scalars[\"String\"][\"output\"];\n  total_minted_v2?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  transaction_timestamp: Scalars[\"timestamp\"][\"output\"];\n  transaction_version: Scalars[\"bigint\"][\"output\"];\n  uri: Scalars[\"String\"][\"output\"];\n  write_set_change_index: Scalars[\"bigint\"][\"output\"];\n};\n\n/** columns and relationships of \"collections_v2\" */\nexport type CollectionsV2CollectionPropertiesArgs = {\n  path?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregated selection of \"collections_v2\" */\nexport type CollectionsV2Aggregate = {\n  aggregate?: Maybe<CollectionsV2AggregateFields>;\n  nodes: Array<CollectionsV2>;\n};\n\n/** aggregate fields of \"collections_v2\" */\nexport type CollectionsV2AggregateFields = {\n  avg?: Maybe<CollectionsV2AvgFields>;\n  count: Scalars[\"Int\"][\"output\"];\n  max?: Maybe<CollectionsV2MaxFields>;\n  min?: Maybe<CollectionsV2MinFields>;\n  stddev?: Maybe<CollectionsV2StddevFields>;\n  stddev_pop?: Maybe<CollectionsV2StddevPopFields>;\n  stddev_samp?: Maybe<CollectionsV2StddevSampFields>;\n  sum?: Maybe<CollectionsV2SumFields>;\n  var_pop?: Maybe<CollectionsV2VarPopFields>;\n  var_samp?: Maybe<CollectionsV2VarSampFields>;\n  variance?: Maybe<CollectionsV2VarianceFields>;\n};\n\n/** aggregate fields of \"collections_v2\" */\nexport type CollectionsV2AggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<CollectionsV2SelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** append existing jsonb value of filtered columns with new jsonb value */\nexport type CollectionsV2AppendInput = {\n  collection_properties?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n};\n\n/** aggregate avg on columns */\nexport type CollectionsV2AvgFields = {\n  current_supply?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  max_supply?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  total_minted_v2?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Boolean expression to filter rows from the table \"collections_v2\". All fields are combined with a logical 'AND'. */\nexport type CollectionsV2BoolExp = {\n  _and?: InputMaybe<Array<CollectionsV2BoolExp>>;\n  _not?: InputMaybe<CollectionsV2BoolExp>;\n  _or?: InputMaybe<Array<CollectionsV2BoolExp>>;\n  collection_id?: InputMaybe<StringComparisonExp>;\n  collection_name?: InputMaybe<StringComparisonExp>;\n  collection_properties?: InputMaybe<JsonbComparisonExp>;\n  creator_address?: InputMaybe<StringComparisonExp>;\n  current_supply?: InputMaybe<NumericComparisonExp>;\n  description?: InputMaybe<StringComparisonExp>;\n  inserted_at?: InputMaybe<TimestampComparisonExp>;\n  max_supply?: InputMaybe<NumericComparisonExp>;\n  mutable_description?: InputMaybe<BooleanComparisonExp>;\n  mutable_uri?: InputMaybe<BooleanComparisonExp>;\n  table_handle_v1?: InputMaybe<StringComparisonExp>;\n  token_standard?: InputMaybe<StringComparisonExp>;\n  total_minted_v2?: InputMaybe<NumericComparisonExp>;\n  transaction_timestamp?: InputMaybe<TimestampComparisonExp>;\n  transaction_version?: InputMaybe<BigintComparisonExp>;\n  uri?: InputMaybe<StringComparisonExp>;\n  write_set_change_index?: InputMaybe<BigintComparisonExp>;\n};\n\n/** unique or primary key constraints on table \"collections_v2\" */\nexport enum CollectionsV2Constraint {\n  /** unique or primary key constraint on columns \"write_set_change_index\", \"transaction_version\" */\n  CollectionsV2Pkey = \"collections_v2_pkey\",\n}\n\n/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */\nexport type CollectionsV2DeleteAtPathInput = {\n  collection_properties?: InputMaybe<Array<Scalars[\"String\"][\"input\"]>>;\n};\n\n/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */\nexport type CollectionsV2DeleteElemInput = {\n  collection_properties?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n};\n\n/** delete key/value pair or string element. key/value pairs are matched based on their key value */\nexport type CollectionsV2DeleteKeyInput = {\n  collection_properties?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** input type for incrementing numeric columns in table \"collections_v2\" */\nexport type CollectionsV2IncInput = {\n  current_supply?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  max_supply?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  total_minted_v2?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  write_set_change_index?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** input type for inserting data into table \"collections_v2\" */\nexport type CollectionsV2InsertInput = {\n  collection_id?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  collection_name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  collection_properties?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  creator_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  current_supply?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  description?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  max_supply?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  mutable_description?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  mutable_uri?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  table_handle_v1?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_standard?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  total_minted_v2?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  uri?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  write_set_change_index?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** aggregate max on columns */\nexport type CollectionsV2MaxFields = {\n  collection_id?: Maybe<Scalars[\"String\"][\"output\"]>;\n  collection_name?: Maybe<Scalars[\"String\"][\"output\"]>;\n  creator_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  current_supply?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  description?: Maybe<Scalars[\"String\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  max_supply?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  table_handle_v1?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_standard?: Maybe<Scalars[\"String\"][\"output\"]>;\n  total_minted_v2?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  transaction_timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  uri?: Maybe<Scalars[\"String\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** aggregate min on columns */\nexport type CollectionsV2MinFields = {\n  collection_id?: Maybe<Scalars[\"String\"][\"output\"]>;\n  collection_name?: Maybe<Scalars[\"String\"][\"output\"]>;\n  creator_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  current_supply?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  description?: Maybe<Scalars[\"String\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  max_supply?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  table_handle_v1?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_standard?: Maybe<Scalars[\"String\"][\"output\"]>;\n  total_minted_v2?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  transaction_timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  uri?: Maybe<Scalars[\"String\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** response of any mutation on the table \"collections_v2\" */\nexport type CollectionsV2MutationResponse = {\n  /** number of rows affected by the mutation */\n  affected_rows: Scalars[\"Int\"][\"output\"];\n  /** data from the rows affected by the mutation */\n  returning: Array<CollectionsV2>;\n};\n\n/** on_conflict condition type for table \"collections_v2\" */\nexport type CollectionsV2OnConflict = {\n  constraint: CollectionsV2Constraint;\n  update_columns?: Array<CollectionsV2UpdateColumn>;\n  where?: InputMaybe<CollectionsV2BoolExp>;\n};\n\n/** Ordering options when selecting data from \"collections_v2\". */\nexport type CollectionsV2OrderBy = {\n  collection_id?: InputMaybe<OrderBy>;\n  collection_name?: InputMaybe<OrderBy>;\n  collection_properties?: InputMaybe<OrderBy>;\n  creator_address?: InputMaybe<OrderBy>;\n  current_supply?: InputMaybe<OrderBy>;\n  description?: InputMaybe<OrderBy>;\n  inserted_at?: InputMaybe<OrderBy>;\n  max_supply?: InputMaybe<OrderBy>;\n  mutable_description?: InputMaybe<OrderBy>;\n  mutable_uri?: InputMaybe<OrderBy>;\n  table_handle_v1?: InputMaybe<OrderBy>;\n  token_standard?: InputMaybe<OrderBy>;\n  total_minted_v2?: InputMaybe<OrderBy>;\n  transaction_timestamp?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n  uri?: InputMaybe<OrderBy>;\n  write_set_change_index?: InputMaybe<OrderBy>;\n};\n\n/** primary key columns input for table: collections_v2 */\nexport type CollectionsV2PkColumnsInput = {\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n  write_set_change_index: Scalars[\"bigint\"][\"input\"];\n};\n\n/** prepend existing jsonb value of filtered columns with new jsonb value */\nexport type CollectionsV2PrependInput = {\n  collection_properties?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n};\n\n/** select columns of table \"collections_v2\" */\nexport enum CollectionsV2SelectColumn {\n  /** column name */\n  CollectionId = \"collection_id\",\n  /** column name */\n  CollectionName = \"collection_name\",\n  /** column name */\n  CollectionProperties = \"collection_properties\",\n  /** column name */\n  CreatorAddress = \"creator_address\",\n  /** column name */\n  CurrentSupply = \"current_supply\",\n  /** column name */\n  Description = \"description\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  MaxSupply = \"max_supply\",\n  /** column name */\n  MutableDescription = \"mutable_description\",\n  /** column name */\n  MutableUri = \"mutable_uri\",\n  /** column name */\n  TableHandleV1 = \"table_handle_v1\",\n  /** column name */\n  TokenStandard = \"token_standard\",\n  /** column name */\n  TotalMintedV2 = \"total_minted_v2\",\n  /** column name */\n  TransactionTimestamp = \"transaction_timestamp\",\n  /** column name */\n  TransactionVersion = \"transaction_version\",\n  /** column name */\n  Uri = \"uri\",\n  /** column name */\n  WriteSetChangeIndex = \"write_set_change_index\",\n}\n\n/** input type for updating data in table \"collections_v2\" */\nexport type CollectionsV2SetInput = {\n  collection_id?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  collection_name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  collection_properties?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  creator_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  current_supply?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  description?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  max_supply?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  mutable_description?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  mutable_uri?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  table_handle_v1?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_standard?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  total_minted_v2?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  uri?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  write_set_change_index?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** aggregate stddev on columns */\nexport type CollectionsV2StddevFields = {\n  current_supply?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  max_supply?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  total_minted_v2?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_pop on columns */\nexport type CollectionsV2StddevPopFields = {\n  current_supply?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  max_supply?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  total_minted_v2?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_samp on columns */\nexport type CollectionsV2StddevSampFields = {\n  current_supply?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  max_supply?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  total_minted_v2?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Streaming cursor of the table \"collections_v2\" */\nexport type CollectionsV2StreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: CollectionsV2StreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type CollectionsV2StreamCursorValueInput = {\n  collection_id?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  collection_name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  collection_properties?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  creator_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  current_supply?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  description?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  max_supply?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  mutable_description?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  mutable_uri?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  table_handle_v1?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_standard?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  total_minted_v2?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  uri?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  write_set_change_index?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** aggregate sum on columns */\nexport type CollectionsV2SumFields = {\n  current_supply?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  max_supply?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  total_minted_v2?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** update columns of table \"collections_v2\" */\nexport enum CollectionsV2UpdateColumn {\n  /** column name */\n  CollectionId = \"collection_id\",\n  /** column name */\n  CollectionName = \"collection_name\",\n  /** column name */\n  CollectionProperties = \"collection_properties\",\n  /** column name */\n  CreatorAddress = \"creator_address\",\n  /** column name */\n  CurrentSupply = \"current_supply\",\n  /** column name */\n  Description = \"description\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  MaxSupply = \"max_supply\",\n  /** column name */\n  MutableDescription = \"mutable_description\",\n  /** column name */\n  MutableUri = \"mutable_uri\",\n  /** column name */\n  TableHandleV1 = \"table_handle_v1\",\n  /** column name */\n  TokenStandard = \"token_standard\",\n  /** column name */\n  TotalMintedV2 = \"total_minted_v2\",\n  /** column name */\n  TransactionTimestamp = \"transaction_timestamp\",\n  /** column name */\n  TransactionVersion = \"transaction_version\",\n  /** column name */\n  Uri = \"uri\",\n  /** column name */\n  WriteSetChangeIndex = \"write_set_change_index\",\n}\n\nexport type CollectionsV2Updates = {\n  /** append existing jsonb value of filtered columns with new jsonb value */\n  _append?: InputMaybe<CollectionsV2AppendInput>;\n  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */\n  _delete_at_path?: InputMaybe<CollectionsV2DeleteAtPathInput>;\n  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */\n  _delete_elem?: InputMaybe<CollectionsV2DeleteElemInput>;\n  /** delete key/value pair or string element. key/value pairs are matched based on their key value */\n  _delete_key?: InputMaybe<CollectionsV2DeleteKeyInput>;\n  /** increments the numeric columns with given value of the filtered values */\n  _inc?: InputMaybe<CollectionsV2IncInput>;\n  /** prepend existing jsonb value of filtered columns with new jsonb value */\n  _prepend?: InputMaybe<CollectionsV2PrependInput>;\n  /** sets the columns of the filtered rows to the given values */\n  _set?: InputMaybe<CollectionsV2SetInput>;\n  /** filter the rows which have to be updated */\n  where: CollectionsV2BoolExp;\n};\n\n/** aggregate var_pop on columns */\nexport type CollectionsV2VarPopFields = {\n  current_supply?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  max_supply?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  total_minted_v2?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate var_samp on columns */\nexport type CollectionsV2VarSampFields = {\n  current_supply?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  max_supply?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  total_minted_v2?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate variance on columns */\nexport type CollectionsV2VarianceFields = {\n  current_supply?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  max_supply?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  total_minted_v2?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** columns and relationships of \"current_ans_lookup\" */\nexport type CurrentAnsLookup = {\n  domain: Scalars[\"String\"][\"output\"];\n  expiration_timestamp: Scalars[\"timestamp\"][\"output\"];\n  inserted_at: Scalars[\"timestamp\"][\"output\"];\n  is_deleted: Scalars[\"Boolean\"][\"output\"];\n  last_transaction_version: Scalars[\"bigint\"][\"output\"];\n  registered_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  subdomain: Scalars[\"String\"][\"output\"];\n  token_name: Scalars[\"String\"][\"output\"];\n};\n\n/** aggregated selection of \"current_ans_lookup\" */\nexport type CurrentAnsLookupAggregate = {\n  aggregate?: Maybe<CurrentAnsLookupAggregateFields>;\n  nodes: Array<CurrentAnsLookup>;\n};\n\n/** aggregate fields of \"current_ans_lookup\" */\nexport type CurrentAnsLookupAggregateFields = {\n  avg?: Maybe<CurrentAnsLookupAvgFields>;\n  count: Scalars[\"Int\"][\"output\"];\n  max?: Maybe<CurrentAnsLookupMaxFields>;\n  min?: Maybe<CurrentAnsLookupMinFields>;\n  stddev?: Maybe<CurrentAnsLookupStddevFields>;\n  stddev_pop?: Maybe<CurrentAnsLookupStddevPopFields>;\n  stddev_samp?: Maybe<CurrentAnsLookupStddevSampFields>;\n  sum?: Maybe<CurrentAnsLookupSumFields>;\n  var_pop?: Maybe<CurrentAnsLookupVarPopFields>;\n  var_samp?: Maybe<CurrentAnsLookupVarSampFields>;\n  variance?: Maybe<CurrentAnsLookupVarianceFields>;\n};\n\n/** aggregate fields of \"current_ans_lookup\" */\nexport type CurrentAnsLookupAggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<CurrentAnsLookupSelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** aggregate avg on columns */\nexport type CurrentAnsLookupAvgFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Boolean expression to filter rows from the table \"current_ans_lookup\". All fields are combined with a logical 'AND'. */\nexport type CurrentAnsLookupBoolExp = {\n  _and?: InputMaybe<Array<CurrentAnsLookupBoolExp>>;\n  _not?: InputMaybe<CurrentAnsLookupBoolExp>;\n  _or?: InputMaybe<Array<CurrentAnsLookupBoolExp>>;\n  domain?: InputMaybe<StringComparisonExp>;\n  expiration_timestamp?: InputMaybe<TimestampComparisonExp>;\n  inserted_at?: InputMaybe<TimestampComparisonExp>;\n  is_deleted?: InputMaybe<BooleanComparisonExp>;\n  last_transaction_version?: InputMaybe<BigintComparisonExp>;\n  registered_address?: InputMaybe<StringComparisonExp>;\n  subdomain?: InputMaybe<StringComparisonExp>;\n  token_name?: InputMaybe<StringComparisonExp>;\n};\n\n/** unique or primary key constraints on table \"current_ans_lookup\" */\nexport enum CurrentAnsLookupConstraint {\n  /** unique or primary key constraint on columns \"domain\", \"subdomain\" */\n  CurrentAnsLookupPkey = \"current_ans_lookup_pkey\",\n}\n\n/** input type for incrementing numeric columns in table \"current_ans_lookup\" */\nexport type CurrentAnsLookupIncInput = {\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** input type for inserting data into table \"current_ans_lookup\" */\nexport type CurrentAnsLookupInsertInput = {\n  domain?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  expiration_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  is_deleted?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  registered_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  subdomain?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate max on columns */\nexport type CurrentAnsLookupMaxFields = {\n  domain?: Maybe<Scalars[\"String\"][\"output\"]>;\n  expiration_timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  registered_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  subdomain?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_name?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** aggregate min on columns */\nexport type CurrentAnsLookupMinFields = {\n  domain?: Maybe<Scalars[\"String\"][\"output\"]>;\n  expiration_timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  registered_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  subdomain?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_name?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** response of any mutation on the table \"current_ans_lookup\" */\nexport type CurrentAnsLookupMutationResponse = {\n  /** number of rows affected by the mutation */\n  affected_rows: Scalars[\"Int\"][\"output\"];\n  /** data from the rows affected by the mutation */\n  returning: Array<CurrentAnsLookup>;\n};\n\n/** on_conflict condition type for table \"current_ans_lookup\" */\nexport type CurrentAnsLookupOnConflict = {\n  constraint: CurrentAnsLookupConstraint;\n  update_columns?: Array<CurrentAnsLookupUpdateColumn>;\n  where?: InputMaybe<CurrentAnsLookupBoolExp>;\n};\n\n/** Ordering options when selecting data from \"current_ans_lookup\". */\nexport type CurrentAnsLookupOrderBy = {\n  domain?: InputMaybe<OrderBy>;\n  expiration_timestamp?: InputMaybe<OrderBy>;\n  inserted_at?: InputMaybe<OrderBy>;\n  is_deleted?: InputMaybe<OrderBy>;\n  last_transaction_version?: InputMaybe<OrderBy>;\n  registered_address?: InputMaybe<OrderBy>;\n  subdomain?: InputMaybe<OrderBy>;\n  token_name?: InputMaybe<OrderBy>;\n};\n\n/** primary key columns input for table: current_ans_lookup */\nexport type CurrentAnsLookupPkColumnsInput = {\n  domain: Scalars[\"String\"][\"input\"];\n  subdomain: Scalars[\"String\"][\"input\"];\n};\n\n/** select columns of table \"current_ans_lookup\" */\nexport enum CurrentAnsLookupSelectColumn {\n  /** column name */\n  Domain = \"domain\",\n  /** column name */\n  ExpirationTimestamp = \"expiration_timestamp\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  IsDeleted = \"is_deleted\",\n  /** column name */\n  LastTransactionVersion = \"last_transaction_version\",\n  /** column name */\n  RegisteredAddress = \"registered_address\",\n  /** column name */\n  Subdomain = \"subdomain\",\n  /** column name */\n  TokenName = \"token_name\",\n}\n\n/** input type for updating data in table \"current_ans_lookup\" */\nexport type CurrentAnsLookupSetInput = {\n  domain?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  expiration_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  is_deleted?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  registered_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  subdomain?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate stddev on columns */\nexport type CurrentAnsLookupStddevFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_pop on columns */\nexport type CurrentAnsLookupStddevPopFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_samp on columns */\nexport type CurrentAnsLookupStddevSampFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Streaming cursor of the table \"current_ans_lookup\" */\nexport type CurrentAnsLookupStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: CurrentAnsLookupStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type CurrentAnsLookupStreamCursorValueInput = {\n  domain?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  expiration_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  is_deleted?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  registered_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  subdomain?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate sum on columns */\nexport type CurrentAnsLookupSumFields = {\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** update columns of table \"current_ans_lookup\" */\nexport enum CurrentAnsLookupUpdateColumn {\n  /** column name */\n  Domain = \"domain\",\n  /** column name */\n  ExpirationTimestamp = \"expiration_timestamp\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  IsDeleted = \"is_deleted\",\n  /** column name */\n  LastTransactionVersion = \"last_transaction_version\",\n  /** column name */\n  RegisteredAddress = \"registered_address\",\n  /** column name */\n  Subdomain = \"subdomain\",\n  /** column name */\n  TokenName = \"token_name\",\n}\n\nexport type CurrentAnsLookupUpdates = {\n  /** increments the numeric columns with given value of the filtered values */\n  _inc?: InputMaybe<CurrentAnsLookupIncInput>;\n  /** sets the columns of the filtered rows to the given values */\n  _set?: InputMaybe<CurrentAnsLookupSetInput>;\n  /** filter the rows which have to be updated */\n  where: CurrentAnsLookupBoolExp;\n};\n\n/** columns and relationships of \"current_ans_lookup_v2\" */\nexport type CurrentAnsLookupV2 = {\n  domain: Scalars[\"String\"][\"output\"];\n  expiration_timestamp: Scalars[\"timestamp\"][\"output\"];\n  inserted_at: Scalars[\"timestamp\"][\"output\"];\n  is_deleted: Scalars[\"Boolean\"][\"output\"];\n  last_transaction_version: Scalars[\"bigint\"][\"output\"];\n  registered_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  subdomain: Scalars[\"String\"][\"output\"];\n  subdomain_expiration_policy?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  token_name?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_standard: Scalars[\"String\"][\"output\"];\n};\n\n/** aggregated selection of \"current_ans_lookup_v2\" */\nexport type CurrentAnsLookupV2Aggregate = {\n  aggregate?: Maybe<CurrentAnsLookupV2AggregateFields>;\n  nodes: Array<CurrentAnsLookupV2>;\n};\n\n/** aggregate fields of \"current_ans_lookup_v2\" */\nexport type CurrentAnsLookupV2AggregateFields = {\n  avg?: Maybe<CurrentAnsLookupV2AvgFields>;\n  count: Scalars[\"Int\"][\"output\"];\n  max?: Maybe<CurrentAnsLookupV2MaxFields>;\n  min?: Maybe<CurrentAnsLookupV2MinFields>;\n  stddev?: Maybe<CurrentAnsLookupV2StddevFields>;\n  stddev_pop?: Maybe<CurrentAnsLookupV2StddevPopFields>;\n  stddev_samp?: Maybe<CurrentAnsLookupV2StddevSampFields>;\n  sum?: Maybe<CurrentAnsLookupV2SumFields>;\n  var_pop?: Maybe<CurrentAnsLookupV2VarPopFields>;\n  var_samp?: Maybe<CurrentAnsLookupV2VarSampFields>;\n  variance?: Maybe<CurrentAnsLookupV2VarianceFields>;\n};\n\n/** aggregate fields of \"current_ans_lookup_v2\" */\nexport type CurrentAnsLookupV2AggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<CurrentAnsLookupV2SelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** aggregate avg on columns */\nexport type CurrentAnsLookupV2AvgFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  subdomain_expiration_policy?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Boolean expression to filter rows from the table \"current_ans_lookup_v2\". All fields are combined with a logical 'AND'. */\nexport type CurrentAnsLookupV2BoolExp = {\n  _and?: InputMaybe<Array<CurrentAnsLookupV2BoolExp>>;\n  _not?: InputMaybe<CurrentAnsLookupV2BoolExp>;\n  _or?: InputMaybe<Array<CurrentAnsLookupV2BoolExp>>;\n  domain?: InputMaybe<StringComparisonExp>;\n  expiration_timestamp?: InputMaybe<TimestampComparisonExp>;\n  inserted_at?: InputMaybe<TimestampComparisonExp>;\n  is_deleted?: InputMaybe<BooleanComparisonExp>;\n  last_transaction_version?: InputMaybe<BigintComparisonExp>;\n  registered_address?: InputMaybe<StringComparisonExp>;\n  subdomain?: InputMaybe<StringComparisonExp>;\n  subdomain_expiration_policy?: InputMaybe<BigintComparisonExp>;\n  token_name?: InputMaybe<StringComparisonExp>;\n  token_standard?: InputMaybe<StringComparisonExp>;\n};\n\n/** unique or primary key constraints on table \"current_ans_lookup_v2\" */\nexport enum CurrentAnsLookupV2Constraint {\n  /** unique or primary key constraint on columns \"domain\", \"token_standard\", \"subdomain\" */\n  CurrentAnsLookupV2Pkey = \"current_ans_lookup_v2_pkey\",\n}\n\n/** input type for incrementing numeric columns in table \"current_ans_lookup_v2\" */\nexport type CurrentAnsLookupV2IncInput = {\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  subdomain_expiration_policy?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** input type for inserting data into table \"current_ans_lookup_v2\" */\nexport type CurrentAnsLookupV2InsertInput = {\n  domain?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  expiration_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  is_deleted?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  registered_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  subdomain?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  subdomain_expiration_policy?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  token_name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_standard?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate max on columns */\nexport type CurrentAnsLookupV2MaxFields = {\n  domain?: Maybe<Scalars[\"String\"][\"output\"]>;\n  expiration_timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  registered_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  subdomain?: Maybe<Scalars[\"String\"][\"output\"]>;\n  subdomain_expiration_policy?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  token_name?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_standard?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** aggregate min on columns */\nexport type CurrentAnsLookupV2MinFields = {\n  domain?: Maybe<Scalars[\"String\"][\"output\"]>;\n  expiration_timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  registered_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  subdomain?: Maybe<Scalars[\"String\"][\"output\"]>;\n  subdomain_expiration_policy?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  token_name?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_standard?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** response of any mutation on the table \"current_ans_lookup_v2\" */\nexport type CurrentAnsLookupV2MutationResponse = {\n  /** number of rows affected by the mutation */\n  affected_rows: Scalars[\"Int\"][\"output\"];\n  /** data from the rows affected by the mutation */\n  returning: Array<CurrentAnsLookupV2>;\n};\n\n/** on_conflict condition type for table \"current_ans_lookup_v2\" */\nexport type CurrentAnsLookupV2OnConflict = {\n  constraint: CurrentAnsLookupV2Constraint;\n  update_columns?: Array<CurrentAnsLookupV2UpdateColumn>;\n  where?: InputMaybe<CurrentAnsLookupV2BoolExp>;\n};\n\n/** Ordering options when selecting data from \"current_ans_lookup_v2\". */\nexport type CurrentAnsLookupV2OrderBy = {\n  domain?: InputMaybe<OrderBy>;\n  expiration_timestamp?: InputMaybe<OrderBy>;\n  inserted_at?: InputMaybe<OrderBy>;\n  is_deleted?: InputMaybe<OrderBy>;\n  last_transaction_version?: InputMaybe<OrderBy>;\n  registered_address?: InputMaybe<OrderBy>;\n  subdomain?: InputMaybe<OrderBy>;\n  subdomain_expiration_policy?: InputMaybe<OrderBy>;\n  token_name?: InputMaybe<OrderBy>;\n  token_standard?: InputMaybe<OrderBy>;\n};\n\n/** primary key columns input for table: current_ans_lookup_v2 */\nexport type CurrentAnsLookupV2PkColumnsInput = {\n  domain: Scalars[\"String\"][\"input\"];\n  subdomain: Scalars[\"String\"][\"input\"];\n  token_standard: Scalars[\"String\"][\"input\"];\n};\n\n/** select columns of table \"current_ans_lookup_v2\" */\nexport enum CurrentAnsLookupV2SelectColumn {\n  /** column name */\n  Domain = \"domain\",\n  /** column name */\n  ExpirationTimestamp = \"expiration_timestamp\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  IsDeleted = \"is_deleted\",\n  /** column name */\n  LastTransactionVersion = \"last_transaction_version\",\n  /** column name */\n  RegisteredAddress = \"registered_address\",\n  /** column name */\n  Subdomain = \"subdomain\",\n  /** column name */\n  SubdomainExpirationPolicy = \"subdomain_expiration_policy\",\n  /** column name */\n  TokenName = \"token_name\",\n  /** column name */\n  TokenStandard = \"token_standard\",\n}\n\n/** input type for updating data in table \"current_ans_lookup_v2\" */\nexport type CurrentAnsLookupV2SetInput = {\n  domain?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  expiration_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  is_deleted?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  registered_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  subdomain?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  subdomain_expiration_policy?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  token_name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_standard?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate stddev on columns */\nexport type CurrentAnsLookupV2StddevFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  subdomain_expiration_policy?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_pop on columns */\nexport type CurrentAnsLookupV2StddevPopFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  subdomain_expiration_policy?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_samp on columns */\nexport type CurrentAnsLookupV2StddevSampFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  subdomain_expiration_policy?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Streaming cursor of the table \"current_ans_lookup_v2\" */\nexport type CurrentAnsLookupV2StreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: CurrentAnsLookupV2StreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type CurrentAnsLookupV2StreamCursorValueInput = {\n  domain?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  expiration_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  is_deleted?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  registered_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  subdomain?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  subdomain_expiration_policy?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  token_name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_standard?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate sum on columns */\nexport type CurrentAnsLookupV2SumFields = {\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  subdomain_expiration_policy?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** update columns of table \"current_ans_lookup_v2\" */\nexport enum CurrentAnsLookupV2UpdateColumn {\n  /** column name */\n  Domain = \"domain\",\n  /** column name */\n  ExpirationTimestamp = \"expiration_timestamp\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  IsDeleted = \"is_deleted\",\n  /** column name */\n  LastTransactionVersion = \"last_transaction_version\",\n  /** column name */\n  RegisteredAddress = \"registered_address\",\n  /** column name */\n  Subdomain = \"subdomain\",\n  /** column name */\n  SubdomainExpirationPolicy = \"subdomain_expiration_policy\",\n  /** column name */\n  TokenName = \"token_name\",\n  /** column name */\n  TokenStandard = \"token_standard\",\n}\n\nexport type CurrentAnsLookupV2Updates = {\n  /** increments the numeric columns with given value of the filtered values */\n  _inc?: InputMaybe<CurrentAnsLookupV2IncInput>;\n  /** sets the columns of the filtered rows to the given values */\n  _set?: InputMaybe<CurrentAnsLookupV2SetInput>;\n  /** filter the rows which have to be updated */\n  where: CurrentAnsLookupV2BoolExp;\n};\n\n/** aggregate var_pop on columns */\nexport type CurrentAnsLookupV2VarPopFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  subdomain_expiration_policy?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate var_samp on columns */\nexport type CurrentAnsLookupV2VarSampFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  subdomain_expiration_policy?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate variance on columns */\nexport type CurrentAnsLookupV2VarianceFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  subdomain_expiration_policy?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate var_pop on columns */\nexport type CurrentAnsLookupVarPopFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate var_samp on columns */\nexport type CurrentAnsLookupVarSampFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate variance on columns */\nexport type CurrentAnsLookupVarianceFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** columns and relationships of \"current_ans_primary_name\" */\nexport type CurrentAnsPrimaryName = {\n  domain?: Maybe<Scalars[\"String\"][\"output\"]>;\n  inserted_at: Scalars[\"timestamp\"][\"output\"];\n  is_deleted: Scalars[\"Boolean\"][\"output\"];\n  last_transaction_version: Scalars[\"bigint\"][\"output\"];\n  registered_address: Scalars[\"String\"][\"output\"];\n  subdomain?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_name?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** aggregated selection of \"current_ans_primary_name\" */\nexport type CurrentAnsPrimaryNameAggregate = {\n  aggregate?: Maybe<CurrentAnsPrimaryNameAggregateFields>;\n  nodes: Array<CurrentAnsPrimaryName>;\n};\n\n/** aggregate fields of \"current_ans_primary_name\" */\nexport type CurrentAnsPrimaryNameAggregateFields = {\n  avg?: Maybe<CurrentAnsPrimaryNameAvgFields>;\n  count: Scalars[\"Int\"][\"output\"];\n  max?: Maybe<CurrentAnsPrimaryNameMaxFields>;\n  min?: Maybe<CurrentAnsPrimaryNameMinFields>;\n  stddev?: Maybe<CurrentAnsPrimaryNameStddevFields>;\n  stddev_pop?: Maybe<CurrentAnsPrimaryNameStddevPopFields>;\n  stddev_samp?: Maybe<CurrentAnsPrimaryNameStddevSampFields>;\n  sum?: Maybe<CurrentAnsPrimaryNameSumFields>;\n  var_pop?: Maybe<CurrentAnsPrimaryNameVarPopFields>;\n  var_samp?: Maybe<CurrentAnsPrimaryNameVarSampFields>;\n  variance?: Maybe<CurrentAnsPrimaryNameVarianceFields>;\n};\n\n/** aggregate fields of \"current_ans_primary_name\" */\nexport type CurrentAnsPrimaryNameAggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<CurrentAnsPrimaryNameSelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** aggregate avg on columns */\nexport type CurrentAnsPrimaryNameAvgFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Boolean expression to filter rows from the table \"current_ans_primary_name\". All fields are combined with a logical 'AND'. */\nexport type CurrentAnsPrimaryNameBoolExp = {\n  _and?: InputMaybe<Array<CurrentAnsPrimaryNameBoolExp>>;\n  _not?: InputMaybe<CurrentAnsPrimaryNameBoolExp>;\n  _or?: InputMaybe<Array<CurrentAnsPrimaryNameBoolExp>>;\n  domain?: InputMaybe<StringComparisonExp>;\n  inserted_at?: InputMaybe<TimestampComparisonExp>;\n  is_deleted?: InputMaybe<BooleanComparisonExp>;\n  last_transaction_version?: InputMaybe<BigintComparisonExp>;\n  registered_address?: InputMaybe<StringComparisonExp>;\n  subdomain?: InputMaybe<StringComparisonExp>;\n  token_name?: InputMaybe<StringComparisonExp>;\n};\n\n/** unique or primary key constraints on table \"current_ans_primary_name\" */\nexport enum CurrentAnsPrimaryNameConstraint {\n  /** unique or primary key constraint on columns \"registered_address\" */\n  CurrentAnsPrimaryNamePkey = \"current_ans_primary_name_pkey\",\n}\n\n/** input type for incrementing numeric columns in table \"current_ans_primary_name\" */\nexport type CurrentAnsPrimaryNameIncInput = {\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** input type for inserting data into table \"current_ans_primary_name\" */\nexport type CurrentAnsPrimaryNameInsertInput = {\n  domain?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  is_deleted?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  registered_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  subdomain?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate max on columns */\nexport type CurrentAnsPrimaryNameMaxFields = {\n  domain?: Maybe<Scalars[\"String\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  registered_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  subdomain?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_name?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** aggregate min on columns */\nexport type CurrentAnsPrimaryNameMinFields = {\n  domain?: Maybe<Scalars[\"String\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  registered_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  subdomain?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_name?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** response of any mutation on the table \"current_ans_primary_name\" */\nexport type CurrentAnsPrimaryNameMutationResponse = {\n  /** number of rows affected by the mutation */\n  affected_rows: Scalars[\"Int\"][\"output\"];\n  /** data from the rows affected by the mutation */\n  returning: Array<CurrentAnsPrimaryName>;\n};\n\n/** on_conflict condition type for table \"current_ans_primary_name\" */\nexport type CurrentAnsPrimaryNameOnConflict = {\n  constraint: CurrentAnsPrimaryNameConstraint;\n  update_columns?: Array<CurrentAnsPrimaryNameUpdateColumn>;\n  where?: InputMaybe<CurrentAnsPrimaryNameBoolExp>;\n};\n\n/** Ordering options when selecting data from \"current_ans_primary_name\". */\nexport type CurrentAnsPrimaryNameOrderBy = {\n  domain?: InputMaybe<OrderBy>;\n  inserted_at?: InputMaybe<OrderBy>;\n  is_deleted?: InputMaybe<OrderBy>;\n  last_transaction_version?: InputMaybe<OrderBy>;\n  registered_address?: InputMaybe<OrderBy>;\n  subdomain?: InputMaybe<OrderBy>;\n  token_name?: InputMaybe<OrderBy>;\n};\n\n/** primary key columns input for table: current_ans_primary_name */\nexport type CurrentAnsPrimaryNamePkColumnsInput = {\n  registered_address: Scalars[\"String\"][\"input\"];\n};\n\n/** select columns of table \"current_ans_primary_name\" */\nexport enum CurrentAnsPrimaryNameSelectColumn {\n  /** column name */\n  Domain = \"domain\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  IsDeleted = \"is_deleted\",\n  /** column name */\n  LastTransactionVersion = \"last_transaction_version\",\n  /** column name */\n  RegisteredAddress = \"registered_address\",\n  /** column name */\n  Subdomain = \"subdomain\",\n  /** column name */\n  TokenName = \"token_name\",\n}\n\n/** input type for updating data in table \"current_ans_primary_name\" */\nexport type CurrentAnsPrimaryNameSetInput = {\n  domain?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  is_deleted?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  registered_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  subdomain?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate stddev on columns */\nexport type CurrentAnsPrimaryNameStddevFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_pop on columns */\nexport type CurrentAnsPrimaryNameStddevPopFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_samp on columns */\nexport type CurrentAnsPrimaryNameStddevSampFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Streaming cursor of the table \"current_ans_primary_name\" */\nexport type CurrentAnsPrimaryNameStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: CurrentAnsPrimaryNameStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type CurrentAnsPrimaryNameStreamCursorValueInput = {\n  domain?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  is_deleted?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  registered_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  subdomain?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate sum on columns */\nexport type CurrentAnsPrimaryNameSumFields = {\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** update columns of table \"current_ans_primary_name\" */\nexport enum CurrentAnsPrimaryNameUpdateColumn {\n  /** column name */\n  Domain = \"domain\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  IsDeleted = \"is_deleted\",\n  /** column name */\n  LastTransactionVersion = \"last_transaction_version\",\n  /** column name */\n  RegisteredAddress = \"registered_address\",\n  /** column name */\n  Subdomain = \"subdomain\",\n  /** column name */\n  TokenName = \"token_name\",\n}\n\nexport type CurrentAnsPrimaryNameUpdates = {\n  /** increments the numeric columns with given value of the filtered values */\n  _inc?: InputMaybe<CurrentAnsPrimaryNameIncInput>;\n  /** sets the columns of the filtered rows to the given values */\n  _set?: InputMaybe<CurrentAnsPrimaryNameSetInput>;\n  /** filter the rows which have to be updated */\n  where: CurrentAnsPrimaryNameBoolExp;\n};\n\n/** columns and relationships of \"current_ans_primary_name_v2\" */\nexport type CurrentAnsPrimaryNameV2 = {\n  domain?: Maybe<Scalars[\"String\"][\"output\"]>;\n  inserted_at: Scalars[\"timestamp\"][\"output\"];\n  is_deleted: Scalars[\"Boolean\"][\"output\"];\n  last_transaction_version: Scalars[\"bigint\"][\"output\"];\n  registered_address: Scalars[\"String\"][\"output\"];\n  subdomain?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_name?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_standard: Scalars[\"String\"][\"output\"];\n};\n\n/** aggregated selection of \"current_ans_primary_name_v2\" */\nexport type CurrentAnsPrimaryNameV2Aggregate = {\n  aggregate?: Maybe<CurrentAnsPrimaryNameV2AggregateFields>;\n  nodes: Array<CurrentAnsPrimaryNameV2>;\n};\n\n/** aggregate fields of \"current_ans_primary_name_v2\" */\nexport type CurrentAnsPrimaryNameV2AggregateFields = {\n  avg?: Maybe<CurrentAnsPrimaryNameV2AvgFields>;\n  count: Scalars[\"Int\"][\"output\"];\n  max?: Maybe<CurrentAnsPrimaryNameV2MaxFields>;\n  min?: Maybe<CurrentAnsPrimaryNameV2MinFields>;\n  stddev?: Maybe<CurrentAnsPrimaryNameV2StddevFields>;\n  stddev_pop?: Maybe<CurrentAnsPrimaryNameV2StddevPopFields>;\n  stddev_samp?: Maybe<CurrentAnsPrimaryNameV2StddevSampFields>;\n  sum?: Maybe<CurrentAnsPrimaryNameV2SumFields>;\n  var_pop?: Maybe<CurrentAnsPrimaryNameV2VarPopFields>;\n  var_samp?: Maybe<CurrentAnsPrimaryNameV2VarSampFields>;\n  variance?: Maybe<CurrentAnsPrimaryNameV2VarianceFields>;\n};\n\n/** aggregate fields of \"current_ans_primary_name_v2\" */\nexport type CurrentAnsPrimaryNameV2AggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<CurrentAnsPrimaryNameV2SelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** aggregate avg on columns */\nexport type CurrentAnsPrimaryNameV2AvgFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Boolean expression to filter rows from the table \"current_ans_primary_name_v2\". All fields are combined with a logical 'AND'. */\nexport type CurrentAnsPrimaryNameV2BoolExp = {\n  _and?: InputMaybe<Array<CurrentAnsPrimaryNameV2BoolExp>>;\n  _not?: InputMaybe<CurrentAnsPrimaryNameV2BoolExp>;\n  _or?: InputMaybe<Array<CurrentAnsPrimaryNameV2BoolExp>>;\n  domain?: InputMaybe<StringComparisonExp>;\n  inserted_at?: InputMaybe<TimestampComparisonExp>;\n  is_deleted?: InputMaybe<BooleanComparisonExp>;\n  last_transaction_version?: InputMaybe<BigintComparisonExp>;\n  registered_address?: InputMaybe<StringComparisonExp>;\n  subdomain?: InputMaybe<StringComparisonExp>;\n  token_name?: InputMaybe<StringComparisonExp>;\n  token_standard?: InputMaybe<StringComparisonExp>;\n};\n\n/** unique or primary key constraints on table \"current_ans_primary_name_v2\" */\nexport enum CurrentAnsPrimaryNameV2Constraint {\n  /** unique or primary key constraint on columns \"token_standard\", \"registered_address\" */\n  CurrentAnsPrimaryNameV2Pkey = \"current_ans_primary_name_v2_pkey\",\n}\n\n/** input type for incrementing numeric columns in table \"current_ans_primary_name_v2\" */\nexport type CurrentAnsPrimaryNameV2IncInput = {\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** input type for inserting data into table \"current_ans_primary_name_v2\" */\nexport type CurrentAnsPrimaryNameV2InsertInput = {\n  domain?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  is_deleted?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  registered_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  subdomain?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_standard?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate max on columns */\nexport type CurrentAnsPrimaryNameV2MaxFields = {\n  domain?: Maybe<Scalars[\"String\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  registered_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  subdomain?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_name?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_standard?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** aggregate min on columns */\nexport type CurrentAnsPrimaryNameV2MinFields = {\n  domain?: Maybe<Scalars[\"String\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  registered_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  subdomain?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_name?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_standard?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** response of any mutation on the table \"current_ans_primary_name_v2\" */\nexport type CurrentAnsPrimaryNameV2MutationResponse = {\n  /** number of rows affected by the mutation */\n  affected_rows: Scalars[\"Int\"][\"output\"];\n  /** data from the rows affected by the mutation */\n  returning: Array<CurrentAnsPrimaryNameV2>;\n};\n\n/** on_conflict condition type for table \"current_ans_primary_name_v2\" */\nexport type CurrentAnsPrimaryNameV2OnConflict = {\n  constraint: CurrentAnsPrimaryNameV2Constraint;\n  update_columns?: Array<CurrentAnsPrimaryNameV2UpdateColumn>;\n  where?: InputMaybe<CurrentAnsPrimaryNameV2BoolExp>;\n};\n\n/** Ordering options when selecting data from \"current_ans_primary_name_v2\". */\nexport type CurrentAnsPrimaryNameV2OrderBy = {\n  domain?: InputMaybe<OrderBy>;\n  inserted_at?: InputMaybe<OrderBy>;\n  is_deleted?: InputMaybe<OrderBy>;\n  last_transaction_version?: InputMaybe<OrderBy>;\n  registered_address?: InputMaybe<OrderBy>;\n  subdomain?: InputMaybe<OrderBy>;\n  token_name?: InputMaybe<OrderBy>;\n  token_standard?: InputMaybe<OrderBy>;\n};\n\n/** primary key columns input for table: current_ans_primary_name_v2 */\nexport type CurrentAnsPrimaryNameV2PkColumnsInput = {\n  registered_address: Scalars[\"String\"][\"input\"];\n  token_standard: Scalars[\"String\"][\"input\"];\n};\n\n/** select columns of table \"current_ans_primary_name_v2\" */\nexport enum CurrentAnsPrimaryNameV2SelectColumn {\n  /** column name */\n  Domain = \"domain\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  IsDeleted = \"is_deleted\",\n  /** column name */\n  LastTransactionVersion = \"last_transaction_version\",\n  /** column name */\n  RegisteredAddress = \"registered_address\",\n  /** column name */\n  Subdomain = \"subdomain\",\n  /** column name */\n  TokenName = \"token_name\",\n  /** column name */\n  TokenStandard = \"token_standard\",\n}\n\n/** input type for updating data in table \"current_ans_primary_name_v2\" */\nexport type CurrentAnsPrimaryNameV2SetInput = {\n  domain?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  is_deleted?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  registered_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  subdomain?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_standard?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate stddev on columns */\nexport type CurrentAnsPrimaryNameV2StddevFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_pop on columns */\nexport type CurrentAnsPrimaryNameV2StddevPopFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_samp on columns */\nexport type CurrentAnsPrimaryNameV2StddevSampFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Streaming cursor of the table \"current_ans_primary_name_v2\" */\nexport type CurrentAnsPrimaryNameV2StreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: CurrentAnsPrimaryNameV2StreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type CurrentAnsPrimaryNameV2StreamCursorValueInput = {\n  domain?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  is_deleted?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  registered_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  subdomain?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_standard?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate sum on columns */\nexport type CurrentAnsPrimaryNameV2SumFields = {\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** update columns of table \"current_ans_primary_name_v2\" */\nexport enum CurrentAnsPrimaryNameV2UpdateColumn {\n  /** column name */\n  Domain = \"domain\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  IsDeleted = \"is_deleted\",\n  /** column name */\n  LastTransactionVersion = \"last_transaction_version\",\n  /** column name */\n  RegisteredAddress = \"registered_address\",\n  /** column name */\n  Subdomain = \"subdomain\",\n  /** column name */\n  TokenName = \"token_name\",\n  /** column name */\n  TokenStandard = \"token_standard\",\n}\n\nexport type CurrentAnsPrimaryNameV2Updates = {\n  /** increments the numeric columns with given value of the filtered values */\n  _inc?: InputMaybe<CurrentAnsPrimaryNameV2IncInput>;\n  /** sets the columns of the filtered rows to the given values */\n  _set?: InputMaybe<CurrentAnsPrimaryNameV2SetInput>;\n  /** filter the rows which have to be updated */\n  where: CurrentAnsPrimaryNameV2BoolExp;\n};\n\n/** aggregate var_pop on columns */\nexport type CurrentAnsPrimaryNameV2VarPopFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate var_samp on columns */\nexport type CurrentAnsPrimaryNameV2VarSampFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate variance on columns */\nexport type CurrentAnsPrimaryNameV2VarianceFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate var_pop on columns */\nexport type CurrentAnsPrimaryNameVarPopFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate var_samp on columns */\nexport type CurrentAnsPrimaryNameVarSampFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate variance on columns */\nexport type CurrentAnsPrimaryNameVarianceFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** columns and relationships of \"current_cedra_names\" */\nexport type CurrentCedraNames = {\n  domain?: Maybe<Scalars[\"String\"][\"output\"]>;\n  domain_expiration_timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  domain_with_suffix?: Maybe<Scalars[\"String\"][\"output\"]>;\n  expiration_timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  is_active?: Maybe<Scalars[\"Boolean\"][\"output\"]>;\n  /** An object relationship */\n  is_domain_owner?: Maybe<CurrentCedraNames>;\n  is_primary?: Maybe<Scalars[\"Boolean\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  owner_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  registered_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  subdomain?: Maybe<Scalars[\"String\"][\"output\"]>;\n  subdomain_expiration_policy?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  token_data_id?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_name?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_standard?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** aggregated selection of \"current_cedra_names\" */\nexport type CurrentCedraNamesAggregate = {\n  aggregate?: Maybe<CurrentCedraNamesAggregateFields>;\n  nodes: Array<CurrentCedraNames>;\n};\n\nexport type CurrentCedraNamesAggregateBoolExp = {\n  bool_and?: InputMaybe<CurrentCedraNamesAggregateBoolExpBoolAnd>;\n  bool_or?: InputMaybe<CurrentCedraNamesAggregateBoolExpBoolOr>;\n  count?: InputMaybe<CurrentCedraNamesAggregateBoolExpCount>;\n};\n\nexport type CurrentCedraNamesAggregateBoolExpBoolAnd = {\n  arguments: CurrentCedraNamesSelectColumnCurrentCedraNamesAggregateBoolExpBoolAndArgumentsColumns;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  filter?: InputMaybe<CurrentCedraNamesBoolExp>;\n  predicate: BooleanComparisonExp;\n};\n\nexport type CurrentCedraNamesAggregateBoolExpBoolOr = {\n  arguments: CurrentCedraNamesSelectColumnCurrentCedraNamesAggregateBoolExpBoolOrArgumentsColumns;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  filter?: InputMaybe<CurrentCedraNamesBoolExp>;\n  predicate: BooleanComparisonExp;\n};\n\nexport type CurrentCedraNamesAggregateBoolExpCount = {\n  arguments?: InputMaybe<Array<CurrentCedraNamesSelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  filter?: InputMaybe<CurrentCedraNamesBoolExp>;\n  predicate: IntComparisonExp;\n};\n\n/** aggregate fields of \"current_cedra_names\" */\nexport type CurrentCedraNamesAggregateFields = {\n  avg?: Maybe<CurrentCedraNamesAvgFields>;\n  count: Scalars[\"Int\"][\"output\"];\n  max?: Maybe<CurrentCedraNamesMaxFields>;\n  min?: Maybe<CurrentCedraNamesMinFields>;\n  stddev?: Maybe<CurrentCedraNamesStddevFields>;\n  stddev_pop?: Maybe<CurrentCedraNamesStddevPopFields>;\n  stddev_samp?: Maybe<CurrentCedraNamesStddevSampFields>;\n  sum?: Maybe<CurrentCedraNamesSumFields>;\n  var_pop?: Maybe<CurrentCedraNamesVarPopFields>;\n  var_samp?: Maybe<CurrentCedraNamesVarSampFields>;\n  variance?: Maybe<CurrentCedraNamesVarianceFields>;\n};\n\n/** aggregate fields of \"current_cedra_names\" */\nexport type CurrentCedraNamesAggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<CurrentCedraNamesSelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** order by aggregate values of table \"current_cedra_names\" */\nexport type CurrentCedraNamesAggregateOrderBy = {\n  avg?: InputMaybe<CurrentCedraNamesAvgOrderBy>;\n  count?: InputMaybe<OrderBy>;\n  max?: InputMaybe<CurrentCedraNamesMaxOrderBy>;\n  min?: InputMaybe<CurrentCedraNamesMinOrderBy>;\n  stddev?: InputMaybe<CurrentCedraNamesStddevOrderBy>;\n  stddev_pop?: InputMaybe<CurrentCedraNamesStddevPopOrderBy>;\n  stddev_samp?: InputMaybe<CurrentCedraNamesStddevSampOrderBy>;\n  sum?: InputMaybe<CurrentCedraNamesSumOrderBy>;\n  var_pop?: InputMaybe<CurrentCedraNamesVarPopOrderBy>;\n  var_samp?: InputMaybe<CurrentCedraNamesVarSampOrderBy>;\n  variance?: InputMaybe<CurrentCedraNamesVarianceOrderBy>;\n};\n\n/** input type for inserting array relation for remote table \"current_cedra_names\" */\nexport type CurrentCedraNamesArrRelInsertInput = {\n  data: Array<CurrentCedraNamesInsertInput>;\n};\n\n/** aggregate avg on columns */\nexport type CurrentCedraNamesAvgFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  subdomain_expiration_policy?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** order by avg() on columns of table \"current_cedra_names\" */\nexport type CurrentCedraNamesAvgOrderBy = {\n  last_transaction_version?: InputMaybe<OrderBy>;\n  subdomain_expiration_policy?: InputMaybe<OrderBy>;\n};\n\n/** Boolean expression to filter rows from the table \"current_cedra_names\". All fields are combined with a logical 'AND'. */\nexport type CurrentCedraNamesBoolExp = {\n  _and?: InputMaybe<Array<CurrentCedraNamesBoolExp>>;\n  _not?: InputMaybe<CurrentCedraNamesBoolExp>;\n  _or?: InputMaybe<Array<CurrentCedraNamesBoolExp>>;\n  domain?: InputMaybe<StringComparisonExp>;\n  domain_expiration_timestamp?: InputMaybe<TimestampComparisonExp>;\n  domain_with_suffix?: InputMaybe<StringComparisonExp>;\n  expiration_timestamp?: InputMaybe<TimestampComparisonExp>;\n  is_active?: InputMaybe<BooleanComparisonExp>;\n  is_domain_owner?: InputMaybe<CurrentCedraNamesBoolExp>;\n  is_primary?: InputMaybe<BooleanComparisonExp>;\n  last_transaction_version?: InputMaybe<BigintComparisonExp>;\n  owner_address?: InputMaybe<StringComparisonExp>;\n  registered_address?: InputMaybe<StringComparisonExp>;\n  subdomain?: InputMaybe<StringComparisonExp>;\n  subdomain_expiration_policy?: InputMaybe<BigintComparisonExp>;\n  token_data_id?: InputMaybe<StringComparisonExp>;\n  token_name?: InputMaybe<StringComparisonExp>;\n  token_standard?: InputMaybe<StringComparisonExp>;\n};\n\n/** input type for inserting data into table \"current_cedra_names\" */\nexport type CurrentCedraNamesInsertInput = {\n  domain?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  domain_expiration_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  domain_with_suffix?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  expiration_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  is_active?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  is_domain_owner?: InputMaybe<CurrentCedraNamesObjRelInsertInput>;\n  is_primary?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  owner_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  registered_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  subdomain?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  subdomain_expiration_policy?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  token_data_id?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_standard?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate max on columns */\nexport type CurrentCedraNamesMaxFields = {\n  domain?: Maybe<Scalars[\"String\"][\"output\"]>;\n  domain_expiration_timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  domain_with_suffix?: Maybe<Scalars[\"String\"][\"output\"]>;\n  expiration_timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  owner_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  registered_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  subdomain?: Maybe<Scalars[\"String\"][\"output\"]>;\n  subdomain_expiration_policy?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  token_data_id?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_name?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_standard?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** order by max() on columns of table \"current_cedra_names\" */\nexport type CurrentCedraNamesMaxOrderBy = {\n  domain?: InputMaybe<OrderBy>;\n  domain_expiration_timestamp?: InputMaybe<OrderBy>;\n  domain_with_suffix?: InputMaybe<OrderBy>;\n  expiration_timestamp?: InputMaybe<OrderBy>;\n  last_transaction_version?: InputMaybe<OrderBy>;\n  owner_address?: InputMaybe<OrderBy>;\n  registered_address?: InputMaybe<OrderBy>;\n  subdomain?: InputMaybe<OrderBy>;\n  subdomain_expiration_policy?: InputMaybe<OrderBy>;\n  token_data_id?: InputMaybe<OrderBy>;\n  token_name?: InputMaybe<OrderBy>;\n  token_standard?: InputMaybe<OrderBy>;\n};\n\n/** aggregate min on columns */\nexport type CurrentCedraNamesMinFields = {\n  domain?: Maybe<Scalars[\"String\"][\"output\"]>;\n  domain_expiration_timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  domain_with_suffix?: Maybe<Scalars[\"String\"][\"output\"]>;\n  expiration_timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  owner_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  registered_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  subdomain?: Maybe<Scalars[\"String\"][\"output\"]>;\n  subdomain_expiration_policy?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  token_data_id?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_name?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_standard?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** order by min() on columns of table \"current_cedra_names\" */\nexport type CurrentCedraNamesMinOrderBy = {\n  domain?: InputMaybe<OrderBy>;\n  domain_expiration_timestamp?: InputMaybe<OrderBy>;\n  domain_with_suffix?: InputMaybe<OrderBy>;\n  expiration_timestamp?: InputMaybe<OrderBy>;\n  last_transaction_version?: InputMaybe<OrderBy>;\n  owner_address?: InputMaybe<OrderBy>;\n  registered_address?: InputMaybe<OrderBy>;\n  subdomain?: InputMaybe<OrderBy>;\n  subdomain_expiration_policy?: InputMaybe<OrderBy>;\n  token_data_id?: InputMaybe<OrderBy>;\n  token_name?: InputMaybe<OrderBy>;\n  token_standard?: InputMaybe<OrderBy>;\n};\n\n/** input type for inserting object relation for remote table \"current_cedra_names\" */\nexport type CurrentCedraNamesObjRelInsertInput = {\n  data: CurrentCedraNamesInsertInput;\n};\n\n/** Ordering options when selecting data from \"current_cedra_names\". */\nexport type CurrentCedraNamesOrderBy = {\n  domain?: InputMaybe<OrderBy>;\n  domain_expiration_timestamp?: InputMaybe<OrderBy>;\n  domain_with_suffix?: InputMaybe<OrderBy>;\n  expiration_timestamp?: InputMaybe<OrderBy>;\n  is_active?: InputMaybe<OrderBy>;\n  is_domain_owner?: InputMaybe<CurrentCedraNamesOrderBy>;\n  is_primary?: InputMaybe<OrderBy>;\n  last_transaction_version?: InputMaybe<OrderBy>;\n  owner_address?: InputMaybe<OrderBy>;\n  registered_address?: InputMaybe<OrderBy>;\n  subdomain?: InputMaybe<OrderBy>;\n  subdomain_expiration_policy?: InputMaybe<OrderBy>;\n  token_data_id?: InputMaybe<OrderBy>;\n  token_name?: InputMaybe<OrderBy>;\n  token_standard?: InputMaybe<OrderBy>;\n};\n\n/** select columns of table \"current_cedra_names\" */\nexport enum CurrentCedraNamesSelectColumn {\n  /** column name */\n  Domain = \"domain\",\n  /** column name */\n  DomainExpirationTimestamp = \"domain_expiration_timestamp\",\n  /** column name */\n  DomainWithSuffix = \"domain_with_suffix\",\n  /** column name */\n  ExpirationTimestamp = \"expiration_timestamp\",\n  /** column name */\n  IsActive = \"is_active\",\n  /** column name */\n  IsPrimary = \"is_primary\",\n  /** column name */\n  LastTransactionVersion = \"last_transaction_version\",\n  /** column name */\n  OwnerAddress = \"owner_address\",\n  /** column name */\n  RegisteredAddress = \"registered_address\",\n  /** column name */\n  Subdomain = \"subdomain\",\n  /** column name */\n  SubdomainExpirationPolicy = \"subdomain_expiration_policy\",\n  /** column name */\n  TokenDataId = \"token_data_id\",\n  /** column name */\n  TokenName = \"token_name\",\n  /** column name */\n  TokenStandard = \"token_standard\",\n}\n\n/** select \"current_cedra_names_aggregate_bool_exp_bool_and_arguments_columns\" columns of table \"current_cedra_names\" */\nexport enum CurrentCedraNamesSelectColumnCurrentCedraNamesAggregateBoolExpBoolAndArgumentsColumns {\n  /** column name */\n  IsActive = \"is_active\",\n  /** column name */\n  IsPrimary = \"is_primary\",\n}\n\n/** select \"current_cedra_names_aggregate_bool_exp_bool_or_arguments_columns\" columns of table \"current_cedra_names\" */\nexport enum CurrentCedraNamesSelectColumnCurrentCedraNamesAggregateBoolExpBoolOrArgumentsColumns {\n  /** column name */\n  IsActive = \"is_active\",\n  /** column name */\n  IsPrimary = \"is_primary\",\n}\n\n/** aggregate stddev on columns */\nexport type CurrentCedraNamesStddevFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  subdomain_expiration_policy?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** order by stddev() on columns of table \"current_cedra_names\" */\nexport type CurrentCedraNamesStddevOrderBy = {\n  last_transaction_version?: InputMaybe<OrderBy>;\n  subdomain_expiration_policy?: InputMaybe<OrderBy>;\n};\n\n/** aggregate stddev_pop on columns */\nexport type CurrentCedraNamesStddevPopFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  subdomain_expiration_policy?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** order by stddev_pop() on columns of table \"current_cedra_names\" */\nexport type CurrentCedraNamesStddevPopOrderBy = {\n  last_transaction_version?: InputMaybe<OrderBy>;\n  subdomain_expiration_policy?: InputMaybe<OrderBy>;\n};\n\n/** aggregate stddev_samp on columns */\nexport type CurrentCedraNamesStddevSampFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  subdomain_expiration_policy?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** order by stddev_samp() on columns of table \"current_cedra_names\" */\nexport type CurrentCedraNamesStddevSampOrderBy = {\n  last_transaction_version?: InputMaybe<OrderBy>;\n  subdomain_expiration_policy?: InputMaybe<OrderBy>;\n};\n\n/** Streaming cursor of the table \"current_cedra_names\" */\nexport type CurrentCedraNamesStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: CurrentCedraNamesStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type CurrentCedraNamesStreamCursorValueInput = {\n  domain?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  domain_expiration_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  domain_with_suffix?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  expiration_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  is_active?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  is_primary?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  owner_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  registered_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  subdomain?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  subdomain_expiration_policy?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  token_data_id?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_standard?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate sum on columns */\nexport type CurrentCedraNamesSumFields = {\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  subdomain_expiration_policy?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** order by sum() on columns of table \"current_cedra_names\" */\nexport type CurrentCedraNamesSumOrderBy = {\n  last_transaction_version?: InputMaybe<OrderBy>;\n  subdomain_expiration_policy?: InputMaybe<OrderBy>;\n};\n\n/** aggregate var_pop on columns */\nexport type CurrentCedraNamesVarPopFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  subdomain_expiration_policy?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** order by var_pop() on columns of table \"current_cedra_names\" */\nexport type CurrentCedraNamesVarPopOrderBy = {\n  last_transaction_version?: InputMaybe<OrderBy>;\n  subdomain_expiration_policy?: InputMaybe<OrderBy>;\n};\n\n/** aggregate var_samp on columns */\nexport type CurrentCedraNamesVarSampFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  subdomain_expiration_policy?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** order by var_samp() on columns of table \"current_cedra_names\" */\nexport type CurrentCedraNamesVarSampOrderBy = {\n  last_transaction_version?: InputMaybe<OrderBy>;\n  subdomain_expiration_policy?: InputMaybe<OrderBy>;\n};\n\n/** aggregate variance on columns */\nexport type CurrentCedraNamesVarianceFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  subdomain_expiration_policy?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** order by variance() on columns of table \"current_cedra_names\" */\nexport type CurrentCedraNamesVarianceOrderBy = {\n  last_transaction_version?: InputMaybe<OrderBy>;\n  subdomain_expiration_policy?: InputMaybe<OrderBy>;\n};\n\n/** columns and relationships of \"current_coin_balances\" */\nexport type CurrentCoinBalances = {\n  amount: Scalars[\"numeric\"][\"output\"];\n  coin_type: Scalars[\"String\"][\"output\"];\n  coin_type_hash: Scalars[\"String\"][\"output\"];\n  inserted_at: Scalars[\"timestamp\"][\"output\"];\n  last_transaction_timestamp: Scalars[\"timestamp\"][\"output\"];\n  last_transaction_version: Scalars[\"bigint\"][\"output\"];\n  owner_address: Scalars[\"String\"][\"output\"];\n};\n\n/** aggregated selection of \"current_coin_balances\" */\nexport type CurrentCoinBalancesAggregate = {\n  aggregate?: Maybe<CurrentCoinBalancesAggregateFields>;\n  nodes: Array<CurrentCoinBalances>;\n};\n\n/** aggregate fields of \"current_coin_balances\" */\nexport type CurrentCoinBalancesAggregateFields = {\n  avg?: Maybe<CurrentCoinBalancesAvgFields>;\n  count: Scalars[\"Int\"][\"output\"];\n  max?: Maybe<CurrentCoinBalancesMaxFields>;\n  min?: Maybe<CurrentCoinBalancesMinFields>;\n  stddev?: Maybe<CurrentCoinBalancesStddevFields>;\n  stddev_pop?: Maybe<CurrentCoinBalancesStddevPopFields>;\n  stddev_samp?: Maybe<CurrentCoinBalancesStddevSampFields>;\n  sum?: Maybe<CurrentCoinBalancesSumFields>;\n  var_pop?: Maybe<CurrentCoinBalancesVarPopFields>;\n  var_samp?: Maybe<CurrentCoinBalancesVarSampFields>;\n  variance?: Maybe<CurrentCoinBalancesVarianceFields>;\n};\n\n/** aggregate fields of \"current_coin_balances\" */\nexport type CurrentCoinBalancesAggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<CurrentCoinBalancesSelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** aggregate avg on columns */\nexport type CurrentCoinBalancesAvgFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Boolean expression to filter rows from the table \"current_coin_balances\". All fields are combined with a logical 'AND'. */\nexport type CurrentCoinBalancesBoolExp = {\n  _and?: InputMaybe<Array<CurrentCoinBalancesBoolExp>>;\n  _not?: InputMaybe<CurrentCoinBalancesBoolExp>;\n  _or?: InputMaybe<Array<CurrentCoinBalancesBoolExp>>;\n  amount?: InputMaybe<NumericComparisonExp>;\n  coin_type?: InputMaybe<StringComparisonExp>;\n  coin_type_hash?: InputMaybe<StringComparisonExp>;\n  inserted_at?: InputMaybe<TimestampComparisonExp>;\n  last_transaction_timestamp?: InputMaybe<TimestampComparisonExp>;\n  last_transaction_version?: InputMaybe<BigintComparisonExp>;\n  owner_address?: InputMaybe<StringComparisonExp>;\n};\n\n/** unique or primary key constraints on table \"current_coin_balances\" */\nexport enum CurrentCoinBalancesConstraint {\n  /** unique or primary key constraint on columns \"coin_type_hash\", \"owner_address\" */\n  CurrentCoinBalancesPkey = \"current_coin_balances_pkey\",\n}\n\n/** input type for incrementing numeric columns in table \"current_coin_balances\" */\nexport type CurrentCoinBalancesIncInput = {\n  amount?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** input type for inserting data into table \"current_coin_balances\" */\nexport type CurrentCoinBalancesInsertInput = {\n  amount?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  coin_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  coin_type_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  last_transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  owner_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate max on columns */\nexport type CurrentCoinBalancesMaxFields = {\n  amount?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  coin_type?: Maybe<Scalars[\"String\"][\"output\"]>;\n  coin_type_hash?: Maybe<Scalars[\"String\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  last_transaction_timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  owner_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** aggregate min on columns */\nexport type CurrentCoinBalancesMinFields = {\n  amount?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  coin_type?: Maybe<Scalars[\"String\"][\"output\"]>;\n  coin_type_hash?: Maybe<Scalars[\"String\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  last_transaction_timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  owner_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** response of any mutation on the table \"current_coin_balances\" */\nexport type CurrentCoinBalancesMutationResponse = {\n  /** number of rows affected by the mutation */\n  affected_rows: Scalars[\"Int\"][\"output\"];\n  /** data from the rows affected by the mutation */\n  returning: Array<CurrentCoinBalances>;\n};\n\n/** on_conflict condition type for table \"current_coin_balances\" */\nexport type CurrentCoinBalancesOnConflict = {\n  constraint: CurrentCoinBalancesConstraint;\n  update_columns?: Array<CurrentCoinBalancesUpdateColumn>;\n  where?: InputMaybe<CurrentCoinBalancesBoolExp>;\n};\n\n/** Ordering options when selecting data from \"current_coin_balances\". */\nexport type CurrentCoinBalancesOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  coin_type?: InputMaybe<OrderBy>;\n  coin_type_hash?: InputMaybe<OrderBy>;\n  inserted_at?: InputMaybe<OrderBy>;\n  last_transaction_timestamp?: InputMaybe<OrderBy>;\n  last_transaction_version?: InputMaybe<OrderBy>;\n  owner_address?: InputMaybe<OrderBy>;\n};\n\n/** primary key columns input for table: current_coin_balances */\nexport type CurrentCoinBalancesPkColumnsInput = {\n  coin_type_hash: Scalars[\"String\"][\"input\"];\n  owner_address: Scalars[\"String\"][\"input\"];\n};\n\n/** select columns of table \"current_coin_balances\" */\nexport enum CurrentCoinBalancesSelectColumn {\n  /** column name */\n  Amount = \"amount\",\n  /** column name */\n  CoinType = \"coin_type\",\n  /** column name */\n  CoinTypeHash = \"coin_type_hash\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  LastTransactionTimestamp = \"last_transaction_timestamp\",\n  /** column name */\n  LastTransactionVersion = \"last_transaction_version\",\n  /** column name */\n  OwnerAddress = \"owner_address\",\n}\n\n/** input type for updating data in table \"current_coin_balances\" */\nexport type CurrentCoinBalancesSetInput = {\n  amount?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  coin_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  coin_type_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  last_transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  owner_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate stddev on columns */\nexport type CurrentCoinBalancesStddevFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_pop on columns */\nexport type CurrentCoinBalancesStddevPopFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_samp on columns */\nexport type CurrentCoinBalancesStddevSampFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Streaming cursor of the table \"current_coin_balances\" */\nexport type CurrentCoinBalancesStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: CurrentCoinBalancesStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type CurrentCoinBalancesStreamCursorValueInput = {\n  amount?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  coin_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  coin_type_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  last_transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  owner_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate sum on columns */\nexport type CurrentCoinBalancesSumFields = {\n  amount?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** update columns of table \"current_coin_balances\" */\nexport enum CurrentCoinBalancesUpdateColumn {\n  /** column name */\n  Amount = \"amount\",\n  /** column name */\n  CoinType = \"coin_type\",\n  /** column name */\n  CoinTypeHash = \"coin_type_hash\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  LastTransactionTimestamp = \"last_transaction_timestamp\",\n  /** column name */\n  LastTransactionVersion = \"last_transaction_version\",\n  /** column name */\n  OwnerAddress = \"owner_address\",\n}\n\nexport type CurrentCoinBalancesUpdates = {\n  /** increments the numeric columns with given value of the filtered values */\n  _inc?: InputMaybe<CurrentCoinBalancesIncInput>;\n  /** sets the columns of the filtered rows to the given values */\n  _set?: InputMaybe<CurrentCoinBalancesSetInput>;\n  /** filter the rows which have to be updated */\n  where: CurrentCoinBalancesBoolExp;\n};\n\n/** aggregate var_pop on columns */\nexport type CurrentCoinBalancesVarPopFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate var_samp on columns */\nexport type CurrentCoinBalancesVarSampFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate variance on columns */\nexport type CurrentCoinBalancesVarianceFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** columns and relationships of \"current_collection_datas\" */\nexport type CurrentCollectionDatas = {\n  collection_data_id_hash: Scalars[\"String\"][\"output\"];\n  collection_name: Scalars[\"String\"][\"output\"];\n  creator_address: Scalars[\"String\"][\"output\"];\n  description: Scalars[\"String\"][\"output\"];\n  description_mutable: Scalars[\"Boolean\"][\"output\"];\n  inserted_at: Scalars[\"timestamp\"][\"output\"];\n  last_transaction_timestamp: Scalars[\"timestamp\"][\"output\"];\n  last_transaction_version: Scalars[\"bigint\"][\"output\"];\n  maximum: Scalars[\"numeric\"][\"output\"];\n  maximum_mutable: Scalars[\"Boolean\"][\"output\"];\n  metadata_uri: Scalars[\"String\"][\"output\"];\n  supply: Scalars[\"numeric\"][\"output\"];\n  table_handle: Scalars[\"String\"][\"output\"];\n  uri_mutable: Scalars[\"Boolean\"][\"output\"];\n};\n\n/** aggregated selection of \"current_collection_datas\" */\nexport type CurrentCollectionDatasAggregate = {\n  aggregate?: Maybe<CurrentCollectionDatasAggregateFields>;\n  nodes: Array<CurrentCollectionDatas>;\n};\n\n/** aggregate fields of \"current_collection_datas\" */\nexport type CurrentCollectionDatasAggregateFields = {\n  avg?: Maybe<CurrentCollectionDatasAvgFields>;\n  count: Scalars[\"Int\"][\"output\"];\n  max?: Maybe<CurrentCollectionDatasMaxFields>;\n  min?: Maybe<CurrentCollectionDatasMinFields>;\n  stddev?: Maybe<CurrentCollectionDatasStddevFields>;\n  stddev_pop?: Maybe<CurrentCollectionDatasStddevPopFields>;\n  stddev_samp?: Maybe<CurrentCollectionDatasStddevSampFields>;\n  sum?: Maybe<CurrentCollectionDatasSumFields>;\n  var_pop?: Maybe<CurrentCollectionDatasVarPopFields>;\n  var_samp?: Maybe<CurrentCollectionDatasVarSampFields>;\n  variance?: Maybe<CurrentCollectionDatasVarianceFields>;\n};\n\n/** aggregate fields of \"current_collection_datas\" */\nexport type CurrentCollectionDatasAggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<CurrentCollectionDatasSelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** aggregate avg on columns */\nexport type CurrentCollectionDatasAvgFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  maximum?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  supply?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Boolean expression to filter rows from the table \"current_collection_datas\". All fields are combined with a logical 'AND'. */\nexport type CurrentCollectionDatasBoolExp = {\n  _and?: InputMaybe<Array<CurrentCollectionDatasBoolExp>>;\n  _not?: InputMaybe<CurrentCollectionDatasBoolExp>;\n  _or?: InputMaybe<Array<CurrentCollectionDatasBoolExp>>;\n  collection_data_id_hash?: InputMaybe<StringComparisonExp>;\n  collection_name?: InputMaybe<StringComparisonExp>;\n  creator_address?: InputMaybe<StringComparisonExp>;\n  description?: InputMaybe<StringComparisonExp>;\n  description_mutable?: InputMaybe<BooleanComparisonExp>;\n  inserted_at?: InputMaybe<TimestampComparisonExp>;\n  last_transaction_timestamp?: InputMaybe<TimestampComparisonExp>;\n  last_transaction_version?: InputMaybe<BigintComparisonExp>;\n  maximum?: InputMaybe<NumericComparisonExp>;\n  maximum_mutable?: InputMaybe<BooleanComparisonExp>;\n  metadata_uri?: InputMaybe<StringComparisonExp>;\n  supply?: InputMaybe<NumericComparisonExp>;\n  table_handle?: InputMaybe<StringComparisonExp>;\n  uri_mutable?: InputMaybe<BooleanComparisonExp>;\n};\n\n/** unique or primary key constraints on table \"current_collection_datas\" */\nexport enum CurrentCollectionDatasConstraint {\n  /** unique or primary key constraint on columns \"collection_data_id_hash\" */\n  CurrentCollectionDatasPkey = \"current_collection_datas_pkey\",\n}\n\n/** input type for incrementing numeric columns in table \"current_collection_datas\" */\nexport type CurrentCollectionDatasIncInput = {\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  maximum?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  supply?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n};\n\n/** input type for inserting data into table \"current_collection_datas\" */\nexport type CurrentCollectionDatasInsertInput = {\n  collection_data_id_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  collection_name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  creator_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  description?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  description_mutable?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  last_transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  maximum?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  maximum_mutable?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  metadata_uri?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  supply?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  table_handle?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  uri_mutable?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** aggregate max on columns */\nexport type CurrentCollectionDatasMaxFields = {\n  collection_data_id_hash?: Maybe<Scalars[\"String\"][\"output\"]>;\n  collection_name?: Maybe<Scalars[\"String\"][\"output\"]>;\n  creator_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  description?: Maybe<Scalars[\"String\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  last_transaction_timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  maximum?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  metadata_uri?: Maybe<Scalars[\"String\"][\"output\"]>;\n  supply?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  table_handle?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** aggregate min on columns */\nexport type CurrentCollectionDatasMinFields = {\n  collection_data_id_hash?: Maybe<Scalars[\"String\"][\"output\"]>;\n  collection_name?: Maybe<Scalars[\"String\"][\"output\"]>;\n  creator_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  description?: Maybe<Scalars[\"String\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  last_transaction_timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  maximum?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  metadata_uri?: Maybe<Scalars[\"String\"][\"output\"]>;\n  supply?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  table_handle?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** response of any mutation on the table \"current_collection_datas\" */\nexport type CurrentCollectionDatasMutationResponse = {\n  /** number of rows affected by the mutation */\n  affected_rows: Scalars[\"Int\"][\"output\"];\n  /** data from the rows affected by the mutation */\n  returning: Array<CurrentCollectionDatas>;\n};\n\n/** on_conflict condition type for table \"current_collection_datas\" */\nexport type CurrentCollectionDatasOnConflict = {\n  constraint: CurrentCollectionDatasConstraint;\n  update_columns?: Array<CurrentCollectionDatasUpdateColumn>;\n  where?: InputMaybe<CurrentCollectionDatasBoolExp>;\n};\n\n/** Ordering options when selecting data from \"current_collection_datas\". */\nexport type CurrentCollectionDatasOrderBy = {\n  collection_data_id_hash?: InputMaybe<OrderBy>;\n  collection_name?: InputMaybe<OrderBy>;\n  creator_address?: InputMaybe<OrderBy>;\n  description?: InputMaybe<OrderBy>;\n  description_mutable?: InputMaybe<OrderBy>;\n  inserted_at?: InputMaybe<OrderBy>;\n  last_transaction_timestamp?: InputMaybe<OrderBy>;\n  last_transaction_version?: InputMaybe<OrderBy>;\n  maximum?: InputMaybe<OrderBy>;\n  maximum_mutable?: InputMaybe<OrderBy>;\n  metadata_uri?: InputMaybe<OrderBy>;\n  supply?: InputMaybe<OrderBy>;\n  table_handle?: InputMaybe<OrderBy>;\n  uri_mutable?: InputMaybe<OrderBy>;\n};\n\n/** primary key columns input for table: current_collection_datas */\nexport type CurrentCollectionDatasPkColumnsInput = {\n  collection_data_id_hash: Scalars[\"String\"][\"input\"];\n};\n\n/** select columns of table \"current_collection_datas\" */\nexport enum CurrentCollectionDatasSelectColumn {\n  /** column name */\n  CollectionDataIdHash = \"collection_data_id_hash\",\n  /** column name */\n  CollectionName = \"collection_name\",\n  /** column name */\n  CreatorAddress = \"creator_address\",\n  /** column name */\n  Description = \"description\",\n  /** column name */\n  DescriptionMutable = \"description_mutable\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  LastTransactionTimestamp = \"last_transaction_timestamp\",\n  /** column name */\n  LastTransactionVersion = \"last_transaction_version\",\n  /** column name */\n  Maximum = \"maximum\",\n  /** column name */\n  MaximumMutable = \"maximum_mutable\",\n  /** column name */\n  MetadataUri = \"metadata_uri\",\n  /** column name */\n  Supply = \"supply\",\n  /** column name */\n  TableHandle = \"table_handle\",\n  /** column name */\n  UriMutable = \"uri_mutable\",\n}\n\n/** input type for updating data in table \"current_collection_datas\" */\nexport type CurrentCollectionDatasSetInput = {\n  collection_data_id_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  collection_name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  creator_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  description?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  description_mutable?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  last_transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  maximum?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  maximum_mutable?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  metadata_uri?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  supply?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  table_handle?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  uri_mutable?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** aggregate stddev on columns */\nexport type CurrentCollectionDatasStddevFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  maximum?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  supply?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_pop on columns */\nexport type CurrentCollectionDatasStddevPopFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  maximum?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  supply?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_samp on columns */\nexport type CurrentCollectionDatasStddevSampFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  maximum?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  supply?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Streaming cursor of the table \"current_collection_datas\" */\nexport type CurrentCollectionDatasStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: CurrentCollectionDatasStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type CurrentCollectionDatasStreamCursorValueInput = {\n  collection_data_id_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  collection_name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  creator_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  description?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  description_mutable?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  last_transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  maximum?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  maximum_mutable?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  metadata_uri?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  supply?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  table_handle?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  uri_mutable?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** aggregate sum on columns */\nexport type CurrentCollectionDatasSumFields = {\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  maximum?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  supply?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n};\n\n/** update columns of table \"current_collection_datas\" */\nexport enum CurrentCollectionDatasUpdateColumn {\n  /** column name */\n  CollectionDataIdHash = \"collection_data_id_hash\",\n  /** column name */\n  CollectionName = \"collection_name\",\n  /** column name */\n  CreatorAddress = \"creator_address\",\n  /** column name */\n  Description = \"description\",\n  /** column name */\n  DescriptionMutable = \"description_mutable\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  LastTransactionTimestamp = \"last_transaction_timestamp\",\n  /** column name */\n  LastTransactionVersion = \"last_transaction_version\",\n  /** column name */\n  Maximum = \"maximum\",\n  /** column name */\n  MaximumMutable = \"maximum_mutable\",\n  /** column name */\n  MetadataUri = \"metadata_uri\",\n  /** column name */\n  Supply = \"supply\",\n  /** column name */\n  TableHandle = \"table_handle\",\n  /** column name */\n  UriMutable = \"uri_mutable\",\n}\n\nexport type CurrentCollectionDatasUpdates = {\n  /** increments the numeric columns with given value of the filtered values */\n  _inc?: InputMaybe<CurrentCollectionDatasIncInput>;\n  /** sets the columns of the filtered rows to the given values */\n  _set?: InputMaybe<CurrentCollectionDatasSetInput>;\n  /** filter the rows which have to be updated */\n  where: CurrentCollectionDatasBoolExp;\n};\n\n/** aggregate var_pop on columns */\nexport type CurrentCollectionDatasVarPopFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  maximum?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  supply?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate var_samp on columns */\nexport type CurrentCollectionDatasVarSampFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  maximum?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  supply?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate variance on columns */\nexport type CurrentCollectionDatasVarianceFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  maximum?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  supply?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** columns and relationships of \"current_collection_ownership_v2_view\" */\nexport type CurrentCollectionOwnershipV2View = {\n  collection_id?: Maybe<Scalars[\"String\"][\"output\"]>;\n  collection_name?: Maybe<Scalars[\"String\"][\"output\"]>;\n  collection_uri?: Maybe<Scalars[\"String\"][\"output\"]>;\n  creator_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  /** An object relationship */\n  current_collection?: Maybe<CurrentCollectionsV2>;\n  distinct_tokens?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  owner_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  single_token_uri?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** aggregated selection of \"current_collection_ownership_v2_view\" */\nexport type CurrentCollectionOwnershipV2ViewAggregate = {\n  aggregate?: Maybe<CurrentCollectionOwnershipV2ViewAggregateFields>;\n  nodes: Array<CurrentCollectionOwnershipV2View>;\n};\n\n/** aggregate fields of \"current_collection_ownership_v2_view\" */\nexport type CurrentCollectionOwnershipV2ViewAggregateFields = {\n  avg?: Maybe<CurrentCollectionOwnershipV2ViewAvgFields>;\n  count: Scalars[\"Int\"][\"output\"];\n  max?: Maybe<CurrentCollectionOwnershipV2ViewMaxFields>;\n  min?: Maybe<CurrentCollectionOwnershipV2ViewMinFields>;\n  stddev?: Maybe<CurrentCollectionOwnershipV2ViewStddevFields>;\n  stddev_pop?: Maybe<CurrentCollectionOwnershipV2ViewStddevPopFields>;\n  stddev_samp?: Maybe<CurrentCollectionOwnershipV2ViewStddevSampFields>;\n  sum?: Maybe<CurrentCollectionOwnershipV2ViewSumFields>;\n  var_pop?: Maybe<CurrentCollectionOwnershipV2ViewVarPopFields>;\n  var_samp?: Maybe<CurrentCollectionOwnershipV2ViewVarSampFields>;\n  variance?: Maybe<CurrentCollectionOwnershipV2ViewVarianceFields>;\n};\n\n/** aggregate fields of \"current_collection_ownership_v2_view\" */\nexport type CurrentCollectionOwnershipV2ViewAggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<CurrentCollectionOwnershipV2ViewSelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** aggregate avg on columns */\nexport type CurrentCollectionOwnershipV2ViewAvgFields = {\n  distinct_tokens?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Boolean expression to filter rows from the table \"current_collection_ownership_v2_view\". All fields are combined with a logical 'AND'. */\nexport type CurrentCollectionOwnershipV2ViewBoolExp = {\n  _and?: InputMaybe<Array<CurrentCollectionOwnershipV2ViewBoolExp>>;\n  _not?: InputMaybe<CurrentCollectionOwnershipV2ViewBoolExp>;\n  _or?: InputMaybe<Array<CurrentCollectionOwnershipV2ViewBoolExp>>;\n  collection_id?: InputMaybe<StringComparisonExp>;\n  collection_name?: InputMaybe<StringComparisonExp>;\n  collection_uri?: InputMaybe<StringComparisonExp>;\n  creator_address?: InputMaybe<StringComparisonExp>;\n  current_collection?: InputMaybe<CurrentCollectionsV2BoolExp>;\n  distinct_tokens?: InputMaybe<BigintComparisonExp>;\n  last_transaction_version?: InputMaybe<BigintComparisonExp>;\n  owner_address?: InputMaybe<StringComparisonExp>;\n  single_token_uri?: InputMaybe<StringComparisonExp>;\n};\n\n/** aggregate max on columns */\nexport type CurrentCollectionOwnershipV2ViewMaxFields = {\n  collection_id?: Maybe<Scalars[\"String\"][\"output\"]>;\n  collection_name?: Maybe<Scalars[\"String\"][\"output\"]>;\n  collection_uri?: Maybe<Scalars[\"String\"][\"output\"]>;\n  creator_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  distinct_tokens?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  owner_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  single_token_uri?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** aggregate min on columns */\nexport type CurrentCollectionOwnershipV2ViewMinFields = {\n  collection_id?: Maybe<Scalars[\"String\"][\"output\"]>;\n  collection_name?: Maybe<Scalars[\"String\"][\"output\"]>;\n  collection_uri?: Maybe<Scalars[\"String\"][\"output\"]>;\n  creator_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  distinct_tokens?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  owner_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  single_token_uri?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** Ordering options when selecting data from \"current_collection_ownership_v2_view\". */\nexport type CurrentCollectionOwnershipV2ViewOrderBy = {\n  collection_id?: InputMaybe<OrderBy>;\n  collection_name?: InputMaybe<OrderBy>;\n  collection_uri?: InputMaybe<OrderBy>;\n  creator_address?: InputMaybe<OrderBy>;\n  current_collection?: InputMaybe<CurrentCollectionsV2OrderBy>;\n  distinct_tokens?: InputMaybe<OrderBy>;\n  last_transaction_version?: InputMaybe<OrderBy>;\n  owner_address?: InputMaybe<OrderBy>;\n  single_token_uri?: InputMaybe<OrderBy>;\n};\n\n/** select columns of table \"current_collection_ownership_v2_view\" */\nexport enum CurrentCollectionOwnershipV2ViewSelectColumn {\n  /** column name */\n  CollectionId = \"collection_id\",\n  /** column name */\n  CollectionName = \"collection_name\",\n  /** column name */\n  CollectionUri = \"collection_uri\",\n  /** column name */\n  CreatorAddress = \"creator_address\",\n  /** column name */\n  DistinctTokens = \"distinct_tokens\",\n  /** column name */\n  LastTransactionVersion = \"last_transaction_version\",\n  /** column name */\n  OwnerAddress = \"owner_address\",\n  /** column name */\n  SingleTokenUri = \"single_token_uri\",\n}\n\n/** aggregate stddev on columns */\nexport type CurrentCollectionOwnershipV2ViewStddevFields = {\n  distinct_tokens?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_pop on columns */\nexport type CurrentCollectionOwnershipV2ViewStddevPopFields = {\n  distinct_tokens?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_samp on columns */\nexport type CurrentCollectionOwnershipV2ViewStddevSampFields = {\n  distinct_tokens?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Streaming cursor of the table \"current_collection_ownership_v2_view\" */\nexport type CurrentCollectionOwnershipV2ViewStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: CurrentCollectionOwnershipV2ViewStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type CurrentCollectionOwnershipV2ViewStreamCursorValueInput = {\n  collection_id?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  collection_name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  collection_uri?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  creator_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  distinct_tokens?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  owner_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  single_token_uri?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate sum on columns */\nexport type CurrentCollectionOwnershipV2ViewSumFields = {\n  distinct_tokens?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** aggregate var_pop on columns */\nexport type CurrentCollectionOwnershipV2ViewVarPopFields = {\n  distinct_tokens?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate var_samp on columns */\nexport type CurrentCollectionOwnershipV2ViewVarSampFields = {\n  distinct_tokens?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate variance on columns */\nexport type CurrentCollectionOwnershipV2ViewVarianceFields = {\n  distinct_tokens?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** columns and relationships of \"current_collection_ownership_view\" */\nexport type CurrentCollectionOwnershipView = {\n  collection_data_id_hash?: Maybe<Scalars[\"String\"][\"output\"]>;\n  collection_name?: Maybe<Scalars[\"String\"][\"output\"]>;\n  creator_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  distinct_tokens?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  owner_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** aggregated selection of \"current_collection_ownership_view\" */\nexport type CurrentCollectionOwnershipViewAggregate = {\n  aggregate?: Maybe<CurrentCollectionOwnershipViewAggregateFields>;\n  nodes: Array<CurrentCollectionOwnershipView>;\n};\n\n/** aggregate fields of \"current_collection_ownership_view\" */\nexport type CurrentCollectionOwnershipViewAggregateFields = {\n  avg?: Maybe<CurrentCollectionOwnershipViewAvgFields>;\n  count: Scalars[\"Int\"][\"output\"];\n  max?: Maybe<CurrentCollectionOwnershipViewMaxFields>;\n  min?: Maybe<CurrentCollectionOwnershipViewMinFields>;\n  stddev?: Maybe<CurrentCollectionOwnershipViewStddevFields>;\n  stddev_pop?: Maybe<CurrentCollectionOwnershipViewStddevPopFields>;\n  stddev_samp?: Maybe<CurrentCollectionOwnershipViewStddevSampFields>;\n  sum?: Maybe<CurrentCollectionOwnershipViewSumFields>;\n  var_pop?: Maybe<CurrentCollectionOwnershipViewVarPopFields>;\n  var_samp?: Maybe<CurrentCollectionOwnershipViewVarSampFields>;\n  variance?: Maybe<CurrentCollectionOwnershipViewVarianceFields>;\n};\n\n/** aggregate fields of \"current_collection_ownership_view\" */\nexport type CurrentCollectionOwnershipViewAggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<CurrentCollectionOwnershipViewSelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** aggregate avg on columns */\nexport type CurrentCollectionOwnershipViewAvgFields = {\n  distinct_tokens?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Boolean expression to filter rows from the table \"current_collection_ownership_view\". All fields are combined with a logical 'AND'. */\nexport type CurrentCollectionOwnershipViewBoolExp = {\n  _and?: InputMaybe<Array<CurrentCollectionOwnershipViewBoolExp>>;\n  _not?: InputMaybe<CurrentCollectionOwnershipViewBoolExp>;\n  _or?: InputMaybe<Array<CurrentCollectionOwnershipViewBoolExp>>;\n  collection_data_id_hash?: InputMaybe<StringComparisonExp>;\n  collection_name?: InputMaybe<StringComparisonExp>;\n  creator_address?: InputMaybe<StringComparisonExp>;\n  distinct_tokens?: InputMaybe<BigintComparisonExp>;\n  last_transaction_version?: InputMaybe<BigintComparisonExp>;\n  owner_address?: InputMaybe<StringComparisonExp>;\n};\n\n/** aggregate max on columns */\nexport type CurrentCollectionOwnershipViewMaxFields = {\n  collection_data_id_hash?: Maybe<Scalars[\"String\"][\"output\"]>;\n  collection_name?: Maybe<Scalars[\"String\"][\"output\"]>;\n  creator_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  distinct_tokens?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  owner_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** aggregate min on columns */\nexport type CurrentCollectionOwnershipViewMinFields = {\n  collection_data_id_hash?: Maybe<Scalars[\"String\"][\"output\"]>;\n  collection_name?: Maybe<Scalars[\"String\"][\"output\"]>;\n  creator_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  distinct_tokens?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  owner_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** Ordering options when selecting data from \"current_collection_ownership_view\". */\nexport type CurrentCollectionOwnershipViewOrderBy = {\n  collection_data_id_hash?: InputMaybe<OrderBy>;\n  collection_name?: InputMaybe<OrderBy>;\n  creator_address?: InputMaybe<OrderBy>;\n  distinct_tokens?: InputMaybe<OrderBy>;\n  last_transaction_version?: InputMaybe<OrderBy>;\n  owner_address?: InputMaybe<OrderBy>;\n};\n\n/** select columns of table \"current_collection_ownership_view\" */\nexport enum CurrentCollectionOwnershipViewSelectColumn {\n  /** column name */\n  CollectionDataIdHash = \"collection_data_id_hash\",\n  /** column name */\n  CollectionName = \"collection_name\",\n  /** column name */\n  CreatorAddress = \"creator_address\",\n  /** column name */\n  DistinctTokens = \"distinct_tokens\",\n  /** column name */\n  LastTransactionVersion = \"last_transaction_version\",\n  /** column name */\n  OwnerAddress = \"owner_address\",\n}\n\n/** aggregate stddev on columns */\nexport type CurrentCollectionOwnershipViewStddevFields = {\n  distinct_tokens?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_pop on columns */\nexport type CurrentCollectionOwnershipViewStddevPopFields = {\n  distinct_tokens?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_samp on columns */\nexport type CurrentCollectionOwnershipViewStddevSampFields = {\n  distinct_tokens?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Streaming cursor of the table \"current_collection_ownership_view\" */\nexport type CurrentCollectionOwnershipViewStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: CurrentCollectionOwnershipViewStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type CurrentCollectionOwnershipViewStreamCursorValueInput = {\n  collection_data_id_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  collection_name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  creator_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  distinct_tokens?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  owner_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate sum on columns */\nexport type CurrentCollectionOwnershipViewSumFields = {\n  distinct_tokens?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** aggregate var_pop on columns */\nexport type CurrentCollectionOwnershipViewVarPopFields = {\n  distinct_tokens?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate var_samp on columns */\nexport type CurrentCollectionOwnershipViewVarSampFields = {\n  distinct_tokens?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate variance on columns */\nexport type CurrentCollectionOwnershipViewVarianceFields = {\n  distinct_tokens?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** columns and relationships of \"current_collections_v2\" */\nexport type CurrentCollectionsV2 = {\n  /** An object relationship */\n  cdn_asset_uris?: Maybe<NftMetadataCrawlerParsedAssetUris>;\n  collection_id: Scalars[\"String\"][\"output\"];\n  collection_name: Scalars[\"String\"][\"output\"];\n  collection_properties?: Maybe<Scalars[\"jsonb\"][\"output\"]>;\n  creator_address: Scalars[\"String\"][\"output\"];\n  current_supply: Scalars[\"numeric\"][\"output\"];\n  description: Scalars[\"String\"][\"output\"];\n  inserted_at: Scalars[\"timestamp\"][\"output\"];\n  last_transaction_timestamp: Scalars[\"timestamp\"][\"output\"];\n  last_transaction_version: Scalars[\"bigint\"][\"output\"];\n  max_supply?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  mutable_description?: Maybe<Scalars[\"Boolean\"][\"output\"]>;\n  mutable_uri?: Maybe<Scalars[\"Boolean\"][\"output\"]>;\n  table_handle_v1?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_standard: Scalars[\"String\"][\"output\"];\n  total_minted_v2?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  uri: Scalars[\"String\"][\"output\"];\n};\n\n/** columns and relationships of \"current_collections_v2\" */\nexport type CurrentCollectionsV2CollectionPropertiesArgs = {\n  path?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregated selection of \"current_collections_v2\" */\nexport type CurrentCollectionsV2Aggregate = {\n  aggregate?: Maybe<CurrentCollectionsV2AggregateFields>;\n  nodes: Array<CurrentCollectionsV2>;\n};\n\n/** aggregate fields of \"current_collections_v2\" */\nexport type CurrentCollectionsV2AggregateFields = {\n  avg?: Maybe<CurrentCollectionsV2AvgFields>;\n  count: Scalars[\"Int\"][\"output\"];\n  max?: Maybe<CurrentCollectionsV2MaxFields>;\n  min?: Maybe<CurrentCollectionsV2MinFields>;\n  stddev?: Maybe<CurrentCollectionsV2StddevFields>;\n  stddev_pop?: Maybe<CurrentCollectionsV2StddevPopFields>;\n  stddev_samp?: Maybe<CurrentCollectionsV2StddevSampFields>;\n  sum?: Maybe<CurrentCollectionsV2SumFields>;\n  var_pop?: Maybe<CurrentCollectionsV2VarPopFields>;\n  var_samp?: Maybe<CurrentCollectionsV2VarSampFields>;\n  variance?: Maybe<CurrentCollectionsV2VarianceFields>;\n};\n\n/** aggregate fields of \"current_collections_v2\" */\nexport type CurrentCollectionsV2AggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<CurrentCollectionsV2SelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** append existing jsonb value of filtered columns with new jsonb value */\nexport type CurrentCollectionsV2AppendInput = {\n  collection_properties?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n};\n\n/** aggregate avg on columns */\nexport type CurrentCollectionsV2AvgFields = {\n  current_supply?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  max_supply?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  total_minted_v2?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Boolean expression to filter rows from the table \"current_collections_v2\". All fields are combined with a logical 'AND'. */\nexport type CurrentCollectionsV2BoolExp = {\n  _and?: InputMaybe<Array<CurrentCollectionsV2BoolExp>>;\n  _not?: InputMaybe<CurrentCollectionsV2BoolExp>;\n  _or?: InputMaybe<Array<CurrentCollectionsV2BoolExp>>;\n  cdn_asset_uris?: InputMaybe<NftMetadataCrawlerParsedAssetUrisBoolExp>;\n  collection_id?: InputMaybe<StringComparisonExp>;\n  collection_name?: InputMaybe<StringComparisonExp>;\n  collection_properties?: InputMaybe<JsonbComparisonExp>;\n  creator_address?: InputMaybe<StringComparisonExp>;\n  current_supply?: InputMaybe<NumericComparisonExp>;\n  description?: InputMaybe<StringComparisonExp>;\n  inserted_at?: InputMaybe<TimestampComparisonExp>;\n  last_transaction_timestamp?: InputMaybe<TimestampComparisonExp>;\n  last_transaction_version?: InputMaybe<BigintComparisonExp>;\n  max_supply?: InputMaybe<NumericComparisonExp>;\n  mutable_description?: InputMaybe<BooleanComparisonExp>;\n  mutable_uri?: InputMaybe<BooleanComparisonExp>;\n  table_handle_v1?: InputMaybe<StringComparisonExp>;\n  token_standard?: InputMaybe<StringComparisonExp>;\n  total_minted_v2?: InputMaybe<NumericComparisonExp>;\n  uri?: InputMaybe<StringComparisonExp>;\n};\n\n/** unique or primary key constraints on table \"current_collections_v2\" */\nexport enum CurrentCollectionsV2Constraint {\n  /** unique or primary key constraint on columns \"collection_id\" */\n  CurrentCollectionsV2Pkey = \"current_collections_v2_pkey\",\n}\n\n/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */\nexport type CurrentCollectionsV2DeleteAtPathInput = {\n  collection_properties?: InputMaybe<Array<Scalars[\"String\"][\"input\"]>>;\n};\n\n/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */\nexport type CurrentCollectionsV2DeleteElemInput = {\n  collection_properties?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n};\n\n/** delete key/value pair or string element. key/value pairs are matched based on their key value */\nexport type CurrentCollectionsV2DeleteKeyInput = {\n  collection_properties?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** input type for incrementing numeric columns in table \"current_collections_v2\" */\nexport type CurrentCollectionsV2IncInput = {\n  current_supply?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  max_supply?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  total_minted_v2?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n};\n\n/** input type for inserting data into table \"current_collections_v2\" */\nexport type CurrentCollectionsV2InsertInput = {\n  cdn_asset_uris?: InputMaybe<NftMetadataCrawlerParsedAssetUrisObjRelInsertInput>;\n  collection_id?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  collection_name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  collection_properties?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  creator_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  current_supply?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  description?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  last_transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  max_supply?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  mutable_description?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  mutable_uri?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  table_handle_v1?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_standard?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  total_minted_v2?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  uri?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate max on columns */\nexport type CurrentCollectionsV2MaxFields = {\n  collection_id?: Maybe<Scalars[\"String\"][\"output\"]>;\n  collection_name?: Maybe<Scalars[\"String\"][\"output\"]>;\n  creator_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  current_supply?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  description?: Maybe<Scalars[\"String\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  last_transaction_timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  max_supply?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  table_handle_v1?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_standard?: Maybe<Scalars[\"String\"][\"output\"]>;\n  total_minted_v2?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  uri?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** aggregate min on columns */\nexport type CurrentCollectionsV2MinFields = {\n  collection_id?: Maybe<Scalars[\"String\"][\"output\"]>;\n  collection_name?: Maybe<Scalars[\"String\"][\"output\"]>;\n  creator_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  current_supply?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  description?: Maybe<Scalars[\"String\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  last_transaction_timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  max_supply?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  table_handle_v1?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_standard?: Maybe<Scalars[\"String\"][\"output\"]>;\n  total_minted_v2?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  uri?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** response of any mutation on the table \"current_collections_v2\" */\nexport type CurrentCollectionsV2MutationResponse = {\n  /** number of rows affected by the mutation */\n  affected_rows: Scalars[\"Int\"][\"output\"];\n  /** data from the rows affected by the mutation */\n  returning: Array<CurrentCollectionsV2>;\n};\n\n/** input type for inserting object relation for remote table \"current_collections_v2\" */\nexport type CurrentCollectionsV2ObjRelInsertInput = {\n  data: CurrentCollectionsV2InsertInput;\n  /** upsert condition */\n  on_conflict?: InputMaybe<CurrentCollectionsV2OnConflict>;\n};\n\n/** on_conflict condition type for table \"current_collections_v2\" */\nexport type CurrentCollectionsV2OnConflict = {\n  constraint: CurrentCollectionsV2Constraint;\n  update_columns?: Array<CurrentCollectionsV2UpdateColumn>;\n  where?: InputMaybe<CurrentCollectionsV2BoolExp>;\n};\n\n/** Ordering options when selecting data from \"current_collections_v2\". */\nexport type CurrentCollectionsV2OrderBy = {\n  cdn_asset_uris?: InputMaybe<NftMetadataCrawlerParsedAssetUrisOrderBy>;\n  collection_id?: InputMaybe<OrderBy>;\n  collection_name?: InputMaybe<OrderBy>;\n  collection_properties?: InputMaybe<OrderBy>;\n  creator_address?: InputMaybe<OrderBy>;\n  current_supply?: InputMaybe<OrderBy>;\n  description?: InputMaybe<OrderBy>;\n  inserted_at?: InputMaybe<OrderBy>;\n  last_transaction_timestamp?: InputMaybe<OrderBy>;\n  last_transaction_version?: InputMaybe<OrderBy>;\n  max_supply?: InputMaybe<OrderBy>;\n  mutable_description?: InputMaybe<OrderBy>;\n  mutable_uri?: InputMaybe<OrderBy>;\n  table_handle_v1?: InputMaybe<OrderBy>;\n  token_standard?: InputMaybe<OrderBy>;\n  total_minted_v2?: InputMaybe<OrderBy>;\n  uri?: InputMaybe<OrderBy>;\n};\n\n/** primary key columns input for table: current_collections_v2 */\nexport type CurrentCollectionsV2PkColumnsInput = {\n  collection_id: Scalars[\"String\"][\"input\"];\n};\n\n/** prepend existing jsonb value of filtered columns with new jsonb value */\nexport type CurrentCollectionsV2PrependInput = {\n  collection_properties?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n};\n\n/** select columns of table \"current_collections_v2\" */\nexport enum CurrentCollectionsV2SelectColumn {\n  /** column name */\n  CollectionId = \"collection_id\",\n  /** column name */\n  CollectionName = \"collection_name\",\n  /** column name */\n  CollectionProperties = \"collection_properties\",\n  /** column name */\n  CreatorAddress = \"creator_address\",\n  /** column name */\n  CurrentSupply = \"current_supply\",\n  /** column name */\n  Description = \"description\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  LastTransactionTimestamp = \"last_transaction_timestamp\",\n  /** column name */\n  LastTransactionVersion = \"last_transaction_version\",\n  /** column name */\n  MaxSupply = \"max_supply\",\n  /** column name */\n  MutableDescription = \"mutable_description\",\n  /** column name */\n  MutableUri = \"mutable_uri\",\n  /** column name */\n  TableHandleV1 = \"table_handle_v1\",\n  /** column name */\n  TokenStandard = \"token_standard\",\n  /** column name */\n  TotalMintedV2 = \"total_minted_v2\",\n  /** column name */\n  Uri = \"uri\",\n}\n\n/** input type for updating data in table \"current_collections_v2\" */\nexport type CurrentCollectionsV2SetInput = {\n  collection_id?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  collection_name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  collection_properties?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  creator_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  current_supply?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  description?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  last_transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  max_supply?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  mutable_description?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  mutable_uri?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  table_handle_v1?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_standard?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  total_minted_v2?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  uri?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate stddev on columns */\nexport type CurrentCollectionsV2StddevFields = {\n  current_supply?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  max_supply?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  total_minted_v2?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_pop on columns */\nexport type CurrentCollectionsV2StddevPopFields = {\n  current_supply?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  max_supply?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  total_minted_v2?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_samp on columns */\nexport type CurrentCollectionsV2StddevSampFields = {\n  current_supply?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  max_supply?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  total_minted_v2?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Streaming cursor of the table \"current_collections_v2\" */\nexport type CurrentCollectionsV2StreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: CurrentCollectionsV2StreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type CurrentCollectionsV2StreamCursorValueInput = {\n  collection_id?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  collection_name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  collection_properties?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  creator_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  current_supply?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  description?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  last_transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  max_supply?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  mutable_description?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  mutable_uri?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  table_handle_v1?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_standard?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  total_minted_v2?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  uri?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate sum on columns */\nexport type CurrentCollectionsV2SumFields = {\n  current_supply?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  max_supply?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  total_minted_v2?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n};\n\n/** update columns of table \"current_collections_v2\" */\nexport enum CurrentCollectionsV2UpdateColumn {\n  /** column name */\n  CollectionId = \"collection_id\",\n  /** column name */\n  CollectionName = \"collection_name\",\n  /** column name */\n  CollectionProperties = \"collection_properties\",\n  /** column name */\n  CreatorAddress = \"creator_address\",\n  /** column name */\n  CurrentSupply = \"current_supply\",\n  /** column name */\n  Description = \"description\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  LastTransactionTimestamp = \"last_transaction_timestamp\",\n  /** column name */\n  LastTransactionVersion = \"last_transaction_version\",\n  /** column name */\n  MaxSupply = \"max_supply\",\n  /** column name */\n  MutableDescription = \"mutable_description\",\n  /** column name */\n  MutableUri = \"mutable_uri\",\n  /** column name */\n  TableHandleV1 = \"table_handle_v1\",\n  /** column name */\n  TokenStandard = \"token_standard\",\n  /** column name */\n  TotalMintedV2 = \"total_minted_v2\",\n  /** column name */\n  Uri = \"uri\",\n}\n\nexport type CurrentCollectionsV2Updates = {\n  /** append existing jsonb value of filtered columns with new jsonb value */\n  _append?: InputMaybe<CurrentCollectionsV2AppendInput>;\n  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */\n  _delete_at_path?: InputMaybe<CurrentCollectionsV2DeleteAtPathInput>;\n  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */\n  _delete_elem?: InputMaybe<CurrentCollectionsV2DeleteElemInput>;\n  /** delete key/value pair or string element. key/value pairs are matched based on their key value */\n  _delete_key?: InputMaybe<CurrentCollectionsV2DeleteKeyInput>;\n  /** increments the numeric columns with given value of the filtered values */\n  _inc?: InputMaybe<CurrentCollectionsV2IncInput>;\n  /** prepend existing jsonb value of filtered columns with new jsonb value */\n  _prepend?: InputMaybe<CurrentCollectionsV2PrependInput>;\n  /** sets the columns of the filtered rows to the given values */\n  _set?: InputMaybe<CurrentCollectionsV2SetInput>;\n  /** filter the rows which have to be updated */\n  where: CurrentCollectionsV2BoolExp;\n};\n\n/** aggregate var_pop on columns */\nexport type CurrentCollectionsV2VarPopFields = {\n  current_supply?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  max_supply?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  total_minted_v2?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate var_samp on columns */\nexport type CurrentCollectionsV2VarSampFields = {\n  current_supply?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  max_supply?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  total_minted_v2?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate variance on columns */\nexport type CurrentCollectionsV2VarianceFields = {\n  current_supply?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  max_supply?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  total_minted_v2?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** columns and relationships of \"current_delegated_staking_pool_balances\" */\nexport type CurrentDelegatedStakingPoolBalances = {\n  active_table_handle: Scalars[\"String\"][\"output\"];\n  inactive_table_handle: Scalars[\"String\"][\"output\"];\n  inserted_at: Scalars[\"timestamp\"][\"output\"];\n  last_transaction_version: Scalars[\"bigint\"][\"output\"];\n  operator_commission_percentage: Scalars[\"numeric\"][\"output\"];\n  staking_pool_address: Scalars[\"String\"][\"output\"];\n  total_coins: Scalars[\"numeric\"][\"output\"];\n  total_shares: Scalars[\"numeric\"][\"output\"];\n};\n\n/** aggregated selection of \"current_delegated_staking_pool_balances\" */\nexport type CurrentDelegatedStakingPoolBalancesAggregate = {\n  aggregate?: Maybe<CurrentDelegatedStakingPoolBalancesAggregateFields>;\n  nodes: Array<CurrentDelegatedStakingPoolBalances>;\n};\n\n/** aggregate fields of \"current_delegated_staking_pool_balances\" */\nexport type CurrentDelegatedStakingPoolBalancesAggregateFields = {\n  avg?: Maybe<CurrentDelegatedStakingPoolBalancesAvgFields>;\n  count: Scalars[\"Int\"][\"output\"];\n  max?: Maybe<CurrentDelegatedStakingPoolBalancesMaxFields>;\n  min?: Maybe<CurrentDelegatedStakingPoolBalancesMinFields>;\n  stddev?: Maybe<CurrentDelegatedStakingPoolBalancesStddevFields>;\n  stddev_pop?: Maybe<CurrentDelegatedStakingPoolBalancesStddevPopFields>;\n  stddev_samp?: Maybe<CurrentDelegatedStakingPoolBalancesStddevSampFields>;\n  sum?: Maybe<CurrentDelegatedStakingPoolBalancesSumFields>;\n  var_pop?: Maybe<CurrentDelegatedStakingPoolBalancesVarPopFields>;\n  var_samp?: Maybe<CurrentDelegatedStakingPoolBalancesVarSampFields>;\n  variance?: Maybe<CurrentDelegatedStakingPoolBalancesVarianceFields>;\n};\n\n/** aggregate fields of \"current_delegated_staking_pool_balances\" */\nexport type CurrentDelegatedStakingPoolBalancesAggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<CurrentDelegatedStakingPoolBalancesSelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** aggregate avg on columns */\nexport type CurrentDelegatedStakingPoolBalancesAvgFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  operator_commission_percentage?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  total_coins?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  total_shares?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Boolean expression to filter rows from the table \"current_delegated_staking_pool_balances\". All fields are combined with a logical 'AND'. */\nexport type CurrentDelegatedStakingPoolBalancesBoolExp = {\n  _and?: InputMaybe<Array<CurrentDelegatedStakingPoolBalancesBoolExp>>;\n  _not?: InputMaybe<CurrentDelegatedStakingPoolBalancesBoolExp>;\n  _or?: InputMaybe<Array<CurrentDelegatedStakingPoolBalancesBoolExp>>;\n  active_table_handle?: InputMaybe<StringComparisonExp>;\n  inactive_table_handle?: InputMaybe<StringComparisonExp>;\n  inserted_at?: InputMaybe<TimestampComparisonExp>;\n  last_transaction_version?: InputMaybe<BigintComparisonExp>;\n  operator_commission_percentage?: InputMaybe<NumericComparisonExp>;\n  staking_pool_address?: InputMaybe<StringComparisonExp>;\n  total_coins?: InputMaybe<NumericComparisonExp>;\n  total_shares?: InputMaybe<NumericComparisonExp>;\n};\n\n/** unique or primary key constraints on table \"current_delegated_staking_pool_balances\" */\nexport enum CurrentDelegatedStakingPoolBalancesConstraint {\n  /** unique or primary key constraint on columns \"staking_pool_address\" */\n  CurrentDelegatedStakingPoolBalancesPkey = \"current_delegated_staking_pool_balances_pkey\",\n}\n\n/** input type for incrementing numeric columns in table \"current_delegated_staking_pool_balances\" */\nexport type CurrentDelegatedStakingPoolBalancesIncInput = {\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  operator_commission_percentage?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  total_coins?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  total_shares?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n};\n\n/** input type for inserting data into table \"current_delegated_staking_pool_balances\" */\nexport type CurrentDelegatedStakingPoolBalancesInsertInput = {\n  active_table_handle?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inactive_table_handle?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  operator_commission_percentage?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  staking_pool_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  total_coins?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  total_shares?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n};\n\n/** aggregate max on columns */\nexport type CurrentDelegatedStakingPoolBalancesMaxFields = {\n  active_table_handle?: Maybe<Scalars[\"String\"][\"output\"]>;\n  inactive_table_handle?: Maybe<Scalars[\"String\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  operator_commission_percentage?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  staking_pool_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  total_coins?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  total_shares?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n};\n\n/** aggregate min on columns */\nexport type CurrentDelegatedStakingPoolBalancesMinFields = {\n  active_table_handle?: Maybe<Scalars[\"String\"][\"output\"]>;\n  inactive_table_handle?: Maybe<Scalars[\"String\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  operator_commission_percentage?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  staking_pool_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  total_coins?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  total_shares?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n};\n\n/** response of any mutation on the table \"current_delegated_staking_pool_balances\" */\nexport type CurrentDelegatedStakingPoolBalancesMutationResponse = {\n  /** number of rows affected by the mutation */\n  affected_rows: Scalars[\"Int\"][\"output\"];\n  /** data from the rows affected by the mutation */\n  returning: Array<CurrentDelegatedStakingPoolBalances>;\n};\n\n/** input type for inserting object relation for remote table \"current_delegated_staking_pool_balances\" */\nexport type CurrentDelegatedStakingPoolBalancesObjRelInsertInput = {\n  data: CurrentDelegatedStakingPoolBalancesInsertInput;\n  /** upsert condition */\n  on_conflict?: InputMaybe<CurrentDelegatedStakingPoolBalancesOnConflict>;\n};\n\n/** on_conflict condition type for table \"current_delegated_staking_pool_balances\" */\nexport type CurrentDelegatedStakingPoolBalancesOnConflict = {\n  constraint: CurrentDelegatedStakingPoolBalancesConstraint;\n  update_columns?: Array<CurrentDelegatedStakingPoolBalancesUpdateColumn>;\n  where?: InputMaybe<CurrentDelegatedStakingPoolBalancesBoolExp>;\n};\n\n/** Ordering options when selecting data from \"current_delegated_staking_pool_balances\". */\nexport type CurrentDelegatedStakingPoolBalancesOrderBy = {\n  active_table_handle?: InputMaybe<OrderBy>;\n  inactive_table_handle?: InputMaybe<OrderBy>;\n  inserted_at?: InputMaybe<OrderBy>;\n  last_transaction_version?: InputMaybe<OrderBy>;\n  operator_commission_percentage?: InputMaybe<OrderBy>;\n  staking_pool_address?: InputMaybe<OrderBy>;\n  total_coins?: InputMaybe<OrderBy>;\n  total_shares?: InputMaybe<OrderBy>;\n};\n\n/** primary key columns input for table: current_delegated_staking_pool_balances */\nexport type CurrentDelegatedStakingPoolBalancesPkColumnsInput = {\n  staking_pool_address: Scalars[\"String\"][\"input\"];\n};\n\n/** select columns of table \"current_delegated_staking_pool_balances\" */\nexport enum CurrentDelegatedStakingPoolBalancesSelectColumn {\n  /** column name */\n  ActiveTableHandle = \"active_table_handle\",\n  /** column name */\n  InactiveTableHandle = \"inactive_table_handle\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  LastTransactionVersion = \"last_transaction_version\",\n  /** column name */\n  OperatorCommissionPercentage = \"operator_commission_percentage\",\n  /** column name */\n  StakingPoolAddress = \"staking_pool_address\",\n  /** column name */\n  TotalCoins = \"total_coins\",\n  /** column name */\n  TotalShares = \"total_shares\",\n}\n\n/** input type for updating data in table \"current_delegated_staking_pool_balances\" */\nexport type CurrentDelegatedStakingPoolBalancesSetInput = {\n  active_table_handle?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inactive_table_handle?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  operator_commission_percentage?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  staking_pool_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  total_coins?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  total_shares?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n};\n\n/** aggregate stddev on columns */\nexport type CurrentDelegatedStakingPoolBalancesStddevFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  operator_commission_percentage?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  total_coins?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  total_shares?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_pop on columns */\nexport type CurrentDelegatedStakingPoolBalancesStddevPopFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  operator_commission_percentage?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  total_coins?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  total_shares?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_samp on columns */\nexport type CurrentDelegatedStakingPoolBalancesStddevSampFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  operator_commission_percentage?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  total_coins?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  total_shares?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Streaming cursor of the table \"current_delegated_staking_pool_balances\" */\nexport type CurrentDelegatedStakingPoolBalancesStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: CurrentDelegatedStakingPoolBalancesStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type CurrentDelegatedStakingPoolBalancesStreamCursorValueInput = {\n  active_table_handle?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inactive_table_handle?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  operator_commission_percentage?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  staking_pool_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  total_coins?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  total_shares?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n};\n\n/** aggregate sum on columns */\nexport type CurrentDelegatedStakingPoolBalancesSumFields = {\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  operator_commission_percentage?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  total_coins?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  total_shares?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n};\n\n/** update columns of table \"current_delegated_staking_pool_balances\" */\nexport enum CurrentDelegatedStakingPoolBalancesUpdateColumn {\n  /** column name */\n  ActiveTableHandle = \"active_table_handle\",\n  /** column name */\n  InactiveTableHandle = \"inactive_table_handle\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  LastTransactionVersion = \"last_transaction_version\",\n  /** column name */\n  OperatorCommissionPercentage = \"operator_commission_percentage\",\n  /** column name */\n  StakingPoolAddress = \"staking_pool_address\",\n  /** column name */\n  TotalCoins = \"total_coins\",\n  /** column name */\n  TotalShares = \"total_shares\",\n}\n\nexport type CurrentDelegatedStakingPoolBalancesUpdates = {\n  /** increments the numeric columns with given value of the filtered values */\n  _inc?: InputMaybe<CurrentDelegatedStakingPoolBalancesIncInput>;\n  /** sets the columns of the filtered rows to the given values */\n  _set?: InputMaybe<CurrentDelegatedStakingPoolBalancesSetInput>;\n  /** filter the rows which have to be updated */\n  where: CurrentDelegatedStakingPoolBalancesBoolExp;\n};\n\n/** aggregate var_pop on columns */\nexport type CurrentDelegatedStakingPoolBalancesVarPopFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  operator_commission_percentage?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  total_coins?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  total_shares?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate var_samp on columns */\nexport type CurrentDelegatedStakingPoolBalancesVarSampFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  operator_commission_percentage?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  total_coins?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  total_shares?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate variance on columns */\nexport type CurrentDelegatedStakingPoolBalancesVarianceFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  operator_commission_percentage?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  total_coins?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  total_shares?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** columns and relationships of \"current_delegated_voter\" */\nexport type CurrentDelegatedVoter = {\n  delegation_pool_address: Scalars[\"String\"][\"output\"];\n  delegator_address: Scalars[\"String\"][\"output\"];\n  inserted_at: Scalars[\"timestamp\"][\"output\"];\n  last_transaction_timestamp: Scalars[\"timestamp\"][\"output\"];\n  last_transaction_version: Scalars[\"bigint\"][\"output\"];\n  pending_voter?: Maybe<Scalars[\"String\"][\"output\"]>;\n  table_handle?: Maybe<Scalars[\"String\"][\"output\"]>;\n  voter?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** aggregated selection of \"current_delegated_voter\" */\nexport type CurrentDelegatedVoterAggregate = {\n  aggregate?: Maybe<CurrentDelegatedVoterAggregateFields>;\n  nodes: Array<CurrentDelegatedVoter>;\n};\n\n/** aggregate fields of \"current_delegated_voter\" */\nexport type CurrentDelegatedVoterAggregateFields = {\n  avg?: Maybe<CurrentDelegatedVoterAvgFields>;\n  count: Scalars[\"Int\"][\"output\"];\n  max?: Maybe<CurrentDelegatedVoterMaxFields>;\n  min?: Maybe<CurrentDelegatedVoterMinFields>;\n  stddev?: Maybe<CurrentDelegatedVoterStddevFields>;\n  stddev_pop?: Maybe<CurrentDelegatedVoterStddevPopFields>;\n  stddev_samp?: Maybe<CurrentDelegatedVoterStddevSampFields>;\n  sum?: Maybe<CurrentDelegatedVoterSumFields>;\n  var_pop?: Maybe<CurrentDelegatedVoterVarPopFields>;\n  var_samp?: Maybe<CurrentDelegatedVoterVarSampFields>;\n  variance?: Maybe<CurrentDelegatedVoterVarianceFields>;\n};\n\n/** aggregate fields of \"current_delegated_voter\" */\nexport type CurrentDelegatedVoterAggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<CurrentDelegatedVoterSelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** aggregate avg on columns */\nexport type CurrentDelegatedVoterAvgFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Boolean expression to filter rows from the table \"current_delegated_voter\". All fields are combined with a logical 'AND'. */\nexport type CurrentDelegatedVoterBoolExp = {\n  _and?: InputMaybe<Array<CurrentDelegatedVoterBoolExp>>;\n  _not?: InputMaybe<CurrentDelegatedVoterBoolExp>;\n  _or?: InputMaybe<Array<CurrentDelegatedVoterBoolExp>>;\n  delegation_pool_address?: InputMaybe<StringComparisonExp>;\n  delegator_address?: InputMaybe<StringComparisonExp>;\n  inserted_at?: InputMaybe<TimestampComparisonExp>;\n  last_transaction_timestamp?: InputMaybe<TimestampComparisonExp>;\n  last_transaction_version?: InputMaybe<BigintComparisonExp>;\n  pending_voter?: InputMaybe<StringComparisonExp>;\n  table_handle?: InputMaybe<StringComparisonExp>;\n  voter?: InputMaybe<StringComparisonExp>;\n};\n\n/** unique or primary key constraints on table \"current_delegated_voter\" */\nexport enum CurrentDelegatedVoterConstraint {\n  /** unique or primary key constraint on columns \"delegator_address\", \"delegation_pool_address\" */\n  CurrentDelegatedVoterPkey = \"current_delegated_voter_pkey\",\n}\n\n/** input type for incrementing numeric columns in table \"current_delegated_voter\" */\nexport type CurrentDelegatedVoterIncInput = {\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** input type for inserting data into table \"current_delegated_voter\" */\nexport type CurrentDelegatedVoterInsertInput = {\n  delegation_pool_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  delegator_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  last_transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  pending_voter?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  table_handle?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  voter?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate max on columns */\nexport type CurrentDelegatedVoterMaxFields = {\n  delegation_pool_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  delegator_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  last_transaction_timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  pending_voter?: Maybe<Scalars[\"String\"][\"output\"]>;\n  table_handle?: Maybe<Scalars[\"String\"][\"output\"]>;\n  voter?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** aggregate min on columns */\nexport type CurrentDelegatedVoterMinFields = {\n  delegation_pool_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  delegator_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  last_transaction_timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  pending_voter?: Maybe<Scalars[\"String\"][\"output\"]>;\n  table_handle?: Maybe<Scalars[\"String\"][\"output\"]>;\n  voter?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** response of any mutation on the table \"current_delegated_voter\" */\nexport type CurrentDelegatedVoterMutationResponse = {\n  /** number of rows affected by the mutation */\n  affected_rows: Scalars[\"Int\"][\"output\"];\n  /** data from the rows affected by the mutation */\n  returning: Array<CurrentDelegatedVoter>;\n};\n\n/** on_conflict condition type for table \"current_delegated_voter\" */\nexport type CurrentDelegatedVoterOnConflict = {\n  constraint: CurrentDelegatedVoterConstraint;\n  update_columns?: Array<CurrentDelegatedVoterUpdateColumn>;\n  where?: InputMaybe<CurrentDelegatedVoterBoolExp>;\n};\n\n/** Ordering options when selecting data from \"current_delegated_voter\". */\nexport type CurrentDelegatedVoterOrderBy = {\n  delegation_pool_address?: InputMaybe<OrderBy>;\n  delegator_address?: InputMaybe<OrderBy>;\n  inserted_at?: InputMaybe<OrderBy>;\n  last_transaction_timestamp?: InputMaybe<OrderBy>;\n  last_transaction_version?: InputMaybe<OrderBy>;\n  pending_voter?: InputMaybe<OrderBy>;\n  table_handle?: InputMaybe<OrderBy>;\n  voter?: InputMaybe<OrderBy>;\n};\n\n/** primary key columns input for table: current_delegated_voter */\nexport type CurrentDelegatedVoterPkColumnsInput = {\n  delegation_pool_address: Scalars[\"String\"][\"input\"];\n  delegator_address: Scalars[\"String\"][\"input\"];\n};\n\n/** select columns of table \"current_delegated_voter\" */\nexport enum CurrentDelegatedVoterSelectColumn {\n  /** column name */\n  DelegationPoolAddress = \"delegation_pool_address\",\n  /** column name */\n  DelegatorAddress = \"delegator_address\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  LastTransactionTimestamp = \"last_transaction_timestamp\",\n  /** column name */\n  LastTransactionVersion = \"last_transaction_version\",\n  /** column name */\n  PendingVoter = \"pending_voter\",\n  /** column name */\n  TableHandle = \"table_handle\",\n  /** column name */\n  Voter = \"voter\",\n}\n\n/** input type for updating data in table \"current_delegated_voter\" */\nexport type CurrentDelegatedVoterSetInput = {\n  delegation_pool_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  delegator_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  last_transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  pending_voter?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  table_handle?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  voter?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate stddev on columns */\nexport type CurrentDelegatedVoterStddevFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_pop on columns */\nexport type CurrentDelegatedVoterStddevPopFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_samp on columns */\nexport type CurrentDelegatedVoterStddevSampFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Streaming cursor of the table \"current_delegated_voter\" */\nexport type CurrentDelegatedVoterStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: CurrentDelegatedVoterStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type CurrentDelegatedVoterStreamCursorValueInput = {\n  delegation_pool_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  delegator_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  last_transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  pending_voter?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  table_handle?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  voter?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate sum on columns */\nexport type CurrentDelegatedVoterSumFields = {\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** update columns of table \"current_delegated_voter\" */\nexport enum CurrentDelegatedVoterUpdateColumn {\n  /** column name */\n  DelegationPoolAddress = \"delegation_pool_address\",\n  /** column name */\n  DelegatorAddress = \"delegator_address\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  LastTransactionTimestamp = \"last_transaction_timestamp\",\n  /** column name */\n  LastTransactionVersion = \"last_transaction_version\",\n  /** column name */\n  PendingVoter = \"pending_voter\",\n  /** column name */\n  TableHandle = \"table_handle\",\n  /** column name */\n  Voter = \"voter\",\n}\n\nexport type CurrentDelegatedVoterUpdates = {\n  /** increments the numeric columns with given value of the filtered values */\n  _inc?: InputMaybe<CurrentDelegatedVoterIncInput>;\n  /** sets the columns of the filtered rows to the given values */\n  _set?: InputMaybe<CurrentDelegatedVoterSetInput>;\n  /** filter the rows which have to be updated */\n  where: CurrentDelegatedVoterBoolExp;\n};\n\n/** aggregate var_pop on columns */\nexport type CurrentDelegatedVoterVarPopFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate var_samp on columns */\nexport type CurrentDelegatedVoterVarSampFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate variance on columns */\nexport type CurrentDelegatedVoterVarianceFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** columns and relationships of \"current_delegator_balances\" */\nexport type CurrentDelegatorBalances = {\n  /** An object relationship */\n  current_pool_balance?: Maybe<CurrentDelegatedStakingPoolBalances>;\n  delegator_address: Scalars[\"String\"][\"output\"];\n  inserted_at: Scalars[\"timestamp\"][\"output\"];\n  last_transaction_version: Scalars[\"bigint\"][\"output\"];\n  parent_table_handle: Scalars[\"String\"][\"output\"];\n  pool_address: Scalars[\"String\"][\"output\"];\n  pool_type: Scalars[\"String\"][\"output\"];\n  shares: Scalars[\"numeric\"][\"output\"];\n  /** An object relationship */\n  staking_pool_metadata?: Maybe<CurrentStakingPoolVoter>;\n  table_handle: Scalars[\"String\"][\"output\"];\n};\n\n/** aggregated selection of \"current_delegator_balances\" */\nexport type CurrentDelegatorBalancesAggregate = {\n  aggregate?: Maybe<CurrentDelegatorBalancesAggregateFields>;\n  nodes: Array<CurrentDelegatorBalances>;\n};\n\n/** aggregate fields of \"current_delegator_balances\" */\nexport type CurrentDelegatorBalancesAggregateFields = {\n  avg?: Maybe<CurrentDelegatorBalancesAvgFields>;\n  count: Scalars[\"Int\"][\"output\"];\n  max?: Maybe<CurrentDelegatorBalancesMaxFields>;\n  min?: Maybe<CurrentDelegatorBalancesMinFields>;\n  stddev?: Maybe<CurrentDelegatorBalancesStddevFields>;\n  stddev_pop?: Maybe<CurrentDelegatorBalancesStddevPopFields>;\n  stddev_samp?: Maybe<CurrentDelegatorBalancesStddevSampFields>;\n  sum?: Maybe<CurrentDelegatorBalancesSumFields>;\n  var_pop?: Maybe<CurrentDelegatorBalancesVarPopFields>;\n  var_samp?: Maybe<CurrentDelegatorBalancesVarSampFields>;\n  variance?: Maybe<CurrentDelegatorBalancesVarianceFields>;\n};\n\n/** aggregate fields of \"current_delegator_balances\" */\nexport type CurrentDelegatorBalancesAggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<CurrentDelegatorBalancesSelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** aggregate avg on columns */\nexport type CurrentDelegatorBalancesAvgFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  shares?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Boolean expression to filter rows from the table \"current_delegator_balances\". All fields are combined with a logical 'AND'. */\nexport type CurrentDelegatorBalancesBoolExp = {\n  _and?: InputMaybe<Array<CurrentDelegatorBalancesBoolExp>>;\n  _not?: InputMaybe<CurrentDelegatorBalancesBoolExp>;\n  _or?: InputMaybe<Array<CurrentDelegatorBalancesBoolExp>>;\n  current_pool_balance?: InputMaybe<CurrentDelegatedStakingPoolBalancesBoolExp>;\n  delegator_address?: InputMaybe<StringComparisonExp>;\n  inserted_at?: InputMaybe<TimestampComparisonExp>;\n  last_transaction_version?: InputMaybe<BigintComparisonExp>;\n  parent_table_handle?: InputMaybe<StringComparisonExp>;\n  pool_address?: InputMaybe<StringComparisonExp>;\n  pool_type?: InputMaybe<StringComparisonExp>;\n  shares?: InputMaybe<NumericComparisonExp>;\n  staking_pool_metadata?: InputMaybe<CurrentStakingPoolVoterBoolExp>;\n  table_handle?: InputMaybe<StringComparisonExp>;\n};\n\n/** unique or primary key constraints on table \"current_delegator_balances\" */\nexport enum CurrentDelegatorBalancesConstraint {\n  /** unique or primary key constraint on columns \"delegator_address\", \"pool_address\", \"pool_type\", \"table_handle\" */\n  CurrentDelegatorBalancesPkey = \"current_delegator_balances_pkey\",\n}\n\n/** input type for incrementing numeric columns in table \"current_delegator_balances\" */\nexport type CurrentDelegatorBalancesIncInput = {\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  shares?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n};\n\n/** input type for inserting data into table \"current_delegator_balances\" */\nexport type CurrentDelegatorBalancesInsertInput = {\n  current_pool_balance?: InputMaybe<CurrentDelegatedStakingPoolBalancesObjRelInsertInput>;\n  delegator_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  parent_table_handle?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  pool_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  pool_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  shares?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  staking_pool_metadata?: InputMaybe<CurrentStakingPoolVoterObjRelInsertInput>;\n  table_handle?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate max on columns */\nexport type CurrentDelegatorBalancesMaxFields = {\n  delegator_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  parent_table_handle?: Maybe<Scalars[\"String\"][\"output\"]>;\n  pool_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  pool_type?: Maybe<Scalars[\"String\"][\"output\"]>;\n  shares?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  table_handle?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** aggregate min on columns */\nexport type CurrentDelegatorBalancesMinFields = {\n  delegator_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  parent_table_handle?: Maybe<Scalars[\"String\"][\"output\"]>;\n  pool_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  pool_type?: Maybe<Scalars[\"String\"][\"output\"]>;\n  shares?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  table_handle?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** response of any mutation on the table \"current_delegator_balances\" */\nexport type CurrentDelegatorBalancesMutationResponse = {\n  /** number of rows affected by the mutation */\n  affected_rows: Scalars[\"Int\"][\"output\"];\n  /** data from the rows affected by the mutation */\n  returning: Array<CurrentDelegatorBalances>;\n};\n\n/** on_conflict condition type for table \"current_delegator_balances\" */\nexport type CurrentDelegatorBalancesOnConflict = {\n  constraint: CurrentDelegatorBalancesConstraint;\n  update_columns?: Array<CurrentDelegatorBalancesUpdateColumn>;\n  where?: InputMaybe<CurrentDelegatorBalancesBoolExp>;\n};\n\n/** Ordering options when selecting data from \"current_delegator_balances\". */\nexport type CurrentDelegatorBalancesOrderBy = {\n  current_pool_balance?: InputMaybe<CurrentDelegatedStakingPoolBalancesOrderBy>;\n  delegator_address?: InputMaybe<OrderBy>;\n  inserted_at?: InputMaybe<OrderBy>;\n  last_transaction_version?: InputMaybe<OrderBy>;\n  parent_table_handle?: InputMaybe<OrderBy>;\n  pool_address?: InputMaybe<OrderBy>;\n  pool_type?: InputMaybe<OrderBy>;\n  shares?: InputMaybe<OrderBy>;\n  staking_pool_metadata?: InputMaybe<CurrentStakingPoolVoterOrderBy>;\n  table_handle?: InputMaybe<OrderBy>;\n};\n\n/** primary key columns input for table: current_delegator_balances */\nexport type CurrentDelegatorBalancesPkColumnsInput = {\n  delegator_address: Scalars[\"String\"][\"input\"];\n  pool_address: Scalars[\"String\"][\"input\"];\n  pool_type: Scalars[\"String\"][\"input\"];\n  table_handle: Scalars[\"String\"][\"input\"];\n};\n\n/** select columns of table \"current_delegator_balances\" */\nexport enum CurrentDelegatorBalancesSelectColumn {\n  /** column name */\n  DelegatorAddress = \"delegator_address\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  LastTransactionVersion = \"last_transaction_version\",\n  /** column name */\n  ParentTableHandle = \"parent_table_handle\",\n  /** column name */\n  PoolAddress = \"pool_address\",\n  /** column name */\n  PoolType = \"pool_type\",\n  /** column name */\n  Shares = \"shares\",\n  /** column name */\n  TableHandle = \"table_handle\",\n}\n\n/** input type for updating data in table \"current_delegator_balances\" */\nexport type CurrentDelegatorBalancesSetInput = {\n  delegator_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  parent_table_handle?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  pool_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  pool_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  shares?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  table_handle?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate stddev on columns */\nexport type CurrentDelegatorBalancesStddevFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  shares?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_pop on columns */\nexport type CurrentDelegatorBalancesStddevPopFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  shares?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_samp on columns */\nexport type CurrentDelegatorBalancesStddevSampFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  shares?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Streaming cursor of the table \"current_delegator_balances\" */\nexport type CurrentDelegatorBalancesStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: CurrentDelegatorBalancesStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type CurrentDelegatorBalancesStreamCursorValueInput = {\n  delegator_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  parent_table_handle?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  pool_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  pool_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  shares?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  table_handle?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate sum on columns */\nexport type CurrentDelegatorBalancesSumFields = {\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  shares?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n};\n\n/** update columns of table \"current_delegator_balances\" */\nexport enum CurrentDelegatorBalancesUpdateColumn {\n  /** column name */\n  DelegatorAddress = \"delegator_address\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  LastTransactionVersion = \"last_transaction_version\",\n  /** column name */\n  ParentTableHandle = \"parent_table_handle\",\n  /** column name */\n  PoolAddress = \"pool_address\",\n  /** column name */\n  PoolType = \"pool_type\",\n  /** column name */\n  Shares = \"shares\",\n  /** column name */\n  TableHandle = \"table_handle\",\n}\n\nexport type CurrentDelegatorBalancesUpdates = {\n  /** increments the numeric columns with given value of the filtered values */\n  _inc?: InputMaybe<CurrentDelegatorBalancesIncInput>;\n  /** sets the columns of the filtered rows to the given values */\n  _set?: InputMaybe<CurrentDelegatorBalancesSetInput>;\n  /** filter the rows which have to be updated */\n  where: CurrentDelegatorBalancesBoolExp;\n};\n\n/** aggregate var_pop on columns */\nexport type CurrentDelegatorBalancesVarPopFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  shares?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate var_samp on columns */\nexport type CurrentDelegatorBalancesVarSampFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  shares?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate variance on columns */\nexport type CurrentDelegatorBalancesVarianceFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  shares?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** columns and relationships of \"current_fungible_asset_balances_legacy\" */\nexport type CurrentFungibleAssetBalances = {\n  amount: Scalars[\"numeric\"][\"output\"];\n  asset_type: Scalars[\"String\"][\"output\"];\n  inserted_at: Scalars[\"timestamp\"][\"output\"];\n  is_frozen: Scalars[\"Boolean\"][\"output\"];\n  is_primary: Scalars[\"Boolean\"][\"output\"];\n  last_transaction_timestamp: Scalars[\"timestamp\"][\"output\"];\n  last_transaction_version: Scalars[\"bigint\"][\"output\"];\n  /** An object relationship */\n  metadata?: Maybe<FungibleAssetMetadata>;\n  owner_address: Scalars[\"String\"][\"output\"];\n  storage_id: Scalars[\"String\"][\"output\"];\n  token_standard: Scalars[\"String\"][\"output\"];\n};\n\n/** aggregated selection of \"current_fungible_asset_balances_legacy\" */\nexport type CurrentFungibleAssetBalancesAggregate = {\n  aggregate?: Maybe<CurrentFungibleAssetBalancesAggregateFields>;\n  nodes: Array<CurrentFungibleAssetBalances>;\n};\n\n/** aggregate fields of \"current_fungible_asset_balances_legacy\" */\nexport type CurrentFungibleAssetBalancesAggregateFields = {\n  avg?: Maybe<CurrentFungibleAssetBalancesAvgFields>;\n  count: Scalars[\"Int\"][\"output\"];\n  max?: Maybe<CurrentFungibleAssetBalancesMaxFields>;\n  min?: Maybe<CurrentFungibleAssetBalancesMinFields>;\n  stddev?: Maybe<CurrentFungibleAssetBalancesStddevFields>;\n  stddev_pop?: Maybe<CurrentFungibleAssetBalancesStddevPopFields>;\n  stddev_samp?: Maybe<CurrentFungibleAssetBalancesStddevSampFields>;\n  sum?: Maybe<CurrentFungibleAssetBalancesSumFields>;\n  var_pop?: Maybe<CurrentFungibleAssetBalancesVarPopFields>;\n  var_samp?: Maybe<CurrentFungibleAssetBalancesVarSampFields>;\n  variance?: Maybe<CurrentFungibleAssetBalancesVarianceFields>;\n};\n\n/** aggregate fields of \"current_fungible_asset_balances_legacy\" */\nexport type CurrentFungibleAssetBalancesAggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<CurrentFungibleAssetBalancesSelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** aggregate avg on columns */\nexport type CurrentFungibleAssetBalancesAvgFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Boolean expression to filter rows from the table \"current_fungible_asset_balances_legacy\". All fields are combined with a logical 'AND'. */\nexport type CurrentFungibleAssetBalancesBoolExp = {\n  _and?: InputMaybe<Array<CurrentFungibleAssetBalancesBoolExp>>;\n  _not?: InputMaybe<CurrentFungibleAssetBalancesBoolExp>;\n  _or?: InputMaybe<Array<CurrentFungibleAssetBalancesBoolExp>>;\n  amount?: InputMaybe<NumericComparisonExp>;\n  asset_type?: InputMaybe<StringComparisonExp>;\n  inserted_at?: InputMaybe<TimestampComparisonExp>;\n  is_frozen?: InputMaybe<BooleanComparisonExp>;\n  is_primary?: InputMaybe<BooleanComparisonExp>;\n  last_transaction_timestamp?: InputMaybe<TimestampComparisonExp>;\n  last_transaction_version?: InputMaybe<BigintComparisonExp>;\n  metadata?: InputMaybe<FungibleAssetMetadataBoolExp>;\n  owner_address?: InputMaybe<StringComparisonExp>;\n  storage_id?: InputMaybe<StringComparisonExp>;\n  token_standard?: InputMaybe<StringComparisonExp>;\n};\n\n/** unique or primary key constraints on table \"current_fungible_asset_balances_legacy\" */\nexport enum CurrentFungibleAssetBalancesConstraint {\n  /** unique or primary key constraint on columns \"storage_id\" */\n  CurrentFungibleAssetBalancesPkey = \"current_fungible_asset_balances_pkey\",\n}\n\n/** input type for incrementing numeric columns in table \"current_fungible_asset_balances_legacy\" */\nexport type CurrentFungibleAssetBalancesIncInput = {\n  amount?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** input type for inserting data into table \"current_fungible_asset_balances_legacy\" */\nexport type CurrentFungibleAssetBalancesInsertInput = {\n  amount?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  asset_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  is_frozen?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  is_primary?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  last_transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  metadata?: InputMaybe<FungibleAssetMetadataObjRelInsertInput>;\n  owner_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  storage_id?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_standard?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate max on columns */\nexport type CurrentFungibleAssetBalancesMaxFields = {\n  amount?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  asset_type?: Maybe<Scalars[\"String\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  last_transaction_timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  owner_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  storage_id?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_standard?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** aggregate min on columns */\nexport type CurrentFungibleAssetBalancesMinFields = {\n  amount?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  asset_type?: Maybe<Scalars[\"String\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  last_transaction_timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  owner_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  storage_id?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_standard?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** response of any mutation on the table \"current_fungible_asset_balances_legacy\" */\nexport type CurrentFungibleAssetBalancesMutationResponse = {\n  /** number of rows affected by the mutation */\n  affected_rows: Scalars[\"Int\"][\"output\"];\n  /** data from the rows affected by the mutation */\n  returning: Array<CurrentFungibleAssetBalances>;\n};\n\n/** columns and relationships of \"current_fungible_asset_balances\" */\nexport type CurrentFungibleAssetBalancesNew = {\n  amount: Scalars[\"numeric\"][\"output\"];\n  amount_v1?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  amount_v2?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  asset_type: Scalars[\"String\"][\"output\"];\n  asset_type_v1?: Maybe<Scalars[\"String\"][\"output\"]>;\n  asset_type_v2?: Maybe<Scalars[\"String\"][\"output\"]>;\n  inserted_at: Scalars[\"timestamp\"][\"output\"];\n  is_frozen: Scalars[\"Boolean\"][\"output\"];\n  is_primary: Scalars[\"Boolean\"][\"output\"];\n  last_transaction_timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  last_transaction_timestamp_v1?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  last_transaction_timestamp_v2?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  last_transaction_version_v1?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  last_transaction_version_v2?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  /** An object relationship */\n  metadata?: Maybe<FungibleAssetMetadata>;\n  owner_address: Scalars[\"String\"][\"output\"];\n  storage_id: Scalars[\"String\"][\"output\"];\n  token_standard: Scalars[\"String\"][\"output\"];\n};\n\n/** aggregated selection of \"current_fungible_asset_balances\" */\nexport type CurrentFungibleAssetBalancesNewAggregate = {\n  aggregate?: Maybe<CurrentFungibleAssetBalancesNewAggregateFields>;\n  nodes: Array<CurrentFungibleAssetBalancesNew>;\n};\n\n/** aggregate fields of \"current_fungible_asset_balances\" */\nexport type CurrentFungibleAssetBalancesNewAggregateFields = {\n  avg?: Maybe<CurrentFungibleAssetBalancesNewAvgFields>;\n  count: Scalars[\"Int\"][\"output\"];\n  max?: Maybe<CurrentFungibleAssetBalancesNewMaxFields>;\n  min?: Maybe<CurrentFungibleAssetBalancesNewMinFields>;\n  stddev?: Maybe<CurrentFungibleAssetBalancesNewStddevFields>;\n  stddev_pop?: Maybe<CurrentFungibleAssetBalancesNewStddevPopFields>;\n  stddev_samp?: Maybe<CurrentFungibleAssetBalancesNewStddevSampFields>;\n  sum?: Maybe<CurrentFungibleAssetBalancesNewSumFields>;\n  var_pop?: Maybe<CurrentFungibleAssetBalancesNewVarPopFields>;\n  var_samp?: Maybe<CurrentFungibleAssetBalancesNewVarSampFields>;\n  variance?: Maybe<CurrentFungibleAssetBalancesNewVarianceFields>;\n};\n\n/** aggregate fields of \"current_fungible_asset_balances\" */\nexport type CurrentFungibleAssetBalancesNewAggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<CurrentFungibleAssetBalancesNewSelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** aggregate avg on columns */\nexport type CurrentFungibleAssetBalancesNewAvgFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  amount_v1?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  amount_v2?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version_v1?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version_v2?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Boolean expression to filter rows from the table \"current_fungible_asset_balances\". All fields are combined with a logical 'AND'. */\nexport type CurrentFungibleAssetBalancesNewBoolExp = {\n  _and?: InputMaybe<Array<CurrentFungibleAssetBalancesNewBoolExp>>;\n  _not?: InputMaybe<CurrentFungibleAssetBalancesNewBoolExp>;\n  _or?: InputMaybe<Array<CurrentFungibleAssetBalancesNewBoolExp>>;\n  amount?: InputMaybe<NumericComparisonExp>;\n  amount_v1?: InputMaybe<NumericComparisonExp>;\n  amount_v2?: InputMaybe<NumericComparisonExp>;\n  asset_type?: InputMaybe<StringComparisonExp>;\n  asset_type_v1?: InputMaybe<StringComparisonExp>;\n  asset_type_v2?: InputMaybe<StringComparisonExp>;\n  inserted_at?: InputMaybe<TimestampComparisonExp>;\n  is_frozen?: InputMaybe<BooleanComparisonExp>;\n  is_primary?: InputMaybe<BooleanComparisonExp>;\n  last_transaction_timestamp?: InputMaybe<TimestampComparisonExp>;\n  last_transaction_timestamp_v1?: InputMaybe<TimestampComparisonExp>;\n  last_transaction_timestamp_v2?: InputMaybe<TimestampComparisonExp>;\n  last_transaction_version?: InputMaybe<BigintComparisonExp>;\n  last_transaction_version_v1?: InputMaybe<BigintComparisonExp>;\n  last_transaction_version_v2?: InputMaybe<BigintComparisonExp>;\n  metadata?: InputMaybe<FungibleAssetMetadataBoolExp>;\n  owner_address?: InputMaybe<StringComparisonExp>;\n  storage_id?: InputMaybe<StringComparisonExp>;\n  token_standard?: InputMaybe<StringComparisonExp>;\n};\n\n/** unique or primary key constraints on table \"current_fungible_asset_balances\" */\nexport enum CurrentFungibleAssetBalancesNewConstraint {\n  /** unique or primary key constraint on columns \"storage_id\" */\n  CurrentUnifiedFungibleAssetBalancesPkey = \"current_unified_fungible_asset_balances_pkey\",\n}\n\n/** input type for incrementing numeric columns in table \"current_fungible_asset_balances\" */\nexport type CurrentFungibleAssetBalancesNewIncInput = {\n  amount_v1?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  amount_v2?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  last_transaction_version_v1?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  last_transaction_version_v2?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** input type for inserting data into table \"current_fungible_asset_balances\" */\nexport type CurrentFungibleAssetBalancesNewInsertInput = {\n  amount_v1?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  amount_v2?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  asset_type_v1?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  asset_type_v2?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  is_frozen?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  is_primary?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  last_transaction_timestamp_v1?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  last_transaction_timestamp_v2?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  last_transaction_version_v1?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  last_transaction_version_v2?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  metadata?: InputMaybe<FungibleAssetMetadataObjRelInsertInput>;\n  owner_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  storage_id?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate max on columns */\nexport type CurrentFungibleAssetBalancesNewMaxFields = {\n  amount?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  amount_v1?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  amount_v2?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  asset_type?: Maybe<Scalars[\"String\"][\"output\"]>;\n  asset_type_v1?: Maybe<Scalars[\"String\"][\"output\"]>;\n  asset_type_v2?: Maybe<Scalars[\"String\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  last_transaction_timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  last_transaction_timestamp_v1?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  last_transaction_timestamp_v2?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  last_transaction_version_v1?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  last_transaction_version_v2?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  owner_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  storage_id?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_standard?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** aggregate min on columns */\nexport type CurrentFungibleAssetBalancesNewMinFields = {\n  amount?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  amount_v1?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  amount_v2?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  asset_type?: Maybe<Scalars[\"String\"][\"output\"]>;\n  asset_type_v1?: Maybe<Scalars[\"String\"][\"output\"]>;\n  asset_type_v2?: Maybe<Scalars[\"String\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  last_transaction_timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  last_transaction_timestamp_v1?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  last_transaction_timestamp_v2?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  last_transaction_version_v1?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  last_transaction_version_v2?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  owner_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  storage_id?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_standard?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** response of any mutation on the table \"current_fungible_asset_balances\" */\nexport type CurrentFungibleAssetBalancesNewMutationResponse = {\n  /** number of rows affected by the mutation */\n  affected_rows: Scalars[\"Int\"][\"output\"];\n  /** data from the rows affected by the mutation */\n  returning: Array<CurrentFungibleAssetBalancesNew>;\n};\n\n/** on_conflict condition type for table \"current_fungible_asset_balances\" */\nexport type CurrentFungibleAssetBalancesNewOnConflict = {\n  constraint: CurrentFungibleAssetBalancesNewConstraint;\n  update_columns?: Array<CurrentFungibleAssetBalancesNewUpdateColumn>;\n  where?: InputMaybe<CurrentFungibleAssetBalancesNewBoolExp>;\n};\n\n/** Ordering options when selecting data from \"current_fungible_asset_balances\". */\nexport type CurrentFungibleAssetBalancesNewOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  amount_v1?: InputMaybe<OrderBy>;\n  amount_v2?: InputMaybe<OrderBy>;\n  asset_type?: InputMaybe<OrderBy>;\n  asset_type_v1?: InputMaybe<OrderBy>;\n  asset_type_v2?: InputMaybe<OrderBy>;\n  inserted_at?: InputMaybe<OrderBy>;\n  is_frozen?: InputMaybe<OrderBy>;\n  is_primary?: InputMaybe<OrderBy>;\n  last_transaction_timestamp?: InputMaybe<OrderBy>;\n  last_transaction_timestamp_v1?: InputMaybe<OrderBy>;\n  last_transaction_timestamp_v2?: InputMaybe<OrderBy>;\n  last_transaction_version?: InputMaybe<OrderBy>;\n  last_transaction_version_v1?: InputMaybe<OrderBy>;\n  last_transaction_version_v2?: InputMaybe<OrderBy>;\n  metadata?: InputMaybe<FungibleAssetMetadataOrderBy>;\n  owner_address?: InputMaybe<OrderBy>;\n  storage_id?: InputMaybe<OrderBy>;\n  token_standard?: InputMaybe<OrderBy>;\n};\n\n/** primary key columns input for table: current_fungible_asset_balances */\nexport type CurrentFungibleAssetBalancesNewPkColumnsInput = {\n  storage_id: Scalars[\"String\"][\"input\"];\n};\n\n/** select columns of table \"current_fungible_asset_balances\" */\nexport enum CurrentFungibleAssetBalancesNewSelectColumn {\n  /** column name */\n  Amount = \"amount\",\n  /** column name */\n  AmountV1 = \"amount_v1\",\n  /** column name */\n  AmountV2 = \"amount_v2\",\n  /** column name */\n  AssetType = \"asset_type\",\n  /** column name */\n  AssetTypeV1 = \"asset_type_v1\",\n  /** column name */\n  AssetTypeV2 = \"asset_type_v2\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  IsFrozen = \"is_frozen\",\n  /** column name */\n  IsPrimary = \"is_primary\",\n  /** column name */\n  LastTransactionTimestamp = \"last_transaction_timestamp\",\n  /** column name */\n  LastTransactionTimestampV1 = \"last_transaction_timestamp_v1\",\n  /** column name */\n  LastTransactionTimestampV2 = \"last_transaction_timestamp_v2\",\n  /** column name */\n  LastTransactionVersion = \"last_transaction_version\",\n  /** column name */\n  LastTransactionVersionV1 = \"last_transaction_version_v1\",\n  /** column name */\n  LastTransactionVersionV2 = \"last_transaction_version_v2\",\n  /** column name */\n  OwnerAddress = \"owner_address\",\n  /** column name */\n  StorageId = \"storage_id\",\n  /** column name */\n  TokenStandard = \"token_standard\",\n}\n\n/** input type for updating data in table \"current_fungible_asset_balances\" */\nexport type CurrentFungibleAssetBalancesNewSetInput = {\n  amount_v1?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  amount_v2?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  asset_type_v1?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  asset_type_v2?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  is_frozen?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  is_primary?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  last_transaction_timestamp_v1?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  last_transaction_timestamp_v2?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  last_transaction_version_v1?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  last_transaction_version_v2?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  owner_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  storage_id?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate stddev on columns */\nexport type CurrentFungibleAssetBalancesNewStddevFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  amount_v1?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  amount_v2?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version_v1?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version_v2?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_pop on columns */\nexport type CurrentFungibleAssetBalancesNewStddevPopFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  amount_v1?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  amount_v2?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version_v1?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version_v2?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_samp on columns */\nexport type CurrentFungibleAssetBalancesNewStddevSampFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  amount_v1?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  amount_v2?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version_v1?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version_v2?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Streaming cursor of the table \"current_fungible_asset_balances_new\" */\nexport type CurrentFungibleAssetBalancesNewStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: CurrentFungibleAssetBalancesNewStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type CurrentFungibleAssetBalancesNewStreamCursorValueInput = {\n  amount?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  amount_v1?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  amount_v2?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  asset_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  asset_type_v1?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  asset_type_v2?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  is_frozen?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  is_primary?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  last_transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  last_transaction_timestamp_v1?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  last_transaction_timestamp_v2?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  last_transaction_version_v1?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  last_transaction_version_v2?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  owner_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  storage_id?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_standard?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate sum on columns */\nexport type CurrentFungibleAssetBalancesNewSumFields = {\n  amount?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  amount_v1?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  amount_v2?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  last_transaction_version_v1?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  last_transaction_version_v2?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** update columns of table \"current_fungible_asset_balances\" */\nexport enum CurrentFungibleAssetBalancesNewUpdateColumn {\n  /** column name */\n  AmountV1 = \"amount_v1\",\n  /** column name */\n  AmountV2 = \"amount_v2\",\n  /** column name */\n  AssetTypeV1 = \"asset_type_v1\",\n  /** column name */\n  AssetTypeV2 = \"asset_type_v2\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  IsFrozen = \"is_frozen\",\n  /** column name */\n  IsPrimary = \"is_primary\",\n  /** column name */\n  LastTransactionTimestampV1 = \"last_transaction_timestamp_v1\",\n  /** column name */\n  LastTransactionTimestampV2 = \"last_transaction_timestamp_v2\",\n  /** column name */\n  LastTransactionVersionV1 = \"last_transaction_version_v1\",\n  /** column name */\n  LastTransactionVersionV2 = \"last_transaction_version_v2\",\n  /** column name */\n  OwnerAddress = \"owner_address\",\n  /** column name */\n  StorageId = \"storage_id\",\n}\n\nexport type CurrentFungibleAssetBalancesNewUpdates = {\n  /** increments the numeric columns with given value of the filtered values */\n  _inc?: InputMaybe<CurrentFungibleAssetBalancesNewIncInput>;\n  /** sets the columns of the filtered rows to the given values */\n  _set?: InputMaybe<CurrentFungibleAssetBalancesNewSetInput>;\n  /** filter the rows which have to be updated */\n  where: CurrentFungibleAssetBalancesNewBoolExp;\n};\n\n/** aggregate var_pop on columns */\nexport type CurrentFungibleAssetBalancesNewVarPopFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  amount_v1?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  amount_v2?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version_v1?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version_v2?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate var_samp on columns */\nexport type CurrentFungibleAssetBalancesNewVarSampFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  amount_v1?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  amount_v2?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version_v1?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version_v2?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate variance on columns */\nexport type CurrentFungibleAssetBalancesNewVarianceFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  amount_v1?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  amount_v2?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version_v1?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version_v2?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** on_conflict condition type for table \"current_fungible_asset_balances_legacy\" */\nexport type CurrentFungibleAssetBalancesOnConflict = {\n  constraint: CurrentFungibleAssetBalancesConstraint;\n  update_columns?: Array<CurrentFungibleAssetBalancesUpdateColumn>;\n  where?: InputMaybe<CurrentFungibleAssetBalancesBoolExp>;\n};\n\n/** Ordering options when selecting data from \"current_fungible_asset_balances_legacy\". */\nexport type CurrentFungibleAssetBalancesOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  asset_type?: InputMaybe<OrderBy>;\n  inserted_at?: InputMaybe<OrderBy>;\n  is_frozen?: InputMaybe<OrderBy>;\n  is_primary?: InputMaybe<OrderBy>;\n  last_transaction_timestamp?: InputMaybe<OrderBy>;\n  last_transaction_version?: InputMaybe<OrderBy>;\n  metadata?: InputMaybe<FungibleAssetMetadataOrderBy>;\n  owner_address?: InputMaybe<OrderBy>;\n  storage_id?: InputMaybe<OrderBy>;\n  token_standard?: InputMaybe<OrderBy>;\n};\n\n/** primary key columns input for table: current_fungible_asset_balances_legacy */\nexport type CurrentFungibleAssetBalancesPkColumnsInput = {\n  storage_id: Scalars[\"String\"][\"input\"];\n};\n\n/** select columns of table \"current_fungible_asset_balances_legacy\" */\nexport enum CurrentFungibleAssetBalancesSelectColumn {\n  /** column name */\n  Amount = \"amount\",\n  /** column name */\n  AssetType = \"asset_type\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  IsFrozen = \"is_frozen\",\n  /** column name */\n  IsPrimary = \"is_primary\",\n  /** column name */\n  LastTransactionTimestamp = \"last_transaction_timestamp\",\n  /** column name */\n  LastTransactionVersion = \"last_transaction_version\",\n  /** column name */\n  OwnerAddress = \"owner_address\",\n  /** column name */\n  StorageId = \"storage_id\",\n  /** column name */\n  TokenStandard = \"token_standard\",\n}\n\n/** input type for updating data in table \"current_fungible_asset_balances_legacy\" */\nexport type CurrentFungibleAssetBalancesSetInput = {\n  amount?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  asset_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  is_frozen?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  is_primary?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  last_transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  owner_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  storage_id?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_standard?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate stddev on columns */\nexport type CurrentFungibleAssetBalancesStddevFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_pop on columns */\nexport type CurrentFungibleAssetBalancesStddevPopFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_samp on columns */\nexport type CurrentFungibleAssetBalancesStddevSampFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Streaming cursor of the table \"current_fungible_asset_balances\" */\nexport type CurrentFungibleAssetBalancesStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: CurrentFungibleAssetBalancesStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type CurrentFungibleAssetBalancesStreamCursorValueInput = {\n  amount?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  asset_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  is_frozen?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  is_primary?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  last_transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  owner_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  storage_id?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_standard?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate sum on columns */\nexport type CurrentFungibleAssetBalancesSumFields = {\n  amount?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** update columns of table \"current_fungible_asset_balances_legacy\" */\nexport enum CurrentFungibleAssetBalancesUpdateColumn {\n  /** column name */\n  Amount = \"amount\",\n  /** column name */\n  AssetType = \"asset_type\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  IsFrozen = \"is_frozen\",\n  /** column name */\n  IsPrimary = \"is_primary\",\n  /** column name */\n  LastTransactionTimestamp = \"last_transaction_timestamp\",\n  /** column name */\n  LastTransactionVersion = \"last_transaction_version\",\n  /** column name */\n  OwnerAddress = \"owner_address\",\n  /** column name */\n  StorageId = \"storage_id\",\n  /** column name */\n  TokenStandard = \"token_standard\",\n}\n\nexport type CurrentFungibleAssetBalancesUpdates = {\n  /** increments the numeric columns with given value of the filtered values */\n  _inc?: InputMaybe<CurrentFungibleAssetBalancesIncInput>;\n  /** sets the columns of the filtered rows to the given values */\n  _set?: InputMaybe<CurrentFungibleAssetBalancesSetInput>;\n  /** filter the rows which have to be updated */\n  where: CurrentFungibleAssetBalancesBoolExp;\n};\n\n/** aggregate var_pop on columns */\nexport type CurrentFungibleAssetBalancesVarPopFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate var_samp on columns */\nexport type CurrentFungibleAssetBalancesVarSampFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate variance on columns */\nexport type CurrentFungibleAssetBalancesVarianceFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** columns and relationships of \"current_objects\" */\nexport type CurrentObjects = {\n  allow_ungated_transfer: Scalars[\"Boolean\"][\"output\"];\n  inserted_at: Scalars[\"timestamp\"][\"output\"];\n  is_deleted: Scalars[\"Boolean\"][\"output\"];\n  last_guid_creation_num: Scalars[\"numeric\"][\"output\"];\n  last_transaction_version: Scalars[\"bigint\"][\"output\"];\n  object_address: Scalars[\"String\"][\"output\"];\n  owner_address: Scalars[\"String\"][\"output\"];\n  state_key_hash: Scalars[\"String\"][\"output\"];\n  untransferrable: Scalars[\"Boolean\"][\"output\"];\n};\n\n/** aggregated selection of \"current_objects\" */\nexport type CurrentObjectsAggregate = {\n  aggregate?: Maybe<CurrentObjectsAggregateFields>;\n  nodes: Array<CurrentObjects>;\n};\n\n/** aggregate fields of \"current_objects\" */\nexport type CurrentObjectsAggregateFields = {\n  avg?: Maybe<CurrentObjectsAvgFields>;\n  count: Scalars[\"Int\"][\"output\"];\n  max?: Maybe<CurrentObjectsMaxFields>;\n  min?: Maybe<CurrentObjectsMinFields>;\n  stddev?: Maybe<CurrentObjectsStddevFields>;\n  stddev_pop?: Maybe<CurrentObjectsStddevPopFields>;\n  stddev_samp?: Maybe<CurrentObjectsStddevSampFields>;\n  sum?: Maybe<CurrentObjectsSumFields>;\n  var_pop?: Maybe<CurrentObjectsVarPopFields>;\n  var_samp?: Maybe<CurrentObjectsVarSampFields>;\n  variance?: Maybe<CurrentObjectsVarianceFields>;\n};\n\n/** aggregate fields of \"current_objects\" */\nexport type CurrentObjectsAggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<CurrentObjectsSelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** aggregate avg on columns */\nexport type CurrentObjectsAvgFields = {\n  last_guid_creation_num?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Boolean expression to filter rows from the table \"current_objects\". All fields are combined with a logical 'AND'. */\nexport type CurrentObjectsBoolExp = {\n  _and?: InputMaybe<Array<CurrentObjectsBoolExp>>;\n  _not?: InputMaybe<CurrentObjectsBoolExp>;\n  _or?: InputMaybe<Array<CurrentObjectsBoolExp>>;\n  allow_ungated_transfer?: InputMaybe<BooleanComparisonExp>;\n  inserted_at?: InputMaybe<TimestampComparisonExp>;\n  is_deleted?: InputMaybe<BooleanComparisonExp>;\n  last_guid_creation_num?: InputMaybe<NumericComparisonExp>;\n  last_transaction_version?: InputMaybe<BigintComparisonExp>;\n  object_address?: InputMaybe<StringComparisonExp>;\n  owner_address?: InputMaybe<StringComparisonExp>;\n  state_key_hash?: InputMaybe<StringComparisonExp>;\n  untransferrable?: InputMaybe<BooleanComparisonExp>;\n};\n\n/** unique or primary key constraints on table \"current_objects\" */\nexport enum CurrentObjectsConstraint {\n  /** unique or primary key constraint on columns \"object_address\" */\n  CurrentObjectsPkey = \"current_objects_pkey\",\n}\n\n/** input type for incrementing numeric columns in table \"current_objects\" */\nexport type CurrentObjectsIncInput = {\n  last_guid_creation_num?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** input type for inserting data into table \"current_objects\" */\nexport type CurrentObjectsInsertInput = {\n  allow_ungated_transfer?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  is_deleted?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  last_guid_creation_num?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  object_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  owner_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  state_key_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  untransferrable?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** aggregate max on columns */\nexport type CurrentObjectsMaxFields = {\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  last_guid_creation_num?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  object_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  owner_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  state_key_hash?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** aggregate min on columns */\nexport type CurrentObjectsMinFields = {\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  last_guid_creation_num?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  object_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  owner_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  state_key_hash?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** response of any mutation on the table \"current_objects\" */\nexport type CurrentObjectsMutationResponse = {\n  /** number of rows affected by the mutation */\n  affected_rows: Scalars[\"Int\"][\"output\"];\n  /** data from the rows affected by the mutation */\n  returning: Array<CurrentObjects>;\n};\n\n/** on_conflict condition type for table \"current_objects\" */\nexport type CurrentObjectsOnConflict = {\n  constraint: CurrentObjectsConstraint;\n  update_columns?: Array<CurrentObjectsUpdateColumn>;\n  where?: InputMaybe<CurrentObjectsBoolExp>;\n};\n\n/** Ordering options when selecting data from \"current_objects\". */\nexport type CurrentObjectsOrderBy = {\n  allow_ungated_transfer?: InputMaybe<OrderBy>;\n  inserted_at?: InputMaybe<OrderBy>;\n  is_deleted?: InputMaybe<OrderBy>;\n  last_guid_creation_num?: InputMaybe<OrderBy>;\n  last_transaction_version?: InputMaybe<OrderBy>;\n  object_address?: InputMaybe<OrderBy>;\n  owner_address?: InputMaybe<OrderBy>;\n  state_key_hash?: InputMaybe<OrderBy>;\n  untransferrable?: InputMaybe<OrderBy>;\n};\n\n/** primary key columns input for table: current_objects */\nexport type CurrentObjectsPkColumnsInput = {\n  object_address: Scalars[\"String\"][\"input\"];\n};\n\n/** select columns of table \"current_objects\" */\nexport enum CurrentObjectsSelectColumn {\n  /** column name */\n  AllowUngatedTransfer = \"allow_ungated_transfer\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  IsDeleted = \"is_deleted\",\n  /** column name */\n  LastGuidCreationNum = \"last_guid_creation_num\",\n  /** column name */\n  LastTransactionVersion = \"last_transaction_version\",\n  /** column name */\n  ObjectAddress = \"object_address\",\n  /** column name */\n  OwnerAddress = \"owner_address\",\n  /** column name */\n  StateKeyHash = \"state_key_hash\",\n  /** column name */\n  Untransferrable = \"untransferrable\",\n}\n\n/** input type for updating data in table \"current_objects\" */\nexport type CurrentObjectsSetInput = {\n  allow_ungated_transfer?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  is_deleted?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  last_guid_creation_num?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  object_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  owner_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  state_key_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  untransferrable?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** aggregate stddev on columns */\nexport type CurrentObjectsStddevFields = {\n  last_guid_creation_num?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_pop on columns */\nexport type CurrentObjectsStddevPopFields = {\n  last_guid_creation_num?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_samp on columns */\nexport type CurrentObjectsStddevSampFields = {\n  last_guid_creation_num?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Streaming cursor of the table \"current_objects\" */\nexport type CurrentObjectsStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: CurrentObjectsStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type CurrentObjectsStreamCursorValueInput = {\n  allow_ungated_transfer?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  is_deleted?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  last_guid_creation_num?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  object_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  owner_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  state_key_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  untransferrable?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** aggregate sum on columns */\nexport type CurrentObjectsSumFields = {\n  last_guid_creation_num?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** update columns of table \"current_objects\" */\nexport enum CurrentObjectsUpdateColumn {\n  /** column name */\n  AllowUngatedTransfer = \"allow_ungated_transfer\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  IsDeleted = \"is_deleted\",\n  /** column name */\n  LastGuidCreationNum = \"last_guid_creation_num\",\n  /** column name */\n  LastTransactionVersion = \"last_transaction_version\",\n  /** column name */\n  ObjectAddress = \"object_address\",\n  /** column name */\n  OwnerAddress = \"owner_address\",\n  /** column name */\n  StateKeyHash = \"state_key_hash\",\n  /** column name */\n  Untransferrable = \"untransferrable\",\n}\n\nexport type CurrentObjectsUpdates = {\n  /** increments the numeric columns with given value of the filtered values */\n  _inc?: InputMaybe<CurrentObjectsIncInput>;\n  /** sets the columns of the filtered rows to the given values */\n  _set?: InputMaybe<CurrentObjectsSetInput>;\n  /** filter the rows which have to be updated */\n  where: CurrentObjectsBoolExp;\n};\n\n/** aggregate var_pop on columns */\nexport type CurrentObjectsVarPopFields = {\n  last_guid_creation_num?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate var_samp on columns */\nexport type CurrentObjectsVarSampFields = {\n  last_guid_creation_num?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate variance on columns */\nexport type CurrentObjectsVarianceFields = {\n  last_guid_creation_num?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** columns and relationships of \"current_staking_pool_voter\" */\nexport type CurrentStakingPoolVoter = {\n  inserted_at: Scalars[\"timestamp\"][\"output\"];\n  last_transaction_version: Scalars[\"bigint\"][\"output\"];\n  operator_address: Scalars[\"String\"][\"output\"];\n  /** An array relationship */\n  operator_cedra_name: Array<CurrentCedraNames>;\n  /** An aggregate relationship */\n  operator_cedra_name_aggregate: CurrentCedraNamesAggregate;\n  staking_pool_address: Scalars[\"String\"][\"output\"];\n  voter_address: Scalars[\"String\"][\"output\"];\n};\n\n/** columns and relationships of \"current_staking_pool_voter\" */\nexport type CurrentStakingPoolVoterOperatorCedraNameArgs = {\n  distinct_on?: InputMaybe<Array<CurrentCedraNamesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentCedraNamesOrderBy>>;\n  where?: InputMaybe<CurrentCedraNamesBoolExp>;\n};\n\n/** columns and relationships of \"current_staking_pool_voter\" */\nexport type CurrentStakingPoolVoterOperatorCedraNameAggregateArgs = {\n  distinct_on?: InputMaybe<Array<CurrentCedraNamesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentCedraNamesOrderBy>>;\n  where?: InputMaybe<CurrentCedraNamesBoolExp>;\n};\n\n/** aggregated selection of \"current_staking_pool_voter\" */\nexport type CurrentStakingPoolVoterAggregate = {\n  aggregate?: Maybe<CurrentStakingPoolVoterAggregateFields>;\n  nodes: Array<CurrentStakingPoolVoter>;\n};\n\n/** aggregate fields of \"current_staking_pool_voter\" */\nexport type CurrentStakingPoolVoterAggregateFields = {\n  avg?: Maybe<CurrentStakingPoolVoterAvgFields>;\n  count: Scalars[\"Int\"][\"output\"];\n  max?: Maybe<CurrentStakingPoolVoterMaxFields>;\n  min?: Maybe<CurrentStakingPoolVoterMinFields>;\n  stddev?: Maybe<CurrentStakingPoolVoterStddevFields>;\n  stddev_pop?: Maybe<CurrentStakingPoolVoterStddevPopFields>;\n  stddev_samp?: Maybe<CurrentStakingPoolVoterStddevSampFields>;\n  sum?: Maybe<CurrentStakingPoolVoterSumFields>;\n  var_pop?: Maybe<CurrentStakingPoolVoterVarPopFields>;\n  var_samp?: Maybe<CurrentStakingPoolVoterVarSampFields>;\n  variance?: Maybe<CurrentStakingPoolVoterVarianceFields>;\n};\n\n/** aggregate fields of \"current_staking_pool_voter\" */\nexport type CurrentStakingPoolVoterAggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<CurrentStakingPoolVoterSelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** aggregate avg on columns */\nexport type CurrentStakingPoolVoterAvgFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Boolean expression to filter rows from the table \"current_staking_pool_voter\". All fields are combined with a logical 'AND'. */\nexport type CurrentStakingPoolVoterBoolExp = {\n  _and?: InputMaybe<Array<CurrentStakingPoolVoterBoolExp>>;\n  _not?: InputMaybe<CurrentStakingPoolVoterBoolExp>;\n  _or?: InputMaybe<Array<CurrentStakingPoolVoterBoolExp>>;\n  inserted_at?: InputMaybe<TimestampComparisonExp>;\n  last_transaction_version?: InputMaybe<BigintComparisonExp>;\n  operator_address?: InputMaybe<StringComparisonExp>;\n  operator_cedra_name?: InputMaybe<CurrentCedraNamesBoolExp>;\n  operator_cedra_name_aggregate?: InputMaybe<CurrentCedraNamesAggregateBoolExp>;\n  staking_pool_address?: InputMaybe<StringComparisonExp>;\n  voter_address?: InputMaybe<StringComparisonExp>;\n};\n\n/** unique or primary key constraints on table \"current_staking_pool_voter\" */\nexport enum CurrentStakingPoolVoterConstraint {\n  /** unique or primary key constraint on columns \"staking_pool_address\" */\n  CurrentStakingPoolVoterPkey = \"current_staking_pool_voter_pkey\",\n}\n\n/** input type for incrementing numeric columns in table \"current_staking_pool_voter\" */\nexport type CurrentStakingPoolVoterIncInput = {\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** input type for inserting data into table \"current_staking_pool_voter\" */\nexport type CurrentStakingPoolVoterInsertInput = {\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  operator_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  operator_cedra_name?: InputMaybe<CurrentCedraNamesArrRelInsertInput>;\n  staking_pool_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  voter_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate max on columns */\nexport type CurrentStakingPoolVoterMaxFields = {\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  operator_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  staking_pool_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  voter_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** aggregate min on columns */\nexport type CurrentStakingPoolVoterMinFields = {\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  operator_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  staking_pool_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  voter_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** response of any mutation on the table \"current_staking_pool_voter\" */\nexport type CurrentStakingPoolVoterMutationResponse = {\n  /** number of rows affected by the mutation */\n  affected_rows: Scalars[\"Int\"][\"output\"];\n  /** data from the rows affected by the mutation */\n  returning: Array<CurrentStakingPoolVoter>;\n};\n\n/** input type for inserting object relation for remote table \"current_staking_pool_voter\" */\nexport type CurrentStakingPoolVoterObjRelInsertInput = {\n  data: CurrentStakingPoolVoterInsertInput;\n  /** upsert condition */\n  on_conflict?: InputMaybe<CurrentStakingPoolVoterOnConflict>;\n};\n\n/** on_conflict condition type for table \"current_staking_pool_voter\" */\nexport type CurrentStakingPoolVoterOnConflict = {\n  constraint: CurrentStakingPoolVoterConstraint;\n  update_columns?: Array<CurrentStakingPoolVoterUpdateColumn>;\n  where?: InputMaybe<CurrentStakingPoolVoterBoolExp>;\n};\n\n/** Ordering options when selecting data from \"current_staking_pool_voter\". */\nexport type CurrentStakingPoolVoterOrderBy = {\n  inserted_at?: InputMaybe<OrderBy>;\n  last_transaction_version?: InputMaybe<OrderBy>;\n  operator_address?: InputMaybe<OrderBy>;\n  operator_cedra_name_aggregate?: InputMaybe<CurrentCedraNamesAggregateOrderBy>;\n  staking_pool_address?: InputMaybe<OrderBy>;\n  voter_address?: InputMaybe<OrderBy>;\n};\n\n/** primary key columns input for table: current_staking_pool_voter */\nexport type CurrentStakingPoolVoterPkColumnsInput = {\n  staking_pool_address: Scalars[\"String\"][\"input\"];\n};\n\n/** select columns of table \"current_staking_pool_voter\" */\nexport enum CurrentStakingPoolVoterSelectColumn {\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  LastTransactionVersion = \"last_transaction_version\",\n  /** column name */\n  OperatorAddress = \"operator_address\",\n  /** column name */\n  StakingPoolAddress = \"staking_pool_address\",\n  /** column name */\n  VoterAddress = \"voter_address\",\n}\n\n/** input type for updating data in table \"current_staking_pool_voter\" */\nexport type CurrentStakingPoolVoterSetInput = {\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  operator_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  staking_pool_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  voter_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate stddev on columns */\nexport type CurrentStakingPoolVoterStddevFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_pop on columns */\nexport type CurrentStakingPoolVoterStddevPopFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_samp on columns */\nexport type CurrentStakingPoolVoterStddevSampFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Streaming cursor of the table \"current_staking_pool_voter\" */\nexport type CurrentStakingPoolVoterStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: CurrentStakingPoolVoterStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type CurrentStakingPoolVoterStreamCursorValueInput = {\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  operator_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  staking_pool_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  voter_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate sum on columns */\nexport type CurrentStakingPoolVoterSumFields = {\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** update columns of table \"current_staking_pool_voter\" */\nexport enum CurrentStakingPoolVoterUpdateColumn {\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  LastTransactionVersion = \"last_transaction_version\",\n  /** column name */\n  OperatorAddress = \"operator_address\",\n  /** column name */\n  StakingPoolAddress = \"staking_pool_address\",\n  /** column name */\n  VoterAddress = \"voter_address\",\n}\n\nexport type CurrentStakingPoolVoterUpdates = {\n  /** increments the numeric columns with given value of the filtered values */\n  _inc?: InputMaybe<CurrentStakingPoolVoterIncInput>;\n  /** sets the columns of the filtered rows to the given values */\n  _set?: InputMaybe<CurrentStakingPoolVoterSetInput>;\n  /** filter the rows which have to be updated */\n  where: CurrentStakingPoolVoterBoolExp;\n};\n\n/** aggregate var_pop on columns */\nexport type CurrentStakingPoolVoterVarPopFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate var_samp on columns */\nexport type CurrentStakingPoolVoterVarSampFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate variance on columns */\nexport type CurrentStakingPoolVoterVarianceFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** columns and relationships of \"current_table_items\" */\nexport type CurrentTableItems = {\n  decoded_key: Scalars[\"jsonb\"][\"output\"];\n  decoded_value?: Maybe<Scalars[\"jsonb\"][\"output\"]>;\n  inserted_at: Scalars[\"timestamp\"][\"output\"];\n  is_deleted: Scalars[\"Boolean\"][\"output\"];\n  key: Scalars[\"String\"][\"output\"];\n  key_hash: Scalars[\"String\"][\"output\"];\n  last_transaction_version: Scalars[\"bigint\"][\"output\"];\n  table_handle: Scalars[\"String\"][\"output\"];\n};\n\n/** columns and relationships of \"current_table_items\" */\nexport type CurrentTableItemsDecodedKeyArgs = {\n  path?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** columns and relationships of \"current_table_items\" */\nexport type CurrentTableItemsDecodedValueArgs = {\n  path?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregated selection of \"current_table_items\" */\nexport type CurrentTableItemsAggregate = {\n  aggregate?: Maybe<CurrentTableItemsAggregateFields>;\n  nodes: Array<CurrentTableItems>;\n};\n\n/** aggregate fields of \"current_table_items\" */\nexport type CurrentTableItemsAggregateFields = {\n  avg?: Maybe<CurrentTableItemsAvgFields>;\n  count: Scalars[\"Int\"][\"output\"];\n  max?: Maybe<CurrentTableItemsMaxFields>;\n  min?: Maybe<CurrentTableItemsMinFields>;\n  stddev?: Maybe<CurrentTableItemsStddevFields>;\n  stddev_pop?: Maybe<CurrentTableItemsStddevPopFields>;\n  stddev_samp?: Maybe<CurrentTableItemsStddevSampFields>;\n  sum?: Maybe<CurrentTableItemsSumFields>;\n  var_pop?: Maybe<CurrentTableItemsVarPopFields>;\n  var_samp?: Maybe<CurrentTableItemsVarSampFields>;\n  variance?: Maybe<CurrentTableItemsVarianceFields>;\n};\n\n/** aggregate fields of \"current_table_items\" */\nexport type CurrentTableItemsAggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<CurrentTableItemsSelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** append existing jsonb value of filtered columns with new jsonb value */\nexport type CurrentTableItemsAppendInput = {\n  decoded_key?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  decoded_value?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n};\n\n/** aggregate avg on columns */\nexport type CurrentTableItemsAvgFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Boolean expression to filter rows from the table \"current_table_items\". All fields are combined with a logical 'AND'. */\nexport type CurrentTableItemsBoolExp = {\n  _and?: InputMaybe<Array<CurrentTableItemsBoolExp>>;\n  _not?: InputMaybe<CurrentTableItemsBoolExp>;\n  _or?: InputMaybe<Array<CurrentTableItemsBoolExp>>;\n  decoded_key?: InputMaybe<JsonbComparisonExp>;\n  decoded_value?: InputMaybe<JsonbComparisonExp>;\n  inserted_at?: InputMaybe<TimestampComparisonExp>;\n  is_deleted?: InputMaybe<BooleanComparisonExp>;\n  key?: InputMaybe<StringComparisonExp>;\n  key_hash?: InputMaybe<StringComparisonExp>;\n  last_transaction_version?: InputMaybe<BigintComparisonExp>;\n  table_handle?: InputMaybe<StringComparisonExp>;\n};\n\n/** unique or primary key constraints on table \"current_table_items\" */\nexport enum CurrentTableItemsConstraint {\n  /** unique or primary key constraint on columns \"key_hash\", \"table_handle\" */\n  CurrentTableItemsPkey = \"current_table_items_pkey\",\n}\n\n/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */\nexport type CurrentTableItemsDeleteAtPathInput = {\n  decoded_key?: InputMaybe<Array<Scalars[\"String\"][\"input\"]>>;\n  decoded_value?: InputMaybe<Array<Scalars[\"String\"][\"input\"]>>;\n};\n\n/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */\nexport type CurrentTableItemsDeleteElemInput = {\n  decoded_key?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  decoded_value?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n};\n\n/** delete key/value pair or string element. key/value pairs are matched based on their key value */\nexport type CurrentTableItemsDeleteKeyInput = {\n  decoded_key?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  decoded_value?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** input type for incrementing numeric columns in table \"current_table_items\" */\nexport type CurrentTableItemsIncInput = {\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** input type for inserting data into table \"current_table_items\" */\nexport type CurrentTableItemsInsertInput = {\n  decoded_key?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  decoded_value?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  is_deleted?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  key?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  key_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  table_handle?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate max on columns */\nexport type CurrentTableItemsMaxFields = {\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  key?: Maybe<Scalars[\"String\"][\"output\"]>;\n  key_hash?: Maybe<Scalars[\"String\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  table_handle?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** aggregate min on columns */\nexport type CurrentTableItemsMinFields = {\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  key?: Maybe<Scalars[\"String\"][\"output\"]>;\n  key_hash?: Maybe<Scalars[\"String\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  table_handle?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** response of any mutation on the table \"current_table_items\" */\nexport type CurrentTableItemsMutationResponse = {\n  /** number of rows affected by the mutation */\n  affected_rows: Scalars[\"Int\"][\"output\"];\n  /** data from the rows affected by the mutation */\n  returning: Array<CurrentTableItems>;\n};\n\n/** on_conflict condition type for table \"current_table_items\" */\nexport type CurrentTableItemsOnConflict = {\n  constraint: CurrentTableItemsConstraint;\n  update_columns?: Array<CurrentTableItemsUpdateColumn>;\n  where?: InputMaybe<CurrentTableItemsBoolExp>;\n};\n\n/** Ordering options when selecting data from \"current_table_items\". */\nexport type CurrentTableItemsOrderBy = {\n  decoded_key?: InputMaybe<OrderBy>;\n  decoded_value?: InputMaybe<OrderBy>;\n  inserted_at?: InputMaybe<OrderBy>;\n  is_deleted?: InputMaybe<OrderBy>;\n  key?: InputMaybe<OrderBy>;\n  key_hash?: InputMaybe<OrderBy>;\n  last_transaction_version?: InputMaybe<OrderBy>;\n  table_handle?: InputMaybe<OrderBy>;\n};\n\n/** primary key columns input for table: current_table_items */\nexport type CurrentTableItemsPkColumnsInput = {\n  key_hash: Scalars[\"String\"][\"input\"];\n  table_handle: Scalars[\"String\"][\"input\"];\n};\n\n/** prepend existing jsonb value of filtered columns with new jsonb value */\nexport type CurrentTableItemsPrependInput = {\n  decoded_key?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  decoded_value?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n};\n\n/** select columns of table \"current_table_items\" */\nexport enum CurrentTableItemsSelectColumn {\n  /** column name */\n  DecodedKey = \"decoded_key\",\n  /** column name */\n  DecodedValue = \"decoded_value\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  IsDeleted = \"is_deleted\",\n  /** column name */\n  Key = \"key\",\n  /** column name */\n  KeyHash = \"key_hash\",\n  /** column name */\n  LastTransactionVersion = \"last_transaction_version\",\n  /** column name */\n  TableHandle = \"table_handle\",\n}\n\n/** input type for updating data in table \"current_table_items\" */\nexport type CurrentTableItemsSetInput = {\n  decoded_key?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  decoded_value?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  is_deleted?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  key?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  key_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  table_handle?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate stddev on columns */\nexport type CurrentTableItemsStddevFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_pop on columns */\nexport type CurrentTableItemsStddevPopFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_samp on columns */\nexport type CurrentTableItemsStddevSampFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Streaming cursor of the table \"current_table_items\" */\nexport type CurrentTableItemsStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: CurrentTableItemsStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type CurrentTableItemsStreamCursorValueInput = {\n  decoded_key?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  decoded_value?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  is_deleted?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  key?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  key_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  table_handle?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate sum on columns */\nexport type CurrentTableItemsSumFields = {\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** update columns of table \"current_table_items\" */\nexport enum CurrentTableItemsUpdateColumn {\n  /** column name */\n  DecodedKey = \"decoded_key\",\n  /** column name */\n  DecodedValue = \"decoded_value\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  IsDeleted = \"is_deleted\",\n  /** column name */\n  Key = \"key\",\n  /** column name */\n  KeyHash = \"key_hash\",\n  /** column name */\n  LastTransactionVersion = \"last_transaction_version\",\n  /** column name */\n  TableHandle = \"table_handle\",\n}\n\nexport type CurrentTableItemsUpdates = {\n  /** append existing jsonb value of filtered columns with new jsonb value */\n  _append?: InputMaybe<CurrentTableItemsAppendInput>;\n  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */\n  _delete_at_path?: InputMaybe<CurrentTableItemsDeleteAtPathInput>;\n  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */\n  _delete_elem?: InputMaybe<CurrentTableItemsDeleteElemInput>;\n  /** delete key/value pair or string element. key/value pairs are matched based on their key value */\n  _delete_key?: InputMaybe<CurrentTableItemsDeleteKeyInput>;\n  /** increments the numeric columns with given value of the filtered values */\n  _inc?: InputMaybe<CurrentTableItemsIncInput>;\n  /** prepend existing jsonb value of filtered columns with new jsonb value */\n  _prepend?: InputMaybe<CurrentTableItemsPrependInput>;\n  /** sets the columns of the filtered rows to the given values */\n  _set?: InputMaybe<CurrentTableItemsSetInput>;\n  /** filter the rows which have to be updated */\n  where: CurrentTableItemsBoolExp;\n};\n\n/** aggregate var_pop on columns */\nexport type CurrentTableItemsVarPopFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate var_samp on columns */\nexport type CurrentTableItemsVarSampFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate variance on columns */\nexport type CurrentTableItemsVarianceFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** columns and relationships of \"current_table_items_view\" */\nexport type CurrentTableItemsView = {\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  is_deleted?: Maybe<Scalars[\"Boolean\"][\"output\"]>;\n  json_decoded_key?: Maybe<Scalars[\"String\"][\"output\"]>;\n  json_decoded_value?: Maybe<Scalars[\"String\"][\"output\"]>;\n  key?: Maybe<Scalars[\"String\"][\"output\"]>;\n  key_hash?: Maybe<Scalars[\"String\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  table_handle?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** aggregated selection of \"current_table_items_view\" */\nexport type CurrentTableItemsViewAggregate = {\n  aggregate?: Maybe<CurrentTableItemsViewAggregateFields>;\n  nodes: Array<CurrentTableItemsView>;\n};\n\n/** aggregate fields of \"current_table_items_view\" */\nexport type CurrentTableItemsViewAggregateFields = {\n  avg?: Maybe<CurrentTableItemsViewAvgFields>;\n  count: Scalars[\"Int\"][\"output\"];\n  max?: Maybe<CurrentTableItemsViewMaxFields>;\n  min?: Maybe<CurrentTableItemsViewMinFields>;\n  stddev?: Maybe<CurrentTableItemsViewStddevFields>;\n  stddev_pop?: Maybe<CurrentTableItemsViewStddevPopFields>;\n  stddev_samp?: Maybe<CurrentTableItemsViewStddevSampFields>;\n  sum?: Maybe<CurrentTableItemsViewSumFields>;\n  var_pop?: Maybe<CurrentTableItemsViewVarPopFields>;\n  var_samp?: Maybe<CurrentTableItemsViewVarSampFields>;\n  variance?: Maybe<CurrentTableItemsViewVarianceFields>;\n};\n\n/** aggregate fields of \"current_table_items_view\" */\nexport type CurrentTableItemsViewAggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<CurrentTableItemsViewSelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** aggregate avg on columns */\nexport type CurrentTableItemsViewAvgFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Boolean expression to filter rows from the table \"current_table_items_view\". All fields are combined with a logical 'AND'. */\nexport type CurrentTableItemsViewBoolExp = {\n  _and?: InputMaybe<Array<CurrentTableItemsViewBoolExp>>;\n  _not?: InputMaybe<CurrentTableItemsViewBoolExp>;\n  _or?: InputMaybe<Array<CurrentTableItemsViewBoolExp>>;\n  inserted_at?: InputMaybe<TimestampComparisonExp>;\n  is_deleted?: InputMaybe<BooleanComparisonExp>;\n  json_decoded_key?: InputMaybe<StringComparisonExp>;\n  json_decoded_value?: InputMaybe<StringComparisonExp>;\n  key?: InputMaybe<StringComparisonExp>;\n  key_hash?: InputMaybe<StringComparisonExp>;\n  last_transaction_version?: InputMaybe<BigintComparisonExp>;\n  table_handle?: InputMaybe<StringComparisonExp>;\n};\n\n/** input type for incrementing numeric columns in table \"current_table_items_view\" */\nexport type CurrentTableItemsViewIncInput = {\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** input type for inserting data into table \"current_table_items_view\" */\nexport type CurrentTableItemsViewInsertInput = {\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  is_deleted?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  json_decoded_key?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  json_decoded_value?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  key?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  key_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  table_handle?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate max on columns */\nexport type CurrentTableItemsViewMaxFields = {\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  json_decoded_key?: Maybe<Scalars[\"String\"][\"output\"]>;\n  json_decoded_value?: Maybe<Scalars[\"String\"][\"output\"]>;\n  key?: Maybe<Scalars[\"String\"][\"output\"]>;\n  key_hash?: Maybe<Scalars[\"String\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  table_handle?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** aggregate min on columns */\nexport type CurrentTableItemsViewMinFields = {\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  json_decoded_key?: Maybe<Scalars[\"String\"][\"output\"]>;\n  json_decoded_value?: Maybe<Scalars[\"String\"][\"output\"]>;\n  key?: Maybe<Scalars[\"String\"][\"output\"]>;\n  key_hash?: Maybe<Scalars[\"String\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  table_handle?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** response of any mutation on the table \"current_table_items_view\" */\nexport type CurrentTableItemsViewMutationResponse = {\n  /** number of rows affected by the mutation */\n  affected_rows: Scalars[\"Int\"][\"output\"];\n  /** data from the rows affected by the mutation */\n  returning: Array<CurrentTableItemsView>;\n};\n\n/** Ordering options when selecting data from \"current_table_items_view\". */\nexport type CurrentTableItemsViewOrderBy = {\n  inserted_at?: InputMaybe<OrderBy>;\n  is_deleted?: InputMaybe<OrderBy>;\n  json_decoded_key?: InputMaybe<OrderBy>;\n  json_decoded_value?: InputMaybe<OrderBy>;\n  key?: InputMaybe<OrderBy>;\n  key_hash?: InputMaybe<OrderBy>;\n  last_transaction_version?: InputMaybe<OrderBy>;\n  table_handle?: InputMaybe<OrderBy>;\n};\n\n/** select columns of table \"current_table_items_view\" */\nexport enum CurrentTableItemsViewSelectColumn {\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  IsDeleted = \"is_deleted\",\n  /** column name */\n  JsonDecodedKey = \"json_decoded_key\",\n  /** column name */\n  JsonDecodedValue = \"json_decoded_value\",\n  /** column name */\n  Key = \"key\",\n  /** column name */\n  KeyHash = \"key_hash\",\n  /** column name */\n  LastTransactionVersion = \"last_transaction_version\",\n  /** column name */\n  TableHandle = \"table_handle\",\n}\n\n/** input type for updating data in table \"current_table_items_view\" */\nexport type CurrentTableItemsViewSetInput = {\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  is_deleted?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  json_decoded_key?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  json_decoded_value?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  key?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  key_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  table_handle?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate stddev on columns */\nexport type CurrentTableItemsViewStddevFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_pop on columns */\nexport type CurrentTableItemsViewStddevPopFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_samp on columns */\nexport type CurrentTableItemsViewStddevSampFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Streaming cursor of the table \"current_table_items_view\" */\nexport type CurrentTableItemsViewStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: CurrentTableItemsViewStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type CurrentTableItemsViewStreamCursorValueInput = {\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  is_deleted?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  json_decoded_key?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  json_decoded_value?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  key?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  key_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  table_handle?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate sum on columns */\nexport type CurrentTableItemsViewSumFields = {\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\nexport type CurrentTableItemsViewUpdates = {\n  /** increments the numeric columns with given value of the filtered values */\n  _inc?: InputMaybe<CurrentTableItemsViewIncInput>;\n  /** sets the columns of the filtered rows to the given values */\n  _set?: InputMaybe<CurrentTableItemsViewSetInput>;\n  /** filter the rows which have to be updated */\n  where: CurrentTableItemsViewBoolExp;\n};\n\n/** aggregate var_pop on columns */\nexport type CurrentTableItemsViewVarPopFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate var_samp on columns */\nexport type CurrentTableItemsViewVarSampFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate variance on columns */\nexport type CurrentTableItemsViewVarianceFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** columns and relationships of \"current_token_datas\" */\nexport type CurrentTokenDatas = {\n  collection_data_id_hash: Scalars[\"String\"][\"output\"];\n  collection_name: Scalars[\"String\"][\"output\"];\n  creator_address: Scalars[\"String\"][\"output\"];\n  default_properties: Scalars[\"jsonb\"][\"output\"];\n  description: Scalars[\"String\"][\"output\"];\n  description_mutable: Scalars[\"Boolean\"][\"output\"];\n  inserted_at: Scalars[\"timestamp\"][\"output\"];\n  largest_property_version: Scalars[\"numeric\"][\"output\"];\n  last_transaction_timestamp: Scalars[\"timestamp\"][\"output\"];\n  last_transaction_version: Scalars[\"bigint\"][\"output\"];\n  maximum: Scalars[\"numeric\"][\"output\"];\n  maximum_mutable: Scalars[\"Boolean\"][\"output\"];\n  metadata_uri: Scalars[\"String\"][\"output\"];\n  name: Scalars[\"String\"][\"output\"];\n  payee_address: Scalars[\"String\"][\"output\"];\n  properties_mutable: Scalars[\"Boolean\"][\"output\"];\n  royalty_mutable: Scalars[\"Boolean\"][\"output\"];\n  royalty_points_denominator: Scalars[\"numeric\"][\"output\"];\n  royalty_points_numerator: Scalars[\"numeric\"][\"output\"];\n  supply: Scalars[\"numeric\"][\"output\"];\n  token_data_id_hash: Scalars[\"String\"][\"output\"];\n  uri_mutable: Scalars[\"Boolean\"][\"output\"];\n};\n\n/** columns and relationships of \"current_token_datas\" */\nexport type CurrentTokenDatasDefaultPropertiesArgs = {\n  path?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregated selection of \"current_token_datas\" */\nexport type CurrentTokenDatasAggregate = {\n  aggregate?: Maybe<CurrentTokenDatasAggregateFields>;\n  nodes: Array<CurrentTokenDatas>;\n};\n\n/** aggregate fields of \"current_token_datas\" */\nexport type CurrentTokenDatasAggregateFields = {\n  avg?: Maybe<CurrentTokenDatasAvgFields>;\n  count: Scalars[\"Int\"][\"output\"];\n  max?: Maybe<CurrentTokenDatasMaxFields>;\n  min?: Maybe<CurrentTokenDatasMinFields>;\n  stddev?: Maybe<CurrentTokenDatasStddevFields>;\n  stddev_pop?: Maybe<CurrentTokenDatasStddevPopFields>;\n  stddev_samp?: Maybe<CurrentTokenDatasStddevSampFields>;\n  sum?: Maybe<CurrentTokenDatasSumFields>;\n  var_pop?: Maybe<CurrentTokenDatasVarPopFields>;\n  var_samp?: Maybe<CurrentTokenDatasVarSampFields>;\n  variance?: Maybe<CurrentTokenDatasVarianceFields>;\n};\n\n/** aggregate fields of \"current_token_datas\" */\nexport type CurrentTokenDatasAggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<CurrentTokenDatasSelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** append existing jsonb value of filtered columns with new jsonb value */\nexport type CurrentTokenDatasAppendInput = {\n  default_properties?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n};\n\n/** aggregate avg on columns */\nexport type CurrentTokenDatasAvgFields = {\n  largest_property_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  maximum?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  royalty_points_denominator?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  royalty_points_numerator?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  supply?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Boolean expression to filter rows from the table \"current_token_datas\". All fields are combined with a logical 'AND'. */\nexport type CurrentTokenDatasBoolExp = {\n  _and?: InputMaybe<Array<CurrentTokenDatasBoolExp>>;\n  _not?: InputMaybe<CurrentTokenDatasBoolExp>;\n  _or?: InputMaybe<Array<CurrentTokenDatasBoolExp>>;\n  collection_data_id_hash?: InputMaybe<StringComparisonExp>;\n  collection_name?: InputMaybe<StringComparisonExp>;\n  creator_address?: InputMaybe<StringComparisonExp>;\n  default_properties?: InputMaybe<JsonbComparisonExp>;\n  description?: InputMaybe<StringComparisonExp>;\n  description_mutable?: InputMaybe<BooleanComparisonExp>;\n  inserted_at?: InputMaybe<TimestampComparisonExp>;\n  largest_property_version?: InputMaybe<NumericComparisonExp>;\n  last_transaction_timestamp?: InputMaybe<TimestampComparisonExp>;\n  last_transaction_version?: InputMaybe<BigintComparisonExp>;\n  maximum?: InputMaybe<NumericComparisonExp>;\n  maximum_mutable?: InputMaybe<BooleanComparisonExp>;\n  metadata_uri?: InputMaybe<StringComparisonExp>;\n  name?: InputMaybe<StringComparisonExp>;\n  payee_address?: InputMaybe<StringComparisonExp>;\n  properties_mutable?: InputMaybe<BooleanComparisonExp>;\n  royalty_mutable?: InputMaybe<BooleanComparisonExp>;\n  royalty_points_denominator?: InputMaybe<NumericComparisonExp>;\n  royalty_points_numerator?: InputMaybe<NumericComparisonExp>;\n  supply?: InputMaybe<NumericComparisonExp>;\n  token_data_id_hash?: InputMaybe<StringComparisonExp>;\n  uri_mutable?: InputMaybe<BooleanComparisonExp>;\n};\n\n/** unique or primary key constraints on table \"current_token_datas\" */\nexport enum CurrentTokenDatasConstraint {\n  /** unique or primary key constraint on columns \"token_data_id_hash\" */\n  CurrentTokenDatasPkey = \"current_token_datas_pkey\",\n}\n\n/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */\nexport type CurrentTokenDatasDeleteAtPathInput = {\n  default_properties?: InputMaybe<Array<Scalars[\"String\"][\"input\"]>>;\n};\n\n/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */\nexport type CurrentTokenDatasDeleteElemInput = {\n  default_properties?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n};\n\n/** delete key/value pair or string element. key/value pairs are matched based on their key value */\nexport type CurrentTokenDatasDeleteKeyInput = {\n  default_properties?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** input type for incrementing numeric columns in table \"current_token_datas\" */\nexport type CurrentTokenDatasIncInput = {\n  largest_property_version?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  maximum?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  royalty_points_denominator?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  royalty_points_numerator?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  supply?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n};\n\n/** input type for inserting data into table \"current_token_datas\" */\nexport type CurrentTokenDatasInsertInput = {\n  collection_data_id_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  collection_name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  creator_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  default_properties?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  description?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  description_mutable?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  largest_property_version?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  last_transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  maximum?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  maximum_mutable?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  metadata_uri?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  payee_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  properties_mutable?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  royalty_mutable?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  royalty_points_denominator?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  royalty_points_numerator?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  supply?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  token_data_id_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  uri_mutable?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** aggregate max on columns */\nexport type CurrentTokenDatasMaxFields = {\n  collection_data_id_hash?: Maybe<Scalars[\"String\"][\"output\"]>;\n  collection_name?: Maybe<Scalars[\"String\"][\"output\"]>;\n  creator_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  description?: Maybe<Scalars[\"String\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  largest_property_version?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  last_transaction_timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  maximum?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  metadata_uri?: Maybe<Scalars[\"String\"][\"output\"]>;\n  name?: Maybe<Scalars[\"String\"][\"output\"]>;\n  payee_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  royalty_points_denominator?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  royalty_points_numerator?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  supply?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  token_data_id_hash?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** aggregate min on columns */\nexport type CurrentTokenDatasMinFields = {\n  collection_data_id_hash?: Maybe<Scalars[\"String\"][\"output\"]>;\n  collection_name?: Maybe<Scalars[\"String\"][\"output\"]>;\n  creator_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  description?: Maybe<Scalars[\"String\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  largest_property_version?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  last_transaction_timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  maximum?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  metadata_uri?: Maybe<Scalars[\"String\"][\"output\"]>;\n  name?: Maybe<Scalars[\"String\"][\"output\"]>;\n  payee_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  royalty_points_denominator?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  royalty_points_numerator?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  supply?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  token_data_id_hash?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** response of any mutation on the table \"current_token_datas\" */\nexport type CurrentTokenDatasMutationResponse = {\n  /** number of rows affected by the mutation */\n  affected_rows: Scalars[\"Int\"][\"output\"];\n  /** data from the rows affected by the mutation */\n  returning: Array<CurrentTokenDatas>;\n};\n\n/** on_conflict condition type for table \"current_token_datas\" */\nexport type CurrentTokenDatasOnConflict = {\n  constraint: CurrentTokenDatasConstraint;\n  update_columns?: Array<CurrentTokenDatasUpdateColumn>;\n  where?: InputMaybe<CurrentTokenDatasBoolExp>;\n};\n\n/** Ordering options when selecting data from \"current_token_datas\". */\nexport type CurrentTokenDatasOrderBy = {\n  collection_data_id_hash?: InputMaybe<OrderBy>;\n  collection_name?: InputMaybe<OrderBy>;\n  creator_address?: InputMaybe<OrderBy>;\n  default_properties?: InputMaybe<OrderBy>;\n  description?: InputMaybe<OrderBy>;\n  description_mutable?: InputMaybe<OrderBy>;\n  inserted_at?: InputMaybe<OrderBy>;\n  largest_property_version?: InputMaybe<OrderBy>;\n  last_transaction_timestamp?: InputMaybe<OrderBy>;\n  last_transaction_version?: InputMaybe<OrderBy>;\n  maximum?: InputMaybe<OrderBy>;\n  maximum_mutable?: InputMaybe<OrderBy>;\n  metadata_uri?: InputMaybe<OrderBy>;\n  name?: InputMaybe<OrderBy>;\n  payee_address?: InputMaybe<OrderBy>;\n  properties_mutable?: InputMaybe<OrderBy>;\n  royalty_mutable?: InputMaybe<OrderBy>;\n  royalty_points_denominator?: InputMaybe<OrderBy>;\n  royalty_points_numerator?: InputMaybe<OrderBy>;\n  supply?: InputMaybe<OrderBy>;\n  token_data_id_hash?: InputMaybe<OrderBy>;\n  uri_mutable?: InputMaybe<OrderBy>;\n};\n\n/** primary key columns input for table: current_token_datas */\nexport type CurrentTokenDatasPkColumnsInput = {\n  token_data_id_hash: Scalars[\"String\"][\"input\"];\n};\n\n/** prepend existing jsonb value of filtered columns with new jsonb value */\nexport type CurrentTokenDatasPrependInput = {\n  default_properties?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n};\n\n/** select columns of table \"current_token_datas\" */\nexport enum CurrentTokenDatasSelectColumn {\n  /** column name */\n  CollectionDataIdHash = \"collection_data_id_hash\",\n  /** column name */\n  CollectionName = \"collection_name\",\n  /** column name */\n  CreatorAddress = \"creator_address\",\n  /** column name */\n  DefaultProperties = \"default_properties\",\n  /** column name */\n  Description = \"description\",\n  /** column name */\n  DescriptionMutable = \"description_mutable\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  LargestPropertyVersion = \"largest_property_version\",\n  /** column name */\n  LastTransactionTimestamp = \"last_transaction_timestamp\",\n  /** column name */\n  LastTransactionVersion = \"last_transaction_version\",\n  /** column name */\n  Maximum = \"maximum\",\n  /** column name */\n  MaximumMutable = \"maximum_mutable\",\n  /** column name */\n  MetadataUri = \"metadata_uri\",\n  /** column name */\n  Name = \"name\",\n  /** column name */\n  PayeeAddress = \"payee_address\",\n  /** column name */\n  PropertiesMutable = \"properties_mutable\",\n  /** column name */\n  RoyaltyMutable = \"royalty_mutable\",\n  /** column name */\n  RoyaltyPointsDenominator = \"royalty_points_denominator\",\n  /** column name */\n  RoyaltyPointsNumerator = \"royalty_points_numerator\",\n  /** column name */\n  Supply = \"supply\",\n  /** column name */\n  TokenDataIdHash = \"token_data_id_hash\",\n  /** column name */\n  UriMutable = \"uri_mutable\",\n}\n\n/** input type for updating data in table \"current_token_datas\" */\nexport type CurrentTokenDatasSetInput = {\n  collection_data_id_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  collection_name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  creator_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  default_properties?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  description?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  description_mutable?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  largest_property_version?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  last_transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  maximum?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  maximum_mutable?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  metadata_uri?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  payee_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  properties_mutable?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  royalty_mutable?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  royalty_points_denominator?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  royalty_points_numerator?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  supply?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  token_data_id_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  uri_mutable?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** aggregate stddev on columns */\nexport type CurrentTokenDatasStddevFields = {\n  largest_property_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  maximum?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  royalty_points_denominator?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  royalty_points_numerator?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  supply?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_pop on columns */\nexport type CurrentTokenDatasStddevPopFields = {\n  largest_property_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  maximum?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  royalty_points_denominator?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  royalty_points_numerator?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  supply?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_samp on columns */\nexport type CurrentTokenDatasStddevSampFields = {\n  largest_property_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  maximum?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  royalty_points_denominator?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  royalty_points_numerator?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  supply?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Streaming cursor of the table \"current_token_datas\" */\nexport type CurrentTokenDatasStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: CurrentTokenDatasStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type CurrentTokenDatasStreamCursorValueInput = {\n  collection_data_id_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  collection_name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  creator_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  default_properties?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  description?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  description_mutable?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  largest_property_version?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  last_transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  maximum?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  maximum_mutable?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  metadata_uri?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  payee_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  properties_mutable?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  royalty_mutable?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  royalty_points_denominator?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  royalty_points_numerator?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  supply?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  token_data_id_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  uri_mutable?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** aggregate sum on columns */\nexport type CurrentTokenDatasSumFields = {\n  largest_property_version?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  maximum?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  royalty_points_denominator?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  royalty_points_numerator?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  supply?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n};\n\n/** update columns of table \"current_token_datas\" */\nexport enum CurrentTokenDatasUpdateColumn {\n  /** column name */\n  CollectionDataIdHash = \"collection_data_id_hash\",\n  /** column name */\n  CollectionName = \"collection_name\",\n  /** column name */\n  CreatorAddress = \"creator_address\",\n  /** column name */\n  DefaultProperties = \"default_properties\",\n  /** column name */\n  Description = \"description\",\n  /** column name */\n  DescriptionMutable = \"description_mutable\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  LargestPropertyVersion = \"largest_property_version\",\n  /** column name */\n  LastTransactionTimestamp = \"last_transaction_timestamp\",\n  /** column name */\n  LastTransactionVersion = \"last_transaction_version\",\n  /** column name */\n  Maximum = \"maximum\",\n  /** column name */\n  MaximumMutable = \"maximum_mutable\",\n  /** column name */\n  MetadataUri = \"metadata_uri\",\n  /** column name */\n  Name = \"name\",\n  /** column name */\n  PayeeAddress = \"payee_address\",\n  /** column name */\n  PropertiesMutable = \"properties_mutable\",\n  /** column name */\n  RoyaltyMutable = \"royalty_mutable\",\n  /** column name */\n  RoyaltyPointsDenominator = \"royalty_points_denominator\",\n  /** column name */\n  RoyaltyPointsNumerator = \"royalty_points_numerator\",\n  /** column name */\n  Supply = \"supply\",\n  /** column name */\n  TokenDataIdHash = \"token_data_id_hash\",\n  /** column name */\n  UriMutable = \"uri_mutable\",\n}\n\nexport type CurrentTokenDatasUpdates = {\n  /** append existing jsonb value of filtered columns with new jsonb value */\n  _append?: InputMaybe<CurrentTokenDatasAppendInput>;\n  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */\n  _delete_at_path?: InputMaybe<CurrentTokenDatasDeleteAtPathInput>;\n  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */\n  _delete_elem?: InputMaybe<CurrentTokenDatasDeleteElemInput>;\n  /** delete key/value pair or string element. key/value pairs are matched based on their key value */\n  _delete_key?: InputMaybe<CurrentTokenDatasDeleteKeyInput>;\n  /** increments the numeric columns with given value of the filtered values */\n  _inc?: InputMaybe<CurrentTokenDatasIncInput>;\n  /** prepend existing jsonb value of filtered columns with new jsonb value */\n  _prepend?: InputMaybe<CurrentTokenDatasPrependInput>;\n  /** sets the columns of the filtered rows to the given values */\n  _set?: InputMaybe<CurrentTokenDatasSetInput>;\n  /** filter the rows which have to be updated */\n  where: CurrentTokenDatasBoolExp;\n};\n\n/** columns and relationships of \"current_token_datas_v2\" */\nexport type CurrentTokenDatasV2 = {\n  /** An object relationship */\n  cdn_asset_uris?: Maybe<NftMetadataCrawlerParsedAssetUris>;\n  /** An object relationship */\n  cedra_name?: Maybe<CurrentCedraNames>;\n  collection_id: Scalars[\"String\"][\"output\"];\n  /** An object relationship */\n  current_collection?: Maybe<CurrentCollectionsV2>;\n  /** An object relationship */\n  current_royalty_v1?: Maybe<CurrentTokenRoyaltyV1>;\n  /** An array relationship */\n  current_token_ownerships: Array<CurrentTokenOwnershipsV2>;\n  /** An aggregate relationship */\n  current_token_ownerships_aggregate: CurrentTokenOwnershipsV2Aggregate;\n  decimals?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  description: Scalars[\"String\"][\"output\"];\n  inserted_at: Scalars[\"timestamp\"][\"output\"];\n  is_deleted_v2?: Maybe<Scalars[\"Boolean\"][\"output\"]>;\n  is_fungible_v2?: Maybe<Scalars[\"Boolean\"][\"output\"]>;\n  largest_property_version_v1?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  last_transaction_timestamp: Scalars[\"timestamp\"][\"output\"];\n  last_transaction_version: Scalars[\"bigint\"][\"output\"];\n  maximum?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  supply?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  token_data_id: Scalars[\"String\"][\"output\"];\n  token_name: Scalars[\"String\"][\"output\"];\n  token_properties: Scalars[\"jsonb\"][\"output\"];\n  token_standard: Scalars[\"String\"][\"output\"];\n  token_uri: Scalars[\"String\"][\"output\"];\n};\n\n/** columns and relationships of \"current_token_datas_v2\" */\nexport type CurrentTokenDatasV2CurrentTokenOwnershipsArgs = {\n  distinct_on?: InputMaybe<Array<CurrentTokenOwnershipsV2SelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentTokenOwnershipsV2OrderBy>>;\n  where?: InputMaybe<CurrentTokenOwnershipsV2BoolExp>;\n};\n\n/** columns and relationships of \"current_token_datas_v2\" */\nexport type CurrentTokenDatasV2CurrentTokenOwnershipsAggregateArgs = {\n  distinct_on?: InputMaybe<Array<CurrentTokenOwnershipsV2SelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentTokenOwnershipsV2OrderBy>>;\n  where?: InputMaybe<CurrentTokenOwnershipsV2BoolExp>;\n};\n\n/** columns and relationships of \"current_token_datas_v2\" */\nexport type CurrentTokenDatasV2TokenPropertiesArgs = {\n  path?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregated selection of \"current_token_datas_v2\" */\nexport type CurrentTokenDatasV2Aggregate = {\n  aggregate?: Maybe<CurrentTokenDatasV2AggregateFields>;\n  nodes: Array<CurrentTokenDatasV2>;\n};\n\n/** aggregate fields of \"current_token_datas_v2\" */\nexport type CurrentTokenDatasV2AggregateFields = {\n  avg?: Maybe<CurrentTokenDatasV2AvgFields>;\n  count: Scalars[\"Int\"][\"output\"];\n  max?: Maybe<CurrentTokenDatasV2MaxFields>;\n  min?: Maybe<CurrentTokenDatasV2MinFields>;\n  stddev?: Maybe<CurrentTokenDatasV2StddevFields>;\n  stddev_pop?: Maybe<CurrentTokenDatasV2StddevPopFields>;\n  stddev_samp?: Maybe<CurrentTokenDatasV2StddevSampFields>;\n  sum?: Maybe<CurrentTokenDatasV2SumFields>;\n  var_pop?: Maybe<CurrentTokenDatasV2VarPopFields>;\n  var_samp?: Maybe<CurrentTokenDatasV2VarSampFields>;\n  variance?: Maybe<CurrentTokenDatasV2VarianceFields>;\n};\n\n/** aggregate fields of \"current_token_datas_v2\" */\nexport type CurrentTokenDatasV2AggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<CurrentTokenDatasV2SelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** append existing jsonb value of filtered columns with new jsonb value */\nexport type CurrentTokenDatasV2AppendInput = {\n  token_properties?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n};\n\n/** aggregate avg on columns */\nexport type CurrentTokenDatasV2AvgFields = {\n  decimals?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  largest_property_version_v1?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  maximum?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  supply?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Boolean expression to filter rows from the table \"current_token_datas_v2\". All fields are combined with a logical 'AND'. */\nexport type CurrentTokenDatasV2BoolExp = {\n  _and?: InputMaybe<Array<CurrentTokenDatasV2BoolExp>>;\n  _not?: InputMaybe<CurrentTokenDatasV2BoolExp>;\n  _or?: InputMaybe<Array<CurrentTokenDatasV2BoolExp>>;\n  cdn_asset_uris?: InputMaybe<NftMetadataCrawlerParsedAssetUrisBoolExp>;\n  cedra_name?: InputMaybe<CurrentCedraNamesBoolExp>;\n  collection_id?: InputMaybe<StringComparisonExp>;\n  current_collection?: InputMaybe<CurrentCollectionsV2BoolExp>;\n  current_royalty_v1?: InputMaybe<CurrentTokenRoyaltyV1BoolExp>;\n  current_token_ownerships?: InputMaybe<CurrentTokenOwnershipsV2BoolExp>;\n  current_token_ownerships_aggregate?: InputMaybe<CurrentTokenOwnershipsV2AggregateBoolExp>;\n  decimals?: InputMaybe<BigintComparisonExp>;\n  description?: InputMaybe<StringComparisonExp>;\n  inserted_at?: InputMaybe<TimestampComparisonExp>;\n  is_deleted_v2?: InputMaybe<BooleanComparisonExp>;\n  is_fungible_v2?: InputMaybe<BooleanComparisonExp>;\n  largest_property_version_v1?: InputMaybe<NumericComparisonExp>;\n  last_transaction_timestamp?: InputMaybe<TimestampComparisonExp>;\n  last_transaction_version?: InputMaybe<BigintComparisonExp>;\n  maximum?: InputMaybe<NumericComparisonExp>;\n  supply?: InputMaybe<NumericComparisonExp>;\n  token_data_id?: InputMaybe<StringComparisonExp>;\n  token_name?: InputMaybe<StringComparisonExp>;\n  token_properties?: InputMaybe<JsonbComparisonExp>;\n  token_standard?: InputMaybe<StringComparisonExp>;\n  token_uri?: InputMaybe<StringComparisonExp>;\n};\n\n/** unique or primary key constraints on table \"current_token_datas_v2\" */\nexport enum CurrentTokenDatasV2Constraint {\n  /** unique or primary key constraint on columns \"token_data_id\" */\n  CurrentTokenDatasV2Pkey = \"current_token_datas_v2_pkey\",\n}\n\n/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */\nexport type CurrentTokenDatasV2DeleteAtPathInput = {\n  token_properties?: InputMaybe<Array<Scalars[\"String\"][\"input\"]>>;\n};\n\n/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */\nexport type CurrentTokenDatasV2DeleteElemInput = {\n  token_properties?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n};\n\n/** delete key/value pair or string element. key/value pairs are matched based on their key value */\nexport type CurrentTokenDatasV2DeleteKeyInput = {\n  token_properties?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** input type for incrementing numeric columns in table \"current_token_datas_v2\" */\nexport type CurrentTokenDatasV2IncInput = {\n  decimals?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  largest_property_version_v1?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  maximum?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  supply?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n};\n\n/** input type for inserting data into table \"current_token_datas_v2\" */\nexport type CurrentTokenDatasV2InsertInput = {\n  cdn_asset_uris?: InputMaybe<NftMetadataCrawlerParsedAssetUrisObjRelInsertInput>;\n  cedra_name?: InputMaybe<CurrentCedraNamesObjRelInsertInput>;\n  collection_id?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  current_collection?: InputMaybe<CurrentCollectionsV2ObjRelInsertInput>;\n  current_royalty_v1?: InputMaybe<CurrentTokenRoyaltyV1ObjRelInsertInput>;\n  current_token_ownerships?: InputMaybe<CurrentTokenOwnershipsV2ArrRelInsertInput>;\n  decimals?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  description?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  is_deleted_v2?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  is_fungible_v2?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  largest_property_version_v1?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  last_transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  maximum?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  supply?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  token_data_id?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_properties?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  token_standard?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_uri?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate max on columns */\nexport type CurrentTokenDatasV2MaxFields = {\n  collection_id?: Maybe<Scalars[\"String\"][\"output\"]>;\n  decimals?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  description?: Maybe<Scalars[\"String\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  largest_property_version_v1?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  last_transaction_timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  maximum?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  supply?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  token_data_id?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_name?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_standard?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_uri?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** aggregate min on columns */\nexport type CurrentTokenDatasV2MinFields = {\n  collection_id?: Maybe<Scalars[\"String\"][\"output\"]>;\n  decimals?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  description?: Maybe<Scalars[\"String\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  largest_property_version_v1?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  last_transaction_timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  maximum?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  supply?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  token_data_id?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_name?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_standard?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_uri?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** response of any mutation on the table \"current_token_datas_v2\" */\nexport type CurrentTokenDatasV2MutationResponse = {\n  /** number of rows affected by the mutation */\n  affected_rows: Scalars[\"Int\"][\"output\"];\n  /** data from the rows affected by the mutation */\n  returning: Array<CurrentTokenDatasV2>;\n};\n\n/** input type for inserting object relation for remote table \"current_token_datas_v2\" */\nexport type CurrentTokenDatasV2ObjRelInsertInput = {\n  data: CurrentTokenDatasV2InsertInput;\n  /** upsert condition */\n  on_conflict?: InputMaybe<CurrentTokenDatasV2OnConflict>;\n};\n\n/** on_conflict condition type for table \"current_token_datas_v2\" */\nexport type CurrentTokenDatasV2OnConflict = {\n  constraint: CurrentTokenDatasV2Constraint;\n  update_columns?: Array<CurrentTokenDatasV2UpdateColumn>;\n  where?: InputMaybe<CurrentTokenDatasV2BoolExp>;\n};\n\n/** Ordering options when selecting data from \"current_token_datas_v2\". */\nexport type CurrentTokenDatasV2OrderBy = {\n  cdn_asset_uris?: InputMaybe<NftMetadataCrawlerParsedAssetUrisOrderBy>;\n  cedra_name?: InputMaybe<CurrentCedraNamesOrderBy>;\n  collection_id?: InputMaybe<OrderBy>;\n  current_collection?: InputMaybe<CurrentCollectionsV2OrderBy>;\n  current_royalty_v1?: InputMaybe<CurrentTokenRoyaltyV1OrderBy>;\n  current_token_ownerships_aggregate?: InputMaybe<CurrentTokenOwnershipsV2AggregateOrderBy>;\n  decimals?: InputMaybe<OrderBy>;\n  description?: InputMaybe<OrderBy>;\n  inserted_at?: InputMaybe<OrderBy>;\n  is_deleted_v2?: InputMaybe<OrderBy>;\n  is_fungible_v2?: InputMaybe<OrderBy>;\n  largest_property_version_v1?: InputMaybe<OrderBy>;\n  last_transaction_timestamp?: InputMaybe<OrderBy>;\n  last_transaction_version?: InputMaybe<OrderBy>;\n  maximum?: InputMaybe<OrderBy>;\n  supply?: InputMaybe<OrderBy>;\n  token_data_id?: InputMaybe<OrderBy>;\n  token_name?: InputMaybe<OrderBy>;\n  token_properties?: InputMaybe<OrderBy>;\n  token_standard?: InputMaybe<OrderBy>;\n  token_uri?: InputMaybe<OrderBy>;\n};\n\n/** primary key columns input for table: current_token_datas_v2 */\nexport type CurrentTokenDatasV2PkColumnsInput = {\n  token_data_id: Scalars[\"String\"][\"input\"];\n};\n\n/** prepend existing jsonb value of filtered columns with new jsonb value */\nexport type CurrentTokenDatasV2PrependInput = {\n  token_properties?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n};\n\n/** select columns of table \"current_token_datas_v2\" */\nexport enum CurrentTokenDatasV2SelectColumn {\n  /** column name */\n  CollectionId = \"collection_id\",\n  /** column name */\n  Decimals = \"decimals\",\n  /** column name */\n  Description = \"description\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  IsDeletedV2 = \"is_deleted_v2\",\n  /** column name */\n  IsFungibleV2 = \"is_fungible_v2\",\n  /** column name */\n  LargestPropertyVersionV1 = \"largest_property_version_v1\",\n  /** column name */\n  LastTransactionTimestamp = \"last_transaction_timestamp\",\n  /** column name */\n  LastTransactionVersion = \"last_transaction_version\",\n  /** column name */\n  Maximum = \"maximum\",\n  /** column name */\n  Supply = \"supply\",\n  /** column name */\n  TokenDataId = \"token_data_id\",\n  /** column name */\n  TokenName = \"token_name\",\n  /** column name */\n  TokenProperties = \"token_properties\",\n  /** column name */\n  TokenStandard = \"token_standard\",\n  /** column name */\n  TokenUri = \"token_uri\",\n}\n\n/** input type for updating data in table \"current_token_datas_v2\" */\nexport type CurrentTokenDatasV2SetInput = {\n  collection_id?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  decimals?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  description?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  is_deleted_v2?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  is_fungible_v2?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  largest_property_version_v1?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  last_transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  maximum?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  supply?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  token_data_id?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_properties?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  token_standard?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_uri?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate stddev on columns */\nexport type CurrentTokenDatasV2StddevFields = {\n  decimals?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  largest_property_version_v1?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  maximum?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  supply?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_pop on columns */\nexport type CurrentTokenDatasV2StddevPopFields = {\n  decimals?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  largest_property_version_v1?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  maximum?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  supply?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_samp on columns */\nexport type CurrentTokenDatasV2StddevSampFields = {\n  decimals?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  largest_property_version_v1?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  maximum?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  supply?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Streaming cursor of the table \"current_token_datas_v2\" */\nexport type CurrentTokenDatasV2StreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: CurrentTokenDatasV2StreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type CurrentTokenDatasV2StreamCursorValueInput = {\n  collection_id?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  decimals?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  description?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  is_deleted_v2?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  is_fungible_v2?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  largest_property_version_v1?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  last_transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  maximum?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  supply?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  token_data_id?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_properties?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  token_standard?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_uri?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate sum on columns */\nexport type CurrentTokenDatasV2SumFields = {\n  decimals?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  largest_property_version_v1?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  maximum?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  supply?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n};\n\n/** update columns of table \"current_token_datas_v2\" */\nexport enum CurrentTokenDatasV2UpdateColumn {\n  /** column name */\n  CollectionId = \"collection_id\",\n  /** column name */\n  Decimals = \"decimals\",\n  /** column name */\n  Description = \"description\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  IsDeletedV2 = \"is_deleted_v2\",\n  /** column name */\n  IsFungibleV2 = \"is_fungible_v2\",\n  /** column name */\n  LargestPropertyVersionV1 = \"largest_property_version_v1\",\n  /** column name */\n  LastTransactionTimestamp = \"last_transaction_timestamp\",\n  /** column name */\n  LastTransactionVersion = \"last_transaction_version\",\n  /** column name */\n  Maximum = \"maximum\",\n  /** column name */\n  Supply = \"supply\",\n  /** column name */\n  TokenDataId = \"token_data_id\",\n  /** column name */\n  TokenName = \"token_name\",\n  /** column name */\n  TokenProperties = \"token_properties\",\n  /** column name */\n  TokenStandard = \"token_standard\",\n  /** column name */\n  TokenUri = \"token_uri\",\n}\n\nexport type CurrentTokenDatasV2Updates = {\n  /** append existing jsonb value of filtered columns with new jsonb value */\n  _append?: InputMaybe<CurrentTokenDatasV2AppendInput>;\n  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */\n  _delete_at_path?: InputMaybe<CurrentTokenDatasV2DeleteAtPathInput>;\n  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */\n  _delete_elem?: InputMaybe<CurrentTokenDatasV2DeleteElemInput>;\n  /** delete key/value pair or string element. key/value pairs are matched based on their key value */\n  _delete_key?: InputMaybe<CurrentTokenDatasV2DeleteKeyInput>;\n  /** increments the numeric columns with given value of the filtered values */\n  _inc?: InputMaybe<CurrentTokenDatasV2IncInput>;\n  /** prepend existing jsonb value of filtered columns with new jsonb value */\n  _prepend?: InputMaybe<CurrentTokenDatasV2PrependInput>;\n  /** sets the columns of the filtered rows to the given values */\n  _set?: InputMaybe<CurrentTokenDatasV2SetInput>;\n  /** filter the rows which have to be updated */\n  where: CurrentTokenDatasV2BoolExp;\n};\n\n/** aggregate var_pop on columns */\nexport type CurrentTokenDatasV2VarPopFields = {\n  decimals?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  largest_property_version_v1?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  maximum?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  supply?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate var_samp on columns */\nexport type CurrentTokenDatasV2VarSampFields = {\n  decimals?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  largest_property_version_v1?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  maximum?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  supply?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate variance on columns */\nexport type CurrentTokenDatasV2VarianceFields = {\n  decimals?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  largest_property_version_v1?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  maximum?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  supply?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate var_pop on columns */\nexport type CurrentTokenDatasVarPopFields = {\n  largest_property_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  maximum?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  royalty_points_denominator?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  royalty_points_numerator?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  supply?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate var_samp on columns */\nexport type CurrentTokenDatasVarSampFields = {\n  largest_property_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  maximum?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  royalty_points_denominator?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  royalty_points_numerator?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  supply?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate variance on columns */\nexport type CurrentTokenDatasVarianceFields = {\n  largest_property_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  maximum?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  royalty_points_denominator?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  royalty_points_numerator?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  supply?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** columns and relationships of \"current_token_ownerships\" */\nexport type CurrentTokenOwnerships = {\n  amount: Scalars[\"numeric\"][\"output\"];\n  collection_data_id_hash: Scalars[\"String\"][\"output\"];\n  collection_name: Scalars[\"String\"][\"output\"];\n  creator_address: Scalars[\"String\"][\"output\"];\n  inserted_at: Scalars[\"timestamp\"][\"output\"];\n  last_transaction_timestamp: Scalars[\"timestamp\"][\"output\"];\n  last_transaction_version: Scalars[\"bigint\"][\"output\"];\n  name: Scalars[\"String\"][\"output\"];\n  owner_address: Scalars[\"String\"][\"output\"];\n  property_version: Scalars[\"numeric\"][\"output\"];\n  table_type: Scalars[\"String\"][\"output\"];\n  token_data_id_hash: Scalars[\"String\"][\"output\"];\n  token_properties: Scalars[\"jsonb\"][\"output\"];\n};\n\n/** columns and relationships of \"current_token_ownerships\" */\nexport type CurrentTokenOwnershipsTokenPropertiesArgs = {\n  path?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregated selection of \"current_token_ownerships\" */\nexport type CurrentTokenOwnershipsAggregate = {\n  aggregate?: Maybe<CurrentTokenOwnershipsAggregateFields>;\n  nodes: Array<CurrentTokenOwnerships>;\n};\n\n/** aggregate fields of \"current_token_ownerships\" */\nexport type CurrentTokenOwnershipsAggregateFields = {\n  avg?: Maybe<CurrentTokenOwnershipsAvgFields>;\n  count: Scalars[\"Int\"][\"output\"];\n  max?: Maybe<CurrentTokenOwnershipsMaxFields>;\n  min?: Maybe<CurrentTokenOwnershipsMinFields>;\n  stddev?: Maybe<CurrentTokenOwnershipsStddevFields>;\n  stddev_pop?: Maybe<CurrentTokenOwnershipsStddevPopFields>;\n  stddev_samp?: Maybe<CurrentTokenOwnershipsStddevSampFields>;\n  sum?: Maybe<CurrentTokenOwnershipsSumFields>;\n  var_pop?: Maybe<CurrentTokenOwnershipsVarPopFields>;\n  var_samp?: Maybe<CurrentTokenOwnershipsVarSampFields>;\n  variance?: Maybe<CurrentTokenOwnershipsVarianceFields>;\n};\n\n/** aggregate fields of \"current_token_ownerships\" */\nexport type CurrentTokenOwnershipsAggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<CurrentTokenOwnershipsSelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** append existing jsonb value of filtered columns with new jsonb value */\nexport type CurrentTokenOwnershipsAppendInput = {\n  token_properties?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n};\n\n/** aggregate avg on columns */\nexport type CurrentTokenOwnershipsAvgFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  property_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Boolean expression to filter rows from the table \"current_token_ownerships\". All fields are combined with a logical 'AND'. */\nexport type CurrentTokenOwnershipsBoolExp = {\n  _and?: InputMaybe<Array<CurrentTokenOwnershipsBoolExp>>;\n  _not?: InputMaybe<CurrentTokenOwnershipsBoolExp>;\n  _or?: InputMaybe<Array<CurrentTokenOwnershipsBoolExp>>;\n  amount?: InputMaybe<NumericComparisonExp>;\n  collection_data_id_hash?: InputMaybe<StringComparisonExp>;\n  collection_name?: InputMaybe<StringComparisonExp>;\n  creator_address?: InputMaybe<StringComparisonExp>;\n  inserted_at?: InputMaybe<TimestampComparisonExp>;\n  last_transaction_timestamp?: InputMaybe<TimestampComparisonExp>;\n  last_transaction_version?: InputMaybe<BigintComparisonExp>;\n  name?: InputMaybe<StringComparisonExp>;\n  owner_address?: InputMaybe<StringComparisonExp>;\n  property_version?: InputMaybe<NumericComparisonExp>;\n  table_type?: InputMaybe<StringComparisonExp>;\n  token_data_id_hash?: InputMaybe<StringComparisonExp>;\n  token_properties?: InputMaybe<JsonbComparisonExp>;\n};\n\n/** unique or primary key constraints on table \"current_token_ownerships\" */\nexport enum CurrentTokenOwnershipsConstraint {\n  /** unique or primary key constraint on columns \"owner_address\", \"property_version\", \"token_data_id_hash\" */\n  CurrentTokenOwnershipsPkey = \"current_token_ownerships_pkey\",\n}\n\n/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */\nexport type CurrentTokenOwnershipsDeleteAtPathInput = {\n  token_properties?: InputMaybe<Array<Scalars[\"String\"][\"input\"]>>;\n};\n\n/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */\nexport type CurrentTokenOwnershipsDeleteElemInput = {\n  token_properties?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n};\n\n/** delete key/value pair or string element. key/value pairs are matched based on their key value */\nexport type CurrentTokenOwnershipsDeleteKeyInput = {\n  token_properties?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** input type for incrementing numeric columns in table \"current_token_ownerships\" */\nexport type CurrentTokenOwnershipsIncInput = {\n  amount?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  property_version?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n};\n\n/** input type for inserting data into table \"current_token_ownerships\" */\nexport type CurrentTokenOwnershipsInsertInput = {\n  amount?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  collection_data_id_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  collection_name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  creator_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  last_transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  owner_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  property_version?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  table_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_data_id_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_properties?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n};\n\n/** aggregate max on columns */\nexport type CurrentTokenOwnershipsMaxFields = {\n  amount?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  collection_data_id_hash?: Maybe<Scalars[\"String\"][\"output\"]>;\n  collection_name?: Maybe<Scalars[\"String\"][\"output\"]>;\n  creator_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  last_transaction_timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  name?: Maybe<Scalars[\"String\"][\"output\"]>;\n  owner_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  property_version?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  table_type?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_data_id_hash?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** aggregate min on columns */\nexport type CurrentTokenOwnershipsMinFields = {\n  amount?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  collection_data_id_hash?: Maybe<Scalars[\"String\"][\"output\"]>;\n  collection_name?: Maybe<Scalars[\"String\"][\"output\"]>;\n  creator_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  last_transaction_timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  name?: Maybe<Scalars[\"String\"][\"output\"]>;\n  owner_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  property_version?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  table_type?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_data_id_hash?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** response of any mutation on the table \"current_token_ownerships\" */\nexport type CurrentTokenOwnershipsMutationResponse = {\n  /** number of rows affected by the mutation */\n  affected_rows: Scalars[\"Int\"][\"output\"];\n  /** data from the rows affected by the mutation */\n  returning: Array<CurrentTokenOwnerships>;\n};\n\n/** on_conflict condition type for table \"current_token_ownerships\" */\nexport type CurrentTokenOwnershipsOnConflict = {\n  constraint: CurrentTokenOwnershipsConstraint;\n  update_columns?: Array<CurrentTokenOwnershipsUpdateColumn>;\n  where?: InputMaybe<CurrentTokenOwnershipsBoolExp>;\n};\n\n/** Ordering options when selecting data from \"current_token_ownerships\". */\nexport type CurrentTokenOwnershipsOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  collection_data_id_hash?: InputMaybe<OrderBy>;\n  collection_name?: InputMaybe<OrderBy>;\n  creator_address?: InputMaybe<OrderBy>;\n  inserted_at?: InputMaybe<OrderBy>;\n  last_transaction_timestamp?: InputMaybe<OrderBy>;\n  last_transaction_version?: InputMaybe<OrderBy>;\n  name?: InputMaybe<OrderBy>;\n  owner_address?: InputMaybe<OrderBy>;\n  property_version?: InputMaybe<OrderBy>;\n  table_type?: InputMaybe<OrderBy>;\n  token_data_id_hash?: InputMaybe<OrderBy>;\n  token_properties?: InputMaybe<OrderBy>;\n};\n\n/** primary key columns input for table: current_token_ownerships */\nexport type CurrentTokenOwnershipsPkColumnsInput = {\n  owner_address: Scalars[\"String\"][\"input\"];\n  property_version: Scalars[\"numeric\"][\"input\"];\n  token_data_id_hash: Scalars[\"String\"][\"input\"];\n};\n\n/** prepend existing jsonb value of filtered columns with new jsonb value */\nexport type CurrentTokenOwnershipsPrependInput = {\n  token_properties?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n};\n\n/** select columns of table \"current_token_ownerships\" */\nexport enum CurrentTokenOwnershipsSelectColumn {\n  /** column name */\n  Amount = \"amount\",\n  /** column name */\n  CollectionDataIdHash = \"collection_data_id_hash\",\n  /** column name */\n  CollectionName = \"collection_name\",\n  /** column name */\n  CreatorAddress = \"creator_address\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  LastTransactionTimestamp = \"last_transaction_timestamp\",\n  /** column name */\n  LastTransactionVersion = \"last_transaction_version\",\n  /** column name */\n  Name = \"name\",\n  /** column name */\n  OwnerAddress = \"owner_address\",\n  /** column name */\n  PropertyVersion = \"property_version\",\n  /** column name */\n  TableType = \"table_type\",\n  /** column name */\n  TokenDataIdHash = \"token_data_id_hash\",\n  /** column name */\n  TokenProperties = \"token_properties\",\n}\n\n/** input type for updating data in table \"current_token_ownerships\" */\nexport type CurrentTokenOwnershipsSetInput = {\n  amount?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  collection_data_id_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  collection_name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  creator_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  last_transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  owner_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  property_version?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  table_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_data_id_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_properties?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n};\n\n/** aggregate stddev on columns */\nexport type CurrentTokenOwnershipsStddevFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  property_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_pop on columns */\nexport type CurrentTokenOwnershipsStddevPopFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  property_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_samp on columns */\nexport type CurrentTokenOwnershipsStddevSampFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  property_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Streaming cursor of the table \"current_token_ownerships\" */\nexport type CurrentTokenOwnershipsStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: CurrentTokenOwnershipsStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type CurrentTokenOwnershipsStreamCursorValueInput = {\n  amount?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  collection_data_id_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  collection_name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  creator_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  last_transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  owner_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  property_version?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  table_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_data_id_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_properties?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n};\n\n/** aggregate sum on columns */\nexport type CurrentTokenOwnershipsSumFields = {\n  amount?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  property_version?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n};\n\n/** update columns of table \"current_token_ownerships\" */\nexport enum CurrentTokenOwnershipsUpdateColumn {\n  /** column name */\n  Amount = \"amount\",\n  /** column name */\n  CollectionDataIdHash = \"collection_data_id_hash\",\n  /** column name */\n  CollectionName = \"collection_name\",\n  /** column name */\n  CreatorAddress = \"creator_address\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  LastTransactionTimestamp = \"last_transaction_timestamp\",\n  /** column name */\n  LastTransactionVersion = \"last_transaction_version\",\n  /** column name */\n  Name = \"name\",\n  /** column name */\n  OwnerAddress = \"owner_address\",\n  /** column name */\n  PropertyVersion = \"property_version\",\n  /** column name */\n  TableType = \"table_type\",\n  /** column name */\n  TokenDataIdHash = \"token_data_id_hash\",\n  /** column name */\n  TokenProperties = \"token_properties\",\n}\n\nexport type CurrentTokenOwnershipsUpdates = {\n  /** append existing jsonb value of filtered columns with new jsonb value */\n  _append?: InputMaybe<CurrentTokenOwnershipsAppendInput>;\n  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */\n  _delete_at_path?: InputMaybe<CurrentTokenOwnershipsDeleteAtPathInput>;\n  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */\n  _delete_elem?: InputMaybe<CurrentTokenOwnershipsDeleteElemInput>;\n  /** delete key/value pair or string element. key/value pairs are matched based on their key value */\n  _delete_key?: InputMaybe<CurrentTokenOwnershipsDeleteKeyInput>;\n  /** increments the numeric columns with given value of the filtered values */\n  _inc?: InputMaybe<CurrentTokenOwnershipsIncInput>;\n  /** prepend existing jsonb value of filtered columns with new jsonb value */\n  _prepend?: InputMaybe<CurrentTokenOwnershipsPrependInput>;\n  /** sets the columns of the filtered rows to the given values */\n  _set?: InputMaybe<CurrentTokenOwnershipsSetInput>;\n  /** filter the rows which have to be updated */\n  where: CurrentTokenOwnershipsBoolExp;\n};\n\n/** columns and relationships of \"current_token_ownerships_v2\" */\nexport type CurrentTokenOwnershipsV2 = {\n  amount: Scalars[\"numeric\"][\"output\"];\n  /** An array relationship */\n  composed_nfts: Array<CurrentTokenOwnershipsV2>;\n  /** An aggregate relationship */\n  composed_nfts_aggregate: CurrentTokenOwnershipsV2Aggregate;\n  /** An object relationship */\n  current_token_data?: Maybe<CurrentTokenDatasV2>;\n  inserted_at: Scalars[\"timestamp\"][\"output\"];\n  is_fungible_v2?: Maybe<Scalars[\"Boolean\"][\"output\"]>;\n  is_soulbound_v2?: Maybe<Scalars[\"Boolean\"][\"output\"]>;\n  last_transaction_timestamp: Scalars[\"timestamp\"][\"output\"];\n  last_transaction_version: Scalars[\"bigint\"][\"output\"];\n  non_transferrable_by_owner?: Maybe<Scalars[\"Boolean\"][\"output\"]>;\n  owner_address: Scalars[\"String\"][\"output\"];\n  property_version_v1: Scalars[\"numeric\"][\"output\"];\n  storage_id: Scalars[\"String\"][\"output\"];\n  table_type_v1?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_data_id: Scalars[\"String\"][\"output\"];\n  token_properties_mutated_v1?: Maybe<Scalars[\"jsonb\"][\"output\"]>;\n  token_standard: Scalars[\"String\"][\"output\"];\n};\n\n/** columns and relationships of \"current_token_ownerships_v2\" */\nexport type CurrentTokenOwnershipsV2ComposedNftsArgs = {\n  distinct_on?: InputMaybe<Array<CurrentTokenOwnershipsV2SelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentTokenOwnershipsV2OrderBy>>;\n  where?: InputMaybe<CurrentTokenOwnershipsV2BoolExp>;\n};\n\n/** columns and relationships of \"current_token_ownerships_v2\" */\nexport type CurrentTokenOwnershipsV2ComposedNftsAggregateArgs = {\n  distinct_on?: InputMaybe<Array<CurrentTokenOwnershipsV2SelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentTokenOwnershipsV2OrderBy>>;\n  where?: InputMaybe<CurrentTokenOwnershipsV2BoolExp>;\n};\n\n/** columns and relationships of \"current_token_ownerships_v2\" */\nexport type CurrentTokenOwnershipsV2TokenPropertiesMutatedV1Args = {\n  path?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregated selection of \"current_token_ownerships_v2\" */\nexport type CurrentTokenOwnershipsV2Aggregate = {\n  aggregate?: Maybe<CurrentTokenOwnershipsV2AggregateFields>;\n  nodes: Array<CurrentTokenOwnershipsV2>;\n};\n\nexport type CurrentTokenOwnershipsV2AggregateBoolExp = {\n  bool_and?: InputMaybe<CurrentTokenOwnershipsV2AggregateBoolExpBoolAnd>;\n  bool_or?: InputMaybe<CurrentTokenOwnershipsV2AggregateBoolExpBoolOr>;\n  count?: InputMaybe<CurrentTokenOwnershipsV2AggregateBoolExpCount>;\n};\n\nexport type CurrentTokenOwnershipsV2AggregateBoolExpBoolAnd = {\n  arguments: CurrentTokenOwnershipsV2SelectColumnCurrentTokenOwnershipsV2AggregateBoolExpBoolAndArgumentsColumns;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  filter?: InputMaybe<CurrentTokenOwnershipsV2BoolExp>;\n  predicate: BooleanComparisonExp;\n};\n\nexport type CurrentTokenOwnershipsV2AggregateBoolExpBoolOr = {\n  arguments: CurrentTokenOwnershipsV2SelectColumnCurrentTokenOwnershipsV2AggregateBoolExpBoolOrArgumentsColumns;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  filter?: InputMaybe<CurrentTokenOwnershipsV2BoolExp>;\n  predicate: BooleanComparisonExp;\n};\n\nexport type CurrentTokenOwnershipsV2AggregateBoolExpCount = {\n  arguments?: InputMaybe<Array<CurrentTokenOwnershipsV2SelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  filter?: InputMaybe<CurrentTokenOwnershipsV2BoolExp>;\n  predicate: IntComparisonExp;\n};\n\n/** aggregate fields of \"current_token_ownerships_v2\" */\nexport type CurrentTokenOwnershipsV2AggregateFields = {\n  avg?: Maybe<CurrentTokenOwnershipsV2AvgFields>;\n  count: Scalars[\"Int\"][\"output\"];\n  max?: Maybe<CurrentTokenOwnershipsV2MaxFields>;\n  min?: Maybe<CurrentTokenOwnershipsV2MinFields>;\n  stddev?: Maybe<CurrentTokenOwnershipsV2StddevFields>;\n  stddev_pop?: Maybe<CurrentTokenOwnershipsV2StddevPopFields>;\n  stddev_samp?: Maybe<CurrentTokenOwnershipsV2StddevSampFields>;\n  sum?: Maybe<CurrentTokenOwnershipsV2SumFields>;\n  var_pop?: Maybe<CurrentTokenOwnershipsV2VarPopFields>;\n  var_samp?: Maybe<CurrentTokenOwnershipsV2VarSampFields>;\n  variance?: Maybe<CurrentTokenOwnershipsV2VarianceFields>;\n};\n\n/** aggregate fields of \"current_token_ownerships_v2\" */\nexport type CurrentTokenOwnershipsV2AggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<CurrentTokenOwnershipsV2SelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** order by aggregate values of table \"current_token_ownerships_v2\" */\nexport type CurrentTokenOwnershipsV2AggregateOrderBy = {\n  avg?: InputMaybe<CurrentTokenOwnershipsV2AvgOrderBy>;\n  count?: InputMaybe<OrderBy>;\n  max?: InputMaybe<CurrentTokenOwnershipsV2MaxOrderBy>;\n  min?: InputMaybe<CurrentTokenOwnershipsV2MinOrderBy>;\n  stddev?: InputMaybe<CurrentTokenOwnershipsV2StddevOrderBy>;\n  stddev_pop?: InputMaybe<CurrentTokenOwnershipsV2StddevPopOrderBy>;\n  stddev_samp?: InputMaybe<CurrentTokenOwnershipsV2StddevSampOrderBy>;\n  sum?: InputMaybe<CurrentTokenOwnershipsV2SumOrderBy>;\n  var_pop?: InputMaybe<CurrentTokenOwnershipsV2VarPopOrderBy>;\n  var_samp?: InputMaybe<CurrentTokenOwnershipsV2VarSampOrderBy>;\n  variance?: InputMaybe<CurrentTokenOwnershipsV2VarianceOrderBy>;\n};\n\n/** append existing jsonb value of filtered columns with new jsonb value */\nexport type CurrentTokenOwnershipsV2AppendInput = {\n  token_properties_mutated_v1?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n};\n\n/** input type for inserting array relation for remote table \"current_token_ownerships_v2\" */\nexport type CurrentTokenOwnershipsV2ArrRelInsertInput = {\n  data: Array<CurrentTokenOwnershipsV2InsertInput>;\n  /** upsert condition */\n  on_conflict?: InputMaybe<CurrentTokenOwnershipsV2OnConflict>;\n};\n\n/** aggregate avg on columns */\nexport type CurrentTokenOwnershipsV2AvgFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  property_version_v1?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** order by avg() on columns of table \"current_token_ownerships_v2\" */\nexport type CurrentTokenOwnershipsV2AvgOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  last_transaction_version?: InputMaybe<OrderBy>;\n  property_version_v1?: InputMaybe<OrderBy>;\n};\n\n/** Boolean expression to filter rows from the table \"current_token_ownerships_v2\". All fields are combined with a logical 'AND'. */\nexport type CurrentTokenOwnershipsV2BoolExp = {\n  _and?: InputMaybe<Array<CurrentTokenOwnershipsV2BoolExp>>;\n  _not?: InputMaybe<CurrentTokenOwnershipsV2BoolExp>;\n  _or?: InputMaybe<Array<CurrentTokenOwnershipsV2BoolExp>>;\n  amount?: InputMaybe<NumericComparisonExp>;\n  composed_nfts?: InputMaybe<CurrentTokenOwnershipsV2BoolExp>;\n  composed_nfts_aggregate?: InputMaybe<CurrentTokenOwnershipsV2AggregateBoolExp>;\n  current_token_data?: InputMaybe<CurrentTokenDatasV2BoolExp>;\n  inserted_at?: InputMaybe<TimestampComparisonExp>;\n  is_fungible_v2?: InputMaybe<BooleanComparisonExp>;\n  is_soulbound_v2?: InputMaybe<BooleanComparisonExp>;\n  last_transaction_timestamp?: InputMaybe<TimestampComparisonExp>;\n  last_transaction_version?: InputMaybe<BigintComparisonExp>;\n  non_transferrable_by_owner?: InputMaybe<BooleanComparisonExp>;\n  owner_address?: InputMaybe<StringComparisonExp>;\n  property_version_v1?: InputMaybe<NumericComparisonExp>;\n  storage_id?: InputMaybe<StringComparisonExp>;\n  table_type_v1?: InputMaybe<StringComparisonExp>;\n  token_data_id?: InputMaybe<StringComparisonExp>;\n  token_properties_mutated_v1?: InputMaybe<JsonbComparisonExp>;\n  token_standard?: InputMaybe<StringComparisonExp>;\n};\n\n/** unique or primary key constraints on table \"current_token_ownerships_v2\" */\nexport enum CurrentTokenOwnershipsV2Constraint {\n  /** unique or primary key constraint on columns \"owner_address\", \"property_version_v1\", \"storage_id\", \"token_data_id\" */\n  CurrentTokenOwnershipsV2Pkey = \"current_token_ownerships_v2_pkey\",\n}\n\n/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */\nexport type CurrentTokenOwnershipsV2DeleteAtPathInput = {\n  token_properties_mutated_v1?: InputMaybe<Array<Scalars[\"String\"][\"input\"]>>;\n};\n\n/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */\nexport type CurrentTokenOwnershipsV2DeleteElemInput = {\n  token_properties_mutated_v1?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n};\n\n/** delete key/value pair or string element. key/value pairs are matched based on their key value */\nexport type CurrentTokenOwnershipsV2DeleteKeyInput = {\n  token_properties_mutated_v1?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** input type for incrementing numeric columns in table \"current_token_ownerships_v2\" */\nexport type CurrentTokenOwnershipsV2IncInput = {\n  amount?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  property_version_v1?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n};\n\n/** input type for inserting data into table \"current_token_ownerships_v2\" */\nexport type CurrentTokenOwnershipsV2InsertInput = {\n  amount?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  composed_nfts?: InputMaybe<CurrentTokenOwnershipsV2ArrRelInsertInput>;\n  current_token_data?: InputMaybe<CurrentTokenDatasV2ObjRelInsertInput>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  is_fungible_v2?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  is_soulbound_v2?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  last_transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  non_transferrable_by_owner?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  owner_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  property_version_v1?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  storage_id?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  table_type_v1?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_data_id?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_properties_mutated_v1?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  token_standard?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate max on columns */\nexport type CurrentTokenOwnershipsV2MaxFields = {\n  amount?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  last_transaction_timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  owner_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  property_version_v1?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  storage_id?: Maybe<Scalars[\"String\"][\"output\"]>;\n  table_type_v1?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_data_id?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_standard?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** order by max() on columns of table \"current_token_ownerships_v2\" */\nexport type CurrentTokenOwnershipsV2MaxOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  inserted_at?: InputMaybe<OrderBy>;\n  last_transaction_timestamp?: InputMaybe<OrderBy>;\n  last_transaction_version?: InputMaybe<OrderBy>;\n  owner_address?: InputMaybe<OrderBy>;\n  property_version_v1?: InputMaybe<OrderBy>;\n  storage_id?: InputMaybe<OrderBy>;\n  table_type_v1?: InputMaybe<OrderBy>;\n  token_data_id?: InputMaybe<OrderBy>;\n  token_standard?: InputMaybe<OrderBy>;\n};\n\n/** aggregate min on columns */\nexport type CurrentTokenOwnershipsV2MinFields = {\n  amount?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  last_transaction_timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  owner_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  property_version_v1?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  storage_id?: Maybe<Scalars[\"String\"][\"output\"]>;\n  table_type_v1?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_data_id?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_standard?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** order by min() on columns of table \"current_token_ownerships_v2\" */\nexport type CurrentTokenOwnershipsV2MinOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  inserted_at?: InputMaybe<OrderBy>;\n  last_transaction_timestamp?: InputMaybe<OrderBy>;\n  last_transaction_version?: InputMaybe<OrderBy>;\n  owner_address?: InputMaybe<OrderBy>;\n  property_version_v1?: InputMaybe<OrderBy>;\n  storage_id?: InputMaybe<OrderBy>;\n  table_type_v1?: InputMaybe<OrderBy>;\n  token_data_id?: InputMaybe<OrderBy>;\n  token_standard?: InputMaybe<OrderBy>;\n};\n\n/** response of any mutation on the table \"current_token_ownerships_v2\" */\nexport type CurrentTokenOwnershipsV2MutationResponse = {\n  /** number of rows affected by the mutation */\n  affected_rows: Scalars[\"Int\"][\"output\"];\n  /** data from the rows affected by the mutation */\n  returning: Array<CurrentTokenOwnershipsV2>;\n};\n\n/** on_conflict condition type for table \"current_token_ownerships_v2\" */\nexport type CurrentTokenOwnershipsV2OnConflict = {\n  constraint: CurrentTokenOwnershipsV2Constraint;\n  update_columns?: Array<CurrentTokenOwnershipsV2UpdateColumn>;\n  where?: InputMaybe<CurrentTokenOwnershipsV2BoolExp>;\n};\n\n/** Ordering options when selecting data from \"current_token_ownerships_v2\". */\nexport type CurrentTokenOwnershipsV2OrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  composed_nfts_aggregate?: InputMaybe<CurrentTokenOwnershipsV2AggregateOrderBy>;\n  current_token_data?: InputMaybe<CurrentTokenDatasV2OrderBy>;\n  inserted_at?: InputMaybe<OrderBy>;\n  is_fungible_v2?: InputMaybe<OrderBy>;\n  is_soulbound_v2?: InputMaybe<OrderBy>;\n  last_transaction_timestamp?: InputMaybe<OrderBy>;\n  last_transaction_version?: InputMaybe<OrderBy>;\n  non_transferrable_by_owner?: InputMaybe<OrderBy>;\n  owner_address?: InputMaybe<OrderBy>;\n  property_version_v1?: InputMaybe<OrderBy>;\n  storage_id?: InputMaybe<OrderBy>;\n  table_type_v1?: InputMaybe<OrderBy>;\n  token_data_id?: InputMaybe<OrderBy>;\n  token_properties_mutated_v1?: InputMaybe<OrderBy>;\n  token_standard?: InputMaybe<OrderBy>;\n};\n\n/** primary key columns input for table: current_token_ownerships_v2 */\nexport type CurrentTokenOwnershipsV2PkColumnsInput = {\n  owner_address: Scalars[\"String\"][\"input\"];\n  property_version_v1: Scalars[\"numeric\"][\"input\"];\n  storage_id: Scalars[\"String\"][\"input\"];\n  token_data_id: Scalars[\"String\"][\"input\"];\n};\n\n/** prepend existing jsonb value of filtered columns with new jsonb value */\nexport type CurrentTokenOwnershipsV2PrependInput = {\n  token_properties_mutated_v1?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n};\n\n/** select columns of table \"current_token_ownerships_v2\" */\nexport enum CurrentTokenOwnershipsV2SelectColumn {\n  /** column name */\n  Amount = \"amount\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  IsFungibleV2 = \"is_fungible_v2\",\n  /** column name */\n  IsSoulboundV2 = \"is_soulbound_v2\",\n  /** column name */\n  LastTransactionTimestamp = \"last_transaction_timestamp\",\n  /** column name */\n  LastTransactionVersion = \"last_transaction_version\",\n  /** column name */\n  NonTransferrableByOwner = \"non_transferrable_by_owner\",\n  /** column name */\n  OwnerAddress = \"owner_address\",\n  /** column name */\n  PropertyVersionV1 = \"property_version_v1\",\n  /** column name */\n  StorageId = \"storage_id\",\n  /** column name */\n  TableTypeV1 = \"table_type_v1\",\n  /** column name */\n  TokenDataId = \"token_data_id\",\n  /** column name */\n  TokenPropertiesMutatedV1 = \"token_properties_mutated_v1\",\n  /** column name */\n  TokenStandard = \"token_standard\",\n}\n\n/** select \"current_token_ownerships_v2_aggregate_bool_exp_bool_and_arguments_columns\" columns of table \"current_token_ownerships_v2\" */\nexport enum CurrentTokenOwnershipsV2SelectColumnCurrentTokenOwnershipsV2AggregateBoolExpBoolAndArgumentsColumns {\n  /** column name */\n  IsFungibleV2 = \"is_fungible_v2\",\n  /** column name */\n  IsSoulboundV2 = \"is_soulbound_v2\",\n  /** column name */\n  NonTransferrableByOwner = \"non_transferrable_by_owner\",\n}\n\n/** select \"current_token_ownerships_v2_aggregate_bool_exp_bool_or_arguments_columns\" columns of table \"current_token_ownerships_v2\" */\nexport enum CurrentTokenOwnershipsV2SelectColumnCurrentTokenOwnershipsV2AggregateBoolExpBoolOrArgumentsColumns {\n  /** column name */\n  IsFungibleV2 = \"is_fungible_v2\",\n  /** column name */\n  IsSoulboundV2 = \"is_soulbound_v2\",\n  /** column name */\n  NonTransferrableByOwner = \"non_transferrable_by_owner\",\n}\n\n/** input type for updating data in table \"current_token_ownerships_v2\" */\nexport type CurrentTokenOwnershipsV2SetInput = {\n  amount?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  is_fungible_v2?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  is_soulbound_v2?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  last_transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  non_transferrable_by_owner?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  owner_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  property_version_v1?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  storage_id?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  table_type_v1?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_data_id?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_properties_mutated_v1?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  token_standard?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate stddev on columns */\nexport type CurrentTokenOwnershipsV2StddevFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  property_version_v1?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** order by stddev() on columns of table \"current_token_ownerships_v2\" */\nexport type CurrentTokenOwnershipsV2StddevOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  last_transaction_version?: InputMaybe<OrderBy>;\n  property_version_v1?: InputMaybe<OrderBy>;\n};\n\n/** aggregate stddev_pop on columns */\nexport type CurrentTokenOwnershipsV2StddevPopFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  property_version_v1?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** order by stddev_pop() on columns of table \"current_token_ownerships_v2\" */\nexport type CurrentTokenOwnershipsV2StddevPopOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  last_transaction_version?: InputMaybe<OrderBy>;\n  property_version_v1?: InputMaybe<OrderBy>;\n};\n\n/** aggregate stddev_samp on columns */\nexport type CurrentTokenOwnershipsV2StddevSampFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  property_version_v1?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** order by stddev_samp() on columns of table \"current_token_ownerships_v2\" */\nexport type CurrentTokenOwnershipsV2StddevSampOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  last_transaction_version?: InputMaybe<OrderBy>;\n  property_version_v1?: InputMaybe<OrderBy>;\n};\n\n/** Streaming cursor of the table \"current_token_ownerships_v2\" */\nexport type CurrentTokenOwnershipsV2StreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: CurrentTokenOwnershipsV2StreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type CurrentTokenOwnershipsV2StreamCursorValueInput = {\n  amount?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  is_fungible_v2?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  is_soulbound_v2?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  last_transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  non_transferrable_by_owner?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  owner_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  property_version_v1?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  storage_id?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  table_type_v1?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_data_id?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_properties_mutated_v1?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  token_standard?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate sum on columns */\nexport type CurrentTokenOwnershipsV2SumFields = {\n  amount?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  property_version_v1?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n};\n\n/** order by sum() on columns of table \"current_token_ownerships_v2\" */\nexport type CurrentTokenOwnershipsV2SumOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  last_transaction_version?: InputMaybe<OrderBy>;\n  property_version_v1?: InputMaybe<OrderBy>;\n};\n\n/** update columns of table \"current_token_ownerships_v2\" */\nexport enum CurrentTokenOwnershipsV2UpdateColumn {\n  /** column name */\n  Amount = \"amount\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  IsFungibleV2 = \"is_fungible_v2\",\n  /** column name */\n  IsSoulboundV2 = \"is_soulbound_v2\",\n  /** column name */\n  LastTransactionTimestamp = \"last_transaction_timestamp\",\n  /** column name */\n  LastTransactionVersion = \"last_transaction_version\",\n  /** column name */\n  NonTransferrableByOwner = \"non_transferrable_by_owner\",\n  /** column name */\n  OwnerAddress = \"owner_address\",\n  /** column name */\n  PropertyVersionV1 = \"property_version_v1\",\n  /** column name */\n  StorageId = \"storage_id\",\n  /** column name */\n  TableTypeV1 = \"table_type_v1\",\n  /** column name */\n  TokenDataId = \"token_data_id\",\n  /** column name */\n  TokenPropertiesMutatedV1 = \"token_properties_mutated_v1\",\n  /** column name */\n  TokenStandard = \"token_standard\",\n}\n\nexport type CurrentTokenOwnershipsV2Updates = {\n  /** append existing jsonb value of filtered columns with new jsonb value */\n  _append?: InputMaybe<CurrentTokenOwnershipsV2AppendInput>;\n  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */\n  _delete_at_path?: InputMaybe<CurrentTokenOwnershipsV2DeleteAtPathInput>;\n  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */\n  _delete_elem?: InputMaybe<CurrentTokenOwnershipsV2DeleteElemInput>;\n  /** delete key/value pair or string element. key/value pairs are matched based on their key value */\n  _delete_key?: InputMaybe<CurrentTokenOwnershipsV2DeleteKeyInput>;\n  /** increments the numeric columns with given value of the filtered values */\n  _inc?: InputMaybe<CurrentTokenOwnershipsV2IncInput>;\n  /** prepend existing jsonb value of filtered columns with new jsonb value */\n  _prepend?: InputMaybe<CurrentTokenOwnershipsV2PrependInput>;\n  /** sets the columns of the filtered rows to the given values */\n  _set?: InputMaybe<CurrentTokenOwnershipsV2SetInput>;\n  /** filter the rows which have to be updated */\n  where: CurrentTokenOwnershipsV2BoolExp;\n};\n\n/** aggregate var_pop on columns */\nexport type CurrentTokenOwnershipsV2VarPopFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  property_version_v1?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** order by var_pop() on columns of table \"current_token_ownerships_v2\" */\nexport type CurrentTokenOwnershipsV2VarPopOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  last_transaction_version?: InputMaybe<OrderBy>;\n  property_version_v1?: InputMaybe<OrderBy>;\n};\n\n/** aggregate var_samp on columns */\nexport type CurrentTokenOwnershipsV2VarSampFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  property_version_v1?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** order by var_samp() on columns of table \"current_token_ownerships_v2\" */\nexport type CurrentTokenOwnershipsV2VarSampOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  last_transaction_version?: InputMaybe<OrderBy>;\n  property_version_v1?: InputMaybe<OrderBy>;\n};\n\n/** aggregate variance on columns */\nexport type CurrentTokenOwnershipsV2VarianceFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  property_version_v1?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** order by variance() on columns of table \"current_token_ownerships_v2\" */\nexport type CurrentTokenOwnershipsV2VarianceOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  last_transaction_version?: InputMaybe<OrderBy>;\n  property_version_v1?: InputMaybe<OrderBy>;\n};\n\n/** aggregate var_pop on columns */\nexport type CurrentTokenOwnershipsVarPopFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  property_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate var_samp on columns */\nexport type CurrentTokenOwnershipsVarSampFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  property_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate variance on columns */\nexport type CurrentTokenOwnershipsVarianceFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  property_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** columns and relationships of \"current_token_pending_claims\" */\nexport type CurrentTokenPendingClaims = {\n  amount: Scalars[\"numeric\"][\"output\"];\n  collection_data_id_hash: Scalars[\"String\"][\"output\"];\n  collection_id: Scalars[\"String\"][\"output\"];\n  collection_name: Scalars[\"String\"][\"output\"];\n  creator_address: Scalars[\"String\"][\"output\"];\n  /** An object relationship */\n  current_collection_v2?: Maybe<CurrentCollectionsV2>;\n  /** An object relationship */\n  current_token_data_v2?: Maybe<CurrentTokenDatasV2>;\n  from_address: Scalars[\"String\"][\"output\"];\n  inserted_at: Scalars[\"timestamp\"][\"output\"];\n  last_transaction_timestamp: Scalars[\"timestamp\"][\"output\"];\n  last_transaction_version: Scalars[\"bigint\"][\"output\"];\n  name: Scalars[\"String\"][\"output\"];\n  property_version: Scalars[\"numeric\"][\"output\"];\n  table_handle: Scalars[\"String\"][\"output\"];\n  to_address: Scalars[\"String\"][\"output\"];\n  token_data_id: Scalars[\"String\"][\"output\"];\n  token_data_id_hash: Scalars[\"String\"][\"output\"];\n};\n\n/** aggregated selection of \"current_token_pending_claims\" */\nexport type CurrentTokenPendingClaimsAggregate = {\n  aggregate?: Maybe<CurrentTokenPendingClaimsAggregateFields>;\n  nodes: Array<CurrentTokenPendingClaims>;\n};\n\n/** aggregate fields of \"current_token_pending_claims\" */\nexport type CurrentTokenPendingClaimsAggregateFields = {\n  avg?: Maybe<CurrentTokenPendingClaimsAvgFields>;\n  count: Scalars[\"Int\"][\"output\"];\n  max?: Maybe<CurrentTokenPendingClaimsMaxFields>;\n  min?: Maybe<CurrentTokenPendingClaimsMinFields>;\n  stddev?: Maybe<CurrentTokenPendingClaimsStddevFields>;\n  stddev_pop?: Maybe<CurrentTokenPendingClaimsStddevPopFields>;\n  stddev_samp?: Maybe<CurrentTokenPendingClaimsStddevSampFields>;\n  sum?: Maybe<CurrentTokenPendingClaimsSumFields>;\n  var_pop?: Maybe<CurrentTokenPendingClaimsVarPopFields>;\n  var_samp?: Maybe<CurrentTokenPendingClaimsVarSampFields>;\n  variance?: Maybe<CurrentTokenPendingClaimsVarianceFields>;\n};\n\n/** aggregate fields of \"current_token_pending_claims\" */\nexport type CurrentTokenPendingClaimsAggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<CurrentTokenPendingClaimsSelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** aggregate avg on columns */\nexport type CurrentTokenPendingClaimsAvgFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  property_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Boolean expression to filter rows from the table \"current_token_pending_claims\". All fields are combined with a logical 'AND'. */\nexport type CurrentTokenPendingClaimsBoolExp = {\n  _and?: InputMaybe<Array<CurrentTokenPendingClaimsBoolExp>>;\n  _not?: InputMaybe<CurrentTokenPendingClaimsBoolExp>;\n  _or?: InputMaybe<Array<CurrentTokenPendingClaimsBoolExp>>;\n  amount?: InputMaybe<NumericComparisonExp>;\n  collection_data_id_hash?: InputMaybe<StringComparisonExp>;\n  collection_id?: InputMaybe<StringComparisonExp>;\n  collection_name?: InputMaybe<StringComparisonExp>;\n  creator_address?: InputMaybe<StringComparisonExp>;\n  current_collection_v2?: InputMaybe<CurrentCollectionsV2BoolExp>;\n  current_token_data_v2?: InputMaybe<CurrentTokenDatasV2BoolExp>;\n  from_address?: InputMaybe<StringComparisonExp>;\n  inserted_at?: InputMaybe<TimestampComparisonExp>;\n  last_transaction_timestamp?: InputMaybe<TimestampComparisonExp>;\n  last_transaction_version?: InputMaybe<BigintComparisonExp>;\n  name?: InputMaybe<StringComparisonExp>;\n  property_version?: InputMaybe<NumericComparisonExp>;\n  table_handle?: InputMaybe<StringComparisonExp>;\n  to_address?: InputMaybe<StringComparisonExp>;\n  token_data_id?: InputMaybe<StringComparisonExp>;\n  token_data_id_hash?: InputMaybe<StringComparisonExp>;\n};\n\n/** unique or primary key constraints on table \"current_token_pending_claims\" */\nexport enum CurrentTokenPendingClaimsConstraint {\n  /** unique or primary key constraint on columns \"to_address\", \"property_version\", \"from_address\", \"token_data_id_hash\" */\n  CurrentTokenPendingClaimsPkey = \"current_token_pending_claims_pkey\",\n}\n\n/** input type for incrementing numeric columns in table \"current_token_pending_claims\" */\nexport type CurrentTokenPendingClaimsIncInput = {\n  amount?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  property_version?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n};\n\n/** input type for inserting data into table \"current_token_pending_claims\" */\nexport type CurrentTokenPendingClaimsInsertInput = {\n  amount?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  collection_data_id_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  collection_id?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  collection_name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  creator_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  current_collection_v2?: InputMaybe<CurrentCollectionsV2ObjRelInsertInput>;\n  current_token_data_v2?: InputMaybe<CurrentTokenDatasV2ObjRelInsertInput>;\n  from_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  last_transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  property_version?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  table_handle?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  to_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_data_id?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_data_id_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate max on columns */\nexport type CurrentTokenPendingClaimsMaxFields = {\n  amount?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  collection_data_id_hash?: Maybe<Scalars[\"String\"][\"output\"]>;\n  collection_id?: Maybe<Scalars[\"String\"][\"output\"]>;\n  collection_name?: Maybe<Scalars[\"String\"][\"output\"]>;\n  creator_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  from_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  last_transaction_timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  name?: Maybe<Scalars[\"String\"][\"output\"]>;\n  property_version?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  table_handle?: Maybe<Scalars[\"String\"][\"output\"]>;\n  to_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_data_id?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_data_id_hash?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** aggregate min on columns */\nexport type CurrentTokenPendingClaimsMinFields = {\n  amount?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  collection_data_id_hash?: Maybe<Scalars[\"String\"][\"output\"]>;\n  collection_id?: Maybe<Scalars[\"String\"][\"output\"]>;\n  collection_name?: Maybe<Scalars[\"String\"][\"output\"]>;\n  creator_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  from_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  last_transaction_timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  name?: Maybe<Scalars[\"String\"][\"output\"]>;\n  property_version?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  table_handle?: Maybe<Scalars[\"String\"][\"output\"]>;\n  to_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_data_id?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_data_id_hash?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** response of any mutation on the table \"current_token_pending_claims\" */\nexport type CurrentTokenPendingClaimsMutationResponse = {\n  /** number of rows affected by the mutation */\n  affected_rows: Scalars[\"Int\"][\"output\"];\n  /** data from the rows affected by the mutation */\n  returning: Array<CurrentTokenPendingClaims>;\n};\n\n/** on_conflict condition type for table \"current_token_pending_claims\" */\nexport type CurrentTokenPendingClaimsOnConflict = {\n  constraint: CurrentTokenPendingClaimsConstraint;\n  update_columns?: Array<CurrentTokenPendingClaimsUpdateColumn>;\n  where?: InputMaybe<CurrentTokenPendingClaimsBoolExp>;\n};\n\n/** Ordering options when selecting data from \"current_token_pending_claims\". */\nexport type CurrentTokenPendingClaimsOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  collection_data_id_hash?: InputMaybe<OrderBy>;\n  collection_id?: InputMaybe<OrderBy>;\n  collection_name?: InputMaybe<OrderBy>;\n  creator_address?: InputMaybe<OrderBy>;\n  current_collection_v2?: InputMaybe<CurrentCollectionsV2OrderBy>;\n  current_token_data_v2?: InputMaybe<CurrentTokenDatasV2OrderBy>;\n  from_address?: InputMaybe<OrderBy>;\n  inserted_at?: InputMaybe<OrderBy>;\n  last_transaction_timestamp?: InputMaybe<OrderBy>;\n  last_transaction_version?: InputMaybe<OrderBy>;\n  name?: InputMaybe<OrderBy>;\n  property_version?: InputMaybe<OrderBy>;\n  table_handle?: InputMaybe<OrderBy>;\n  to_address?: InputMaybe<OrderBy>;\n  token_data_id?: InputMaybe<OrderBy>;\n  token_data_id_hash?: InputMaybe<OrderBy>;\n};\n\n/** primary key columns input for table: current_token_pending_claims */\nexport type CurrentTokenPendingClaimsPkColumnsInput = {\n  from_address: Scalars[\"String\"][\"input\"];\n  property_version: Scalars[\"numeric\"][\"input\"];\n  to_address: Scalars[\"String\"][\"input\"];\n  token_data_id_hash: Scalars[\"String\"][\"input\"];\n};\n\n/** select columns of table \"current_token_pending_claims\" */\nexport enum CurrentTokenPendingClaimsSelectColumn {\n  /** column name */\n  Amount = \"amount\",\n  /** column name */\n  CollectionDataIdHash = \"collection_data_id_hash\",\n  /** column name */\n  CollectionId = \"collection_id\",\n  /** column name */\n  CollectionName = \"collection_name\",\n  /** column name */\n  CreatorAddress = \"creator_address\",\n  /** column name */\n  FromAddress = \"from_address\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  LastTransactionTimestamp = \"last_transaction_timestamp\",\n  /** column name */\n  LastTransactionVersion = \"last_transaction_version\",\n  /** column name */\n  Name = \"name\",\n  /** column name */\n  PropertyVersion = \"property_version\",\n  /** column name */\n  TableHandle = \"table_handle\",\n  /** column name */\n  ToAddress = \"to_address\",\n  /** column name */\n  TokenDataId = \"token_data_id\",\n  /** column name */\n  TokenDataIdHash = \"token_data_id_hash\",\n}\n\n/** input type for updating data in table \"current_token_pending_claims\" */\nexport type CurrentTokenPendingClaimsSetInput = {\n  amount?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  collection_data_id_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  collection_id?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  collection_name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  creator_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  from_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  last_transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  property_version?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  table_handle?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  to_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_data_id?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_data_id_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate stddev on columns */\nexport type CurrentTokenPendingClaimsStddevFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  property_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_pop on columns */\nexport type CurrentTokenPendingClaimsStddevPopFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  property_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_samp on columns */\nexport type CurrentTokenPendingClaimsStddevSampFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  property_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Streaming cursor of the table \"current_token_pending_claims\" */\nexport type CurrentTokenPendingClaimsStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: CurrentTokenPendingClaimsStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type CurrentTokenPendingClaimsStreamCursorValueInput = {\n  amount?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  collection_data_id_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  collection_id?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  collection_name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  creator_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  from_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  last_transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  property_version?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  table_handle?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  to_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_data_id?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_data_id_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate sum on columns */\nexport type CurrentTokenPendingClaimsSumFields = {\n  amount?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  property_version?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n};\n\n/** update columns of table \"current_token_pending_claims\" */\nexport enum CurrentTokenPendingClaimsUpdateColumn {\n  /** column name */\n  Amount = \"amount\",\n  /** column name */\n  CollectionDataIdHash = \"collection_data_id_hash\",\n  /** column name */\n  CollectionId = \"collection_id\",\n  /** column name */\n  CollectionName = \"collection_name\",\n  /** column name */\n  CreatorAddress = \"creator_address\",\n  /** column name */\n  FromAddress = \"from_address\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  LastTransactionTimestamp = \"last_transaction_timestamp\",\n  /** column name */\n  LastTransactionVersion = \"last_transaction_version\",\n  /** column name */\n  Name = \"name\",\n  /** column name */\n  PropertyVersion = \"property_version\",\n  /** column name */\n  TableHandle = \"table_handle\",\n  /** column name */\n  ToAddress = \"to_address\",\n  /** column name */\n  TokenDataId = \"token_data_id\",\n  /** column name */\n  TokenDataIdHash = \"token_data_id_hash\",\n}\n\nexport type CurrentTokenPendingClaimsUpdates = {\n  /** increments the numeric columns with given value of the filtered values */\n  _inc?: InputMaybe<CurrentTokenPendingClaimsIncInput>;\n  /** sets the columns of the filtered rows to the given values */\n  _set?: InputMaybe<CurrentTokenPendingClaimsSetInput>;\n  /** filter the rows which have to be updated */\n  where: CurrentTokenPendingClaimsBoolExp;\n};\n\n/** aggregate var_pop on columns */\nexport type CurrentTokenPendingClaimsVarPopFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  property_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate var_samp on columns */\nexport type CurrentTokenPendingClaimsVarSampFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  property_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate variance on columns */\nexport type CurrentTokenPendingClaimsVarianceFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  property_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** columns and relationships of \"current_token_royalty_v1\" */\nexport type CurrentTokenRoyaltyV1 = {\n  inserted_at: Scalars[\"timestamp\"][\"output\"];\n  last_transaction_timestamp: Scalars[\"timestamp\"][\"output\"];\n  last_transaction_version: Scalars[\"bigint\"][\"output\"];\n  payee_address: Scalars[\"String\"][\"output\"];\n  royalty_points_denominator: Scalars[\"numeric\"][\"output\"];\n  royalty_points_numerator: Scalars[\"numeric\"][\"output\"];\n  token_data_id: Scalars[\"String\"][\"output\"];\n};\n\n/** aggregated selection of \"current_token_royalty_v1\" */\nexport type CurrentTokenRoyaltyV1Aggregate = {\n  aggregate?: Maybe<CurrentTokenRoyaltyV1AggregateFields>;\n  nodes: Array<CurrentTokenRoyaltyV1>;\n};\n\n/** aggregate fields of \"current_token_royalty_v1\" */\nexport type CurrentTokenRoyaltyV1AggregateFields = {\n  avg?: Maybe<CurrentTokenRoyaltyV1AvgFields>;\n  count: Scalars[\"Int\"][\"output\"];\n  max?: Maybe<CurrentTokenRoyaltyV1MaxFields>;\n  min?: Maybe<CurrentTokenRoyaltyV1MinFields>;\n  stddev?: Maybe<CurrentTokenRoyaltyV1StddevFields>;\n  stddev_pop?: Maybe<CurrentTokenRoyaltyV1StddevPopFields>;\n  stddev_samp?: Maybe<CurrentTokenRoyaltyV1StddevSampFields>;\n  sum?: Maybe<CurrentTokenRoyaltyV1SumFields>;\n  var_pop?: Maybe<CurrentTokenRoyaltyV1VarPopFields>;\n  var_samp?: Maybe<CurrentTokenRoyaltyV1VarSampFields>;\n  variance?: Maybe<CurrentTokenRoyaltyV1VarianceFields>;\n};\n\n/** aggregate fields of \"current_token_royalty_v1\" */\nexport type CurrentTokenRoyaltyV1AggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<CurrentTokenRoyaltyV1SelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** aggregate avg on columns */\nexport type CurrentTokenRoyaltyV1AvgFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  royalty_points_denominator?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  royalty_points_numerator?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Boolean expression to filter rows from the table \"current_token_royalty_v1\". All fields are combined with a logical 'AND'. */\nexport type CurrentTokenRoyaltyV1BoolExp = {\n  _and?: InputMaybe<Array<CurrentTokenRoyaltyV1BoolExp>>;\n  _not?: InputMaybe<CurrentTokenRoyaltyV1BoolExp>;\n  _or?: InputMaybe<Array<CurrentTokenRoyaltyV1BoolExp>>;\n  inserted_at?: InputMaybe<TimestampComparisonExp>;\n  last_transaction_timestamp?: InputMaybe<TimestampComparisonExp>;\n  last_transaction_version?: InputMaybe<BigintComparisonExp>;\n  payee_address?: InputMaybe<StringComparisonExp>;\n  royalty_points_denominator?: InputMaybe<NumericComparisonExp>;\n  royalty_points_numerator?: InputMaybe<NumericComparisonExp>;\n  token_data_id?: InputMaybe<StringComparisonExp>;\n};\n\n/** unique or primary key constraints on table \"current_token_royalty_v1\" */\nexport enum CurrentTokenRoyaltyV1Constraint {\n  /** unique or primary key constraint on columns \"token_data_id\" */\n  CurrentTokenRoyaltyV1Pkey = \"current_token_royalty_v1_pkey\",\n}\n\n/** input type for incrementing numeric columns in table \"current_token_royalty_v1\" */\nexport type CurrentTokenRoyaltyV1IncInput = {\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  royalty_points_denominator?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  royalty_points_numerator?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n};\n\n/** input type for inserting data into table \"current_token_royalty_v1\" */\nexport type CurrentTokenRoyaltyV1InsertInput = {\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  last_transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  payee_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  royalty_points_denominator?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  royalty_points_numerator?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  token_data_id?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate max on columns */\nexport type CurrentTokenRoyaltyV1MaxFields = {\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  last_transaction_timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  payee_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  royalty_points_denominator?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  royalty_points_numerator?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  token_data_id?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** aggregate min on columns */\nexport type CurrentTokenRoyaltyV1MinFields = {\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  last_transaction_timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  payee_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  royalty_points_denominator?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  royalty_points_numerator?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  token_data_id?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** response of any mutation on the table \"current_token_royalty_v1\" */\nexport type CurrentTokenRoyaltyV1MutationResponse = {\n  /** number of rows affected by the mutation */\n  affected_rows: Scalars[\"Int\"][\"output\"];\n  /** data from the rows affected by the mutation */\n  returning: Array<CurrentTokenRoyaltyV1>;\n};\n\n/** input type for inserting object relation for remote table \"current_token_royalty_v1\" */\nexport type CurrentTokenRoyaltyV1ObjRelInsertInput = {\n  data: CurrentTokenRoyaltyV1InsertInput;\n  /** upsert condition */\n  on_conflict?: InputMaybe<CurrentTokenRoyaltyV1OnConflict>;\n};\n\n/** on_conflict condition type for table \"current_token_royalty_v1\" */\nexport type CurrentTokenRoyaltyV1OnConflict = {\n  constraint: CurrentTokenRoyaltyV1Constraint;\n  update_columns?: Array<CurrentTokenRoyaltyV1UpdateColumn>;\n  where?: InputMaybe<CurrentTokenRoyaltyV1BoolExp>;\n};\n\n/** Ordering options when selecting data from \"current_token_royalty_v1\". */\nexport type CurrentTokenRoyaltyV1OrderBy = {\n  inserted_at?: InputMaybe<OrderBy>;\n  last_transaction_timestamp?: InputMaybe<OrderBy>;\n  last_transaction_version?: InputMaybe<OrderBy>;\n  payee_address?: InputMaybe<OrderBy>;\n  royalty_points_denominator?: InputMaybe<OrderBy>;\n  royalty_points_numerator?: InputMaybe<OrderBy>;\n  token_data_id?: InputMaybe<OrderBy>;\n};\n\n/** primary key columns input for table: current_token_royalty_v1 */\nexport type CurrentTokenRoyaltyV1PkColumnsInput = {\n  token_data_id: Scalars[\"String\"][\"input\"];\n};\n\n/** select columns of table \"current_token_royalty_v1\" */\nexport enum CurrentTokenRoyaltyV1SelectColumn {\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  LastTransactionTimestamp = \"last_transaction_timestamp\",\n  /** column name */\n  LastTransactionVersion = \"last_transaction_version\",\n  /** column name */\n  PayeeAddress = \"payee_address\",\n  /** column name */\n  RoyaltyPointsDenominator = \"royalty_points_denominator\",\n  /** column name */\n  RoyaltyPointsNumerator = \"royalty_points_numerator\",\n  /** column name */\n  TokenDataId = \"token_data_id\",\n}\n\n/** input type for updating data in table \"current_token_royalty_v1\" */\nexport type CurrentTokenRoyaltyV1SetInput = {\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  last_transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  payee_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  royalty_points_denominator?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  royalty_points_numerator?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  token_data_id?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate stddev on columns */\nexport type CurrentTokenRoyaltyV1StddevFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  royalty_points_denominator?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  royalty_points_numerator?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_pop on columns */\nexport type CurrentTokenRoyaltyV1StddevPopFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  royalty_points_denominator?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  royalty_points_numerator?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_samp on columns */\nexport type CurrentTokenRoyaltyV1StddevSampFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  royalty_points_denominator?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  royalty_points_numerator?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Streaming cursor of the table \"current_token_royalty_v1\" */\nexport type CurrentTokenRoyaltyV1StreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: CurrentTokenRoyaltyV1StreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type CurrentTokenRoyaltyV1StreamCursorValueInput = {\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  last_transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  payee_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  royalty_points_denominator?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  royalty_points_numerator?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  token_data_id?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate sum on columns */\nexport type CurrentTokenRoyaltyV1SumFields = {\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  royalty_points_denominator?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  royalty_points_numerator?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n};\n\n/** update columns of table \"current_token_royalty_v1\" */\nexport enum CurrentTokenRoyaltyV1UpdateColumn {\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  LastTransactionTimestamp = \"last_transaction_timestamp\",\n  /** column name */\n  LastTransactionVersion = \"last_transaction_version\",\n  /** column name */\n  PayeeAddress = \"payee_address\",\n  /** column name */\n  RoyaltyPointsDenominator = \"royalty_points_denominator\",\n  /** column name */\n  RoyaltyPointsNumerator = \"royalty_points_numerator\",\n  /** column name */\n  TokenDataId = \"token_data_id\",\n}\n\nexport type CurrentTokenRoyaltyV1Updates = {\n  /** increments the numeric columns with given value of the filtered values */\n  _inc?: InputMaybe<CurrentTokenRoyaltyV1IncInput>;\n  /** sets the columns of the filtered rows to the given values */\n  _set?: InputMaybe<CurrentTokenRoyaltyV1SetInput>;\n  /** filter the rows which have to be updated */\n  where: CurrentTokenRoyaltyV1BoolExp;\n};\n\n/** aggregate var_pop on columns */\nexport type CurrentTokenRoyaltyV1VarPopFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  royalty_points_denominator?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  royalty_points_numerator?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate var_samp on columns */\nexport type CurrentTokenRoyaltyV1VarSampFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  royalty_points_denominator?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  royalty_points_numerator?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate variance on columns */\nexport type CurrentTokenRoyaltyV1VarianceFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  royalty_points_denominator?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  royalty_points_numerator?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** columns and relationships of \"current_token_v2_metadata\" */\nexport type CurrentTokenV2Metadata = {\n  data: Scalars[\"jsonb\"][\"output\"];\n  inserted_at: Scalars[\"timestamp\"][\"output\"];\n  last_transaction_version: Scalars[\"bigint\"][\"output\"];\n  object_address: Scalars[\"String\"][\"output\"];\n  resource_type: Scalars[\"String\"][\"output\"];\n  state_key_hash: Scalars[\"String\"][\"output\"];\n};\n\n/** columns and relationships of \"current_token_v2_metadata\" */\nexport type CurrentTokenV2MetadataDataArgs = {\n  path?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregated selection of \"current_token_v2_metadata\" */\nexport type CurrentTokenV2MetadataAggregate = {\n  aggregate?: Maybe<CurrentTokenV2MetadataAggregateFields>;\n  nodes: Array<CurrentTokenV2Metadata>;\n};\n\n/** aggregate fields of \"current_token_v2_metadata\" */\nexport type CurrentTokenV2MetadataAggregateFields = {\n  avg?: Maybe<CurrentTokenV2MetadataAvgFields>;\n  count: Scalars[\"Int\"][\"output\"];\n  max?: Maybe<CurrentTokenV2MetadataMaxFields>;\n  min?: Maybe<CurrentTokenV2MetadataMinFields>;\n  stddev?: Maybe<CurrentTokenV2MetadataStddevFields>;\n  stddev_pop?: Maybe<CurrentTokenV2MetadataStddevPopFields>;\n  stddev_samp?: Maybe<CurrentTokenV2MetadataStddevSampFields>;\n  sum?: Maybe<CurrentTokenV2MetadataSumFields>;\n  var_pop?: Maybe<CurrentTokenV2MetadataVarPopFields>;\n  var_samp?: Maybe<CurrentTokenV2MetadataVarSampFields>;\n  variance?: Maybe<CurrentTokenV2MetadataVarianceFields>;\n};\n\n/** aggregate fields of \"current_token_v2_metadata\" */\nexport type CurrentTokenV2MetadataAggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<CurrentTokenV2MetadataSelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** append existing jsonb value of filtered columns with new jsonb value */\nexport type CurrentTokenV2MetadataAppendInput = {\n  data?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n};\n\n/** aggregate avg on columns */\nexport type CurrentTokenV2MetadataAvgFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Boolean expression to filter rows from the table \"current_token_v2_metadata\". All fields are combined with a logical 'AND'. */\nexport type CurrentTokenV2MetadataBoolExp = {\n  _and?: InputMaybe<Array<CurrentTokenV2MetadataBoolExp>>;\n  _not?: InputMaybe<CurrentTokenV2MetadataBoolExp>;\n  _or?: InputMaybe<Array<CurrentTokenV2MetadataBoolExp>>;\n  data?: InputMaybe<JsonbComparisonExp>;\n  inserted_at?: InputMaybe<TimestampComparisonExp>;\n  last_transaction_version?: InputMaybe<BigintComparisonExp>;\n  object_address?: InputMaybe<StringComparisonExp>;\n  resource_type?: InputMaybe<StringComparisonExp>;\n  state_key_hash?: InputMaybe<StringComparisonExp>;\n};\n\n/** unique or primary key constraints on table \"current_token_v2_metadata\" */\nexport enum CurrentTokenV2MetadataConstraint {\n  /** unique or primary key constraint on columns \"object_address\", \"resource_type\" */\n  CurrentTokenV2MetadataPkey = \"current_token_v2_metadata_pkey\",\n}\n\n/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */\nexport type CurrentTokenV2MetadataDeleteAtPathInput = {\n  data?: InputMaybe<Array<Scalars[\"String\"][\"input\"]>>;\n};\n\n/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */\nexport type CurrentTokenV2MetadataDeleteElemInput = {\n  data?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n};\n\n/** delete key/value pair or string element. key/value pairs are matched based on their key value */\nexport type CurrentTokenV2MetadataDeleteKeyInput = {\n  data?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** input type for incrementing numeric columns in table \"current_token_v2_metadata\" */\nexport type CurrentTokenV2MetadataIncInput = {\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** input type for inserting data into table \"current_token_v2_metadata\" */\nexport type CurrentTokenV2MetadataInsertInput = {\n  data?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  object_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  resource_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  state_key_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate max on columns */\nexport type CurrentTokenV2MetadataMaxFields = {\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  object_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  resource_type?: Maybe<Scalars[\"String\"][\"output\"]>;\n  state_key_hash?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** aggregate min on columns */\nexport type CurrentTokenV2MetadataMinFields = {\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  object_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  resource_type?: Maybe<Scalars[\"String\"][\"output\"]>;\n  state_key_hash?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** response of any mutation on the table \"current_token_v2_metadata\" */\nexport type CurrentTokenV2MetadataMutationResponse = {\n  /** number of rows affected by the mutation */\n  affected_rows: Scalars[\"Int\"][\"output\"];\n  /** data from the rows affected by the mutation */\n  returning: Array<CurrentTokenV2Metadata>;\n};\n\n/** on_conflict condition type for table \"current_token_v2_metadata\" */\nexport type CurrentTokenV2MetadataOnConflict = {\n  constraint: CurrentTokenV2MetadataConstraint;\n  update_columns?: Array<CurrentTokenV2MetadataUpdateColumn>;\n  where?: InputMaybe<CurrentTokenV2MetadataBoolExp>;\n};\n\n/** Ordering options when selecting data from \"current_token_v2_metadata\". */\nexport type CurrentTokenV2MetadataOrderBy = {\n  data?: InputMaybe<OrderBy>;\n  inserted_at?: InputMaybe<OrderBy>;\n  last_transaction_version?: InputMaybe<OrderBy>;\n  object_address?: InputMaybe<OrderBy>;\n  resource_type?: InputMaybe<OrderBy>;\n  state_key_hash?: InputMaybe<OrderBy>;\n};\n\n/** primary key columns input for table: current_token_v2_metadata */\nexport type CurrentTokenV2MetadataPkColumnsInput = {\n  object_address: Scalars[\"String\"][\"input\"];\n  resource_type: Scalars[\"String\"][\"input\"];\n};\n\n/** prepend existing jsonb value of filtered columns with new jsonb value */\nexport type CurrentTokenV2MetadataPrependInput = {\n  data?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n};\n\n/** select columns of table \"current_token_v2_metadata\" */\nexport enum CurrentTokenV2MetadataSelectColumn {\n  /** column name */\n  Data = \"data\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  LastTransactionVersion = \"last_transaction_version\",\n  /** column name */\n  ObjectAddress = \"object_address\",\n  /** column name */\n  ResourceType = \"resource_type\",\n  /** column name */\n  StateKeyHash = \"state_key_hash\",\n}\n\n/** input type for updating data in table \"current_token_v2_metadata\" */\nexport type CurrentTokenV2MetadataSetInput = {\n  data?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  object_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  resource_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  state_key_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate stddev on columns */\nexport type CurrentTokenV2MetadataStddevFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_pop on columns */\nexport type CurrentTokenV2MetadataStddevPopFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_samp on columns */\nexport type CurrentTokenV2MetadataStddevSampFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Streaming cursor of the table \"current_token_v2_metadata\" */\nexport type CurrentTokenV2MetadataStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: CurrentTokenV2MetadataStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type CurrentTokenV2MetadataStreamCursorValueInput = {\n  data?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  object_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  resource_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  state_key_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate sum on columns */\nexport type CurrentTokenV2MetadataSumFields = {\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** update columns of table \"current_token_v2_metadata\" */\nexport enum CurrentTokenV2MetadataUpdateColumn {\n  /** column name */\n  Data = \"data\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  LastTransactionVersion = \"last_transaction_version\",\n  /** column name */\n  ObjectAddress = \"object_address\",\n  /** column name */\n  ResourceType = \"resource_type\",\n  /** column name */\n  StateKeyHash = \"state_key_hash\",\n}\n\nexport type CurrentTokenV2MetadataUpdates = {\n  /** append existing jsonb value of filtered columns with new jsonb value */\n  _append?: InputMaybe<CurrentTokenV2MetadataAppendInput>;\n  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */\n  _delete_at_path?: InputMaybe<CurrentTokenV2MetadataDeleteAtPathInput>;\n  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */\n  _delete_elem?: InputMaybe<CurrentTokenV2MetadataDeleteElemInput>;\n  /** delete key/value pair or string element. key/value pairs are matched based on their key value */\n  _delete_key?: InputMaybe<CurrentTokenV2MetadataDeleteKeyInput>;\n  /** increments the numeric columns with given value of the filtered values */\n  _inc?: InputMaybe<CurrentTokenV2MetadataIncInput>;\n  /** prepend existing jsonb value of filtered columns with new jsonb value */\n  _prepend?: InputMaybe<CurrentTokenV2MetadataPrependInput>;\n  /** sets the columns of the filtered rows to the given values */\n  _set?: InputMaybe<CurrentTokenV2MetadataSetInput>;\n  /** filter the rows which have to be updated */\n  where: CurrentTokenV2MetadataBoolExp;\n};\n\n/** aggregate var_pop on columns */\nexport type CurrentTokenV2MetadataVarPopFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate var_samp on columns */\nexport type CurrentTokenV2MetadataVarSampFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate variance on columns */\nexport type CurrentTokenV2MetadataVarianceFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** ordering argument of a cursor */\nexport enum CursorOrdering {\n  /** ascending ordering of the cursor */\n  Asc = \"ASC\",\n  /** descending ordering of the cursor */\n  Desc = \"DESC\",\n}\n\n/** columns and relationships of \"delegated_staking_activities\" */\nexport type DelegatedStakingActivities = {\n  amount: Scalars[\"numeric\"][\"output\"];\n  delegator_address: Scalars[\"String\"][\"output\"];\n  event_index: Scalars[\"bigint\"][\"output\"];\n  event_type: Scalars[\"String\"][\"output\"];\n  inserted_at: Scalars[\"timestamp\"][\"output\"];\n  pool_address: Scalars[\"String\"][\"output\"];\n  transaction_version: Scalars[\"bigint\"][\"output\"];\n};\n\n/** aggregated selection of \"delegated_staking_activities\" */\nexport type DelegatedStakingActivitiesAggregate = {\n  aggregate?: Maybe<DelegatedStakingActivitiesAggregateFields>;\n  nodes: Array<DelegatedStakingActivities>;\n};\n\nexport type DelegatedStakingActivitiesAggregateBoolExp = {\n  count?: InputMaybe<DelegatedStakingActivitiesAggregateBoolExpCount>;\n};\n\nexport type DelegatedStakingActivitiesAggregateBoolExpCount = {\n  arguments?: InputMaybe<Array<DelegatedStakingActivitiesSelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  filter?: InputMaybe<DelegatedStakingActivitiesBoolExp>;\n  predicate: IntComparisonExp;\n};\n\n/** aggregate fields of \"delegated_staking_activities\" */\nexport type DelegatedStakingActivitiesAggregateFields = {\n  avg?: Maybe<DelegatedStakingActivitiesAvgFields>;\n  count: Scalars[\"Int\"][\"output\"];\n  max?: Maybe<DelegatedStakingActivitiesMaxFields>;\n  min?: Maybe<DelegatedStakingActivitiesMinFields>;\n  stddev?: Maybe<DelegatedStakingActivitiesStddevFields>;\n  stddev_pop?: Maybe<DelegatedStakingActivitiesStddevPopFields>;\n  stddev_samp?: Maybe<DelegatedStakingActivitiesStddevSampFields>;\n  sum?: Maybe<DelegatedStakingActivitiesSumFields>;\n  var_pop?: Maybe<DelegatedStakingActivitiesVarPopFields>;\n  var_samp?: Maybe<DelegatedStakingActivitiesVarSampFields>;\n  variance?: Maybe<DelegatedStakingActivitiesVarianceFields>;\n};\n\n/** aggregate fields of \"delegated_staking_activities\" */\nexport type DelegatedStakingActivitiesAggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<DelegatedStakingActivitiesSelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** order by aggregate values of table \"delegated_staking_activities\" */\nexport type DelegatedStakingActivitiesAggregateOrderBy = {\n  avg?: InputMaybe<DelegatedStakingActivitiesAvgOrderBy>;\n  count?: InputMaybe<OrderBy>;\n  max?: InputMaybe<DelegatedStakingActivitiesMaxOrderBy>;\n  min?: InputMaybe<DelegatedStakingActivitiesMinOrderBy>;\n  stddev?: InputMaybe<DelegatedStakingActivitiesStddevOrderBy>;\n  stddev_pop?: InputMaybe<DelegatedStakingActivitiesStddevPopOrderBy>;\n  stddev_samp?: InputMaybe<DelegatedStakingActivitiesStddevSampOrderBy>;\n  sum?: InputMaybe<DelegatedStakingActivitiesSumOrderBy>;\n  var_pop?: InputMaybe<DelegatedStakingActivitiesVarPopOrderBy>;\n  var_samp?: InputMaybe<DelegatedStakingActivitiesVarSampOrderBy>;\n  variance?: InputMaybe<DelegatedStakingActivitiesVarianceOrderBy>;\n};\n\n/** input type for inserting array relation for remote table \"delegated_staking_activities\" */\nexport type DelegatedStakingActivitiesArrRelInsertInput = {\n  data: Array<DelegatedStakingActivitiesInsertInput>;\n  /** upsert condition */\n  on_conflict?: InputMaybe<DelegatedStakingActivitiesOnConflict>;\n};\n\n/** aggregate avg on columns */\nexport type DelegatedStakingActivitiesAvgFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  event_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** order by avg() on columns of table \"delegated_staking_activities\" */\nexport type DelegatedStakingActivitiesAvgOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  event_index?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n};\n\n/** Boolean expression to filter rows from the table \"delegated_staking_activities\". All fields are combined with a logical 'AND'. */\nexport type DelegatedStakingActivitiesBoolExp = {\n  _and?: InputMaybe<Array<DelegatedStakingActivitiesBoolExp>>;\n  _not?: InputMaybe<DelegatedStakingActivitiesBoolExp>;\n  _or?: InputMaybe<Array<DelegatedStakingActivitiesBoolExp>>;\n  amount?: InputMaybe<NumericComparisonExp>;\n  delegator_address?: InputMaybe<StringComparisonExp>;\n  event_index?: InputMaybe<BigintComparisonExp>;\n  event_type?: InputMaybe<StringComparisonExp>;\n  inserted_at?: InputMaybe<TimestampComparisonExp>;\n  pool_address?: InputMaybe<StringComparisonExp>;\n  transaction_version?: InputMaybe<BigintComparisonExp>;\n};\n\n/** unique or primary key constraints on table \"delegated_staking_activities\" */\nexport enum DelegatedStakingActivitiesConstraint {\n  /** unique or primary key constraint on columns \"event_index\", \"transaction_version\" */\n  DelegatedStakingActivitiesPkey = \"delegated_staking_activities_pkey\",\n}\n\n/** input type for incrementing numeric columns in table \"delegated_staking_activities\" */\nexport type DelegatedStakingActivitiesIncInput = {\n  amount?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  event_index?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** input type for inserting data into table \"delegated_staking_activities\" */\nexport type DelegatedStakingActivitiesInsertInput = {\n  amount?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  delegator_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  event_index?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  event_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  pool_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** aggregate max on columns */\nexport type DelegatedStakingActivitiesMaxFields = {\n  amount?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  delegator_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  event_index?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  event_type?: Maybe<Scalars[\"String\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  pool_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** order by max() on columns of table \"delegated_staking_activities\" */\nexport type DelegatedStakingActivitiesMaxOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  delegator_address?: InputMaybe<OrderBy>;\n  event_index?: InputMaybe<OrderBy>;\n  event_type?: InputMaybe<OrderBy>;\n  inserted_at?: InputMaybe<OrderBy>;\n  pool_address?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n};\n\n/** aggregate min on columns */\nexport type DelegatedStakingActivitiesMinFields = {\n  amount?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  delegator_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  event_index?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  event_type?: Maybe<Scalars[\"String\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  pool_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** order by min() on columns of table \"delegated_staking_activities\" */\nexport type DelegatedStakingActivitiesMinOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  delegator_address?: InputMaybe<OrderBy>;\n  event_index?: InputMaybe<OrderBy>;\n  event_type?: InputMaybe<OrderBy>;\n  inserted_at?: InputMaybe<OrderBy>;\n  pool_address?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n};\n\n/** response of any mutation on the table \"delegated_staking_activities\" */\nexport type DelegatedStakingActivitiesMutationResponse = {\n  /** number of rows affected by the mutation */\n  affected_rows: Scalars[\"Int\"][\"output\"];\n  /** data from the rows affected by the mutation */\n  returning: Array<DelegatedStakingActivities>;\n};\n\n/** on_conflict condition type for table \"delegated_staking_activities\" */\nexport type DelegatedStakingActivitiesOnConflict = {\n  constraint: DelegatedStakingActivitiesConstraint;\n  update_columns?: Array<DelegatedStakingActivitiesUpdateColumn>;\n  where?: InputMaybe<DelegatedStakingActivitiesBoolExp>;\n};\n\n/** Ordering options when selecting data from \"delegated_staking_activities\". */\nexport type DelegatedStakingActivitiesOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  delegator_address?: InputMaybe<OrderBy>;\n  event_index?: InputMaybe<OrderBy>;\n  event_type?: InputMaybe<OrderBy>;\n  inserted_at?: InputMaybe<OrderBy>;\n  pool_address?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n};\n\n/** primary key columns input for table: delegated_staking_activities */\nexport type DelegatedStakingActivitiesPkColumnsInput = {\n  event_index: Scalars[\"bigint\"][\"input\"];\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\n/** select columns of table \"delegated_staking_activities\" */\nexport enum DelegatedStakingActivitiesSelectColumn {\n  /** column name */\n  Amount = \"amount\",\n  /** column name */\n  DelegatorAddress = \"delegator_address\",\n  /** column name */\n  EventIndex = \"event_index\",\n  /** column name */\n  EventType = \"event_type\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  PoolAddress = \"pool_address\",\n  /** column name */\n  TransactionVersion = \"transaction_version\",\n}\n\n/** input type for updating data in table \"delegated_staking_activities\" */\nexport type DelegatedStakingActivitiesSetInput = {\n  amount?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  delegator_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  event_index?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  event_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  pool_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** aggregate stddev on columns */\nexport type DelegatedStakingActivitiesStddevFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  event_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** order by stddev() on columns of table \"delegated_staking_activities\" */\nexport type DelegatedStakingActivitiesStddevOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  event_index?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n};\n\n/** aggregate stddev_pop on columns */\nexport type DelegatedStakingActivitiesStddevPopFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  event_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** order by stddev_pop() on columns of table \"delegated_staking_activities\" */\nexport type DelegatedStakingActivitiesStddevPopOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  event_index?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n};\n\n/** aggregate stddev_samp on columns */\nexport type DelegatedStakingActivitiesStddevSampFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  event_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** order by stddev_samp() on columns of table \"delegated_staking_activities\" */\nexport type DelegatedStakingActivitiesStddevSampOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  event_index?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n};\n\n/** Streaming cursor of the table \"delegated_staking_activities\" */\nexport type DelegatedStakingActivitiesStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: DelegatedStakingActivitiesStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type DelegatedStakingActivitiesStreamCursorValueInput = {\n  amount?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  delegator_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  event_index?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  event_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  pool_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** aggregate sum on columns */\nexport type DelegatedStakingActivitiesSumFields = {\n  amount?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  event_index?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** order by sum() on columns of table \"delegated_staking_activities\" */\nexport type DelegatedStakingActivitiesSumOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  event_index?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n};\n\n/** update columns of table \"delegated_staking_activities\" */\nexport enum DelegatedStakingActivitiesUpdateColumn {\n  /** column name */\n  Amount = \"amount\",\n  /** column name */\n  DelegatorAddress = \"delegator_address\",\n  /** column name */\n  EventIndex = \"event_index\",\n  /** column name */\n  EventType = \"event_type\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  PoolAddress = \"pool_address\",\n  /** column name */\n  TransactionVersion = \"transaction_version\",\n}\n\nexport type DelegatedStakingActivitiesUpdates = {\n  /** increments the numeric columns with given value of the filtered values */\n  _inc?: InputMaybe<DelegatedStakingActivitiesIncInput>;\n  /** sets the columns of the filtered rows to the given values */\n  _set?: InputMaybe<DelegatedStakingActivitiesSetInput>;\n  /** filter the rows which have to be updated */\n  where: DelegatedStakingActivitiesBoolExp;\n};\n\n/** aggregate var_pop on columns */\nexport type DelegatedStakingActivitiesVarPopFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  event_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** order by var_pop() on columns of table \"delegated_staking_activities\" */\nexport type DelegatedStakingActivitiesVarPopOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  event_index?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n};\n\n/** aggregate var_samp on columns */\nexport type DelegatedStakingActivitiesVarSampFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  event_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** order by var_samp() on columns of table \"delegated_staking_activities\" */\nexport type DelegatedStakingActivitiesVarSampOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  event_index?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n};\n\n/** aggregate variance on columns */\nexport type DelegatedStakingActivitiesVarianceFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  event_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** order by variance() on columns of table \"delegated_staking_activities\" */\nexport type DelegatedStakingActivitiesVarianceOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  event_index?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n};\n\n/** columns and relationships of \"delegated_staking_pool_balances\" */\nexport type DelegatedStakingPoolBalances = {\n  active_table_handle: Scalars[\"String\"][\"output\"];\n  inactive_table_handle: Scalars[\"String\"][\"output\"];\n  inserted_at: Scalars[\"timestamp\"][\"output\"];\n  operator_commission_percentage: Scalars[\"numeric\"][\"output\"];\n  staking_pool_address: Scalars[\"String\"][\"output\"];\n  total_coins: Scalars[\"numeric\"][\"output\"];\n  total_shares: Scalars[\"numeric\"][\"output\"];\n  transaction_version: Scalars[\"bigint\"][\"output\"];\n};\n\n/** aggregated selection of \"delegated_staking_pool_balances\" */\nexport type DelegatedStakingPoolBalancesAggregate = {\n  aggregate?: Maybe<DelegatedStakingPoolBalancesAggregateFields>;\n  nodes: Array<DelegatedStakingPoolBalances>;\n};\n\n/** aggregate fields of \"delegated_staking_pool_balances\" */\nexport type DelegatedStakingPoolBalancesAggregateFields = {\n  avg?: Maybe<DelegatedStakingPoolBalancesAvgFields>;\n  count: Scalars[\"Int\"][\"output\"];\n  max?: Maybe<DelegatedStakingPoolBalancesMaxFields>;\n  min?: Maybe<DelegatedStakingPoolBalancesMinFields>;\n  stddev?: Maybe<DelegatedStakingPoolBalancesStddevFields>;\n  stddev_pop?: Maybe<DelegatedStakingPoolBalancesStddevPopFields>;\n  stddev_samp?: Maybe<DelegatedStakingPoolBalancesStddevSampFields>;\n  sum?: Maybe<DelegatedStakingPoolBalancesSumFields>;\n  var_pop?: Maybe<DelegatedStakingPoolBalancesVarPopFields>;\n  var_samp?: Maybe<DelegatedStakingPoolBalancesVarSampFields>;\n  variance?: Maybe<DelegatedStakingPoolBalancesVarianceFields>;\n};\n\n/** aggregate fields of \"delegated_staking_pool_balances\" */\nexport type DelegatedStakingPoolBalancesAggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<DelegatedStakingPoolBalancesSelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** aggregate avg on columns */\nexport type DelegatedStakingPoolBalancesAvgFields = {\n  operator_commission_percentage?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  total_coins?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  total_shares?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Boolean expression to filter rows from the table \"delegated_staking_pool_balances\". All fields are combined with a logical 'AND'. */\nexport type DelegatedStakingPoolBalancesBoolExp = {\n  _and?: InputMaybe<Array<DelegatedStakingPoolBalancesBoolExp>>;\n  _not?: InputMaybe<DelegatedStakingPoolBalancesBoolExp>;\n  _or?: InputMaybe<Array<DelegatedStakingPoolBalancesBoolExp>>;\n  active_table_handle?: InputMaybe<StringComparisonExp>;\n  inactive_table_handle?: InputMaybe<StringComparisonExp>;\n  inserted_at?: InputMaybe<TimestampComparisonExp>;\n  operator_commission_percentage?: InputMaybe<NumericComparisonExp>;\n  staking_pool_address?: InputMaybe<StringComparisonExp>;\n  total_coins?: InputMaybe<NumericComparisonExp>;\n  total_shares?: InputMaybe<NumericComparisonExp>;\n  transaction_version?: InputMaybe<BigintComparisonExp>;\n};\n\n/** unique or primary key constraints on table \"delegated_staking_pool_balances\" */\nexport enum DelegatedStakingPoolBalancesConstraint {\n  /** unique or primary key constraint on columns \"staking_pool_address\", \"transaction_version\" */\n  DelegatedStakingPoolBalancesPkey = \"delegated_staking_pool_balances_pkey\",\n}\n\n/** input type for incrementing numeric columns in table \"delegated_staking_pool_balances\" */\nexport type DelegatedStakingPoolBalancesIncInput = {\n  operator_commission_percentage?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  total_coins?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  total_shares?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** input type for inserting data into table \"delegated_staking_pool_balances\" */\nexport type DelegatedStakingPoolBalancesInsertInput = {\n  active_table_handle?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inactive_table_handle?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  operator_commission_percentage?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  staking_pool_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  total_coins?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  total_shares?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** aggregate max on columns */\nexport type DelegatedStakingPoolBalancesMaxFields = {\n  active_table_handle?: Maybe<Scalars[\"String\"][\"output\"]>;\n  inactive_table_handle?: Maybe<Scalars[\"String\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  operator_commission_percentage?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  staking_pool_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  total_coins?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  total_shares?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** aggregate min on columns */\nexport type DelegatedStakingPoolBalancesMinFields = {\n  active_table_handle?: Maybe<Scalars[\"String\"][\"output\"]>;\n  inactive_table_handle?: Maybe<Scalars[\"String\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  operator_commission_percentage?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  staking_pool_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  total_coins?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  total_shares?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** response of any mutation on the table \"delegated_staking_pool_balances\" */\nexport type DelegatedStakingPoolBalancesMutationResponse = {\n  /** number of rows affected by the mutation */\n  affected_rows: Scalars[\"Int\"][\"output\"];\n  /** data from the rows affected by the mutation */\n  returning: Array<DelegatedStakingPoolBalances>;\n};\n\n/** on_conflict condition type for table \"delegated_staking_pool_balances\" */\nexport type DelegatedStakingPoolBalancesOnConflict = {\n  constraint: DelegatedStakingPoolBalancesConstraint;\n  update_columns?: Array<DelegatedStakingPoolBalancesUpdateColumn>;\n  where?: InputMaybe<DelegatedStakingPoolBalancesBoolExp>;\n};\n\n/** Ordering options when selecting data from \"delegated_staking_pool_balances\". */\nexport type DelegatedStakingPoolBalancesOrderBy = {\n  active_table_handle?: InputMaybe<OrderBy>;\n  inactive_table_handle?: InputMaybe<OrderBy>;\n  inserted_at?: InputMaybe<OrderBy>;\n  operator_commission_percentage?: InputMaybe<OrderBy>;\n  staking_pool_address?: InputMaybe<OrderBy>;\n  total_coins?: InputMaybe<OrderBy>;\n  total_shares?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n};\n\n/** primary key columns input for table: delegated_staking_pool_balances */\nexport type DelegatedStakingPoolBalancesPkColumnsInput = {\n  staking_pool_address: Scalars[\"String\"][\"input\"];\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\n/** select columns of table \"delegated_staking_pool_balances\" */\nexport enum DelegatedStakingPoolBalancesSelectColumn {\n  /** column name */\n  ActiveTableHandle = \"active_table_handle\",\n  /** column name */\n  InactiveTableHandle = \"inactive_table_handle\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  OperatorCommissionPercentage = \"operator_commission_percentage\",\n  /** column name */\n  StakingPoolAddress = \"staking_pool_address\",\n  /** column name */\n  TotalCoins = \"total_coins\",\n  /** column name */\n  TotalShares = \"total_shares\",\n  /** column name */\n  TransactionVersion = \"transaction_version\",\n}\n\n/** input type for updating data in table \"delegated_staking_pool_balances\" */\nexport type DelegatedStakingPoolBalancesSetInput = {\n  active_table_handle?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inactive_table_handle?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  operator_commission_percentage?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  staking_pool_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  total_coins?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  total_shares?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** aggregate stddev on columns */\nexport type DelegatedStakingPoolBalancesStddevFields = {\n  operator_commission_percentage?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  total_coins?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  total_shares?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_pop on columns */\nexport type DelegatedStakingPoolBalancesStddevPopFields = {\n  operator_commission_percentage?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  total_coins?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  total_shares?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_samp on columns */\nexport type DelegatedStakingPoolBalancesStddevSampFields = {\n  operator_commission_percentage?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  total_coins?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  total_shares?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Streaming cursor of the table \"delegated_staking_pool_balances\" */\nexport type DelegatedStakingPoolBalancesStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: DelegatedStakingPoolBalancesStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type DelegatedStakingPoolBalancesStreamCursorValueInput = {\n  active_table_handle?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inactive_table_handle?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  operator_commission_percentage?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  staking_pool_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  total_coins?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  total_shares?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** aggregate sum on columns */\nexport type DelegatedStakingPoolBalancesSumFields = {\n  operator_commission_percentage?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  total_coins?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  total_shares?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** update columns of table \"delegated_staking_pool_balances\" */\nexport enum DelegatedStakingPoolBalancesUpdateColumn {\n  /** column name */\n  ActiveTableHandle = \"active_table_handle\",\n  /** column name */\n  InactiveTableHandle = \"inactive_table_handle\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  OperatorCommissionPercentage = \"operator_commission_percentage\",\n  /** column name */\n  StakingPoolAddress = \"staking_pool_address\",\n  /** column name */\n  TotalCoins = \"total_coins\",\n  /** column name */\n  TotalShares = \"total_shares\",\n  /** column name */\n  TransactionVersion = \"transaction_version\",\n}\n\nexport type DelegatedStakingPoolBalancesUpdates = {\n  /** increments the numeric columns with given value of the filtered values */\n  _inc?: InputMaybe<DelegatedStakingPoolBalancesIncInput>;\n  /** sets the columns of the filtered rows to the given values */\n  _set?: InputMaybe<DelegatedStakingPoolBalancesSetInput>;\n  /** filter the rows which have to be updated */\n  where: DelegatedStakingPoolBalancesBoolExp;\n};\n\n/** aggregate var_pop on columns */\nexport type DelegatedStakingPoolBalancesVarPopFields = {\n  operator_commission_percentage?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  total_coins?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  total_shares?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate var_samp on columns */\nexport type DelegatedStakingPoolBalancesVarSampFields = {\n  operator_commission_percentage?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  total_coins?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  total_shares?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate variance on columns */\nexport type DelegatedStakingPoolBalancesVarianceFields = {\n  operator_commission_percentage?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  total_coins?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  total_shares?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** columns and relationships of \"delegated_staking_pools\" */\nexport type DelegatedStakingPools = {\n  /** An object relationship */\n  current_staking_pool?: Maybe<CurrentStakingPoolVoter>;\n  first_transaction_version: Scalars[\"bigint\"][\"output\"];\n  inserted_at: Scalars[\"timestamp\"][\"output\"];\n  staking_pool_address: Scalars[\"String\"][\"output\"];\n};\n\n/** aggregated selection of \"delegated_staking_pools\" */\nexport type DelegatedStakingPoolsAggregate = {\n  aggregate?: Maybe<DelegatedStakingPoolsAggregateFields>;\n  nodes: Array<DelegatedStakingPools>;\n};\n\n/** aggregate fields of \"delegated_staking_pools\" */\nexport type DelegatedStakingPoolsAggregateFields = {\n  avg?: Maybe<DelegatedStakingPoolsAvgFields>;\n  count: Scalars[\"Int\"][\"output\"];\n  max?: Maybe<DelegatedStakingPoolsMaxFields>;\n  min?: Maybe<DelegatedStakingPoolsMinFields>;\n  stddev?: Maybe<DelegatedStakingPoolsStddevFields>;\n  stddev_pop?: Maybe<DelegatedStakingPoolsStddevPopFields>;\n  stddev_samp?: Maybe<DelegatedStakingPoolsStddevSampFields>;\n  sum?: Maybe<DelegatedStakingPoolsSumFields>;\n  var_pop?: Maybe<DelegatedStakingPoolsVarPopFields>;\n  var_samp?: Maybe<DelegatedStakingPoolsVarSampFields>;\n  variance?: Maybe<DelegatedStakingPoolsVarianceFields>;\n};\n\n/** aggregate fields of \"delegated_staking_pools\" */\nexport type DelegatedStakingPoolsAggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<DelegatedStakingPoolsSelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** aggregate avg on columns */\nexport type DelegatedStakingPoolsAvgFields = {\n  first_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Boolean expression to filter rows from the table \"delegated_staking_pools\". All fields are combined with a logical 'AND'. */\nexport type DelegatedStakingPoolsBoolExp = {\n  _and?: InputMaybe<Array<DelegatedStakingPoolsBoolExp>>;\n  _not?: InputMaybe<DelegatedStakingPoolsBoolExp>;\n  _or?: InputMaybe<Array<DelegatedStakingPoolsBoolExp>>;\n  current_staking_pool?: InputMaybe<CurrentStakingPoolVoterBoolExp>;\n  first_transaction_version?: InputMaybe<BigintComparisonExp>;\n  inserted_at?: InputMaybe<TimestampComparisonExp>;\n  staking_pool_address?: InputMaybe<StringComparisonExp>;\n};\n\n/** unique or primary key constraints on table \"delegated_staking_pools\" */\nexport enum DelegatedStakingPoolsConstraint {\n  /** unique or primary key constraint on columns \"staking_pool_address\" */\n  DelegatedStakingPoolsPkey = \"delegated_staking_pools_pkey\",\n}\n\n/** input type for incrementing numeric columns in table \"delegated_staking_pools\" */\nexport type DelegatedStakingPoolsIncInput = {\n  first_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** input type for inserting data into table \"delegated_staking_pools\" */\nexport type DelegatedStakingPoolsInsertInput = {\n  current_staking_pool?: InputMaybe<CurrentStakingPoolVoterObjRelInsertInput>;\n  first_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  staking_pool_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate max on columns */\nexport type DelegatedStakingPoolsMaxFields = {\n  first_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  staking_pool_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** aggregate min on columns */\nexport type DelegatedStakingPoolsMinFields = {\n  first_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  staking_pool_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** response of any mutation on the table \"delegated_staking_pools\" */\nexport type DelegatedStakingPoolsMutationResponse = {\n  /** number of rows affected by the mutation */\n  affected_rows: Scalars[\"Int\"][\"output\"];\n  /** data from the rows affected by the mutation */\n  returning: Array<DelegatedStakingPools>;\n};\n\n/** on_conflict condition type for table \"delegated_staking_pools\" */\nexport type DelegatedStakingPoolsOnConflict = {\n  constraint: DelegatedStakingPoolsConstraint;\n  update_columns?: Array<DelegatedStakingPoolsUpdateColumn>;\n  where?: InputMaybe<DelegatedStakingPoolsBoolExp>;\n};\n\n/** Ordering options when selecting data from \"delegated_staking_pools\". */\nexport type DelegatedStakingPoolsOrderBy = {\n  current_staking_pool?: InputMaybe<CurrentStakingPoolVoterOrderBy>;\n  first_transaction_version?: InputMaybe<OrderBy>;\n  inserted_at?: InputMaybe<OrderBy>;\n  staking_pool_address?: InputMaybe<OrderBy>;\n};\n\n/** primary key columns input for table: delegated_staking_pools */\nexport type DelegatedStakingPoolsPkColumnsInput = {\n  staking_pool_address: Scalars[\"String\"][\"input\"];\n};\n\n/** select columns of table \"delegated_staking_pools\" */\nexport enum DelegatedStakingPoolsSelectColumn {\n  /** column name */\n  FirstTransactionVersion = \"first_transaction_version\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  StakingPoolAddress = \"staking_pool_address\",\n}\n\n/** input type for updating data in table \"delegated_staking_pools\" */\nexport type DelegatedStakingPoolsSetInput = {\n  first_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  staking_pool_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate stddev on columns */\nexport type DelegatedStakingPoolsStddevFields = {\n  first_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_pop on columns */\nexport type DelegatedStakingPoolsStddevPopFields = {\n  first_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_samp on columns */\nexport type DelegatedStakingPoolsStddevSampFields = {\n  first_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Streaming cursor of the table \"delegated_staking_pools\" */\nexport type DelegatedStakingPoolsStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: DelegatedStakingPoolsStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type DelegatedStakingPoolsStreamCursorValueInput = {\n  first_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  staking_pool_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate sum on columns */\nexport type DelegatedStakingPoolsSumFields = {\n  first_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** update columns of table \"delegated_staking_pools\" */\nexport enum DelegatedStakingPoolsUpdateColumn {\n  /** column name */\n  FirstTransactionVersion = \"first_transaction_version\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  StakingPoolAddress = \"staking_pool_address\",\n}\n\nexport type DelegatedStakingPoolsUpdates = {\n  /** increments the numeric columns with given value of the filtered values */\n  _inc?: InputMaybe<DelegatedStakingPoolsIncInput>;\n  /** sets the columns of the filtered rows to the given values */\n  _set?: InputMaybe<DelegatedStakingPoolsSetInput>;\n  /** filter the rows which have to be updated */\n  where: DelegatedStakingPoolsBoolExp;\n};\n\n/** aggregate var_pop on columns */\nexport type DelegatedStakingPoolsVarPopFields = {\n  first_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate var_samp on columns */\nexport type DelegatedStakingPoolsVarSampFields = {\n  first_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate variance on columns */\nexport type DelegatedStakingPoolsVarianceFields = {\n  first_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** columns and relationships of \"delegator_balances\" */\nexport type DelegatorBalances = {\n  delegator_address: Scalars[\"String\"][\"output\"];\n  inserted_at: Scalars[\"timestamp\"][\"output\"];\n  parent_table_handle: Scalars[\"String\"][\"output\"];\n  pool_address: Scalars[\"String\"][\"output\"];\n  pool_type: Scalars[\"String\"][\"output\"];\n  shares: Scalars[\"numeric\"][\"output\"];\n  table_handle: Scalars[\"String\"][\"output\"];\n  transaction_version: Scalars[\"bigint\"][\"output\"];\n  write_set_change_index: Scalars[\"bigint\"][\"output\"];\n};\n\n/** aggregated selection of \"delegator_balances\" */\nexport type DelegatorBalancesAggregate = {\n  aggregate?: Maybe<DelegatorBalancesAggregateFields>;\n  nodes: Array<DelegatorBalances>;\n};\n\n/** aggregate fields of \"delegator_balances\" */\nexport type DelegatorBalancesAggregateFields = {\n  avg?: Maybe<DelegatorBalancesAvgFields>;\n  count: Scalars[\"Int\"][\"output\"];\n  max?: Maybe<DelegatorBalancesMaxFields>;\n  min?: Maybe<DelegatorBalancesMinFields>;\n  stddev?: Maybe<DelegatorBalancesStddevFields>;\n  stddev_pop?: Maybe<DelegatorBalancesStddevPopFields>;\n  stddev_samp?: Maybe<DelegatorBalancesStddevSampFields>;\n  sum?: Maybe<DelegatorBalancesSumFields>;\n  var_pop?: Maybe<DelegatorBalancesVarPopFields>;\n  var_samp?: Maybe<DelegatorBalancesVarSampFields>;\n  variance?: Maybe<DelegatorBalancesVarianceFields>;\n};\n\n/** aggregate fields of \"delegator_balances\" */\nexport type DelegatorBalancesAggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<DelegatorBalancesSelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** aggregate avg on columns */\nexport type DelegatorBalancesAvgFields = {\n  shares?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Boolean expression to filter rows from the table \"delegator_balances\". All fields are combined with a logical 'AND'. */\nexport type DelegatorBalancesBoolExp = {\n  _and?: InputMaybe<Array<DelegatorBalancesBoolExp>>;\n  _not?: InputMaybe<DelegatorBalancesBoolExp>;\n  _or?: InputMaybe<Array<DelegatorBalancesBoolExp>>;\n  delegator_address?: InputMaybe<StringComparisonExp>;\n  inserted_at?: InputMaybe<TimestampComparisonExp>;\n  parent_table_handle?: InputMaybe<StringComparisonExp>;\n  pool_address?: InputMaybe<StringComparisonExp>;\n  pool_type?: InputMaybe<StringComparisonExp>;\n  shares?: InputMaybe<NumericComparisonExp>;\n  table_handle?: InputMaybe<StringComparisonExp>;\n  transaction_version?: InputMaybe<BigintComparisonExp>;\n  write_set_change_index?: InputMaybe<BigintComparisonExp>;\n};\n\n/** unique or primary key constraints on table \"delegator_balances\" */\nexport enum DelegatorBalancesConstraint {\n  /** unique or primary key constraint on columns \"write_set_change_index\", \"transaction_version\" */\n  DelegatorBalancesPkey = \"delegator_balances_pkey\",\n}\n\n/** input type for incrementing numeric columns in table \"delegator_balances\" */\nexport type DelegatorBalancesIncInput = {\n  shares?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  write_set_change_index?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** input type for inserting data into table \"delegator_balances\" */\nexport type DelegatorBalancesInsertInput = {\n  delegator_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  parent_table_handle?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  pool_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  pool_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  shares?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  table_handle?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  write_set_change_index?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** aggregate max on columns */\nexport type DelegatorBalancesMaxFields = {\n  delegator_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  parent_table_handle?: Maybe<Scalars[\"String\"][\"output\"]>;\n  pool_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  pool_type?: Maybe<Scalars[\"String\"][\"output\"]>;\n  shares?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  table_handle?: Maybe<Scalars[\"String\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** aggregate min on columns */\nexport type DelegatorBalancesMinFields = {\n  delegator_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  parent_table_handle?: Maybe<Scalars[\"String\"][\"output\"]>;\n  pool_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  pool_type?: Maybe<Scalars[\"String\"][\"output\"]>;\n  shares?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  table_handle?: Maybe<Scalars[\"String\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** response of any mutation on the table \"delegator_balances\" */\nexport type DelegatorBalancesMutationResponse = {\n  /** number of rows affected by the mutation */\n  affected_rows: Scalars[\"Int\"][\"output\"];\n  /** data from the rows affected by the mutation */\n  returning: Array<DelegatorBalances>;\n};\n\n/** on_conflict condition type for table \"delegator_balances\" */\nexport type DelegatorBalancesOnConflict = {\n  constraint: DelegatorBalancesConstraint;\n  update_columns?: Array<DelegatorBalancesUpdateColumn>;\n  where?: InputMaybe<DelegatorBalancesBoolExp>;\n};\n\n/** Ordering options when selecting data from \"delegator_balances\". */\nexport type DelegatorBalancesOrderBy = {\n  delegator_address?: InputMaybe<OrderBy>;\n  inserted_at?: InputMaybe<OrderBy>;\n  parent_table_handle?: InputMaybe<OrderBy>;\n  pool_address?: InputMaybe<OrderBy>;\n  pool_type?: InputMaybe<OrderBy>;\n  shares?: InputMaybe<OrderBy>;\n  table_handle?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n  write_set_change_index?: InputMaybe<OrderBy>;\n};\n\n/** primary key columns input for table: delegator_balances */\nexport type DelegatorBalancesPkColumnsInput = {\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n  write_set_change_index: Scalars[\"bigint\"][\"input\"];\n};\n\n/** select columns of table \"delegator_balances\" */\nexport enum DelegatorBalancesSelectColumn {\n  /** column name */\n  DelegatorAddress = \"delegator_address\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  ParentTableHandle = \"parent_table_handle\",\n  /** column name */\n  PoolAddress = \"pool_address\",\n  /** column name */\n  PoolType = \"pool_type\",\n  /** column name */\n  Shares = \"shares\",\n  /** column name */\n  TableHandle = \"table_handle\",\n  /** column name */\n  TransactionVersion = \"transaction_version\",\n  /** column name */\n  WriteSetChangeIndex = \"write_set_change_index\",\n}\n\n/** input type for updating data in table \"delegator_balances\" */\nexport type DelegatorBalancesSetInput = {\n  delegator_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  parent_table_handle?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  pool_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  pool_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  shares?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  table_handle?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  write_set_change_index?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** aggregate stddev on columns */\nexport type DelegatorBalancesStddevFields = {\n  shares?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_pop on columns */\nexport type DelegatorBalancesStddevPopFields = {\n  shares?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_samp on columns */\nexport type DelegatorBalancesStddevSampFields = {\n  shares?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Streaming cursor of the table \"delegator_balances\" */\nexport type DelegatorBalancesStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: DelegatorBalancesStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type DelegatorBalancesStreamCursorValueInput = {\n  delegator_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  parent_table_handle?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  pool_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  pool_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  shares?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  table_handle?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  write_set_change_index?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** aggregate sum on columns */\nexport type DelegatorBalancesSumFields = {\n  shares?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** update columns of table \"delegator_balances\" */\nexport enum DelegatorBalancesUpdateColumn {\n  /** column name */\n  DelegatorAddress = \"delegator_address\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  ParentTableHandle = \"parent_table_handle\",\n  /** column name */\n  PoolAddress = \"pool_address\",\n  /** column name */\n  PoolType = \"pool_type\",\n  /** column name */\n  Shares = \"shares\",\n  /** column name */\n  TableHandle = \"table_handle\",\n  /** column name */\n  TransactionVersion = \"transaction_version\",\n  /** column name */\n  WriteSetChangeIndex = \"write_set_change_index\",\n}\n\nexport type DelegatorBalancesUpdates = {\n  /** increments the numeric columns with given value of the filtered values */\n  _inc?: InputMaybe<DelegatorBalancesIncInput>;\n  /** sets the columns of the filtered rows to the given values */\n  _set?: InputMaybe<DelegatorBalancesSetInput>;\n  /** filter the rows which have to be updated */\n  where: DelegatorBalancesBoolExp;\n};\n\n/** aggregate var_pop on columns */\nexport type DelegatorBalancesVarPopFields = {\n  shares?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate var_samp on columns */\nexport type DelegatorBalancesVarSampFields = {\n  shares?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate variance on columns */\nexport type DelegatorBalancesVarianceFields = {\n  shares?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** columns and relationships of \"delegator_distinct_pool\" */\nexport type DelegatorDistinctPool = {\n  /** An object relationship */\n  current_pool_balance?: Maybe<CurrentDelegatedStakingPoolBalances>;\n  delegator_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  pool_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  /** An object relationship */\n  staking_pool_metadata?: Maybe<CurrentStakingPoolVoter>;\n};\n\n/** aggregated selection of \"delegator_distinct_pool\" */\nexport type DelegatorDistinctPoolAggregate = {\n  aggregate?: Maybe<DelegatorDistinctPoolAggregateFields>;\n  nodes: Array<DelegatorDistinctPool>;\n};\n\n/** aggregate fields of \"delegator_distinct_pool\" */\nexport type DelegatorDistinctPoolAggregateFields = {\n  count: Scalars[\"Int\"][\"output\"];\n  max?: Maybe<DelegatorDistinctPoolMaxFields>;\n  min?: Maybe<DelegatorDistinctPoolMinFields>;\n};\n\n/** aggregate fields of \"delegator_distinct_pool\" */\nexport type DelegatorDistinctPoolAggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<DelegatorDistinctPoolSelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** Boolean expression to filter rows from the table \"delegator_distinct_pool\". All fields are combined with a logical 'AND'. */\nexport type DelegatorDistinctPoolBoolExp = {\n  _and?: InputMaybe<Array<DelegatorDistinctPoolBoolExp>>;\n  _not?: InputMaybe<DelegatorDistinctPoolBoolExp>;\n  _or?: InputMaybe<Array<DelegatorDistinctPoolBoolExp>>;\n  current_pool_balance?: InputMaybe<CurrentDelegatedStakingPoolBalancesBoolExp>;\n  delegator_address?: InputMaybe<StringComparisonExp>;\n  pool_address?: InputMaybe<StringComparisonExp>;\n  staking_pool_metadata?: InputMaybe<CurrentStakingPoolVoterBoolExp>;\n};\n\n/** aggregate max on columns */\nexport type DelegatorDistinctPoolMaxFields = {\n  delegator_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  pool_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** aggregate min on columns */\nexport type DelegatorDistinctPoolMinFields = {\n  delegator_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  pool_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** Ordering options when selecting data from \"delegator_distinct_pool\". */\nexport type DelegatorDistinctPoolOrderBy = {\n  current_pool_balance?: InputMaybe<CurrentDelegatedStakingPoolBalancesOrderBy>;\n  delegator_address?: InputMaybe<OrderBy>;\n  pool_address?: InputMaybe<OrderBy>;\n  staking_pool_metadata?: InputMaybe<CurrentStakingPoolVoterOrderBy>;\n};\n\n/** select columns of table \"delegator_distinct_pool\" */\nexport enum DelegatorDistinctPoolSelectColumn {\n  /** column name */\n  DelegatorAddress = \"delegator_address\",\n  /** column name */\n  PoolAddress = \"pool_address\",\n}\n\n/** Streaming cursor of the table \"delegator_distinct_pool\" */\nexport type DelegatorDistinctPoolStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: DelegatorDistinctPoolStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type DelegatorDistinctPoolStreamCursorValueInput = {\n  delegator_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  pool_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** columns and relationships of \"event_size_info\" */\nexport type EventSizeInfo = {\n  index: Scalars[\"bigint\"][\"output\"];\n  inserted_at: Scalars[\"timestamp\"][\"output\"];\n  total_bytes: Scalars[\"bigint\"][\"output\"];\n  transaction_version: Scalars[\"bigint\"][\"output\"];\n  type_tag_bytes: Scalars[\"bigint\"][\"output\"];\n};\n\n/** aggregated selection of \"event_size_info\" */\nexport type EventSizeInfoAggregate = {\n  aggregate?: Maybe<EventSizeInfoAggregateFields>;\n  nodes: Array<EventSizeInfo>;\n};\n\n/** aggregate fields of \"event_size_info\" */\nexport type EventSizeInfoAggregateFields = {\n  avg?: Maybe<EventSizeInfoAvgFields>;\n  count: Scalars[\"Int\"][\"output\"];\n  max?: Maybe<EventSizeInfoMaxFields>;\n  min?: Maybe<EventSizeInfoMinFields>;\n  stddev?: Maybe<EventSizeInfoStddevFields>;\n  stddev_pop?: Maybe<EventSizeInfoStddevPopFields>;\n  stddev_samp?: Maybe<EventSizeInfoStddevSampFields>;\n  sum?: Maybe<EventSizeInfoSumFields>;\n  var_pop?: Maybe<EventSizeInfoVarPopFields>;\n  var_samp?: Maybe<EventSizeInfoVarSampFields>;\n  variance?: Maybe<EventSizeInfoVarianceFields>;\n};\n\n/** aggregate fields of \"event_size_info\" */\nexport type EventSizeInfoAggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<EventSizeInfoSelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** aggregate avg on columns */\nexport type EventSizeInfoAvgFields = {\n  index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  total_bytes?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  type_tag_bytes?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Boolean expression to filter rows from the table \"event_size_info\". All fields are combined with a logical 'AND'. */\nexport type EventSizeInfoBoolExp = {\n  _and?: InputMaybe<Array<EventSizeInfoBoolExp>>;\n  _not?: InputMaybe<EventSizeInfoBoolExp>;\n  _or?: InputMaybe<Array<EventSizeInfoBoolExp>>;\n  index?: InputMaybe<BigintComparisonExp>;\n  inserted_at?: InputMaybe<TimestampComparisonExp>;\n  total_bytes?: InputMaybe<BigintComparisonExp>;\n  transaction_version?: InputMaybe<BigintComparisonExp>;\n  type_tag_bytes?: InputMaybe<BigintComparisonExp>;\n};\n\n/** unique or primary key constraints on table \"event_size_info\" */\nexport enum EventSizeInfoConstraint {\n  /** unique or primary key constraint on columns \"index\", \"transaction_version\" */\n  EventSizeInfoPkey = \"event_size_info_pkey\",\n}\n\n/** input type for incrementing numeric columns in table \"event_size_info\" */\nexport type EventSizeInfoIncInput = {\n  index?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  total_bytes?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  type_tag_bytes?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** input type for inserting data into table \"event_size_info\" */\nexport type EventSizeInfoInsertInput = {\n  index?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  total_bytes?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  type_tag_bytes?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** aggregate max on columns */\nexport type EventSizeInfoMaxFields = {\n  index?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  total_bytes?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  type_tag_bytes?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** aggregate min on columns */\nexport type EventSizeInfoMinFields = {\n  index?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  total_bytes?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  type_tag_bytes?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** response of any mutation on the table \"event_size_info\" */\nexport type EventSizeInfoMutationResponse = {\n  /** number of rows affected by the mutation */\n  affected_rows: Scalars[\"Int\"][\"output\"];\n  /** data from the rows affected by the mutation */\n  returning: Array<EventSizeInfo>;\n};\n\n/** on_conflict condition type for table \"event_size_info\" */\nexport type EventSizeInfoOnConflict = {\n  constraint: EventSizeInfoConstraint;\n  update_columns?: Array<EventSizeInfoUpdateColumn>;\n  where?: InputMaybe<EventSizeInfoBoolExp>;\n};\n\n/** Ordering options when selecting data from \"event_size_info\". */\nexport type EventSizeInfoOrderBy = {\n  index?: InputMaybe<OrderBy>;\n  inserted_at?: InputMaybe<OrderBy>;\n  total_bytes?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n  type_tag_bytes?: InputMaybe<OrderBy>;\n};\n\n/** primary key columns input for table: event_size_info */\nexport type EventSizeInfoPkColumnsInput = {\n  index: Scalars[\"bigint\"][\"input\"];\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\n/** select columns of table \"event_size_info\" */\nexport enum EventSizeInfoSelectColumn {\n  /** column name */\n  Index = \"index\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  TotalBytes = \"total_bytes\",\n  /** column name */\n  TransactionVersion = \"transaction_version\",\n  /** column name */\n  TypeTagBytes = \"type_tag_bytes\",\n}\n\n/** input type for updating data in table \"event_size_info\" */\nexport type EventSizeInfoSetInput = {\n  index?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  total_bytes?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  type_tag_bytes?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** aggregate stddev on columns */\nexport type EventSizeInfoStddevFields = {\n  index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  total_bytes?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  type_tag_bytes?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_pop on columns */\nexport type EventSizeInfoStddevPopFields = {\n  index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  total_bytes?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  type_tag_bytes?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_samp on columns */\nexport type EventSizeInfoStddevSampFields = {\n  index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  total_bytes?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  type_tag_bytes?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Streaming cursor of the table \"event_size_info\" */\nexport type EventSizeInfoStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: EventSizeInfoStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type EventSizeInfoStreamCursorValueInput = {\n  index?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  total_bytes?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  type_tag_bytes?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** aggregate sum on columns */\nexport type EventSizeInfoSumFields = {\n  index?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  total_bytes?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  type_tag_bytes?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** update columns of table \"event_size_info\" */\nexport enum EventSizeInfoUpdateColumn {\n  /** column name */\n  Index = \"index\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  TotalBytes = \"total_bytes\",\n  /** column name */\n  TransactionVersion = \"transaction_version\",\n  /** column name */\n  TypeTagBytes = \"type_tag_bytes\",\n}\n\nexport type EventSizeInfoUpdates = {\n  /** increments the numeric columns with given value of the filtered values */\n  _inc?: InputMaybe<EventSizeInfoIncInput>;\n  /** sets the columns of the filtered rows to the given values */\n  _set?: InputMaybe<EventSizeInfoSetInput>;\n  /** filter the rows which have to be updated */\n  where: EventSizeInfoBoolExp;\n};\n\n/** aggregate var_pop on columns */\nexport type EventSizeInfoVarPopFields = {\n  index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  total_bytes?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  type_tag_bytes?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate var_samp on columns */\nexport type EventSizeInfoVarSampFields = {\n  index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  total_bytes?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  type_tag_bytes?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate variance on columns */\nexport type EventSizeInfoVarianceFields = {\n  index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  total_bytes?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  type_tag_bytes?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** columns and relationships of \"events\" */\nexport type Events = {\n  account_address: Scalars[\"String\"][\"output\"];\n  creation_number: Scalars[\"bigint\"][\"output\"];\n  data: Scalars[\"jsonb\"][\"output\"];\n  event_index: Scalars[\"bigint\"][\"output\"];\n  indexed_type: Scalars[\"String\"][\"output\"];\n  inserted_at: Scalars[\"timestamp\"][\"output\"];\n  sequence_number: Scalars[\"bigint\"][\"output\"];\n  transaction_block_height: Scalars[\"bigint\"][\"output\"];\n  transaction_version: Scalars[\"bigint\"][\"output\"];\n  type: Scalars[\"String\"][\"output\"];\n};\n\n/** columns and relationships of \"events\" */\nexport type EventsDataArgs = {\n  path?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregated selection of \"events\" */\nexport type EventsAggregate = {\n  aggregate?: Maybe<EventsAggregateFields>;\n  nodes: Array<Events>;\n};\n\n/** aggregate fields of \"events\" */\nexport type EventsAggregateFields = {\n  avg?: Maybe<EventsAvgFields>;\n  count: Scalars[\"Int\"][\"output\"];\n  max?: Maybe<EventsMaxFields>;\n  min?: Maybe<EventsMinFields>;\n  stddev?: Maybe<EventsStddevFields>;\n  stddev_pop?: Maybe<EventsStddevPopFields>;\n  stddev_samp?: Maybe<EventsStddevSampFields>;\n  sum?: Maybe<EventsSumFields>;\n  var_pop?: Maybe<EventsVarPopFields>;\n  var_samp?: Maybe<EventsVarSampFields>;\n  variance?: Maybe<EventsVarianceFields>;\n};\n\n/** aggregate fields of \"events\" */\nexport type EventsAggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<EventsSelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** append existing jsonb value of filtered columns with new jsonb value */\nexport type EventsAppendInput = {\n  data?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n};\n\n/** aggregate avg on columns */\nexport type EventsAvgFields = {\n  creation_number?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  event_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  sequence_number?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Boolean expression to filter rows from the table \"events\". All fields are combined with a logical 'AND'. */\nexport type EventsBoolExp = {\n  _and?: InputMaybe<Array<EventsBoolExp>>;\n  _not?: InputMaybe<EventsBoolExp>;\n  _or?: InputMaybe<Array<EventsBoolExp>>;\n  account_address?: InputMaybe<StringComparisonExp>;\n  creation_number?: InputMaybe<BigintComparisonExp>;\n  data?: InputMaybe<JsonbComparisonExp>;\n  event_index?: InputMaybe<BigintComparisonExp>;\n  indexed_type?: InputMaybe<StringComparisonExp>;\n  inserted_at?: InputMaybe<TimestampComparisonExp>;\n  sequence_number?: InputMaybe<BigintComparisonExp>;\n  transaction_block_height?: InputMaybe<BigintComparisonExp>;\n  transaction_version?: InputMaybe<BigintComparisonExp>;\n  type?: InputMaybe<StringComparisonExp>;\n};\n\n/** unique or primary key constraints on table \"events\" */\nexport enum EventsConstraint {\n  /** unique or primary key constraint on columns \"event_index\", \"transaction_version\" */\n  EventsPkey = \"events_pkey\",\n}\n\n/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */\nexport type EventsDeleteAtPathInput = {\n  data?: InputMaybe<Array<Scalars[\"String\"][\"input\"]>>;\n};\n\n/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */\nexport type EventsDeleteElemInput = {\n  data?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n};\n\n/** delete key/value pair or string element. key/value pairs are matched based on their key value */\nexport type EventsDeleteKeyInput = {\n  data?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** input type for incrementing numeric columns in table \"events\" */\nexport type EventsIncInput = {\n  creation_number?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  event_index?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  sequence_number?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  transaction_block_height?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** input type for inserting data into table \"events\" */\nexport type EventsInsertInput = {\n  account_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  creation_number?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  data?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  event_index?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  indexed_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  sequence_number?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  transaction_block_height?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate max on columns */\nexport type EventsMaxFields = {\n  account_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  creation_number?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  event_index?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  indexed_type?: Maybe<Scalars[\"String\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  sequence_number?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  transaction_block_height?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  type?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** aggregate min on columns */\nexport type EventsMinFields = {\n  account_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  creation_number?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  event_index?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  indexed_type?: Maybe<Scalars[\"String\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  sequence_number?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  transaction_block_height?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  type?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** response of any mutation on the table \"events\" */\nexport type EventsMutationResponse = {\n  /** number of rows affected by the mutation */\n  affected_rows: Scalars[\"Int\"][\"output\"];\n  /** data from the rows affected by the mutation */\n  returning: Array<Events>;\n};\n\n/** on_conflict condition type for table \"events\" */\nexport type EventsOnConflict = {\n  constraint: EventsConstraint;\n  update_columns?: Array<EventsUpdateColumn>;\n  where?: InputMaybe<EventsBoolExp>;\n};\n\n/** Ordering options when selecting data from \"events\". */\nexport type EventsOrderBy = {\n  account_address?: InputMaybe<OrderBy>;\n  creation_number?: InputMaybe<OrderBy>;\n  data?: InputMaybe<OrderBy>;\n  event_index?: InputMaybe<OrderBy>;\n  indexed_type?: InputMaybe<OrderBy>;\n  inserted_at?: InputMaybe<OrderBy>;\n  sequence_number?: InputMaybe<OrderBy>;\n  transaction_block_height?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n  type?: InputMaybe<OrderBy>;\n};\n\n/** primary key columns input for table: events */\nexport type EventsPkColumnsInput = {\n  event_index: Scalars[\"bigint\"][\"input\"];\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\n/** prepend existing jsonb value of filtered columns with new jsonb value */\nexport type EventsPrependInput = {\n  data?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n};\n\n/** select columns of table \"events\" */\nexport enum EventsSelectColumn {\n  /** column name */\n  AccountAddress = \"account_address\",\n  /** column name */\n  CreationNumber = \"creation_number\",\n  /** column name */\n  Data = \"data\",\n  /** column name */\n  EventIndex = \"event_index\",\n  /** column name */\n  IndexedType = \"indexed_type\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  SequenceNumber = \"sequence_number\",\n  /** column name */\n  TransactionBlockHeight = \"transaction_block_height\",\n  /** column name */\n  TransactionVersion = \"transaction_version\",\n  /** column name */\n  Type = \"type\",\n}\n\n/** input type for updating data in table \"events\" */\nexport type EventsSetInput = {\n  account_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  creation_number?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  data?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  event_index?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  indexed_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  sequence_number?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  transaction_block_height?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate stddev on columns */\nexport type EventsStddevFields = {\n  creation_number?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  event_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  sequence_number?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_pop on columns */\nexport type EventsStddevPopFields = {\n  creation_number?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  event_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  sequence_number?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_samp on columns */\nexport type EventsStddevSampFields = {\n  creation_number?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  event_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  sequence_number?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Streaming cursor of the table \"events\" */\nexport type EventsStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: EventsStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type EventsStreamCursorValueInput = {\n  account_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  creation_number?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  data?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  event_index?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  indexed_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  sequence_number?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  transaction_block_height?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate sum on columns */\nexport type EventsSumFields = {\n  creation_number?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  event_index?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  sequence_number?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  transaction_block_height?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** update columns of table \"events\" */\nexport enum EventsUpdateColumn {\n  /** column name */\n  AccountAddress = \"account_address\",\n  /** column name */\n  CreationNumber = \"creation_number\",\n  /** column name */\n  Data = \"data\",\n  /** column name */\n  EventIndex = \"event_index\",\n  /** column name */\n  IndexedType = \"indexed_type\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  SequenceNumber = \"sequence_number\",\n  /** column name */\n  TransactionBlockHeight = \"transaction_block_height\",\n  /** column name */\n  TransactionVersion = \"transaction_version\",\n  /** column name */\n  Type = \"type\",\n}\n\nexport type EventsUpdates = {\n  /** append existing jsonb value of filtered columns with new jsonb value */\n  _append?: InputMaybe<EventsAppendInput>;\n  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */\n  _delete_at_path?: InputMaybe<EventsDeleteAtPathInput>;\n  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */\n  _delete_elem?: InputMaybe<EventsDeleteElemInput>;\n  /** delete key/value pair or string element. key/value pairs are matched based on their key value */\n  _delete_key?: InputMaybe<EventsDeleteKeyInput>;\n  /** increments the numeric columns with given value of the filtered values */\n  _inc?: InputMaybe<EventsIncInput>;\n  /** prepend existing jsonb value of filtered columns with new jsonb value */\n  _prepend?: InputMaybe<EventsPrependInput>;\n  /** sets the columns of the filtered rows to the given values */\n  _set?: InputMaybe<EventsSetInput>;\n  /** filter the rows which have to be updated */\n  where: EventsBoolExp;\n};\n\n/** aggregate var_pop on columns */\nexport type EventsVarPopFields = {\n  creation_number?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  event_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  sequence_number?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate var_samp on columns */\nexport type EventsVarSampFields = {\n  creation_number?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  event_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  sequence_number?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate variance on columns */\nexport type EventsVarianceFields = {\n  creation_number?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  event_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  sequence_number?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** columns and relationships of \"events_view\" */\nexport type EventsView = {\n  account_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  creation_number?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  json_data?: Maybe<Scalars[\"String\"][\"output\"]>;\n  sequence_number?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  transaction_block_height?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  type?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** aggregated selection of \"events_view\" */\nexport type EventsViewAggregate = {\n  aggregate?: Maybe<EventsViewAggregateFields>;\n  nodes: Array<EventsView>;\n};\n\n/** aggregate fields of \"events_view\" */\nexport type EventsViewAggregateFields = {\n  avg?: Maybe<EventsViewAvgFields>;\n  count: Scalars[\"Int\"][\"output\"];\n  max?: Maybe<EventsViewMaxFields>;\n  min?: Maybe<EventsViewMinFields>;\n  stddev?: Maybe<EventsViewStddevFields>;\n  stddev_pop?: Maybe<EventsViewStddevPopFields>;\n  stddev_samp?: Maybe<EventsViewStddevSampFields>;\n  sum?: Maybe<EventsViewSumFields>;\n  var_pop?: Maybe<EventsViewVarPopFields>;\n  var_samp?: Maybe<EventsViewVarSampFields>;\n  variance?: Maybe<EventsViewVarianceFields>;\n};\n\n/** aggregate fields of \"events_view\" */\nexport type EventsViewAggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<EventsViewSelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** aggregate avg on columns */\nexport type EventsViewAvgFields = {\n  creation_number?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  sequence_number?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Boolean expression to filter rows from the table \"events_view\". All fields are combined with a logical 'AND'. */\nexport type EventsViewBoolExp = {\n  _and?: InputMaybe<Array<EventsViewBoolExp>>;\n  _not?: InputMaybe<EventsViewBoolExp>;\n  _or?: InputMaybe<Array<EventsViewBoolExp>>;\n  account_address?: InputMaybe<StringComparisonExp>;\n  creation_number?: InputMaybe<BigintComparisonExp>;\n  inserted_at?: InputMaybe<TimestampComparisonExp>;\n  json_data?: InputMaybe<StringComparisonExp>;\n  sequence_number?: InputMaybe<BigintComparisonExp>;\n  transaction_block_height?: InputMaybe<BigintComparisonExp>;\n  transaction_version?: InputMaybe<BigintComparisonExp>;\n  type?: InputMaybe<StringComparisonExp>;\n};\n\n/** input type for incrementing numeric columns in table \"events_view\" */\nexport type EventsViewIncInput = {\n  creation_number?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  sequence_number?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  transaction_block_height?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** input type for inserting data into table \"events_view\" */\nexport type EventsViewInsertInput = {\n  account_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  creation_number?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  json_data?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  sequence_number?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  transaction_block_height?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate max on columns */\nexport type EventsViewMaxFields = {\n  account_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  creation_number?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  json_data?: Maybe<Scalars[\"String\"][\"output\"]>;\n  sequence_number?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  transaction_block_height?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  type?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** aggregate min on columns */\nexport type EventsViewMinFields = {\n  account_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  creation_number?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  json_data?: Maybe<Scalars[\"String\"][\"output\"]>;\n  sequence_number?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  transaction_block_height?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  type?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** response of any mutation on the table \"events_view\" */\nexport type EventsViewMutationResponse = {\n  /** number of rows affected by the mutation */\n  affected_rows: Scalars[\"Int\"][\"output\"];\n  /** data from the rows affected by the mutation */\n  returning: Array<EventsView>;\n};\n\n/** Ordering options when selecting data from \"events_view\". */\nexport type EventsViewOrderBy = {\n  account_address?: InputMaybe<OrderBy>;\n  creation_number?: InputMaybe<OrderBy>;\n  inserted_at?: InputMaybe<OrderBy>;\n  json_data?: InputMaybe<OrderBy>;\n  sequence_number?: InputMaybe<OrderBy>;\n  transaction_block_height?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n  type?: InputMaybe<OrderBy>;\n};\n\n/** select columns of table \"events_view\" */\nexport enum EventsViewSelectColumn {\n  /** column name */\n  AccountAddress = \"account_address\",\n  /** column name */\n  CreationNumber = \"creation_number\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  JsonData = \"json_data\",\n  /** column name */\n  SequenceNumber = \"sequence_number\",\n  /** column name */\n  TransactionBlockHeight = \"transaction_block_height\",\n  /** column name */\n  TransactionVersion = \"transaction_version\",\n  /** column name */\n  Type = \"type\",\n}\n\n/** input type for updating data in table \"events_view\" */\nexport type EventsViewSetInput = {\n  account_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  creation_number?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  json_data?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  sequence_number?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  transaction_block_height?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate stddev on columns */\nexport type EventsViewStddevFields = {\n  creation_number?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  sequence_number?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_pop on columns */\nexport type EventsViewStddevPopFields = {\n  creation_number?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  sequence_number?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_samp on columns */\nexport type EventsViewStddevSampFields = {\n  creation_number?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  sequence_number?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Streaming cursor of the table \"events_view\" */\nexport type EventsViewStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: EventsViewStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type EventsViewStreamCursorValueInput = {\n  account_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  creation_number?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  json_data?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  sequence_number?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  transaction_block_height?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate sum on columns */\nexport type EventsViewSumFields = {\n  creation_number?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  sequence_number?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  transaction_block_height?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\nexport type EventsViewUpdates = {\n  /** increments the numeric columns with given value of the filtered values */\n  _inc?: InputMaybe<EventsViewIncInput>;\n  /** sets the columns of the filtered rows to the given values */\n  _set?: InputMaybe<EventsViewSetInput>;\n  /** filter the rows which have to be updated */\n  where: EventsViewBoolExp;\n};\n\n/** aggregate var_pop on columns */\nexport type EventsViewVarPopFields = {\n  creation_number?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  sequence_number?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate var_samp on columns */\nexport type EventsViewVarSampFields = {\n  creation_number?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  sequence_number?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate variance on columns */\nexport type EventsViewVarianceFields = {\n  creation_number?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  sequence_number?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** columns and relationships of \"fungible_asset_activities\" */\nexport type FungibleAssetActivities = {\n  amount?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  asset_type?: Maybe<Scalars[\"String\"][\"output\"]>;\n  block_height: Scalars[\"bigint\"][\"output\"];\n  entry_function_id_str?: Maybe<Scalars[\"String\"][\"output\"]>;\n  event_index: Scalars[\"bigint\"][\"output\"];\n  gas_fee_payer_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  inserted_at: Scalars[\"timestamp\"][\"output\"];\n  is_frozen?: Maybe<Scalars[\"Boolean\"][\"output\"]>;\n  is_gas_fee: Scalars[\"Boolean\"][\"output\"];\n  is_transaction_success: Scalars[\"Boolean\"][\"output\"];\n  /** An object relationship */\n  metadata?: Maybe<FungibleAssetMetadata>;\n  owner_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  /** An array relationship */\n  owner_cedra_names: Array<CurrentCedraNames>;\n  /** An aggregate relationship */\n  owner_cedra_names_aggregate: CurrentCedraNamesAggregate;\n  storage_id: Scalars[\"String\"][\"output\"];\n  storage_refund_amount: Scalars[\"numeric\"][\"output\"];\n  token_standard: Scalars[\"String\"][\"output\"];\n  transaction_timestamp: Scalars[\"timestamp\"][\"output\"];\n  transaction_version: Scalars[\"bigint\"][\"output\"];\n  type: Scalars[\"String\"][\"output\"];\n};\n\n/** columns and relationships of \"fungible_asset_activities\" */\nexport type FungibleAssetActivitiesOwnerCedraNamesArgs = {\n  distinct_on?: InputMaybe<Array<CurrentCedraNamesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentCedraNamesOrderBy>>;\n  where?: InputMaybe<CurrentCedraNamesBoolExp>;\n};\n\n/** columns and relationships of \"fungible_asset_activities\" */\nexport type FungibleAssetActivitiesOwnerCedraNamesAggregateArgs = {\n  distinct_on?: InputMaybe<Array<CurrentCedraNamesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentCedraNamesOrderBy>>;\n  where?: InputMaybe<CurrentCedraNamesBoolExp>;\n};\n\n/** aggregated selection of \"fungible_asset_activities\" */\nexport type FungibleAssetActivitiesAggregate = {\n  aggregate?: Maybe<FungibleAssetActivitiesAggregateFields>;\n  nodes: Array<FungibleAssetActivities>;\n};\n\nexport type FungibleAssetActivitiesAggregateBoolExp = {\n  bool_and?: InputMaybe<FungibleAssetActivitiesAggregateBoolExpBoolAnd>;\n  bool_or?: InputMaybe<FungibleAssetActivitiesAggregateBoolExpBoolOr>;\n  count?: InputMaybe<FungibleAssetActivitiesAggregateBoolExpCount>;\n};\n\nexport type FungibleAssetActivitiesAggregateBoolExpBoolAnd = {\n  arguments: FungibleAssetActivitiesSelectColumnFungibleAssetActivitiesAggregateBoolExpBoolAndArgumentsColumns;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  filter?: InputMaybe<FungibleAssetActivitiesBoolExp>;\n  predicate: BooleanComparisonExp;\n};\n\nexport type FungibleAssetActivitiesAggregateBoolExpBoolOr = {\n  arguments: FungibleAssetActivitiesSelectColumnFungibleAssetActivitiesAggregateBoolExpBoolOrArgumentsColumns;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  filter?: InputMaybe<FungibleAssetActivitiesBoolExp>;\n  predicate: BooleanComparisonExp;\n};\n\nexport type FungibleAssetActivitiesAggregateBoolExpCount = {\n  arguments?: InputMaybe<Array<FungibleAssetActivitiesSelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  filter?: InputMaybe<FungibleAssetActivitiesBoolExp>;\n  predicate: IntComparisonExp;\n};\n\n/** aggregate fields of \"fungible_asset_activities\" */\nexport type FungibleAssetActivitiesAggregateFields = {\n  avg?: Maybe<FungibleAssetActivitiesAvgFields>;\n  count: Scalars[\"Int\"][\"output\"];\n  max?: Maybe<FungibleAssetActivitiesMaxFields>;\n  min?: Maybe<FungibleAssetActivitiesMinFields>;\n  stddev?: Maybe<FungibleAssetActivitiesStddevFields>;\n  stddev_pop?: Maybe<FungibleAssetActivitiesStddevPopFields>;\n  stddev_samp?: Maybe<FungibleAssetActivitiesStddevSampFields>;\n  sum?: Maybe<FungibleAssetActivitiesSumFields>;\n  var_pop?: Maybe<FungibleAssetActivitiesVarPopFields>;\n  var_samp?: Maybe<FungibleAssetActivitiesVarSampFields>;\n  variance?: Maybe<FungibleAssetActivitiesVarianceFields>;\n};\n\n/** aggregate fields of \"fungible_asset_activities\" */\nexport type FungibleAssetActivitiesAggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<FungibleAssetActivitiesSelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** order by aggregate values of table \"fungible_asset_activities\" */\nexport type FungibleAssetActivitiesAggregateOrderBy = {\n  avg?: InputMaybe<FungibleAssetActivitiesAvgOrderBy>;\n  count?: InputMaybe<OrderBy>;\n  max?: InputMaybe<FungibleAssetActivitiesMaxOrderBy>;\n  min?: InputMaybe<FungibleAssetActivitiesMinOrderBy>;\n  stddev?: InputMaybe<FungibleAssetActivitiesStddevOrderBy>;\n  stddev_pop?: InputMaybe<FungibleAssetActivitiesStddevPopOrderBy>;\n  stddev_samp?: InputMaybe<FungibleAssetActivitiesStddevSampOrderBy>;\n  sum?: InputMaybe<FungibleAssetActivitiesSumOrderBy>;\n  var_pop?: InputMaybe<FungibleAssetActivitiesVarPopOrderBy>;\n  var_samp?: InputMaybe<FungibleAssetActivitiesVarSampOrderBy>;\n  variance?: InputMaybe<FungibleAssetActivitiesVarianceOrderBy>;\n};\n\n/** input type for inserting array relation for remote table \"fungible_asset_activities\" */\nexport type FungibleAssetActivitiesArrRelInsertInput = {\n  data: Array<FungibleAssetActivitiesInsertInput>;\n  /** upsert condition */\n  on_conflict?: InputMaybe<FungibleAssetActivitiesOnConflict>;\n};\n\n/** aggregate avg on columns */\nexport type FungibleAssetActivitiesAvgFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  event_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  storage_refund_amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** order by avg() on columns of table \"fungible_asset_activities\" */\nexport type FungibleAssetActivitiesAvgOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  block_height?: InputMaybe<OrderBy>;\n  event_index?: InputMaybe<OrderBy>;\n  storage_refund_amount?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n};\n\n/** Boolean expression to filter rows from the table \"fungible_asset_activities\". All fields are combined with a logical 'AND'. */\nexport type FungibleAssetActivitiesBoolExp = {\n  _and?: InputMaybe<Array<FungibleAssetActivitiesBoolExp>>;\n  _not?: InputMaybe<FungibleAssetActivitiesBoolExp>;\n  _or?: InputMaybe<Array<FungibleAssetActivitiesBoolExp>>;\n  amount?: InputMaybe<NumericComparisonExp>;\n  asset_type?: InputMaybe<StringComparisonExp>;\n  block_height?: InputMaybe<BigintComparisonExp>;\n  entry_function_id_str?: InputMaybe<StringComparisonExp>;\n  event_index?: InputMaybe<BigintComparisonExp>;\n  gas_fee_payer_address?: InputMaybe<StringComparisonExp>;\n  inserted_at?: InputMaybe<TimestampComparisonExp>;\n  is_frozen?: InputMaybe<BooleanComparisonExp>;\n  is_gas_fee?: InputMaybe<BooleanComparisonExp>;\n  is_transaction_success?: InputMaybe<BooleanComparisonExp>;\n  metadata?: InputMaybe<FungibleAssetMetadataBoolExp>;\n  owner_address?: InputMaybe<StringComparisonExp>;\n  owner_cedra_names?: InputMaybe<CurrentCedraNamesBoolExp>;\n  owner_cedra_names_aggregate?: InputMaybe<CurrentCedraNamesAggregateBoolExp>;\n  storage_id?: InputMaybe<StringComparisonExp>;\n  storage_refund_amount?: InputMaybe<NumericComparisonExp>;\n  token_standard?: InputMaybe<StringComparisonExp>;\n  transaction_timestamp?: InputMaybe<TimestampComparisonExp>;\n  transaction_version?: InputMaybe<BigintComparisonExp>;\n  type?: InputMaybe<StringComparisonExp>;\n};\n\n/** unique or primary key constraints on table \"fungible_asset_activities\" */\nexport enum FungibleAssetActivitiesConstraint {\n  /** unique or primary key constraint on columns \"event_index\", \"transaction_version\" */\n  FungibleAssetActivitiesPkey = \"fungible_asset_activities_pkey\",\n}\n\n/** input type for incrementing numeric columns in table \"fungible_asset_activities\" */\nexport type FungibleAssetActivitiesIncInput = {\n  amount?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  block_height?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  event_index?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  storage_refund_amount?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** input type for inserting data into table \"fungible_asset_activities\" */\nexport type FungibleAssetActivitiesInsertInput = {\n  amount?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  asset_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  block_height?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  entry_function_id_str?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  event_index?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  gas_fee_payer_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  is_frozen?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  is_gas_fee?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  is_transaction_success?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  metadata?: InputMaybe<FungibleAssetMetadataObjRelInsertInput>;\n  owner_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  owner_cedra_names?: InputMaybe<CurrentCedraNamesArrRelInsertInput>;\n  storage_id?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  storage_refund_amount?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  token_standard?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate max on columns */\nexport type FungibleAssetActivitiesMaxFields = {\n  amount?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  asset_type?: Maybe<Scalars[\"String\"][\"output\"]>;\n  block_height?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  entry_function_id_str?: Maybe<Scalars[\"String\"][\"output\"]>;\n  event_index?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  gas_fee_payer_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  owner_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  storage_id?: Maybe<Scalars[\"String\"][\"output\"]>;\n  storage_refund_amount?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  token_standard?: Maybe<Scalars[\"String\"][\"output\"]>;\n  transaction_timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  type?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** order by max() on columns of table \"fungible_asset_activities\" */\nexport type FungibleAssetActivitiesMaxOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  asset_type?: InputMaybe<OrderBy>;\n  block_height?: InputMaybe<OrderBy>;\n  entry_function_id_str?: InputMaybe<OrderBy>;\n  event_index?: InputMaybe<OrderBy>;\n  gas_fee_payer_address?: InputMaybe<OrderBy>;\n  inserted_at?: InputMaybe<OrderBy>;\n  owner_address?: InputMaybe<OrderBy>;\n  storage_id?: InputMaybe<OrderBy>;\n  storage_refund_amount?: InputMaybe<OrderBy>;\n  token_standard?: InputMaybe<OrderBy>;\n  transaction_timestamp?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n  type?: InputMaybe<OrderBy>;\n};\n\n/** aggregate min on columns */\nexport type FungibleAssetActivitiesMinFields = {\n  amount?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  asset_type?: Maybe<Scalars[\"String\"][\"output\"]>;\n  block_height?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  entry_function_id_str?: Maybe<Scalars[\"String\"][\"output\"]>;\n  event_index?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  gas_fee_payer_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  owner_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  storage_id?: Maybe<Scalars[\"String\"][\"output\"]>;\n  storage_refund_amount?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  token_standard?: Maybe<Scalars[\"String\"][\"output\"]>;\n  transaction_timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  type?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** order by min() on columns of table \"fungible_asset_activities\" */\nexport type FungibleAssetActivitiesMinOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  asset_type?: InputMaybe<OrderBy>;\n  block_height?: InputMaybe<OrderBy>;\n  entry_function_id_str?: InputMaybe<OrderBy>;\n  event_index?: InputMaybe<OrderBy>;\n  gas_fee_payer_address?: InputMaybe<OrderBy>;\n  inserted_at?: InputMaybe<OrderBy>;\n  owner_address?: InputMaybe<OrderBy>;\n  storage_id?: InputMaybe<OrderBy>;\n  storage_refund_amount?: InputMaybe<OrderBy>;\n  token_standard?: InputMaybe<OrderBy>;\n  transaction_timestamp?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n  type?: InputMaybe<OrderBy>;\n};\n\n/** response of any mutation on the table \"fungible_asset_activities\" */\nexport type FungibleAssetActivitiesMutationResponse = {\n  /** number of rows affected by the mutation */\n  affected_rows: Scalars[\"Int\"][\"output\"];\n  /** data from the rows affected by the mutation */\n  returning: Array<FungibleAssetActivities>;\n};\n\n/** on_conflict condition type for table \"fungible_asset_activities\" */\nexport type FungibleAssetActivitiesOnConflict = {\n  constraint: FungibleAssetActivitiesConstraint;\n  update_columns?: Array<FungibleAssetActivitiesUpdateColumn>;\n  where?: InputMaybe<FungibleAssetActivitiesBoolExp>;\n};\n\n/** Ordering options when selecting data from \"fungible_asset_activities\". */\nexport type FungibleAssetActivitiesOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  asset_type?: InputMaybe<OrderBy>;\n  block_height?: InputMaybe<OrderBy>;\n  entry_function_id_str?: InputMaybe<OrderBy>;\n  event_index?: InputMaybe<OrderBy>;\n  gas_fee_payer_address?: InputMaybe<OrderBy>;\n  inserted_at?: InputMaybe<OrderBy>;\n  is_frozen?: InputMaybe<OrderBy>;\n  is_gas_fee?: InputMaybe<OrderBy>;\n  is_transaction_success?: InputMaybe<OrderBy>;\n  metadata?: InputMaybe<FungibleAssetMetadataOrderBy>;\n  owner_address?: InputMaybe<OrderBy>;\n  owner_cedra_names_aggregate?: InputMaybe<CurrentCedraNamesAggregateOrderBy>;\n  storage_id?: InputMaybe<OrderBy>;\n  storage_refund_amount?: InputMaybe<OrderBy>;\n  token_standard?: InputMaybe<OrderBy>;\n  transaction_timestamp?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n  type?: InputMaybe<OrderBy>;\n};\n\n/** primary key columns input for table: fungible_asset_activities */\nexport type FungibleAssetActivitiesPkColumnsInput = {\n  event_index: Scalars[\"bigint\"][\"input\"];\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\n/** select columns of table \"fungible_asset_activities\" */\nexport enum FungibleAssetActivitiesSelectColumn {\n  /** column name */\n  Amount = \"amount\",\n  /** column name */\n  AssetType = \"asset_type\",\n  /** column name */\n  BlockHeight = \"block_height\",\n  /** column name */\n  EntryFunctionIdStr = \"entry_function_id_str\",\n  /** column name */\n  EventIndex = \"event_index\",\n  /** column name */\n  GasFeePayerAddress = \"gas_fee_payer_address\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  IsFrozen = \"is_frozen\",\n  /** column name */\n  IsGasFee = \"is_gas_fee\",\n  /** column name */\n  IsTransactionSuccess = \"is_transaction_success\",\n  /** column name */\n  OwnerAddress = \"owner_address\",\n  /** column name */\n  StorageId = \"storage_id\",\n  /** column name */\n  StorageRefundAmount = \"storage_refund_amount\",\n  /** column name */\n  TokenStandard = \"token_standard\",\n  /** column name */\n  TransactionTimestamp = \"transaction_timestamp\",\n  /** column name */\n  TransactionVersion = \"transaction_version\",\n  /** column name */\n  Type = \"type\",\n}\n\n/** select \"fungible_asset_activities_aggregate_bool_exp_bool_and_arguments_columns\" columns of table \"fungible_asset_activities\" */\nexport enum FungibleAssetActivitiesSelectColumnFungibleAssetActivitiesAggregateBoolExpBoolAndArgumentsColumns {\n  /** column name */\n  IsFrozen = \"is_frozen\",\n  /** column name */\n  IsGasFee = \"is_gas_fee\",\n  /** column name */\n  IsTransactionSuccess = \"is_transaction_success\",\n}\n\n/** select \"fungible_asset_activities_aggregate_bool_exp_bool_or_arguments_columns\" columns of table \"fungible_asset_activities\" */\nexport enum FungibleAssetActivitiesSelectColumnFungibleAssetActivitiesAggregateBoolExpBoolOrArgumentsColumns {\n  /** column name */\n  IsFrozen = \"is_frozen\",\n  /** column name */\n  IsGasFee = \"is_gas_fee\",\n  /** column name */\n  IsTransactionSuccess = \"is_transaction_success\",\n}\n\n/** input type for updating data in table \"fungible_asset_activities\" */\nexport type FungibleAssetActivitiesSetInput = {\n  amount?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  asset_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  block_height?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  entry_function_id_str?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  event_index?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  gas_fee_payer_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  is_frozen?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  is_gas_fee?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  is_transaction_success?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  owner_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  storage_id?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  storage_refund_amount?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  token_standard?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate stddev on columns */\nexport type FungibleAssetActivitiesStddevFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  event_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  storage_refund_amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** order by stddev() on columns of table \"fungible_asset_activities\" */\nexport type FungibleAssetActivitiesStddevOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  block_height?: InputMaybe<OrderBy>;\n  event_index?: InputMaybe<OrderBy>;\n  storage_refund_amount?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n};\n\n/** aggregate stddev_pop on columns */\nexport type FungibleAssetActivitiesStddevPopFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  event_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  storage_refund_amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** order by stddev_pop() on columns of table \"fungible_asset_activities\" */\nexport type FungibleAssetActivitiesStddevPopOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  block_height?: InputMaybe<OrderBy>;\n  event_index?: InputMaybe<OrderBy>;\n  storage_refund_amount?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n};\n\n/** aggregate stddev_samp on columns */\nexport type FungibleAssetActivitiesStddevSampFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  event_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  storage_refund_amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** order by stddev_samp() on columns of table \"fungible_asset_activities\" */\nexport type FungibleAssetActivitiesStddevSampOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  block_height?: InputMaybe<OrderBy>;\n  event_index?: InputMaybe<OrderBy>;\n  storage_refund_amount?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n};\n\n/** Streaming cursor of the table \"fungible_asset_activities\" */\nexport type FungibleAssetActivitiesStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: FungibleAssetActivitiesStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type FungibleAssetActivitiesStreamCursorValueInput = {\n  amount?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  asset_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  block_height?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  entry_function_id_str?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  event_index?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  gas_fee_payer_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  is_frozen?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  is_gas_fee?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  is_transaction_success?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  owner_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  storage_id?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  storage_refund_amount?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  token_standard?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate sum on columns */\nexport type FungibleAssetActivitiesSumFields = {\n  amount?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  block_height?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  event_index?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  storage_refund_amount?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** order by sum() on columns of table \"fungible_asset_activities\" */\nexport type FungibleAssetActivitiesSumOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  block_height?: InputMaybe<OrderBy>;\n  event_index?: InputMaybe<OrderBy>;\n  storage_refund_amount?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n};\n\n/** update columns of table \"fungible_asset_activities\" */\nexport enum FungibleAssetActivitiesUpdateColumn {\n  /** column name */\n  Amount = \"amount\",\n  /** column name */\n  AssetType = \"asset_type\",\n  /** column name */\n  BlockHeight = \"block_height\",\n  /** column name */\n  EntryFunctionIdStr = \"entry_function_id_str\",\n  /** column name */\n  EventIndex = \"event_index\",\n  /** column name */\n  GasFeePayerAddress = \"gas_fee_payer_address\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  IsFrozen = \"is_frozen\",\n  /** column name */\n  IsGasFee = \"is_gas_fee\",\n  /** column name */\n  IsTransactionSuccess = \"is_transaction_success\",\n  /** column name */\n  OwnerAddress = \"owner_address\",\n  /** column name */\n  StorageId = \"storage_id\",\n  /** column name */\n  StorageRefundAmount = \"storage_refund_amount\",\n  /** column name */\n  TokenStandard = \"token_standard\",\n  /** column name */\n  TransactionTimestamp = \"transaction_timestamp\",\n  /** column name */\n  TransactionVersion = \"transaction_version\",\n  /** column name */\n  Type = \"type\",\n}\n\nexport type FungibleAssetActivitiesUpdates = {\n  /** increments the numeric columns with given value of the filtered values */\n  _inc?: InputMaybe<FungibleAssetActivitiesIncInput>;\n  /** sets the columns of the filtered rows to the given values */\n  _set?: InputMaybe<FungibleAssetActivitiesSetInput>;\n  /** filter the rows which have to be updated */\n  where: FungibleAssetActivitiesBoolExp;\n};\n\n/** aggregate var_pop on columns */\nexport type FungibleAssetActivitiesVarPopFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  event_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  storage_refund_amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** order by var_pop() on columns of table \"fungible_asset_activities\" */\nexport type FungibleAssetActivitiesVarPopOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  block_height?: InputMaybe<OrderBy>;\n  event_index?: InputMaybe<OrderBy>;\n  storage_refund_amount?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n};\n\n/** aggregate var_samp on columns */\nexport type FungibleAssetActivitiesVarSampFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  event_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  storage_refund_amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** order by var_samp() on columns of table \"fungible_asset_activities\" */\nexport type FungibleAssetActivitiesVarSampOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  block_height?: InputMaybe<OrderBy>;\n  event_index?: InputMaybe<OrderBy>;\n  storage_refund_amount?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n};\n\n/** aggregate variance on columns */\nexport type FungibleAssetActivitiesVarianceFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  event_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  storage_refund_amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** order by variance() on columns of table \"fungible_asset_activities\" */\nexport type FungibleAssetActivitiesVarianceOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  block_height?: InputMaybe<OrderBy>;\n  event_index?: InputMaybe<OrderBy>;\n  storage_refund_amount?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n};\n\n/** columns and relationships of \"fungible_asset_balances\" */\nexport type FungibleAssetBalances = {\n  amount: Scalars[\"numeric\"][\"output\"];\n  asset_type: Scalars[\"String\"][\"output\"];\n  inserted_at: Scalars[\"timestamp\"][\"output\"];\n  is_frozen: Scalars[\"Boolean\"][\"output\"];\n  is_primary: Scalars[\"Boolean\"][\"output\"];\n  owner_address: Scalars[\"String\"][\"output\"];\n  storage_id: Scalars[\"String\"][\"output\"];\n  token_standard: Scalars[\"String\"][\"output\"];\n  transaction_timestamp: Scalars[\"timestamp\"][\"output\"];\n  transaction_version: Scalars[\"bigint\"][\"output\"];\n  write_set_change_index: Scalars[\"bigint\"][\"output\"];\n};\n\n/** aggregated selection of \"fungible_asset_balances\" */\nexport type FungibleAssetBalancesAggregate = {\n  aggregate?: Maybe<FungibleAssetBalancesAggregateFields>;\n  nodes: Array<FungibleAssetBalances>;\n};\n\n/** aggregate fields of \"fungible_asset_balances\" */\nexport type FungibleAssetBalancesAggregateFields = {\n  avg?: Maybe<FungibleAssetBalancesAvgFields>;\n  count: Scalars[\"Int\"][\"output\"];\n  max?: Maybe<FungibleAssetBalancesMaxFields>;\n  min?: Maybe<FungibleAssetBalancesMinFields>;\n  stddev?: Maybe<FungibleAssetBalancesStddevFields>;\n  stddev_pop?: Maybe<FungibleAssetBalancesStddevPopFields>;\n  stddev_samp?: Maybe<FungibleAssetBalancesStddevSampFields>;\n  sum?: Maybe<FungibleAssetBalancesSumFields>;\n  var_pop?: Maybe<FungibleAssetBalancesVarPopFields>;\n  var_samp?: Maybe<FungibleAssetBalancesVarSampFields>;\n  variance?: Maybe<FungibleAssetBalancesVarianceFields>;\n};\n\n/** aggregate fields of \"fungible_asset_balances\" */\nexport type FungibleAssetBalancesAggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<FungibleAssetBalancesSelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** aggregate avg on columns */\nexport type FungibleAssetBalancesAvgFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Boolean expression to filter rows from the table \"fungible_asset_balances\". All fields are combined with a logical 'AND'. */\nexport type FungibleAssetBalancesBoolExp = {\n  _and?: InputMaybe<Array<FungibleAssetBalancesBoolExp>>;\n  _not?: InputMaybe<FungibleAssetBalancesBoolExp>;\n  _or?: InputMaybe<Array<FungibleAssetBalancesBoolExp>>;\n  amount?: InputMaybe<NumericComparisonExp>;\n  asset_type?: InputMaybe<StringComparisonExp>;\n  inserted_at?: InputMaybe<TimestampComparisonExp>;\n  is_frozen?: InputMaybe<BooleanComparisonExp>;\n  is_primary?: InputMaybe<BooleanComparisonExp>;\n  owner_address?: InputMaybe<StringComparisonExp>;\n  storage_id?: InputMaybe<StringComparisonExp>;\n  token_standard?: InputMaybe<StringComparisonExp>;\n  transaction_timestamp?: InputMaybe<TimestampComparisonExp>;\n  transaction_version?: InputMaybe<BigintComparisonExp>;\n  write_set_change_index?: InputMaybe<BigintComparisonExp>;\n};\n\n/** unique or primary key constraints on table \"fungible_asset_balances\" */\nexport enum FungibleAssetBalancesConstraint {\n  /** unique or primary key constraint on columns \"write_set_change_index\", \"transaction_version\" */\n  FungibleAssetBalancesPkey = \"fungible_asset_balances_pkey\",\n}\n\n/** input type for incrementing numeric columns in table \"fungible_asset_balances\" */\nexport type FungibleAssetBalancesIncInput = {\n  amount?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  write_set_change_index?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** input type for inserting data into table \"fungible_asset_balances\" */\nexport type FungibleAssetBalancesInsertInput = {\n  amount?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  asset_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  is_frozen?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  is_primary?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  owner_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  storage_id?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_standard?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  write_set_change_index?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** aggregate max on columns */\nexport type FungibleAssetBalancesMaxFields = {\n  amount?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  asset_type?: Maybe<Scalars[\"String\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  owner_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  storage_id?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_standard?: Maybe<Scalars[\"String\"][\"output\"]>;\n  transaction_timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** aggregate min on columns */\nexport type FungibleAssetBalancesMinFields = {\n  amount?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  asset_type?: Maybe<Scalars[\"String\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  owner_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  storage_id?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_standard?: Maybe<Scalars[\"String\"][\"output\"]>;\n  transaction_timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** response of any mutation on the table \"fungible_asset_balances\" */\nexport type FungibleAssetBalancesMutationResponse = {\n  /** number of rows affected by the mutation */\n  affected_rows: Scalars[\"Int\"][\"output\"];\n  /** data from the rows affected by the mutation */\n  returning: Array<FungibleAssetBalances>;\n};\n\n/** on_conflict condition type for table \"fungible_asset_balances\" */\nexport type FungibleAssetBalancesOnConflict = {\n  constraint: FungibleAssetBalancesConstraint;\n  update_columns?: Array<FungibleAssetBalancesUpdateColumn>;\n  where?: InputMaybe<FungibleAssetBalancesBoolExp>;\n};\n\n/** Ordering options when selecting data from \"fungible_asset_balances\". */\nexport type FungibleAssetBalancesOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  asset_type?: InputMaybe<OrderBy>;\n  inserted_at?: InputMaybe<OrderBy>;\n  is_frozen?: InputMaybe<OrderBy>;\n  is_primary?: InputMaybe<OrderBy>;\n  owner_address?: InputMaybe<OrderBy>;\n  storage_id?: InputMaybe<OrderBy>;\n  token_standard?: InputMaybe<OrderBy>;\n  transaction_timestamp?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n  write_set_change_index?: InputMaybe<OrderBy>;\n};\n\n/** primary key columns input for table: fungible_asset_balances */\nexport type FungibleAssetBalancesPkColumnsInput = {\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n  write_set_change_index: Scalars[\"bigint\"][\"input\"];\n};\n\n/** select columns of table \"fungible_asset_balances\" */\nexport enum FungibleAssetBalancesSelectColumn {\n  /** column name */\n  Amount = \"amount\",\n  /** column name */\n  AssetType = \"asset_type\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  IsFrozen = \"is_frozen\",\n  /** column name */\n  IsPrimary = \"is_primary\",\n  /** column name */\n  OwnerAddress = \"owner_address\",\n  /** column name */\n  StorageId = \"storage_id\",\n  /** column name */\n  TokenStandard = \"token_standard\",\n  /** column name */\n  TransactionTimestamp = \"transaction_timestamp\",\n  /** column name */\n  TransactionVersion = \"transaction_version\",\n  /** column name */\n  WriteSetChangeIndex = \"write_set_change_index\",\n}\n\n/** input type for updating data in table \"fungible_asset_balances\" */\nexport type FungibleAssetBalancesSetInput = {\n  amount?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  asset_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  is_frozen?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  is_primary?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  owner_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  storage_id?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_standard?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  write_set_change_index?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** aggregate stddev on columns */\nexport type FungibleAssetBalancesStddevFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_pop on columns */\nexport type FungibleAssetBalancesStddevPopFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_samp on columns */\nexport type FungibleAssetBalancesStddevSampFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Streaming cursor of the table \"fungible_asset_balances\" */\nexport type FungibleAssetBalancesStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: FungibleAssetBalancesStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type FungibleAssetBalancesStreamCursorValueInput = {\n  amount?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  asset_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  is_frozen?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  is_primary?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  owner_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  storage_id?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_standard?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  write_set_change_index?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** aggregate sum on columns */\nexport type FungibleAssetBalancesSumFields = {\n  amount?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** update columns of table \"fungible_asset_balances\" */\nexport enum FungibleAssetBalancesUpdateColumn {\n  /** column name */\n  Amount = \"amount\",\n  /** column name */\n  AssetType = \"asset_type\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  IsFrozen = \"is_frozen\",\n  /** column name */\n  IsPrimary = \"is_primary\",\n  /** column name */\n  OwnerAddress = \"owner_address\",\n  /** column name */\n  StorageId = \"storage_id\",\n  /** column name */\n  TokenStandard = \"token_standard\",\n  /** column name */\n  TransactionTimestamp = \"transaction_timestamp\",\n  /** column name */\n  TransactionVersion = \"transaction_version\",\n  /** column name */\n  WriteSetChangeIndex = \"write_set_change_index\",\n}\n\nexport type FungibleAssetBalancesUpdates = {\n  /** increments the numeric columns with given value of the filtered values */\n  _inc?: InputMaybe<FungibleAssetBalancesIncInput>;\n  /** sets the columns of the filtered rows to the given values */\n  _set?: InputMaybe<FungibleAssetBalancesSetInput>;\n  /** filter the rows which have to be updated */\n  where: FungibleAssetBalancesBoolExp;\n};\n\n/** aggregate var_pop on columns */\nexport type FungibleAssetBalancesVarPopFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate var_samp on columns */\nexport type FungibleAssetBalancesVarSampFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate variance on columns */\nexport type FungibleAssetBalancesVarianceFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** columns and relationships of \"fungible_asset_metadata\" */\nexport type FungibleAssetMetadata = {\n  asset_type: Scalars[\"String\"][\"output\"];\n  creator_address: Scalars[\"String\"][\"output\"];\n  decimals: Scalars[\"Int\"][\"output\"];\n  icon_uri?: Maybe<Scalars[\"String\"][\"output\"]>;\n  inserted_at: Scalars[\"timestamp\"][\"output\"];\n  is_token_v2?: Maybe<Scalars[\"Boolean\"][\"output\"]>;\n  last_transaction_timestamp: Scalars[\"timestamp\"][\"output\"];\n  last_transaction_version: Scalars[\"bigint\"][\"output\"];\n  maximum_v2?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  name: Scalars[\"String\"][\"output\"];\n  project_uri?: Maybe<Scalars[\"String\"][\"output\"]>;\n  supply_aggregator_table_handle_v1?: Maybe<Scalars[\"String\"][\"output\"]>;\n  supply_aggregator_table_key_v1?: Maybe<Scalars[\"String\"][\"output\"]>;\n  supply_v2?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  symbol: Scalars[\"String\"][\"output\"];\n  token_standard: Scalars[\"String\"][\"output\"];\n};\n\n/** aggregated selection of \"fungible_asset_metadata\" */\nexport type FungibleAssetMetadataAggregate = {\n  aggregate?: Maybe<FungibleAssetMetadataAggregateFields>;\n  nodes: Array<FungibleAssetMetadata>;\n};\n\n/** aggregate fields of \"fungible_asset_metadata\" */\nexport type FungibleAssetMetadataAggregateFields = {\n  avg?: Maybe<FungibleAssetMetadataAvgFields>;\n  count: Scalars[\"Int\"][\"output\"];\n  max?: Maybe<FungibleAssetMetadataMaxFields>;\n  min?: Maybe<FungibleAssetMetadataMinFields>;\n  stddev?: Maybe<FungibleAssetMetadataStddevFields>;\n  stddev_pop?: Maybe<FungibleAssetMetadataStddevPopFields>;\n  stddev_samp?: Maybe<FungibleAssetMetadataStddevSampFields>;\n  sum?: Maybe<FungibleAssetMetadataSumFields>;\n  var_pop?: Maybe<FungibleAssetMetadataVarPopFields>;\n  var_samp?: Maybe<FungibleAssetMetadataVarSampFields>;\n  variance?: Maybe<FungibleAssetMetadataVarianceFields>;\n};\n\n/** aggregate fields of \"fungible_asset_metadata\" */\nexport type FungibleAssetMetadataAggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<FungibleAssetMetadataSelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** aggregate avg on columns */\nexport type FungibleAssetMetadataAvgFields = {\n  decimals?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  maximum_v2?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  supply_v2?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Boolean expression to filter rows from the table \"fungible_asset_metadata\". All fields are combined with a logical 'AND'. */\nexport type FungibleAssetMetadataBoolExp = {\n  _and?: InputMaybe<Array<FungibleAssetMetadataBoolExp>>;\n  _not?: InputMaybe<FungibleAssetMetadataBoolExp>;\n  _or?: InputMaybe<Array<FungibleAssetMetadataBoolExp>>;\n  asset_type?: InputMaybe<StringComparisonExp>;\n  creator_address?: InputMaybe<StringComparisonExp>;\n  decimals?: InputMaybe<IntComparisonExp>;\n  icon_uri?: InputMaybe<StringComparisonExp>;\n  inserted_at?: InputMaybe<TimestampComparisonExp>;\n  is_token_v2?: InputMaybe<BooleanComparisonExp>;\n  last_transaction_timestamp?: InputMaybe<TimestampComparisonExp>;\n  last_transaction_version?: InputMaybe<BigintComparisonExp>;\n  maximum_v2?: InputMaybe<NumericComparisonExp>;\n  name?: InputMaybe<StringComparisonExp>;\n  project_uri?: InputMaybe<StringComparisonExp>;\n  supply_aggregator_table_handle_v1?: InputMaybe<StringComparisonExp>;\n  supply_aggregator_table_key_v1?: InputMaybe<StringComparisonExp>;\n  supply_v2?: InputMaybe<NumericComparisonExp>;\n  symbol?: InputMaybe<StringComparisonExp>;\n  token_standard?: InputMaybe<StringComparisonExp>;\n};\n\n/** unique or primary key constraints on table \"fungible_asset_metadata\" */\nexport enum FungibleAssetMetadataConstraint {\n  /** unique or primary key constraint on columns \"asset_type\" */\n  FungibleAssetMetadataPkey = \"fungible_asset_metadata_pkey\",\n}\n\n/** input type for incrementing numeric columns in table \"fungible_asset_metadata\" */\nexport type FungibleAssetMetadataIncInput = {\n  decimals?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  maximum_v2?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  supply_v2?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n};\n\n/** input type for inserting data into table \"fungible_asset_metadata\" */\nexport type FungibleAssetMetadataInsertInput = {\n  asset_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  creator_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  decimals?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  icon_uri?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  is_token_v2?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  last_transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  maximum_v2?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  project_uri?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  supply_aggregator_table_handle_v1?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  supply_aggregator_table_key_v1?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  supply_v2?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  symbol?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_standard?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate max on columns */\nexport type FungibleAssetMetadataMaxFields = {\n  asset_type?: Maybe<Scalars[\"String\"][\"output\"]>;\n  creator_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  decimals?: Maybe<Scalars[\"Int\"][\"output\"]>;\n  icon_uri?: Maybe<Scalars[\"String\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  last_transaction_timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  maximum_v2?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  name?: Maybe<Scalars[\"String\"][\"output\"]>;\n  project_uri?: Maybe<Scalars[\"String\"][\"output\"]>;\n  supply_aggregator_table_handle_v1?: Maybe<Scalars[\"String\"][\"output\"]>;\n  supply_aggregator_table_key_v1?: Maybe<Scalars[\"String\"][\"output\"]>;\n  supply_v2?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  symbol?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_standard?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** aggregate min on columns */\nexport type FungibleAssetMetadataMinFields = {\n  asset_type?: Maybe<Scalars[\"String\"][\"output\"]>;\n  creator_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  decimals?: Maybe<Scalars[\"Int\"][\"output\"]>;\n  icon_uri?: Maybe<Scalars[\"String\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  last_transaction_timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  maximum_v2?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  name?: Maybe<Scalars[\"String\"][\"output\"]>;\n  project_uri?: Maybe<Scalars[\"String\"][\"output\"]>;\n  supply_aggregator_table_handle_v1?: Maybe<Scalars[\"String\"][\"output\"]>;\n  supply_aggregator_table_key_v1?: Maybe<Scalars[\"String\"][\"output\"]>;\n  supply_v2?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  symbol?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_standard?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** response of any mutation on the table \"fungible_asset_metadata\" */\nexport type FungibleAssetMetadataMutationResponse = {\n  /** number of rows affected by the mutation */\n  affected_rows: Scalars[\"Int\"][\"output\"];\n  /** data from the rows affected by the mutation */\n  returning: Array<FungibleAssetMetadata>;\n};\n\n/** input type for inserting object relation for remote table \"fungible_asset_metadata\" */\nexport type FungibleAssetMetadataObjRelInsertInput = {\n  data: FungibleAssetMetadataInsertInput;\n  /** upsert condition */\n  on_conflict?: InputMaybe<FungibleAssetMetadataOnConflict>;\n};\n\n/** on_conflict condition type for table \"fungible_asset_metadata\" */\nexport type FungibleAssetMetadataOnConflict = {\n  constraint: FungibleAssetMetadataConstraint;\n  update_columns?: Array<FungibleAssetMetadataUpdateColumn>;\n  where?: InputMaybe<FungibleAssetMetadataBoolExp>;\n};\n\n/** Ordering options when selecting data from \"fungible_asset_metadata\". */\nexport type FungibleAssetMetadataOrderBy = {\n  asset_type?: InputMaybe<OrderBy>;\n  creator_address?: InputMaybe<OrderBy>;\n  decimals?: InputMaybe<OrderBy>;\n  icon_uri?: InputMaybe<OrderBy>;\n  inserted_at?: InputMaybe<OrderBy>;\n  is_token_v2?: InputMaybe<OrderBy>;\n  last_transaction_timestamp?: InputMaybe<OrderBy>;\n  last_transaction_version?: InputMaybe<OrderBy>;\n  maximum_v2?: InputMaybe<OrderBy>;\n  name?: InputMaybe<OrderBy>;\n  project_uri?: InputMaybe<OrderBy>;\n  supply_aggregator_table_handle_v1?: InputMaybe<OrderBy>;\n  supply_aggregator_table_key_v1?: InputMaybe<OrderBy>;\n  supply_v2?: InputMaybe<OrderBy>;\n  symbol?: InputMaybe<OrderBy>;\n  token_standard?: InputMaybe<OrderBy>;\n};\n\n/** primary key columns input for table: fungible_asset_metadata */\nexport type FungibleAssetMetadataPkColumnsInput = {\n  asset_type: Scalars[\"String\"][\"input\"];\n};\n\n/** select columns of table \"fungible_asset_metadata\" */\nexport enum FungibleAssetMetadataSelectColumn {\n  /** column name */\n  AssetType = \"asset_type\",\n  /** column name */\n  CreatorAddress = \"creator_address\",\n  /** column name */\n  Decimals = \"decimals\",\n  /** column name */\n  IconUri = \"icon_uri\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  IsTokenV2 = \"is_token_v2\",\n  /** column name */\n  LastTransactionTimestamp = \"last_transaction_timestamp\",\n  /** column name */\n  LastTransactionVersion = \"last_transaction_version\",\n  /** column name */\n  MaximumV2 = \"maximum_v2\",\n  /** column name */\n  Name = \"name\",\n  /** column name */\n  ProjectUri = \"project_uri\",\n  /** column name */\n  SupplyAggregatorTableHandleV1 = \"supply_aggregator_table_handle_v1\",\n  /** column name */\n  SupplyAggregatorTableKeyV1 = \"supply_aggregator_table_key_v1\",\n  /** column name */\n  SupplyV2 = \"supply_v2\",\n  /** column name */\n  Symbol = \"symbol\",\n  /** column name */\n  TokenStandard = \"token_standard\",\n}\n\n/** input type for updating data in table \"fungible_asset_metadata\" */\nexport type FungibleAssetMetadataSetInput = {\n  asset_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  creator_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  decimals?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  icon_uri?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  is_token_v2?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  last_transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  maximum_v2?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  project_uri?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  supply_aggregator_table_handle_v1?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  supply_aggregator_table_key_v1?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  supply_v2?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  symbol?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_standard?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate stddev on columns */\nexport type FungibleAssetMetadataStddevFields = {\n  decimals?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  maximum_v2?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  supply_v2?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_pop on columns */\nexport type FungibleAssetMetadataStddevPopFields = {\n  decimals?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  maximum_v2?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  supply_v2?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_samp on columns */\nexport type FungibleAssetMetadataStddevSampFields = {\n  decimals?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  maximum_v2?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  supply_v2?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Streaming cursor of the table \"fungible_asset_metadata\" */\nexport type FungibleAssetMetadataStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: FungibleAssetMetadataStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type FungibleAssetMetadataStreamCursorValueInput = {\n  asset_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  creator_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  decimals?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  icon_uri?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  is_token_v2?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  last_transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  maximum_v2?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  project_uri?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  supply_aggregator_table_handle_v1?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  supply_aggregator_table_key_v1?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  supply_v2?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  symbol?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_standard?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate sum on columns */\nexport type FungibleAssetMetadataSumFields = {\n  decimals?: Maybe<Scalars[\"Int\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  maximum_v2?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  supply_v2?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n};\n\n/** update columns of table \"fungible_asset_metadata\" */\nexport enum FungibleAssetMetadataUpdateColumn {\n  /** column name */\n  AssetType = \"asset_type\",\n  /** column name */\n  CreatorAddress = \"creator_address\",\n  /** column name */\n  Decimals = \"decimals\",\n  /** column name */\n  IconUri = \"icon_uri\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  IsTokenV2 = \"is_token_v2\",\n  /** column name */\n  LastTransactionTimestamp = \"last_transaction_timestamp\",\n  /** column name */\n  LastTransactionVersion = \"last_transaction_version\",\n  /** column name */\n  MaximumV2 = \"maximum_v2\",\n  /** column name */\n  Name = \"name\",\n  /** column name */\n  ProjectUri = \"project_uri\",\n  /** column name */\n  SupplyAggregatorTableHandleV1 = \"supply_aggregator_table_handle_v1\",\n  /** column name */\n  SupplyAggregatorTableKeyV1 = \"supply_aggregator_table_key_v1\",\n  /** column name */\n  SupplyV2 = \"supply_v2\",\n  /** column name */\n  Symbol = \"symbol\",\n  /** column name */\n  TokenStandard = \"token_standard\",\n}\n\nexport type FungibleAssetMetadataUpdates = {\n  /** increments the numeric columns with given value of the filtered values */\n  _inc?: InputMaybe<FungibleAssetMetadataIncInput>;\n  /** sets the columns of the filtered rows to the given values */\n  _set?: InputMaybe<FungibleAssetMetadataSetInput>;\n  /** filter the rows which have to be updated */\n  where: FungibleAssetMetadataBoolExp;\n};\n\n/** aggregate var_pop on columns */\nexport type FungibleAssetMetadataVarPopFields = {\n  decimals?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  maximum_v2?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  supply_v2?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate var_samp on columns */\nexport type FungibleAssetMetadataVarSampFields = {\n  decimals?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  maximum_v2?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  supply_v2?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate variance on columns */\nexport type FungibleAssetMetadataVarianceFields = {\n  decimals?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  maximum_v2?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  supply_v2?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** columns and relationships of \"fungible_asset_to_coin_mappings\" */\nexport type FungibleAssetToCoinMappings = {\n  coin_type: Scalars[\"String\"][\"output\"];\n  fungible_asset_metadata_address: Scalars[\"String\"][\"output\"];\n  last_transaction_version: Scalars[\"bigint\"][\"output\"];\n};\n\n/** aggregated selection of \"fungible_asset_to_coin_mappings\" */\nexport type FungibleAssetToCoinMappingsAggregate = {\n  aggregate?: Maybe<FungibleAssetToCoinMappingsAggregateFields>;\n  nodes: Array<FungibleAssetToCoinMappings>;\n};\n\n/** aggregate fields of \"fungible_asset_to_coin_mappings\" */\nexport type FungibleAssetToCoinMappingsAggregateFields = {\n  avg?: Maybe<FungibleAssetToCoinMappingsAvgFields>;\n  count: Scalars[\"Int\"][\"output\"];\n  max?: Maybe<FungibleAssetToCoinMappingsMaxFields>;\n  min?: Maybe<FungibleAssetToCoinMappingsMinFields>;\n  stddev?: Maybe<FungibleAssetToCoinMappingsStddevFields>;\n  stddev_pop?: Maybe<FungibleAssetToCoinMappingsStddevPopFields>;\n  stddev_samp?: Maybe<FungibleAssetToCoinMappingsStddevSampFields>;\n  sum?: Maybe<FungibleAssetToCoinMappingsSumFields>;\n  var_pop?: Maybe<FungibleAssetToCoinMappingsVarPopFields>;\n  var_samp?: Maybe<FungibleAssetToCoinMappingsVarSampFields>;\n  variance?: Maybe<FungibleAssetToCoinMappingsVarianceFields>;\n};\n\n/** aggregate fields of \"fungible_asset_to_coin_mappings\" */\nexport type FungibleAssetToCoinMappingsAggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<FungibleAssetToCoinMappingsSelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** aggregate avg on columns */\nexport type FungibleAssetToCoinMappingsAvgFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Boolean expression to filter rows from the table \"fungible_asset_to_coin_mappings\". All fields are combined with a logical 'AND'. */\nexport type FungibleAssetToCoinMappingsBoolExp = {\n  _and?: InputMaybe<Array<FungibleAssetToCoinMappingsBoolExp>>;\n  _not?: InputMaybe<FungibleAssetToCoinMappingsBoolExp>;\n  _or?: InputMaybe<Array<FungibleAssetToCoinMappingsBoolExp>>;\n  coin_type?: InputMaybe<StringComparisonExp>;\n  fungible_asset_metadata_address?: InputMaybe<StringComparisonExp>;\n  last_transaction_version?: InputMaybe<BigintComparisonExp>;\n};\n\n/** unique or primary key constraints on table \"fungible_asset_to_coin_mappings\" */\nexport enum FungibleAssetToCoinMappingsConstraint {\n  /** unique or primary key constraint on columns \"fungible_asset_metadata_address\" */\n  FungibleAssetToCoinMappingsPkey = \"fungible_asset_to_coin_mappings_pkey\",\n}\n\n/** input type for incrementing numeric columns in table \"fungible_asset_to_coin_mappings\" */\nexport type FungibleAssetToCoinMappingsIncInput = {\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** input type for inserting data into table \"fungible_asset_to_coin_mappings\" */\nexport type FungibleAssetToCoinMappingsInsertInput = {\n  coin_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  fungible_asset_metadata_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** aggregate max on columns */\nexport type FungibleAssetToCoinMappingsMaxFields = {\n  coin_type?: Maybe<Scalars[\"String\"][\"output\"]>;\n  fungible_asset_metadata_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** aggregate min on columns */\nexport type FungibleAssetToCoinMappingsMinFields = {\n  coin_type?: Maybe<Scalars[\"String\"][\"output\"]>;\n  fungible_asset_metadata_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** response of any mutation on the table \"fungible_asset_to_coin_mappings\" */\nexport type FungibleAssetToCoinMappingsMutationResponse = {\n  /** number of rows affected by the mutation */\n  affected_rows: Scalars[\"Int\"][\"output\"];\n  /** data from the rows affected by the mutation */\n  returning: Array<FungibleAssetToCoinMappings>;\n};\n\n/** on_conflict condition type for table \"fungible_asset_to_coin_mappings\" */\nexport type FungibleAssetToCoinMappingsOnConflict = {\n  constraint: FungibleAssetToCoinMappingsConstraint;\n  update_columns?: Array<FungibleAssetToCoinMappingsUpdateColumn>;\n  where?: InputMaybe<FungibleAssetToCoinMappingsBoolExp>;\n};\n\n/** Ordering options when selecting data from \"fungible_asset_to_coin_mappings\". */\nexport type FungibleAssetToCoinMappingsOrderBy = {\n  coin_type?: InputMaybe<OrderBy>;\n  fungible_asset_metadata_address?: InputMaybe<OrderBy>;\n  last_transaction_version?: InputMaybe<OrderBy>;\n};\n\n/** primary key columns input for table: fungible_asset_to_coin_mappings */\nexport type FungibleAssetToCoinMappingsPkColumnsInput = {\n  fungible_asset_metadata_address: Scalars[\"String\"][\"input\"];\n};\n\n/** select columns of table \"fungible_asset_to_coin_mappings\" */\nexport enum FungibleAssetToCoinMappingsSelectColumn {\n  /** column name */\n  CoinType = \"coin_type\",\n  /** column name */\n  FungibleAssetMetadataAddress = \"fungible_asset_metadata_address\",\n  /** column name */\n  LastTransactionVersion = \"last_transaction_version\",\n}\n\n/** input type for updating data in table \"fungible_asset_to_coin_mappings\" */\nexport type FungibleAssetToCoinMappingsSetInput = {\n  coin_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  fungible_asset_metadata_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** aggregate stddev on columns */\nexport type FungibleAssetToCoinMappingsStddevFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_pop on columns */\nexport type FungibleAssetToCoinMappingsStddevPopFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_samp on columns */\nexport type FungibleAssetToCoinMappingsStddevSampFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Streaming cursor of the table \"fungible_asset_to_coin_mappings\" */\nexport type FungibleAssetToCoinMappingsStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: FungibleAssetToCoinMappingsStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type FungibleAssetToCoinMappingsStreamCursorValueInput = {\n  coin_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  fungible_asset_metadata_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** aggregate sum on columns */\nexport type FungibleAssetToCoinMappingsSumFields = {\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** update columns of table \"fungible_asset_to_coin_mappings\" */\nexport enum FungibleAssetToCoinMappingsUpdateColumn {\n  /** column name */\n  CoinType = \"coin_type\",\n  /** column name */\n  FungibleAssetMetadataAddress = \"fungible_asset_metadata_address\",\n  /** column name */\n  LastTransactionVersion = \"last_transaction_version\",\n}\n\nexport type FungibleAssetToCoinMappingsUpdates = {\n  /** increments the numeric columns with given value of the filtered values */\n  _inc?: InputMaybe<FungibleAssetToCoinMappingsIncInput>;\n  /** sets the columns of the filtered rows to the given values */\n  _set?: InputMaybe<FungibleAssetToCoinMappingsSetInput>;\n  /** filter the rows which have to be updated */\n  where: FungibleAssetToCoinMappingsBoolExp;\n};\n\n/** aggregate var_pop on columns */\nexport type FungibleAssetToCoinMappingsVarPopFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate var_samp on columns */\nexport type FungibleAssetToCoinMappingsVarSampFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate variance on columns */\nexport type FungibleAssetToCoinMappingsVarianceFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** columns and relationships of \"gas_fees\" */\nexport type GasFees = {\n  amount?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  block_height: Scalars[\"bigint\"][\"output\"];\n  entry_function_id_str?: Maybe<Scalars[\"String\"][\"output\"]>;\n  gas_fee_payer_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  is_transaction_success: Scalars[\"Boolean\"][\"output\"];\n  owner_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  storage_refund_amount: Scalars[\"numeric\"][\"output\"];\n  transaction_timestamp: Scalars[\"timestamp\"][\"output\"];\n  transaction_version: Scalars[\"bigint\"][\"output\"];\n};\n\n/** aggregated selection of \"gas_fees\" */\nexport type GasFeesAggregate = {\n  aggregate?: Maybe<GasFeesAggregateFields>;\n  nodes: Array<GasFees>;\n};\n\n/** aggregate fields of \"gas_fees\" */\nexport type GasFeesAggregateFields = {\n  avg?: Maybe<GasFeesAvgFields>;\n  count: Scalars[\"Int\"][\"output\"];\n  max?: Maybe<GasFeesMaxFields>;\n  min?: Maybe<GasFeesMinFields>;\n  stddev?: Maybe<GasFeesStddevFields>;\n  stddev_pop?: Maybe<GasFeesStddevPopFields>;\n  stddev_samp?: Maybe<GasFeesStddevSampFields>;\n  sum?: Maybe<GasFeesSumFields>;\n  var_pop?: Maybe<GasFeesVarPopFields>;\n  var_samp?: Maybe<GasFeesVarSampFields>;\n  variance?: Maybe<GasFeesVarianceFields>;\n};\n\n/** aggregate fields of \"gas_fees\" */\nexport type GasFeesAggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<GasFeesSelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** aggregate avg on columns */\nexport type GasFeesAvgFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  storage_refund_amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Boolean expression to filter rows from the table \"gas_fees\". All fields are combined with a logical 'AND'. */\nexport type GasFeesBoolExp = {\n  _and?: InputMaybe<Array<GasFeesBoolExp>>;\n  _not?: InputMaybe<GasFeesBoolExp>;\n  _or?: InputMaybe<Array<GasFeesBoolExp>>;\n  amount?: InputMaybe<NumericComparisonExp>;\n  block_height?: InputMaybe<BigintComparisonExp>;\n  entry_function_id_str?: InputMaybe<StringComparisonExp>;\n  gas_fee_payer_address?: InputMaybe<StringComparisonExp>;\n  is_transaction_success?: InputMaybe<BooleanComparisonExp>;\n  owner_address?: InputMaybe<StringComparisonExp>;\n  storage_refund_amount?: InputMaybe<NumericComparisonExp>;\n  transaction_timestamp?: InputMaybe<TimestampComparisonExp>;\n  transaction_version?: InputMaybe<BigintComparisonExp>;\n};\n\n/** unique or primary key constraints on table \"gas_fees\" */\nexport enum GasFeesConstraint {\n  /** unique or primary key constraint on columns \"transaction_version\" */\n  GasFeesPkey = \"gas_fees_pkey\",\n}\n\n/** input type for incrementing numeric columns in table \"gas_fees\" */\nexport type GasFeesIncInput = {\n  amount?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  block_height?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  storage_refund_amount?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** input type for inserting data into table \"gas_fees\" */\nexport type GasFeesInsertInput = {\n  amount?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  block_height?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  entry_function_id_str?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  gas_fee_payer_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  is_transaction_success?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  owner_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  storage_refund_amount?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** aggregate max on columns */\nexport type GasFeesMaxFields = {\n  amount?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  block_height?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  entry_function_id_str?: Maybe<Scalars[\"String\"][\"output\"]>;\n  gas_fee_payer_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  owner_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  storage_refund_amount?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  transaction_timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** aggregate min on columns */\nexport type GasFeesMinFields = {\n  amount?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  block_height?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  entry_function_id_str?: Maybe<Scalars[\"String\"][\"output\"]>;\n  gas_fee_payer_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  owner_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  storage_refund_amount?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  transaction_timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** response of any mutation on the table \"gas_fees\" */\nexport type GasFeesMutationResponse = {\n  /** number of rows affected by the mutation */\n  affected_rows: Scalars[\"Int\"][\"output\"];\n  /** data from the rows affected by the mutation */\n  returning: Array<GasFees>;\n};\n\n/** on_conflict condition type for table \"gas_fees\" */\nexport type GasFeesOnConflict = {\n  constraint: GasFeesConstraint;\n  update_columns?: Array<GasFeesUpdateColumn>;\n  where?: InputMaybe<GasFeesBoolExp>;\n};\n\n/** Ordering options when selecting data from \"gas_fees\". */\nexport type GasFeesOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  block_height?: InputMaybe<OrderBy>;\n  entry_function_id_str?: InputMaybe<OrderBy>;\n  gas_fee_payer_address?: InputMaybe<OrderBy>;\n  is_transaction_success?: InputMaybe<OrderBy>;\n  owner_address?: InputMaybe<OrderBy>;\n  storage_refund_amount?: InputMaybe<OrderBy>;\n  transaction_timestamp?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n};\n\n/** primary key columns input for table: gas_fees */\nexport type GasFeesPkColumnsInput = {\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\n/** select columns of table \"gas_fees\" */\nexport enum GasFeesSelectColumn {\n  /** column name */\n  Amount = \"amount\",\n  /** column name */\n  BlockHeight = \"block_height\",\n  /** column name */\n  EntryFunctionIdStr = \"entry_function_id_str\",\n  /** column name */\n  GasFeePayerAddress = \"gas_fee_payer_address\",\n  /** column name */\n  IsTransactionSuccess = \"is_transaction_success\",\n  /** column name */\n  OwnerAddress = \"owner_address\",\n  /** column name */\n  StorageRefundAmount = \"storage_refund_amount\",\n  /** column name */\n  TransactionTimestamp = \"transaction_timestamp\",\n  /** column name */\n  TransactionVersion = \"transaction_version\",\n}\n\n/** input type for updating data in table \"gas_fees\" */\nexport type GasFeesSetInput = {\n  amount?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  block_height?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  entry_function_id_str?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  gas_fee_payer_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  is_transaction_success?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  owner_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  storage_refund_amount?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** aggregate stddev on columns */\nexport type GasFeesStddevFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  storage_refund_amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_pop on columns */\nexport type GasFeesStddevPopFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  storage_refund_amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_samp on columns */\nexport type GasFeesStddevSampFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  storage_refund_amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Streaming cursor of the table \"gas_fees\" */\nexport type GasFeesStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: GasFeesStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type GasFeesStreamCursorValueInput = {\n  amount?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  block_height?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  entry_function_id_str?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  gas_fee_payer_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  is_transaction_success?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  owner_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  storage_refund_amount?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** aggregate sum on columns */\nexport type GasFeesSumFields = {\n  amount?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  block_height?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  storage_refund_amount?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** update columns of table \"gas_fees\" */\nexport enum GasFeesUpdateColumn {\n  /** column name */\n  Amount = \"amount\",\n  /** column name */\n  BlockHeight = \"block_height\",\n  /** column name */\n  EntryFunctionIdStr = \"entry_function_id_str\",\n  /** column name */\n  GasFeePayerAddress = \"gas_fee_payer_address\",\n  /** column name */\n  IsTransactionSuccess = \"is_transaction_success\",\n  /** column name */\n  OwnerAddress = \"owner_address\",\n  /** column name */\n  StorageRefundAmount = \"storage_refund_amount\",\n  /** column name */\n  TransactionTimestamp = \"transaction_timestamp\",\n  /** column name */\n  TransactionVersion = \"transaction_version\",\n}\n\nexport type GasFeesUpdates = {\n  /** increments the numeric columns with given value of the filtered values */\n  _inc?: InputMaybe<GasFeesIncInput>;\n  /** sets the columns of the filtered rows to the given values */\n  _set?: InputMaybe<GasFeesSetInput>;\n  /** filter the rows which have to be updated */\n  where: GasFeesBoolExp;\n};\n\n/** aggregate var_pop on columns */\nexport type GasFeesVarPopFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  storage_refund_amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate var_samp on columns */\nexport type GasFeesVarSampFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  storage_refund_amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate variance on columns */\nexport type GasFeesVarianceFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  storage_refund_amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** columns and relationships of \"indexer_status\" */\nexport type IndexerStatus = {\n  db: Scalars[\"String\"][\"output\"];\n  inserted_at: Scalars[\"timestamp\"][\"output\"];\n  is_indexer_up: Scalars[\"Boolean\"][\"output\"];\n};\n\n/** aggregated selection of \"indexer_status\" */\nexport type IndexerStatusAggregate = {\n  aggregate?: Maybe<IndexerStatusAggregateFields>;\n  nodes: Array<IndexerStatus>;\n};\n\n/** aggregate fields of \"indexer_status\" */\nexport type IndexerStatusAggregateFields = {\n  count: Scalars[\"Int\"][\"output\"];\n  max?: Maybe<IndexerStatusMaxFields>;\n  min?: Maybe<IndexerStatusMinFields>;\n};\n\n/** aggregate fields of \"indexer_status\" */\nexport type IndexerStatusAggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<IndexerStatusSelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** Boolean expression to filter rows from the table \"indexer_status\". All fields are combined with a logical 'AND'. */\nexport type IndexerStatusBoolExp = {\n  _and?: InputMaybe<Array<IndexerStatusBoolExp>>;\n  _not?: InputMaybe<IndexerStatusBoolExp>;\n  _or?: InputMaybe<Array<IndexerStatusBoolExp>>;\n  db?: InputMaybe<StringComparisonExp>;\n  inserted_at?: InputMaybe<TimestampComparisonExp>;\n  is_indexer_up?: InputMaybe<BooleanComparisonExp>;\n};\n\n/** unique or primary key constraints on table \"indexer_status\" */\nexport enum IndexerStatusConstraint {\n  /** unique or primary key constraint on columns \"db\" */\n  IndexerStatusPkey = \"indexer_status_pkey\",\n}\n\n/** input type for inserting data into table \"indexer_status\" */\nexport type IndexerStatusInsertInput = {\n  db?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  is_indexer_up?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** aggregate max on columns */\nexport type IndexerStatusMaxFields = {\n  db?: Maybe<Scalars[\"String\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n};\n\n/** aggregate min on columns */\nexport type IndexerStatusMinFields = {\n  db?: Maybe<Scalars[\"String\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n};\n\n/** response of any mutation on the table \"indexer_status\" */\nexport type IndexerStatusMutationResponse = {\n  /** number of rows affected by the mutation */\n  affected_rows: Scalars[\"Int\"][\"output\"];\n  /** data from the rows affected by the mutation */\n  returning: Array<IndexerStatus>;\n};\n\n/** on_conflict condition type for table \"indexer_status\" */\nexport type IndexerStatusOnConflict = {\n  constraint: IndexerStatusConstraint;\n  update_columns?: Array<IndexerStatusUpdateColumn>;\n  where?: InputMaybe<IndexerStatusBoolExp>;\n};\n\n/** Ordering options when selecting data from \"indexer_status\". */\nexport type IndexerStatusOrderBy = {\n  db?: InputMaybe<OrderBy>;\n  inserted_at?: InputMaybe<OrderBy>;\n  is_indexer_up?: InputMaybe<OrderBy>;\n};\n\n/** primary key columns input for table: indexer_status */\nexport type IndexerStatusPkColumnsInput = {\n  db: Scalars[\"String\"][\"input\"];\n};\n\n/** select columns of table \"indexer_status\" */\nexport enum IndexerStatusSelectColumn {\n  /** column name */\n  Db = \"db\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  IsIndexerUp = \"is_indexer_up\",\n}\n\n/** input type for updating data in table \"indexer_status\" */\nexport type IndexerStatusSetInput = {\n  db?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  is_indexer_up?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** Streaming cursor of the table \"indexer_status\" */\nexport type IndexerStatusStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: IndexerStatusStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type IndexerStatusStreamCursorValueInput = {\n  db?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  is_indexer_up?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** update columns of table \"indexer_status\" */\nexport enum IndexerStatusUpdateColumn {\n  /** column name */\n  Db = \"db\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  IsIndexerUp = \"is_indexer_up\",\n}\n\nexport type IndexerStatusUpdates = {\n  /** sets the columns of the filtered rows to the given values */\n  _set?: InputMaybe<IndexerStatusSetInput>;\n  /** filter the rows which have to be updated */\n  where: IndexerStatusBoolExp;\n};\n\nexport type JsonbCastExp = {\n  String?: InputMaybe<StringComparisonExp>;\n};\n\n/** Boolean expression to compare columns of type \"jsonb\". All fields are combined with logical 'AND'. */\nexport type JsonbComparisonExp = {\n  _cast?: InputMaybe<JsonbCastExp>;\n  /** is the column contained in the given json value */\n  _contained_in?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  /** does the column contain the given json value at the top level */\n  _contains?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  _eq?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  _gt?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  _gte?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  /** does the string exist as a top-level key in the column */\n  _has_key?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  /** do all of these strings exist as top-level keys in the column */\n  _has_keys_all?: InputMaybe<Array<Scalars[\"String\"][\"input\"]>>;\n  /** do any of these strings exist as top-level keys in the column */\n  _has_keys_any?: InputMaybe<Array<Scalars[\"String\"][\"input\"]>>;\n  _in?: InputMaybe<Array<Scalars[\"jsonb\"][\"input\"]>>;\n  _is_null?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  _lt?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  _lte?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  _neq?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  _nin?: InputMaybe<Array<Scalars[\"jsonb\"][\"input\"]>>;\n};\n\n/** columns and relationships of \"move_modules\" */\nexport type MoveModules = {\n  address: Scalars[\"String\"][\"output\"];\n  bytecode?: Maybe<Scalars[\"bytea\"][\"output\"]>;\n  exposed_functions?: Maybe<Scalars[\"jsonb\"][\"output\"]>;\n  friends?: Maybe<Scalars[\"jsonb\"][\"output\"]>;\n  inserted_at: Scalars[\"timestamp\"][\"output\"];\n  is_deleted: Scalars[\"Boolean\"][\"output\"];\n  name: Scalars[\"String\"][\"output\"];\n  structs?: Maybe<Scalars[\"jsonb\"][\"output\"]>;\n  transaction_block_height: Scalars[\"bigint\"][\"output\"];\n  transaction_version: Scalars[\"bigint\"][\"output\"];\n  write_set_change_index: Scalars[\"bigint\"][\"output\"];\n};\n\n/** columns and relationships of \"move_modules\" */\nexport type MoveModulesExposedFunctionsArgs = {\n  path?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** columns and relationships of \"move_modules\" */\nexport type MoveModulesFriendsArgs = {\n  path?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** columns and relationships of \"move_modules\" */\nexport type MoveModulesStructsArgs = {\n  path?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregated selection of \"move_modules\" */\nexport type MoveModulesAggregate = {\n  aggregate?: Maybe<MoveModulesAggregateFields>;\n  nodes: Array<MoveModules>;\n};\n\n/** aggregate fields of \"move_modules\" */\nexport type MoveModulesAggregateFields = {\n  avg?: Maybe<MoveModulesAvgFields>;\n  count: Scalars[\"Int\"][\"output\"];\n  max?: Maybe<MoveModulesMaxFields>;\n  min?: Maybe<MoveModulesMinFields>;\n  stddev?: Maybe<MoveModulesStddevFields>;\n  stddev_pop?: Maybe<MoveModulesStddevPopFields>;\n  stddev_samp?: Maybe<MoveModulesStddevSampFields>;\n  sum?: Maybe<MoveModulesSumFields>;\n  var_pop?: Maybe<MoveModulesVarPopFields>;\n  var_samp?: Maybe<MoveModulesVarSampFields>;\n  variance?: Maybe<MoveModulesVarianceFields>;\n};\n\n/** aggregate fields of \"move_modules\" */\nexport type MoveModulesAggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<MoveModulesSelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** append existing jsonb value of filtered columns with new jsonb value */\nexport type MoveModulesAppendInput = {\n  exposed_functions?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  friends?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  structs?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n};\n\n/** aggregate avg on columns */\nexport type MoveModulesAvgFields = {\n  transaction_block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Boolean expression to filter rows from the table \"move_modules\". All fields are combined with a logical 'AND'. */\nexport type MoveModulesBoolExp = {\n  _and?: InputMaybe<Array<MoveModulesBoolExp>>;\n  _not?: InputMaybe<MoveModulesBoolExp>;\n  _or?: InputMaybe<Array<MoveModulesBoolExp>>;\n  address?: InputMaybe<StringComparisonExp>;\n  bytecode?: InputMaybe<ByteaComparisonExp>;\n  exposed_functions?: InputMaybe<JsonbComparisonExp>;\n  friends?: InputMaybe<JsonbComparisonExp>;\n  inserted_at?: InputMaybe<TimestampComparisonExp>;\n  is_deleted?: InputMaybe<BooleanComparisonExp>;\n  name?: InputMaybe<StringComparisonExp>;\n  structs?: InputMaybe<JsonbComparisonExp>;\n  transaction_block_height?: InputMaybe<BigintComparisonExp>;\n  transaction_version?: InputMaybe<BigintComparisonExp>;\n  write_set_change_index?: InputMaybe<BigintComparisonExp>;\n};\n\n/** unique or primary key constraints on table \"move_modules\" */\nexport enum MoveModulesConstraint {\n  /** unique or primary key constraint on columns \"write_set_change_index\", \"transaction_version\" */\n  MoveModulesPkey = \"move_modules_pkey\",\n}\n\n/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */\nexport type MoveModulesDeleteAtPathInput = {\n  exposed_functions?: InputMaybe<Array<Scalars[\"String\"][\"input\"]>>;\n  friends?: InputMaybe<Array<Scalars[\"String\"][\"input\"]>>;\n  structs?: InputMaybe<Array<Scalars[\"String\"][\"input\"]>>;\n};\n\n/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */\nexport type MoveModulesDeleteElemInput = {\n  exposed_functions?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  friends?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  structs?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n};\n\n/** delete key/value pair or string element. key/value pairs are matched based on their key value */\nexport type MoveModulesDeleteKeyInput = {\n  exposed_functions?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  friends?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  structs?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** input type for incrementing numeric columns in table \"move_modules\" */\nexport type MoveModulesIncInput = {\n  transaction_block_height?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  write_set_change_index?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** input type for inserting data into table \"move_modules\" */\nexport type MoveModulesInsertInput = {\n  address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  bytecode?: InputMaybe<Scalars[\"bytea\"][\"input\"]>;\n  exposed_functions?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  friends?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  is_deleted?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  structs?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  transaction_block_height?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  write_set_change_index?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** aggregate max on columns */\nexport type MoveModulesMaxFields = {\n  address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  name?: Maybe<Scalars[\"String\"][\"output\"]>;\n  transaction_block_height?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** aggregate min on columns */\nexport type MoveModulesMinFields = {\n  address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  name?: Maybe<Scalars[\"String\"][\"output\"]>;\n  transaction_block_height?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** response of any mutation on the table \"move_modules\" */\nexport type MoveModulesMutationResponse = {\n  /** number of rows affected by the mutation */\n  affected_rows: Scalars[\"Int\"][\"output\"];\n  /** data from the rows affected by the mutation */\n  returning: Array<MoveModules>;\n};\n\n/** on_conflict condition type for table \"move_modules\" */\nexport type MoveModulesOnConflict = {\n  constraint: MoveModulesConstraint;\n  update_columns?: Array<MoveModulesUpdateColumn>;\n  where?: InputMaybe<MoveModulesBoolExp>;\n};\n\n/** Ordering options when selecting data from \"move_modules\". */\nexport type MoveModulesOrderBy = {\n  address?: InputMaybe<OrderBy>;\n  bytecode?: InputMaybe<OrderBy>;\n  exposed_functions?: InputMaybe<OrderBy>;\n  friends?: InputMaybe<OrderBy>;\n  inserted_at?: InputMaybe<OrderBy>;\n  is_deleted?: InputMaybe<OrderBy>;\n  name?: InputMaybe<OrderBy>;\n  structs?: InputMaybe<OrderBy>;\n  transaction_block_height?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n  write_set_change_index?: InputMaybe<OrderBy>;\n};\n\n/** primary key columns input for table: move_modules */\nexport type MoveModulesPkColumnsInput = {\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n  write_set_change_index: Scalars[\"bigint\"][\"input\"];\n};\n\n/** prepend existing jsonb value of filtered columns with new jsonb value */\nexport type MoveModulesPrependInput = {\n  exposed_functions?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  friends?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  structs?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n};\n\n/** select columns of table \"move_modules\" */\nexport enum MoveModulesSelectColumn {\n  /** column name */\n  Address = \"address\",\n  /** column name */\n  Bytecode = \"bytecode\",\n  /** column name */\n  ExposedFunctions = \"exposed_functions\",\n  /** column name */\n  Friends = \"friends\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  IsDeleted = \"is_deleted\",\n  /** column name */\n  Name = \"name\",\n  /** column name */\n  Structs = \"structs\",\n  /** column name */\n  TransactionBlockHeight = \"transaction_block_height\",\n  /** column name */\n  TransactionVersion = \"transaction_version\",\n  /** column name */\n  WriteSetChangeIndex = \"write_set_change_index\",\n}\n\n/** input type for updating data in table \"move_modules\" */\nexport type MoveModulesSetInput = {\n  address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  bytecode?: InputMaybe<Scalars[\"bytea\"][\"input\"]>;\n  exposed_functions?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  friends?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  is_deleted?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  structs?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  transaction_block_height?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  write_set_change_index?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** aggregate stddev on columns */\nexport type MoveModulesStddevFields = {\n  transaction_block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_pop on columns */\nexport type MoveModulesStddevPopFields = {\n  transaction_block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_samp on columns */\nexport type MoveModulesStddevSampFields = {\n  transaction_block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Streaming cursor of the table \"move_modules\" */\nexport type MoveModulesStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: MoveModulesStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type MoveModulesStreamCursorValueInput = {\n  address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  bytecode?: InputMaybe<Scalars[\"bytea\"][\"input\"]>;\n  exposed_functions?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  friends?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  is_deleted?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  structs?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  transaction_block_height?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  write_set_change_index?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** aggregate sum on columns */\nexport type MoveModulesSumFields = {\n  transaction_block_height?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** update columns of table \"move_modules\" */\nexport enum MoveModulesUpdateColumn {\n  /** column name */\n  Address = \"address\",\n  /** column name */\n  Bytecode = \"bytecode\",\n  /** column name */\n  ExposedFunctions = \"exposed_functions\",\n  /** column name */\n  Friends = \"friends\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  IsDeleted = \"is_deleted\",\n  /** column name */\n  Name = \"name\",\n  /** column name */\n  Structs = \"structs\",\n  /** column name */\n  TransactionBlockHeight = \"transaction_block_height\",\n  /** column name */\n  TransactionVersion = \"transaction_version\",\n  /** column name */\n  WriteSetChangeIndex = \"write_set_change_index\",\n}\n\nexport type MoveModulesUpdates = {\n  /** append existing jsonb value of filtered columns with new jsonb value */\n  _append?: InputMaybe<MoveModulesAppendInput>;\n  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */\n  _delete_at_path?: InputMaybe<MoveModulesDeleteAtPathInput>;\n  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */\n  _delete_elem?: InputMaybe<MoveModulesDeleteElemInput>;\n  /** delete key/value pair or string element. key/value pairs are matched based on their key value */\n  _delete_key?: InputMaybe<MoveModulesDeleteKeyInput>;\n  /** increments the numeric columns with given value of the filtered values */\n  _inc?: InputMaybe<MoveModulesIncInput>;\n  /** prepend existing jsonb value of filtered columns with new jsonb value */\n  _prepend?: InputMaybe<MoveModulesPrependInput>;\n  /** sets the columns of the filtered rows to the given values */\n  _set?: InputMaybe<MoveModulesSetInput>;\n  /** filter the rows which have to be updated */\n  where: MoveModulesBoolExp;\n};\n\n/** aggregate var_pop on columns */\nexport type MoveModulesVarPopFields = {\n  transaction_block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate var_samp on columns */\nexport type MoveModulesVarSampFields = {\n  transaction_block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate variance on columns */\nexport type MoveModulesVarianceFields = {\n  transaction_block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** columns and relationships of \"move_resources\" */\nexport type MoveResources = {\n  address: Scalars[\"String\"][\"output\"];\n  data?: Maybe<Scalars[\"jsonb\"][\"output\"]>;\n  generic_type_params?: Maybe<Scalars[\"jsonb\"][\"output\"]>;\n  inserted_at: Scalars[\"timestamp\"][\"output\"];\n  is_deleted: Scalars[\"Boolean\"][\"output\"];\n  module: Scalars[\"String\"][\"output\"];\n  name: Scalars[\"String\"][\"output\"];\n  state_key_hash: Scalars[\"String\"][\"output\"];\n  transaction_block_height: Scalars[\"bigint\"][\"output\"];\n  transaction_version: Scalars[\"bigint\"][\"output\"];\n  type: Scalars[\"String\"][\"output\"];\n  write_set_change_index: Scalars[\"bigint\"][\"output\"];\n};\n\n/** columns and relationships of \"move_resources\" */\nexport type MoveResourcesDataArgs = {\n  path?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** columns and relationships of \"move_resources\" */\nexport type MoveResourcesGenericTypeParamsArgs = {\n  path?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregated selection of \"move_resources\" */\nexport type MoveResourcesAggregate = {\n  aggregate?: Maybe<MoveResourcesAggregateFields>;\n  nodes: Array<MoveResources>;\n};\n\n/** aggregate fields of \"move_resources\" */\nexport type MoveResourcesAggregateFields = {\n  avg?: Maybe<MoveResourcesAvgFields>;\n  count: Scalars[\"Int\"][\"output\"];\n  max?: Maybe<MoveResourcesMaxFields>;\n  min?: Maybe<MoveResourcesMinFields>;\n  stddev?: Maybe<MoveResourcesStddevFields>;\n  stddev_pop?: Maybe<MoveResourcesStddevPopFields>;\n  stddev_samp?: Maybe<MoveResourcesStddevSampFields>;\n  sum?: Maybe<MoveResourcesSumFields>;\n  var_pop?: Maybe<MoveResourcesVarPopFields>;\n  var_samp?: Maybe<MoveResourcesVarSampFields>;\n  variance?: Maybe<MoveResourcesVarianceFields>;\n};\n\n/** aggregate fields of \"move_resources\" */\nexport type MoveResourcesAggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<MoveResourcesSelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** append existing jsonb value of filtered columns with new jsonb value */\nexport type MoveResourcesAppendInput = {\n  data?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  generic_type_params?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n};\n\n/** aggregate avg on columns */\nexport type MoveResourcesAvgFields = {\n  transaction_block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Boolean expression to filter rows from the table \"move_resources\". All fields are combined with a logical 'AND'. */\nexport type MoveResourcesBoolExp = {\n  _and?: InputMaybe<Array<MoveResourcesBoolExp>>;\n  _not?: InputMaybe<MoveResourcesBoolExp>;\n  _or?: InputMaybe<Array<MoveResourcesBoolExp>>;\n  address?: InputMaybe<StringComparisonExp>;\n  data?: InputMaybe<JsonbComparisonExp>;\n  generic_type_params?: InputMaybe<JsonbComparisonExp>;\n  inserted_at?: InputMaybe<TimestampComparisonExp>;\n  is_deleted?: InputMaybe<BooleanComparisonExp>;\n  module?: InputMaybe<StringComparisonExp>;\n  name?: InputMaybe<StringComparisonExp>;\n  state_key_hash?: InputMaybe<StringComparisonExp>;\n  transaction_block_height?: InputMaybe<BigintComparisonExp>;\n  transaction_version?: InputMaybe<BigintComparisonExp>;\n  type?: InputMaybe<StringComparisonExp>;\n  write_set_change_index?: InputMaybe<BigintComparisonExp>;\n};\n\n/** unique or primary key constraints on table \"move_resources\" */\nexport enum MoveResourcesConstraint {\n  /** unique or primary key constraint on columns \"write_set_change_index\", \"transaction_version\" */\n  MoveResourcesPkey = \"move_resources_pkey\",\n}\n\n/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */\nexport type MoveResourcesDeleteAtPathInput = {\n  data?: InputMaybe<Array<Scalars[\"String\"][\"input\"]>>;\n  generic_type_params?: InputMaybe<Array<Scalars[\"String\"][\"input\"]>>;\n};\n\n/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */\nexport type MoveResourcesDeleteElemInput = {\n  data?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  generic_type_params?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n};\n\n/** delete key/value pair or string element. key/value pairs are matched based on their key value */\nexport type MoveResourcesDeleteKeyInput = {\n  data?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  generic_type_params?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** input type for incrementing numeric columns in table \"move_resources\" */\nexport type MoveResourcesIncInput = {\n  transaction_block_height?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  write_set_change_index?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** input type for inserting data into table \"move_resources\" */\nexport type MoveResourcesInsertInput = {\n  address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  data?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  generic_type_params?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  is_deleted?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  module?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  state_key_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  transaction_block_height?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  write_set_change_index?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** aggregate max on columns */\nexport type MoveResourcesMaxFields = {\n  address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  module?: Maybe<Scalars[\"String\"][\"output\"]>;\n  name?: Maybe<Scalars[\"String\"][\"output\"]>;\n  state_key_hash?: Maybe<Scalars[\"String\"][\"output\"]>;\n  transaction_block_height?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  type?: Maybe<Scalars[\"String\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** aggregate min on columns */\nexport type MoveResourcesMinFields = {\n  address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  module?: Maybe<Scalars[\"String\"][\"output\"]>;\n  name?: Maybe<Scalars[\"String\"][\"output\"]>;\n  state_key_hash?: Maybe<Scalars[\"String\"][\"output\"]>;\n  transaction_block_height?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  type?: Maybe<Scalars[\"String\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** response of any mutation on the table \"move_resources\" */\nexport type MoveResourcesMutationResponse = {\n  /** number of rows affected by the mutation */\n  affected_rows: Scalars[\"Int\"][\"output\"];\n  /** data from the rows affected by the mutation */\n  returning: Array<MoveResources>;\n};\n\n/** on_conflict condition type for table \"move_resources\" */\nexport type MoveResourcesOnConflict = {\n  constraint: MoveResourcesConstraint;\n  update_columns?: Array<MoveResourcesUpdateColumn>;\n  where?: InputMaybe<MoveResourcesBoolExp>;\n};\n\n/** Ordering options when selecting data from \"move_resources\". */\nexport type MoveResourcesOrderBy = {\n  address?: InputMaybe<OrderBy>;\n  data?: InputMaybe<OrderBy>;\n  generic_type_params?: InputMaybe<OrderBy>;\n  inserted_at?: InputMaybe<OrderBy>;\n  is_deleted?: InputMaybe<OrderBy>;\n  module?: InputMaybe<OrderBy>;\n  name?: InputMaybe<OrderBy>;\n  state_key_hash?: InputMaybe<OrderBy>;\n  transaction_block_height?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n  type?: InputMaybe<OrderBy>;\n  write_set_change_index?: InputMaybe<OrderBy>;\n};\n\n/** primary key columns input for table: move_resources */\nexport type MoveResourcesPkColumnsInput = {\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n  write_set_change_index: Scalars[\"bigint\"][\"input\"];\n};\n\n/** prepend existing jsonb value of filtered columns with new jsonb value */\nexport type MoveResourcesPrependInput = {\n  data?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  generic_type_params?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n};\n\n/** select columns of table \"move_resources\" */\nexport enum MoveResourcesSelectColumn {\n  /** column name */\n  Address = \"address\",\n  /** column name */\n  Data = \"data\",\n  /** column name */\n  GenericTypeParams = \"generic_type_params\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  IsDeleted = \"is_deleted\",\n  /** column name */\n  Module = \"module\",\n  /** column name */\n  Name = \"name\",\n  /** column name */\n  StateKeyHash = \"state_key_hash\",\n  /** column name */\n  TransactionBlockHeight = \"transaction_block_height\",\n  /** column name */\n  TransactionVersion = \"transaction_version\",\n  /** column name */\n  Type = \"type\",\n  /** column name */\n  WriteSetChangeIndex = \"write_set_change_index\",\n}\n\n/** input type for updating data in table \"move_resources\" */\nexport type MoveResourcesSetInput = {\n  address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  data?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  generic_type_params?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  is_deleted?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  module?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  state_key_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  transaction_block_height?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  write_set_change_index?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** aggregate stddev on columns */\nexport type MoveResourcesStddevFields = {\n  transaction_block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_pop on columns */\nexport type MoveResourcesStddevPopFields = {\n  transaction_block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_samp on columns */\nexport type MoveResourcesStddevSampFields = {\n  transaction_block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Streaming cursor of the table \"move_resources\" */\nexport type MoveResourcesStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: MoveResourcesStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type MoveResourcesStreamCursorValueInput = {\n  address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  data?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  generic_type_params?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  is_deleted?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  module?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  state_key_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  transaction_block_height?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  write_set_change_index?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** aggregate sum on columns */\nexport type MoveResourcesSumFields = {\n  transaction_block_height?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** update columns of table \"move_resources\" */\nexport enum MoveResourcesUpdateColumn {\n  /** column name */\n  Address = \"address\",\n  /** column name */\n  Data = \"data\",\n  /** column name */\n  GenericTypeParams = \"generic_type_params\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  IsDeleted = \"is_deleted\",\n  /** column name */\n  Module = \"module\",\n  /** column name */\n  Name = \"name\",\n  /** column name */\n  StateKeyHash = \"state_key_hash\",\n  /** column name */\n  TransactionBlockHeight = \"transaction_block_height\",\n  /** column name */\n  TransactionVersion = \"transaction_version\",\n  /** column name */\n  Type = \"type\",\n  /** column name */\n  WriteSetChangeIndex = \"write_set_change_index\",\n}\n\nexport type MoveResourcesUpdates = {\n  /** append existing jsonb value of filtered columns with new jsonb value */\n  _append?: InputMaybe<MoveResourcesAppendInput>;\n  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */\n  _delete_at_path?: InputMaybe<MoveResourcesDeleteAtPathInput>;\n  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */\n  _delete_elem?: InputMaybe<MoveResourcesDeleteElemInput>;\n  /** delete key/value pair or string element. key/value pairs are matched based on their key value */\n  _delete_key?: InputMaybe<MoveResourcesDeleteKeyInput>;\n  /** increments the numeric columns with given value of the filtered values */\n  _inc?: InputMaybe<MoveResourcesIncInput>;\n  /** prepend existing jsonb value of filtered columns with new jsonb value */\n  _prepend?: InputMaybe<MoveResourcesPrependInput>;\n  /** sets the columns of the filtered rows to the given values */\n  _set?: InputMaybe<MoveResourcesSetInput>;\n  /** filter the rows which have to be updated */\n  where: MoveResourcesBoolExp;\n};\n\n/** aggregate var_pop on columns */\nexport type MoveResourcesVarPopFields = {\n  transaction_block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate var_samp on columns */\nexport type MoveResourcesVarSampFields = {\n  transaction_block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate variance on columns */\nexport type MoveResourcesVarianceFields = {\n  transaction_block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** columns and relationships of \"move_resources_view\" */\nexport type MoveResourcesView = {\n  address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  generic_type_params?: Maybe<Scalars[\"jsonb\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  is_deleted?: Maybe<Scalars[\"Boolean\"][\"output\"]>;\n  json_data?: Maybe<Scalars[\"String\"][\"output\"]>;\n  module?: Maybe<Scalars[\"String\"][\"output\"]>;\n  name?: Maybe<Scalars[\"String\"][\"output\"]>;\n  transaction_block_height?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  type?: Maybe<Scalars[\"String\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** columns and relationships of \"move_resources_view\" */\nexport type MoveResourcesViewGenericTypeParamsArgs = {\n  path?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregated selection of \"move_resources_view\" */\nexport type MoveResourcesViewAggregate = {\n  aggregate?: Maybe<MoveResourcesViewAggregateFields>;\n  nodes: Array<MoveResourcesView>;\n};\n\n/** aggregate fields of \"move_resources_view\" */\nexport type MoveResourcesViewAggregateFields = {\n  avg?: Maybe<MoveResourcesViewAvgFields>;\n  count: Scalars[\"Int\"][\"output\"];\n  max?: Maybe<MoveResourcesViewMaxFields>;\n  min?: Maybe<MoveResourcesViewMinFields>;\n  stddev?: Maybe<MoveResourcesViewStddevFields>;\n  stddev_pop?: Maybe<MoveResourcesViewStddevPopFields>;\n  stddev_samp?: Maybe<MoveResourcesViewStddevSampFields>;\n  sum?: Maybe<MoveResourcesViewSumFields>;\n  var_pop?: Maybe<MoveResourcesViewVarPopFields>;\n  var_samp?: Maybe<MoveResourcesViewVarSampFields>;\n  variance?: Maybe<MoveResourcesViewVarianceFields>;\n};\n\n/** aggregate fields of \"move_resources_view\" */\nexport type MoveResourcesViewAggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<MoveResourcesViewSelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** append existing jsonb value of filtered columns with new jsonb value */\nexport type MoveResourcesViewAppendInput = {\n  generic_type_params?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n};\n\n/** aggregate avg on columns */\nexport type MoveResourcesViewAvgFields = {\n  transaction_block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Boolean expression to filter rows from the table \"move_resources_view\". All fields are combined with a logical 'AND'. */\nexport type MoveResourcesViewBoolExp = {\n  _and?: InputMaybe<Array<MoveResourcesViewBoolExp>>;\n  _not?: InputMaybe<MoveResourcesViewBoolExp>;\n  _or?: InputMaybe<Array<MoveResourcesViewBoolExp>>;\n  address?: InputMaybe<StringComparisonExp>;\n  generic_type_params?: InputMaybe<JsonbComparisonExp>;\n  inserted_at?: InputMaybe<TimestampComparisonExp>;\n  is_deleted?: InputMaybe<BooleanComparisonExp>;\n  json_data?: InputMaybe<StringComparisonExp>;\n  module?: InputMaybe<StringComparisonExp>;\n  name?: InputMaybe<StringComparisonExp>;\n  transaction_block_height?: InputMaybe<BigintComparisonExp>;\n  transaction_version?: InputMaybe<BigintComparisonExp>;\n  type?: InputMaybe<StringComparisonExp>;\n  write_set_change_index?: InputMaybe<BigintComparisonExp>;\n};\n\n/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */\nexport type MoveResourcesViewDeleteAtPathInput = {\n  generic_type_params?: InputMaybe<Array<Scalars[\"String\"][\"input\"]>>;\n};\n\n/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */\nexport type MoveResourcesViewDeleteElemInput = {\n  generic_type_params?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n};\n\n/** delete key/value pair or string element. key/value pairs are matched based on their key value */\nexport type MoveResourcesViewDeleteKeyInput = {\n  generic_type_params?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** input type for incrementing numeric columns in table \"move_resources_view\" */\nexport type MoveResourcesViewIncInput = {\n  transaction_block_height?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  write_set_change_index?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** input type for inserting data into table \"move_resources_view\" */\nexport type MoveResourcesViewInsertInput = {\n  address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  generic_type_params?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  is_deleted?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  json_data?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  module?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  transaction_block_height?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  write_set_change_index?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** aggregate max on columns */\nexport type MoveResourcesViewMaxFields = {\n  address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  json_data?: Maybe<Scalars[\"String\"][\"output\"]>;\n  module?: Maybe<Scalars[\"String\"][\"output\"]>;\n  name?: Maybe<Scalars[\"String\"][\"output\"]>;\n  transaction_block_height?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  type?: Maybe<Scalars[\"String\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** aggregate min on columns */\nexport type MoveResourcesViewMinFields = {\n  address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  json_data?: Maybe<Scalars[\"String\"][\"output\"]>;\n  module?: Maybe<Scalars[\"String\"][\"output\"]>;\n  name?: Maybe<Scalars[\"String\"][\"output\"]>;\n  transaction_block_height?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  type?: Maybe<Scalars[\"String\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** response of any mutation on the table \"move_resources_view\" */\nexport type MoveResourcesViewMutationResponse = {\n  /** number of rows affected by the mutation */\n  affected_rows: Scalars[\"Int\"][\"output\"];\n  /** data from the rows affected by the mutation */\n  returning: Array<MoveResourcesView>;\n};\n\n/** Ordering options when selecting data from \"move_resources_view\". */\nexport type MoveResourcesViewOrderBy = {\n  address?: InputMaybe<OrderBy>;\n  generic_type_params?: InputMaybe<OrderBy>;\n  inserted_at?: InputMaybe<OrderBy>;\n  is_deleted?: InputMaybe<OrderBy>;\n  json_data?: InputMaybe<OrderBy>;\n  module?: InputMaybe<OrderBy>;\n  name?: InputMaybe<OrderBy>;\n  transaction_block_height?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n  type?: InputMaybe<OrderBy>;\n  write_set_change_index?: InputMaybe<OrderBy>;\n};\n\n/** prepend existing jsonb value of filtered columns with new jsonb value */\nexport type MoveResourcesViewPrependInput = {\n  generic_type_params?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n};\n\n/** select columns of table \"move_resources_view\" */\nexport enum MoveResourcesViewSelectColumn {\n  /** column name */\n  Address = \"address\",\n  /** column name */\n  GenericTypeParams = \"generic_type_params\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  IsDeleted = \"is_deleted\",\n  /** column name */\n  JsonData = \"json_data\",\n  /** column name */\n  Module = \"module\",\n  /** column name */\n  Name = \"name\",\n  /** column name */\n  TransactionBlockHeight = \"transaction_block_height\",\n  /** column name */\n  TransactionVersion = \"transaction_version\",\n  /** column name */\n  Type = \"type\",\n  /** column name */\n  WriteSetChangeIndex = \"write_set_change_index\",\n}\n\n/** input type for updating data in table \"move_resources_view\" */\nexport type MoveResourcesViewSetInput = {\n  address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  generic_type_params?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  is_deleted?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  json_data?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  module?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  transaction_block_height?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  write_set_change_index?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** aggregate stddev on columns */\nexport type MoveResourcesViewStddevFields = {\n  transaction_block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_pop on columns */\nexport type MoveResourcesViewStddevPopFields = {\n  transaction_block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_samp on columns */\nexport type MoveResourcesViewStddevSampFields = {\n  transaction_block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Streaming cursor of the table \"move_resources_view\" */\nexport type MoveResourcesViewStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: MoveResourcesViewStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type MoveResourcesViewStreamCursorValueInput = {\n  address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  generic_type_params?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  is_deleted?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  json_data?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  module?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  transaction_block_height?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  write_set_change_index?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** aggregate sum on columns */\nexport type MoveResourcesViewSumFields = {\n  transaction_block_height?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\nexport type MoveResourcesViewUpdates = {\n  /** append existing jsonb value of filtered columns with new jsonb value */\n  _append?: InputMaybe<MoveResourcesViewAppendInput>;\n  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */\n  _delete_at_path?: InputMaybe<MoveResourcesViewDeleteAtPathInput>;\n  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */\n  _delete_elem?: InputMaybe<MoveResourcesViewDeleteElemInput>;\n  /** delete key/value pair or string element. key/value pairs are matched based on their key value */\n  _delete_key?: InputMaybe<MoveResourcesViewDeleteKeyInput>;\n  /** increments the numeric columns with given value of the filtered values */\n  _inc?: InputMaybe<MoveResourcesViewIncInput>;\n  /** prepend existing jsonb value of filtered columns with new jsonb value */\n  _prepend?: InputMaybe<MoveResourcesViewPrependInput>;\n  /** sets the columns of the filtered rows to the given values */\n  _set?: InputMaybe<MoveResourcesViewSetInput>;\n  /** filter the rows which have to be updated */\n  where: MoveResourcesViewBoolExp;\n};\n\n/** aggregate var_pop on columns */\nexport type MoveResourcesViewVarPopFields = {\n  transaction_block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate var_samp on columns */\nexport type MoveResourcesViewVarSampFields = {\n  transaction_block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate variance on columns */\nexport type MoveResourcesViewVarianceFields = {\n  transaction_block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** mutation root */\nexport type MutationRoot = {\n  /** delete data from the table: \"account_transactions\" */\n  delete_account_transactions?: Maybe<AccountTransactionsMutationResponse>;\n  /** delete single row from the table: \"account_transactions\" */\n  delete_account_transactions_by_pk?: Maybe<AccountTransactions>;\n  /** delete data from the table: \"ans_lookup\" */\n  delete_ans_lookup?: Maybe<AnsLookupMutationResponse>;\n  /** delete single row from the table: \"ans_lookup\" */\n  delete_ans_lookup_by_pk?: Maybe<AnsLookup>;\n  /** delete data from the table: \"ans_lookup_v2\" */\n  delete_ans_lookup_v2?: Maybe<AnsLookupV2MutationResponse>;\n  /** delete single row from the table: \"ans_lookup_v2\" */\n  delete_ans_lookup_v2_by_pk?: Maybe<AnsLookupV2>;\n  /** delete data from the table: \"ans_primary_name\" */\n  delete_ans_primary_name?: Maybe<AnsPrimaryNameMutationResponse>;\n  /** delete single row from the table: \"ans_primary_name\" */\n  delete_ans_primary_name_by_pk?: Maybe<AnsPrimaryName>;\n  /** delete data from the table: \"ans_primary_name_v2\" */\n  delete_ans_primary_name_v2?: Maybe<AnsPrimaryNameV2MutationResponse>;\n  /** delete single row from the table: \"ans_primary_name_v2\" */\n  delete_ans_primary_name_v2_by_pk?: Maybe<AnsPrimaryNameV2>;\n  /** delete data from the table: \"auth_key_account_addresses\" */\n  delete_auth_key_account_addresses?: Maybe<AuthKeyAccountAddressesMutationResponse>;\n  /** delete single row from the table: \"auth_key_account_addresses\" */\n  delete_auth_key_account_addresses_by_pk?: Maybe<AuthKeyAccountAddresses>;\n  /** delete data from the table: \"block_metadata_transactions\" */\n  delete_block_metadata_transactions?: Maybe<BlockMetadataTransactionsMutationResponse>;\n  /** delete single row from the table: \"block_metadata_transactions\" */\n  delete_block_metadata_transactions_by_pk?: Maybe<BlockMetadataTransactions>;\n  /** delete data from the table: \"coin_activities\" */\n  delete_coin_activities?: Maybe<CoinActivitiesMutationResponse>;\n  /** delete single row from the table: \"coin_activities\" */\n  delete_coin_activities_by_pk?: Maybe<CoinActivities>;\n  /** delete data from the table: \"coin_balances\" */\n  delete_coin_balances?: Maybe<CoinBalancesMutationResponse>;\n  /** delete single row from the table: \"coin_balances\" */\n  delete_coin_balances_by_pk?: Maybe<CoinBalances>;\n  /** delete data from the table: \"coin_infos\" */\n  delete_coin_infos?: Maybe<CoinInfosMutationResponse>;\n  /** delete single row from the table: \"coin_infos\" */\n  delete_coin_infos_by_pk?: Maybe<CoinInfos>;\n  /** delete data from the table: \"coin_supply\" */\n  delete_coin_supply?: Maybe<CoinSupplyMutationResponse>;\n  /** delete single row from the table: \"coin_supply\" */\n  delete_coin_supply_by_pk?: Maybe<CoinSupply>;\n  /** delete data from the table: \"collection_datas\" */\n  delete_collection_datas?: Maybe<CollectionDatasMutationResponse>;\n  /** delete single row from the table: \"collection_datas\" */\n  delete_collection_datas_by_pk?: Maybe<CollectionDatas>;\n  /** delete data from the table: \"collections_v2\" */\n  delete_collections_v2?: Maybe<CollectionsV2MutationResponse>;\n  /** delete single row from the table: \"collections_v2\" */\n  delete_collections_v2_by_pk?: Maybe<CollectionsV2>;\n  /** delete data from the table: \"current_ans_lookup\" */\n  delete_current_ans_lookup?: Maybe<CurrentAnsLookupMutationResponse>;\n  /** delete single row from the table: \"current_ans_lookup\" */\n  delete_current_ans_lookup_by_pk?: Maybe<CurrentAnsLookup>;\n  /** delete data from the table: \"current_ans_lookup_v2\" */\n  delete_current_ans_lookup_v2?: Maybe<CurrentAnsLookupV2MutationResponse>;\n  /** delete single row from the table: \"current_ans_lookup_v2\" */\n  delete_current_ans_lookup_v2_by_pk?: Maybe<CurrentAnsLookupV2>;\n  /** delete data from the table: \"current_ans_primary_name\" */\n  delete_current_ans_primary_name?: Maybe<CurrentAnsPrimaryNameMutationResponse>;\n  /** delete single row from the table: \"current_ans_primary_name\" */\n  delete_current_ans_primary_name_by_pk?: Maybe<CurrentAnsPrimaryName>;\n  /** delete data from the table: \"current_ans_primary_name_v2\" */\n  delete_current_ans_primary_name_v2?: Maybe<CurrentAnsPrimaryNameV2MutationResponse>;\n  /** delete single row from the table: \"current_ans_primary_name_v2\" */\n  delete_current_ans_primary_name_v2_by_pk?: Maybe<CurrentAnsPrimaryNameV2>;\n  /** delete data from the table: \"current_coin_balances\" */\n  delete_current_coin_balances?: Maybe<CurrentCoinBalancesMutationResponse>;\n  /** delete single row from the table: \"current_coin_balances\" */\n  delete_current_coin_balances_by_pk?: Maybe<CurrentCoinBalances>;\n  /** delete data from the table: \"current_collection_datas\" */\n  delete_current_collection_datas?: Maybe<CurrentCollectionDatasMutationResponse>;\n  /** delete single row from the table: \"current_collection_datas\" */\n  delete_current_collection_datas_by_pk?: Maybe<CurrentCollectionDatas>;\n  /** delete data from the table: \"current_collections_v2\" */\n  delete_current_collections_v2?: Maybe<CurrentCollectionsV2MutationResponse>;\n  /** delete single row from the table: \"current_collections_v2\" */\n  delete_current_collections_v2_by_pk?: Maybe<CurrentCollectionsV2>;\n  /** delete data from the table: \"current_delegated_staking_pool_balances\" */\n  delete_current_delegated_staking_pool_balances?: Maybe<CurrentDelegatedStakingPoolBalancesMutationResponse>;\n  /** delete single row from the table: \"current_delegated_staking_pool_balances\" */\n  delete_current_delegated_staking_pool_balances_by_pk?: Maybe<CurrentDelegatedStakingPoolBalances>;\n  /** delete data from the table: \"current_delegated_voter\" */\n  delete_current_delegated_voter?: Maybe<CurrentDelegatedVoterMutationResponse>;\n  /** delete single row from the table: \"current_delegated_voter\" */\n  delete_current_delegated_voter_by_pk?: Maybe<CurrentDelegatedVoter>;\n  /** delete data from the table: \"current_delegator_balances\" */\n  delete_current_delegator_balances?: Maybe<CurrentDelegatorBalancesMutationResponse>;\n  /** delete single row from the table: \"current_delegator_balances\" */\n  delete_current_delegator_balances_by_pk?: Maybe<CurrentDelegatorBalances>;\n  /** delete data from the table: \"current_fungible_asset_balances_legacy\" */\n  delete_current_fungible_asset_balances?: Maybe<CurrentFungibleAssetBalancesMutationResponse>;\n  /** delete single row from the table: \"current_fungible_asset_balances_legacy\" */\n  delete_current_fungible_asset_balances_by_pk?: Maybe<CurrentFungibleAssetBalances>;\n  /** delete data from the table: \"current_fungible_asset_balances\" */\n  delete_current_fungible_asset_balances_new?: Maybe<CurrentFungibleAssetBalancesNewMutationResponse>;\n  /** delete single row from the table: \"current_fungible_asset_balances\" */\n  delete_current_fungible_asset_balances_new_by_pk?: Maybe<CurrentFungibleAssetBalancesNew>;\n  /** delete data from the table: \"current_objects\" */\n  delete_current_objects?: Maybe<CurrentObjectsMutationResponse>;\n  /** delete single row from the table: \"current_objects\" */\n  delete_current_objects_by_pk?: Maybe<CurrentObjects>;\n  /** delete data from the table: \"current_staking_pool_voter\" */\n  delete_current_staking_pool_voter?: Maybe<CurrentStakingPoolVoterMutationResponse>;\n  /** delete single row from the table: \"current_staking_pool_voter\" */\n  delete_current_staking_pool_voter_by_pk?: Maybe<CurrentStakingPoolVoter>;\n  /** delete data from the table: \"current_table_items\" */\n  delete_current_table_items?: Maybe<CurrentTableItemsMutationResponse>;\n  /** delete single row from the table: \"current_table_items\" */\n  delete_current_table_items_by_pk?: Maybe<CurrentTableItems>;\n  /** delete data from the table: \"current_table_items_view\" */\n  delete_current_table_items_view?: Maybe<CurrentTableItemsViewMutationResponse>;\n  /** delete data from the table: \"current_token_datas\" */\n  delete_current_token_datas?: Maybe<CurrentTokenDatasMutationResponse>;\n  /** delete single row from the table: \"current_token_datas\" */\n  delete_current_token_datas_by_pk?: Maybe<CurrentTokenDatas>;\n  /** delete data from the table: \"current_token_datas_v2\" */\n  delete_current_token_datas_v2?: Maybe<CurrentTokenDatasV2MutationResponse>;\n  /** delete single row from the table: \"current_token_datas_v2\" */\n  delete_current_token_datas_v2_by_pk?: Maybe<CurrentTokenDatasV2>;\n  /** delete data from the table: \"current_token_ownerships\" */\n  delete_current_token_ownerships?: Maybe<CurrentTokenOwnershipsMutationResponse>;\n  /** delete single row from the table: \"current_token_ownerships\" */\n  delete_current_token_ownerships_by_pk?: Maybe<CurrentTokenOwnerships>;\n  /** delete data from the table: \"current_token_ownerships_v2\" */\n  delete_current_token_ownerships_v2?: Maybe<CurrentTokenOwnershipsV2MutationResponse>;\n  /** delete single row from the table: \"current_token_ownerships_v2\" */\n  delete_current_token_ownerships_v2_by_pk?: Maybe<CurrentTokenOwnershipsV2>;\n  /** delete data from the table: \"current_token_pending_claims\" */\n  delete_current_token_pending_claims?: Maybe<CurrentTokenPendingClaimsMutationResponse>;\n  /** delete single row from the table: \"current_token_pending_claims\" */\n  delete_current_token_pending_claims_by_pk?: Maybe<CurrentTokenPendingClaims>;\n  /** delete data from the table: \"current_token_royalty_v1\" */\n  delete_current_token_royalty_v1?: Maybe<CurrentTokenRoyaltyV1MutationResponse>;\n  /** delete single row from the table: \"current_token_royalty_v1\" */\n  delete_current_token_royalty_v1_by_pk?: Maybe<CurrentTokenRoyaltyV1>;\n  /** delete data from the table: \"current_token_v2_metadata\" */\n  delete_current_token_v2_metadata?: Maybe<CurrentTokenV2MetadataMutationResponse>;\n  /** delete single row from the table: \"current_token_v2_metadata\" */\n  delete_current_token_v2_metadata_by_pk?: Maybe<CurrentTokenV2Metadata>;\n  /** delete data from the table: \"delegated_staking_activities\" */\n  delete_delegated_staking_activities?: Maybe<DelegatedStakingActivitiesMutationResponse>;\n  /** delete single row from the table: \"delegated_staking_activities\" */\n  delete_delegated_staking_activities_by_pk?: Maybe<DelegatedStakingActivities>;\n  /** delete data from the table: \"delegated_staking_pool_balances\" */\n  delete_delegated_staking_pool_balances?: Maybe<DelegatedStakingPoolBalancesMutationResponse>;\n  /** delete single row from the table: \"delegated_staking_pool_balances\" */\n  delete_delegated_staking_pool_balances_by_pk?: Maybe<DelegatedStakingPoolBalances>;\n  /** delete data from the table: \"delegated_staking_pools\" */\n  delete_delegated_staking_pools?: Maybe<DelegatedStakingPoolsMutationResponse>;\n  /** delete single row from the table: \"delegated_staking_pools\" */\n  delete_delegated_staking_pools_by_pk?: Maybe<DelegatedStakingPools>;\n  /** delete data from the table: \"delegator_balances\" */\n  delete_delegator_balances?: Maybe<DelegatorBalancesMutationResponse>;\n  /** delete single row from the table: \"delegator_balances\" */\n  delete_delegator_balances_by_pk?: Maybe<DelegatorBalances>;\n  /** delete data from the table: \"event_size_info\" */\n  delete_event_size_info?: Maybe<EventSizeInfoMutationResponse>;\n  /** delete single row from the table: \"event_size_info\" */\n  delete_event_size_info_by_pk?: Maybe<EventSizeInfo>;\n  /** delete data from the table: \"events\" */\n  delete_events?: Maybe<EventsMutationResponse>;\n  /** delete single row from the table: \"events\" */\n  delete_events_by_pk?: Maybe<Events>;\n  /** delete data from the table: \"events_view\" */\n  delete_events_view?: Maybe<EventsViewMutationResponse>;\n  /** delete data from the table: \"fungible_asset_activities\" */\n  delete_fungible_asset_activities?: Maybe<FungibleAssetActivitiesMutationResponse>;\n  /** delete single row from the table: \"fungible_asset_activities\" */\n  delete_fungible_asset_activities_by_pk?: Maybe<FungibleAssetActivities>;\n  /** delete data from the table: \"fungible_asset_balances\" */\n  delete_fungible_asset_balances?: Maybe<FungibleAssetBalancesMutationResponse>;\n  /** delete single row from the table: \"fungible_asset_balances\" */\n  delete_fungible_asset_balances_by_pk?: Maybe<FungibleAssetBalances>;\n  /** delete data from the table: \"fungible_asset_metadata\" */\n  delete_fungible_asset_metadata?: Maybe<FungibleAssetMetadataMutationResponse>;\n  /** delete single row from the table: \"fungible_asset_metadata\" */\n  delete_fungible_asset_metadata_by_pk?: Maybe<FungibleAssetMetadata>;\n  /** delete data from the table: \"fungible_asset_to_coin_mappings\" */\n  delete_fungible_asset_to_coin_mappings?: Maybe<FungibleAssetToCoinMappingsMutationResponse>;\n  /** delete single row from the table: \"fungible_asset_to_coin_mappings\" */\n  delete_fungible_asset_to_coin_mappings_by_pk?: Maybe<FungibleAssetToCoinMappings>;\n  /** delete data from the table: \"gas_fees\" */\n  delete_gas_fees?: Maybe<GasFeesMutationResponse>;\n  /** delete single row from the table: \"gas_fees\" */\n  delete_gas_fees_by_pk?: Maybe<GasFees>;\n  /** delete data from the table: \"indexer_status\" */\n  delete_indexer_status?: Maybe<IndexerStatusMutationResponse>;\n  /** delete single row from the table: \"indexer_status\" */\n  delete_indexer_status_by_pk?: Maybe<IndexerStatus>;\n  /** delete data from the table: \"move_modules\" */\n  delete_move_modules?: Maybe<MoveModulesMutationResponse>;\n  /** delete single row from the table: \"move_modules\" */\n  delete_move_modules_by_pk?: Maybe<MoveModules>;\n  /** delete data from the table: \"move_resources\" */\n  delete_move_resources?: Maybe<MoveResourcesMutationResponse>;\n  /** delete single row from the table: \"move_resources\" */\n  delete_move_resources_by_pk?: Maybe<MoveResources>;\n  /** delete data from the table: \"move_resources_view\" */\n  delete_move_resources_view?: Maybe<MoveResourcesViewMutationResponse>;\n  /** delete data from the table: \"nft_metadata_crawler.parsed_asset_uris\" */\n  delete_nft_metadata_crawler_parsed_asset_uris?: Maybe<NftMetadataCrawlerParsedAssetUrisMutationResponse>;\n  /** delete single row from the table: \"nft_metadata_crawler.parsed_asset_uris\" */\n  delete_nft_metadata_crawler_parsed_asset_uris_by_pk?: Maybe<NftMetadataCrawlerParsedAssetUris>;\n  /** delete data from the table: \"nft_points\" */\n  delete_nft_points?: Maybe<NftPointsMutationResponse>;\n  /** delete single row from the table: \"nft_points\" */\n  delete_nft_points_by_pk?: Maybe<NftPoints>;\n  /** delete data from the table: \"objects\" */\n  delete_objects?: Maybe<ObjectsMutationResponse>;\n  /** delete single row from the table: \"objects\" */\n  delete_objects_by_pk?: Maybe<Objects>;\n  /** delete data from the table: \"processor_metadata.processor_status\" */\n  delete_processor_metadata_processor_status?: Maybe<ProcessorMetadataProcessorStatusMutationResponse>;\n  /** delete single row from the table: \"processor_metadata.processor_status\" */\n  delete_processor_metadata_processor_status_by_pk?: Maybe<ProcessorMetadataProcessorStatus>;\n  /** delete data from the table: \"processor_status\" */\n  delete_processor_status?: Maybe<ProcessorStatusMutationResponse>;\n  /** delete single row from the table: \"processor_status\" */\n  delete_processor_status_by_pk?: Maybe<ProcessorStatus>;\n  /** delete data from the table: \"proposal_votes\" */\n  delete_proposal_votes?: Maybe<ProposalVotesMutationResponse>;\n  /** delete single row from the table: \"proposal_votes\" */\n  delete_proposal_votes_by_pk?: Maybe<ProposalVotes>;\n  /** delete data from the table: \"public_key_auth_keys\" */\n  delete_public_key_auth_keys?: Maybe<PublicKeyAuthKeysMutationResponse>;\n  /** delete single row from the table: \"public_key_auth_keys\" */\n  delete_public_key_auth_keys_by_pk?: Maybe<PublicKeyAuthKeys>;\n  /** delete data from the table: \"signatures\" */\n  delete_signatures?: Maybe<SignaturesMutationResponse>;\n  /** delete single row from the table: \"signatures\" */\n  delete_signatures_by_pk?: Maybe<Signatures>;\n  /** delete data from the table: \"spam_assets\" */\n  delete_spam_assets?: Maybe<SpamAssetsMutationResponse>;\n  /** delete single row from the table: \"spam_assets\" */\n  delete_spam_assets_by_pk?: Maybe<SpamAssets>;\n  /** delete data from the table: \"table_items\" */\n  delete_table_items?: Maybe<TableItemsMutationResponse>;\n  /** delete single row from the table: \"table_items\" */\n  delete_table_items_by_pk?: Maybe<TableItems>;\n  /** delete data from the table: \"table_items_view\" */\n  delete_table_items_view?: Maybe<TableItemsViewMutationResponse>;\n  /** delete data from the table: \"table_metadatas\" */\n  delete_table_metadatas?: Maybe<TableMetadatasMutationResponse>;\n  /** delete single row from the table: \"table_metadatas\" */\n  delete_table_metadatas_by_pk?: Maybe<TableMetadatas>;\n  /** delete data from the table: \"token_activities\" */\n  delete_token_activities?: Maybe<TokenActivitiesMutationResponse>;\n  /** delete single row from the table: \"token_activities\" */\n  delete_token_activities_by_pk?: Maybe<TokenActivities>;\n  /** delete data from the table: \"token_activities_v2\" */\n  delete_token_activities_v2?: Maybe<TokenActivitiesV2MutationResponse>;\n  /** delete single row from the table: \"token_activities_v2\" */\n  delete_token_activities_v2_by_pk?: Maybe<TokenActivitiesV2>;\n  /** delete data from the table: \"token_datas\" */\n  delete_token_datas?: Maybe<TokenDatasMutationResponse>;\n  /** delete single row from the table: \"token_datas\" */\n  delete_token_datas_by_pk?: Maybe<TokenDatas>;\n  /** delete data from the table: \"token_datas_v2\" */\n  delete_token_datas_v2?: Maybe<TokenDatasV2MutationResponse>;\n  /** delete single row from the table: \"token_datas_v2\" */\n  delete_token_datas_v2_by_pk?: Maybe<TokenDatasV2>;\n  /** delete data from the table: \"token_ownerships\" */\n  delete_token_ownerships?: Maybe<TokenOwnershipsMutationResponse>;\n  /** delete single row from the table: \"token_ownerships\" */\n  delete_token_ownerships_by_pk?: Maybe<TokenOwnerships>;\n  /** delete data from the table: \"token_ownerships_v2\" */\n  delete_token_ownerships_v2?: Maybe<TokenOwnershipsV2MutationResponse>;\n  /** delete single row from the table: \"token_ownerships_v2\" */\n  delete_token_ownerships_v2_by_pk?: Maybe<TokenOwnershipsV2>;\n  /** delete data from the table: \"tokens\" */\n  delete_tokens?: Maybe<TokensMutationResponse>;\n  /** delete single row from the table: \"tokens\" */\n  delete_tokens_by_pk?: Maybe<Tokens>;\n  /** delete data from the table: \"transaction_size_info\" */\n  delete_transaction_size_info?: Maybe<TransactionSizeInfoMutationResponse>;\n  /** delete single row from the table: \"transaction_size_info\" */\n  delete_transaction_size_info_by_pk?: Maybe<TransactionSizeInfo>;\n  /** delete data from the table: \"transactions_view\" */\n  delete_transactions_view?: Maybe<TransactionsViewMutationResponse>;\n  /** delete data from the table: \"user_transactions\" */\n  delete_user_transactions?: Maybe<UserTransactionsMutationResponse>;\n  /** delete single row from the table: \"user_transactions\" */\n  delete_user_transactions_by_pk?: Maybe<UserTransactions>;\n  /** insert data into the table: \"account_transactions\" */\n  insert_account_transactions?: Maybe<AccountTransactionsMutationResponse>;\n  /** insert a single row into the table: \"account_transactions\" */\n  insert_account_transactions_one?: Maybe<AccountTransactions>;\n  /** insert data into the table: \"ans_lookup\" */\n  insert_ans_lookup?: Maybe<AnsLookupMutationResponse>;\n  /** insert a single row into the table: \"ans_lookup\" */\n  insert_ans_lookup_one?: Maybe<AnsLookup>;\n  /** insert data into the table: \"ans_lookup_v2\" */\n  insert_ans_lookup_v2?: Maybe<AnsLookupV2MutationResponse>;\n  /** insert a single row into the table: \"ans_lookup_v2\" */\n  insert_ans_lookup_v2_one?: Maybe<AnsLookupV2>;\n  /** insert data into the table: \"ans_primary_name\" */\n  insert_ans_primary_name?: Maybe<AnsPrimaryNameMutationResponse>;\n  /** insert a single row into the table: \"ans_primary_name\" */\n  insert_ans_primary_name_one?: Maybe<AnsPrimaryName>;\n  /** insert data into the table: \"ans_primary_name_v2\" */\n  insert_ans_primary_name_v2?: Maybe<AnsPrimaryNameV2MutationResponse>;\n  /** insert a single row into the table: \"ans_primary_name_v2\" */\n  insert_ans_primary_name_v2_one?: Maybe<AnsPrimaryNameV2>;\n  /** insert data into the table: \"auth_key_account_addresses\" */\n  insert_auth_key_account_addresses?: Maybe<AuthKeyAccountAddressesMutationResponse>;\n  /** insert a single row into the table: \"auth_key_account_addresses\" */\n  insert_auth_key_account_addresses_one?: Maybe<AuthKeyAccountAddresses>;\n  /** insert data into the table: \"block_metadata_transactions\" */\n  insert_block_metadata_transactions?: Maybe<BlockMetadataTransactionsMutationResponse>;\n  /** insert a single row into the table: \"block_metadata_transactions\" */\n  insert_block_metadata_transactions_one?: Maybe<BlockMetadataTransactions>;\n  /** insert data into the table: \"coin_activities\" */\n  insert_coin_activities?: Maybe<CoinActivitiesMutationResponse>;\n  /** insert a single row into the table: \"coin_activities\" */\n  insert_coin_activities_one?: Maybe<CoinActivities>;\n  /** insert data into the table: \"coin_balances\" */\n  insert_coin_balances?: Maybe<CoinBalancesMutationResponse>;\n  /** insert a single row into the table: \"coin_balances\" */\n  insert_coin_balances_one?: Maybe<CoinBalances>;\n  /** insert data into the table: \"coin_infos\" */\n  insert_coin_infos?: Maybe<CoinInfosMutationResponse>;\n  /** insert a single row into the table: \"coin_infos\" */\n  insert_coin_infos_one?: Maybe<CoinInfos>;\n  /** insert data into the table: \"coin_supply\" */\n  insert_coin_supply?: Maybe<CoinSupplyMutationResponse>;\n  /** insert a single row into the table: \"coin_supply\" */\n  insert_coin_supply_one?: Maybe<CoinSupply>;\n  /** insert data into the table: \"collection_datas\" */\n  insert_collection_datas?: Maybe<CollectionDatasMutationResponse>;\n  /** insert a single row into the table: \"collection_datas\" */\n  insert_collection_datas_one?: Maybe<CollectionDatas>;\n  /** insert data into the table: \"collections_v2\" */\n  insert_collections_v2?: Maybe<CollectionsV2MutationResponse>;\n  /** insert a single row into the table: \"collections_v2\" */\n  insert_collections_v2_one?: Maybe<CollectionsV2>;\n  /** insert data into the table: \"current_ans_lookup\" */\n  insert_current_ans_lookup?: Maybe<CurrentAnsLookupMutationResponse>;\n  /** insert a single row into the table: \"current_ans_lookup\" */\n  insert_current_ans_lookup_one?: Maybe<CurrentAnsLookup>;\n  /** insert data into the table: \"current_ans_lookup_v2\" */\n  insert_current_ans_lookup_v2?: Maybe<CurrentAnsLookupV2MutationResponse>;\n  /** insert a single row into the table: \"current_ans_lookup_v2\" */\n  insert_current_ans_lookup_v2_one?: Maybe<CurrentAnsLookupV2>;\n  /** insert data into the table: \"current_ans_primary_name\" */\n  insert_current_ans_primary_name?: Maybe<CurrentAnsPrimaryNameMutationResponse>;\n  /** insert a single row into the table: \"current_ans_primary_name\" */\n  insert_current_ans_primary_name_one?: Maybe<CurrentAnsPrimaryName>;\n  /** insert data into the table: \"current_ans_primary_name_v2\" */\n  insert_current_ans_primary_name_v2?: Maybe<CurrentAnsPrimaryNameV2MutationResponse>;\n  /** insert a single row into the table: \"current_ans_primary_name_v2\" */\n  insert_current_ans_primary_name_v2_one?: Maybe<CurrentAnsPrimaryNameV2>;\n  /** insert data into the table: \"current_coin_balances\" */\n  insert_current_coin_balances?: Maybe<CurrentCoinBalancesMutationResponse>;\n  /** insert a single row into the table: \"current_coin_balances\" */\n  insert_current_coin_balances_one?: Maybe<CurrentCoinBalances>;\n  /** insert data into the table: \"current_collection_datas\" */\n  insert_current_collection_datas?: Maybe<CurrentCollectionDatasMutationResponse>;\n  /** insert a single row into the table: \"current_collection_datas\" */\n  insert_current_collection_datas_one?: Maybe<CurrentCollectionDatas>;\n  /** insert data into the table: \"current_collections_v2\" */\n  insert_current_collections_v2?: Maybe<CurrentCollectionsV2MutationResponse>;\n  /** insert a single row into the table: \"current_collections_v2\" */\n  insert_current_collections_v2_one?: Maybe<CurrentCollectionsV2>;\n  /** insert data into the table: \"current_delegated_staking_pool_balances\" */\n  insert_current_delegated_staking_pool_balances?: Maybe<CurrentDelegatedStakingPoolBalancesMutationResponse>;\n  /** insert a single row into the table: \"current_delegated_staking_pool_balances\" */\n  insert_current_delegated_staking_pool_balances_one?: Maybe<CurrentDelegatedStakingPoolBalances>;\n  /** insert data into the table: \"current_delegated_voter\" */\n  insert_current_delegated_voter?: Maybe<CurrentDelegatedVoterMutationResponse>;\n  /** insert a single row into the table: \"current_delegated_voter\" */\n  insert_current_delegated_voter_one?: Maybe<CurrentDelegatedVoter>;\n  /** insert data into the table: \"current_delegator_balances\" */\n  insert_current_delegator_balances?: Maybe<CurrentDelegatorBalancesMutationResponse>;\n  /** insert a single row into the table: \"current_delegator_balances\" */\n  insert_current_delegator_balances_one?: Maybe<CurrentDelegatorBalances>;\n  /** insert data into the table: \"current_fungible_asset_balances_legacy\" */\n  insert_current_fungible_asset_balances?: Maybe<CurrentFungibleAssetBalancesMutationResponse>;\n  /** insert data into the table: \"current_fungible_asset_balances\" */\n  insert_current_fungible_asset_balances_new?: Maybe<CurrentFungibleAssetBalancesNewMutationResponse>;\n  /** insert a single row into the table: \"current_fungible_asset_balances\" */\n  insert_current_fungible_asset_balances_new_one?: Maybe<CurrentFungibleAssetBalancesNew>;\n  /** insert a single row into the table: \"current_fungible_asset_balances_legacy\" */\n  insert_current_fungible_asset_balances_one?: Maybe<CurrentFungibleAssetBalances>;\n  /** insert data into the table: \"current_objects\" */\n  insert_current_objects?: Maybe<CurrentObjectsMutationResponse>;\n  /** insert a single row into the table: \"current_objects\" */\n  insert_current_objects_one?: Maybe<CurrentObjects>;\n  /** insert data into the table: \"current_staking_pool_voter\" */\n  insert_current_staking_pool_voter?: Maybe<CurrentStakingPoolVoterMutationResponse>;\n  /** insert a single row into the table: \"current_staking_pool_voter\" */\n  insert_current_staking_pool_voter_one?: Maybe<CurrentStakingPoolVoter>;\n  /** insert data into the table: \"current_table_items\" */\n  insert_current_table_items?: Maybe<CurrentTableItemsMutationResponse>;\n  /** insert a single row into the table: \"current_table_items\" */\n  insert_current_table_items_one?: Maybe<CurrentTableItems>;\n  /** insert data into the table: \"current_table_items_view\" */\n  insert_current_table_items_view?: Maybe<CurrentTableItemsViewMutationResponse>;\n  /** insert a single row into the table: \"current_table_items_view\" */\n  insert_current_table_items_view_one?: Maybe<CurrentTableItemsView>;\n  /** insert data into the table: \"current_token_datas\" */\n  insert_current_token_datas?: Maybe<CurrentTokenDatasMutationResponse>;\n  /** insert a single row into the table: \"current_token_datas\" */\n  insert_current_token_datas_one?: Maybe<CurrentTokenDatas>;\n  /** insert data into the table: \"current_token_datas_v2\" */\n  insert_current_token_datas_v2?: Maybe<CurrentTokenDatasV2MutationResponse>;\n  /** insert a single row into the table: \"current_token_datas_v2\" */\n  insert_current_token_datas_v2_one?: Maybe<CurrentTokenDatasV2>;\n  /** insert data into the table: \"current_token_ownerships\" */\n  insert_current_token_ownerships?: Maybe<CurrentTokenOwnershipsMutationResponse>;\n  /** insert a single row into the table: \"current_token_ownerships\" */\n  insert_current_token_ownerships_one?: Maybe<CurrentTokenOwnerships>;\n  /** insert data into the table: \"current_token_ownerships_v2\" */\n  insert_current_token_ownerships_v2?: Maybe<CurrentTokenOwnershipsV2MutationResponse>;\n  /** insert a single row into the table: \"current_token_ownerships_v2\" */\n  insert_current_token_ownerships_v2_one?: Maybe<CurrentTokenOwnershipsV2>;\n  /** insert data into the table: \"current_token_pending_claims\" */\n  insert_current_token_pending_claims?: Maybe<CurrentTokenPendingClaimsMutationResponse>;\n  /** insert a single row into the table: \"current_token_pending_claims\" */\n  insert_current_token_pending_claims_one?: Maybe<CurrentTokenPendingClaims>;\n  /** insert data into the table: \"current_token_royalty_v1\" */\n  insert_current_token_royalty_v1?: Maybe<CurrentTokenRoyaltyV1MutationResponse>;\n  /** insert a single row into the table: \"current_token_royalty_v1\" */\n  insert_current_token_royalty_v1_one?: Maybe<CurrentTokenRoyaltyV1>;\n  /** insert data into the table: \"current_token_v2_metadata\" */\n  insert_current_token_v2_metadata?: Maybe<CurrentTokenV2MetadataMutationResponse>;\n  /** insert a single row into the table: \"current_token_v2_metadata\" */\n  insert_current_token_v2_metadata_one?: Maybe<CurrentTokenV2Metadata>;\n  /** insert data into the table: \"delegated_staking_activities\" */\n  insert_delegated_staking_activities?: Maybe<DelegatedStakingActivitiesMutationResponse>;\n  /** insert a single row into the table: \"delegated_staking_activities\" */\n  insert_delegated_staking_activities_one?: Maybe<DelegatedStakingActivities>;\n  /** insert data into the table: \"delegated_staking_pool_balances\" */\n  insert_delegated_staking_pool_balances?: Maybe<DelegatedStakingPoolBalancesMutationResponse>;\n  /** insert a single row into the table: \"delegated_staking_pool_balances\" */\n  insert_delegated_staking_pool_balances_one?: Maybe<DelegatedStakingPoolBalances>;\n  /** insert data into the table: \"delegated_staking_pools\" */\n  insert_delegated_staking_pools?: Maybe<DelegatedStakingPoolsMutationResponse>;\n  /** insert a single row into the table: \"delegated_staking_pools\" */\n  insert_delegated_staking_pools_one?: Maybe<DelegatedStakingPools>;\n  /** insert data into the table: \"delegator_balances\" */\n  insert_delegator_balances?: Maybe<DelegatorBalancesMutationResponse>;\n  /** insert a single row into the table: \"delegator_balances\" */\n  insert_delegator_balances_one?: Maybe<DelegatorBalances>;\n  /** insert data into the table: \"event_size_info\" */\n  insert_event_size_info?: Maybe<EventSizeInfoMutationResponse>;\n  /** insert a single row into the table: \"event_size_info\" */\n  insert_event_size_info_one?: Maybe<EventSizeInfo>;\n  /** insert data into the table: \"events\" */\n  insert_events?: Maybe<EventsMutationResponse>;\n  /** insert a single row into the table: \"events\" */\n  insert_events_one?: Maybe<Events>;\n  /** insert data into the table: \"events_view\" */\n  insert_events_view?: Maybe<EventsViewMutationResponse>;\n  /** insert a single row into the table: \"events_view\" */\n  insert_events_view_one?: Maybe<EventsView>;\n  /** insert data into the table: \"fungible_asset_activities\" */\n  insert_fungible_asset_activities?: Maybe<FungibleAssetActivitiesMutationResponse>;\n  /** insert a single row into the table: \"fungible_asset_activities\" */\n  insert_fungible_asset_activities_one?: Maybe<FungibleAssetActivities>;\n  /** insert data into the table: \"fungible_asset_balances\" */\n  insert_fungible_asset_balances?: Maybe<FungibleAssetBalancesMutationResponse>;\n  /** insert a single row into the table: \"fungible_asset_balances\" */\n  insert_fungible_asset_balances_one?: Maybe<FungibleAssetBalances>;\n  /** insert data into the table: \"fungible_asset_metadata\" */\n  insert_fungible_asset_metadata?: Maybe<FungibleAssetMetadataMutationResponse>;\n  /** insert a single row into the table: \"fungible_asset_metadata\" */\n  insert_fungible_asset_metadata_one?: Maybe<FungibleAssetMetadata>;\n  /** insert data into the table: \"fungible_asset_to_coin_mappings\" */\n  insert_fungible_asset_to_coin_mappings?: Maybe<FungibleAssetToCoinMappingsMutationResponse>;\n  /** insert a single row into the table: \"fungible_asset_to_coin_mappings\" */\n  insert_fungible_asset_to_coin_mappings_one?: Maybe<FungibleAssetToCoinMappings>;\n  /** insert data into the table: \"gas_fees\" */\n  insert_gas_fees?: Maybe<GasFeesMutationResponse>;\n  /** insert a single row into the table: \"gas_fees\" */\n  insert_gas_fees_one?: Maybe<GasFees>;\n  /** insert data into the table: \"indexer_status\" */\n  insert_indexer_status?: Maybe<IndexerStatusMutationResponse>;\n  /** insert a single row into the table: \"indexer_status\" */\n  insert_indexer_status_one?: Maybe<IndexerStatus>;\n  /** insert data into the table: \"move_modules\" */\n  insert_move_modules?: Maybe<MoveModulesMutationResponse>;\n  /** insert a single row into the table: \"move_modules\" */\n  insert_move_modules_one?: Maybe<MoveModules>;\n  /** insert data into the table: \"move_resources\" */\n  insert_move_resources?: Maybe<MoveResourcesMutationResponse>;\n  /** insert a single row into the table: \"move_resources\" */\n  insert_move_resources_one?: Maybe<MoveResources>;\n  /** insert data into the table: \"move_resources_view\" */\n  insert_move_resources_view?: Maybe<MoveResourcesViewMutationResponse>;\n  /** insert a single row into the table: \"move_resources_view\" */\n  insert_move_resources_view_one?: Maybe<MoveResourcesView>;\n  /** insert data into the table: \"nft_metadata_crawler.parsed_asset_uris\" */\n  insert_nft_metadata_crawler_parsed_asset_uris?: Maybe<NftMetadataCrawlerParsedAssetUrisMutationResponse>;\n  /** insert a single row into the table: \"nft_metadata_crawler.parsed_asset_uris\" */\n  insert_nft_metadata_crawler_parsed_asset_uris_one?: Maybe<NftMetadataCrawlerParsedAssetUris>;\n  /** insert data into the table: \"nft_points\" */\n  insert_nft_points?: Maybe<NftPointsMutationResponse>;\n  /** insert a single row into the table: \"nft_points\" */\n  insert_nft_points_one?: Maybe<NftPoints>;\n  /** insert data into the table: \"objects\" */\n  insert_objects?: Maybe<ObjectsMutationResponse>;\n  /** insert a single row into the table: \"objects\" */\n  insert_objects_one?: Maybe<Objects>;\n  /** insert data into the table: \"processor_metadata.processor_status\" */\n  insert_processor_metadata_processor_status?: Maybe<ProcessorMetadataProcessorStatusMutationResponse>;\n  /** insert a single row into the table: \"processor_metadata.processor_status\" */\n  insert_processor_metadata_processor_status_one?: Maybe<ProcessorMetadataProcessorStatus>;\n  /** insert data into the table: \"processor_status\" */\n  insert_processor_status?: Maybe<ProcessorStatusMutationResponse>;\n  /** insert a single row into the table: \"processor_status\" */\n  insert_processor_status_one?: Maybe<ProcessorStatus>;\n  /** insert data into the table: \"proposal_votes\" */\n  insert_proposal_votes?: Maybe<ProposalVotesMutationResponse>;\n  /** insert a single row into the table: \"proposal_votes\" */\n  insert_proposal_votes_one?: Maybe<ProposalVotes>;\n  /** insert data into the table: \"public_key_auth_keys\" */\n  insert_public_key_auth_keys?: Maybe<PublicKeyAuthKeysMutationResponse>;\n  /** insert a single row into the table: \"public_key_auth_keys\" */\n  insert_public_key_auth_keys_one?: Maybe<PublicKeyAuthKeys>;\n  /** insert data into the table: \"signatures\" */\n  insert_signatures?: Maybe<SignaturesMutationResponse>;\n  /** insert a single row into the table: \"signatures\" */\n  insert_signatures_one?: Maybe<Signatures>;\n  /** insert data into the table: \"spam_assets\" */\n  insert_spam_assets?: Maybe<SpamAssetsMutationResponse>;\n  /** insert a single row into the table: \"spam_assets\" */\n  insert_spam_assets_one?: Maybe<SpamAssets>;\n  /** insert data into the table: \"table_items\" */\n  insert_table_items?: Maybe<TableItemsMutationResponse>;\n  /** insert a single row into the table: \"table_items\" */\n  insert_table_items_one?: Maybe<TableItems>;\n  /** insert data into the table: \"table_items_view\" */\n  insert_table_items_view?: Maybe<TableItemsViewMutationResponse>;\n  /** insert a single row into the table: \"table_items_view\" */\n  insert_table_items_view_one?: Maybe<TableItemsView>;\n  /** insert data into the table: \"table_metadatas\" */\n  insert_table_metadatas?: Maybe<TableMetadatasMutationResponse>;\n  /** insert a single row into the table: \"table_metadatas\" */\n  insert_table_metadatas_one?: Maybe<TableMetadatas>;\n  /** insert data into the table: \"token_activities\" */\n  insert_token_activities?: Maybe<TokenActivitiesMutationResponse>;\n  /** insert a single row into the table: \"token_activities\" */\n  insert_token_activities_one?: Maybe<TokenActivities>;\n  /** insert data into the table: \"token_activities_v2\" */\n  insert_token_activities_v2?: Maybe<TokenActivitiesV2MutationResponse>;\n  /** insert a single row into the table: \"token_activities_v2\" */\n  insert_token_activities_v2_one?: Maybe<TokenActivitiesV2>;\n  /** insert data into the table: \"token_datas\" */\n  insert_token_datas?: Maybe<TokenDatasMutationResponse>;\n  /** insert a single row into the table: \"token_datas\" */\n  insert_token_datas_one?: Maybe<TokenDatas>;\n  /** insert data into the table: \"token_datas_v2\" */\n  insert_token_datas_v2?: Maybe<TokenDatasV2MutationResponse>;\n  /** insert a single row into the table: \"token_datas_v2\" */\n  insert_token_datas_v2_one?: Maybe<TokenDatasV2>;\n  /** insert data into the table: \"token_ownerships\" */\n  insert_token_ownerships?: Maybe<TokenOwnershipsMutationResponse>;\n  /** insert a single row into the table: \"token_ownerships\" */\n  insert_token_ownerships_one?: Maybe<TokenOwnerships>;\n  /** insert data into the table: \"token_ownerships_v2\" */\n  insert_token_ownerships_v2?: Maybe<TokenOwnershipsV2MutationResponse>;\n  /** insert a single row into the table: \"token_ownerships_v2\" */\n  insert_token_ownerships_v2_one?: Maybe<TokenOwnershipsV2>;\n  /** insert data into the table: \"tokens\" */\n  insert_tokens?: Maybe<TokensMutationResponse>;\n  /** insert a single row into the table: \"tokens\" */\n  insert_tokens_one?: Maybe<Tokens>;\n  /** insert data into the table: \"transaction_size_info\" */\n  insert_transaction_size_info?: Maybe<TransactionSizeInfoMutationResponse>;\n  /** insert a single row into the table: \"transaction_size_info\" */\n  insert_transaction_size_info_one?: Maybe<TransactionSizeInfo>;\n  /** insert data into the table: \"transactions_view\" */\n  insert_transactions_view?: Maybe<TransactionsViewMutationResponse>;\n  /** insert a single row into the table: \"transactions_view\" */\n  insert_transactions_view_one?: Maybe<TransactionsView>;\n  /** insert data into the table: \"user_transactions\" */\n  insert_user_transactions?: Maybe<UserTransactionsMutationResponse>;\n  /** insert a single row into the table: \"user_transactions\" */\n  insert_user_transactions_one?: Maybe<UserTransactions>;\n  /** update data of the table: \"account_transactions\" */\n  update_account_transactions?: Maybe<AccountTransactionsMutationResponse>;\n  /** update single row of the table: \"account_transactions\" */\n  update_account_transactions_by_pk?: Maybe<AccountTransactions>;\n  /** update multiples rows of table: \"account_transactions\" */\n  update_account_transactions_many?: Maybe<Array<Maybe<AccountTransactionsMutationResponse>>>;\n  /** update data of the table: \"ans_lookup\" */\n  update_ans_lookup?: Maybe<AnsLookupMutationResponse>;\n  /** update single row of the table: \"ans_lookup\" */\n  update_ans_lookup_by_pk?: Maybe<AnsLookup>;\n  /** update multiples rows of table: \"ans_lookup\" */\n  update_ans_lookup_many?: Maybe<Array<Maybe<AnsLookupMutationResponse>>>;\n  /** update data of the table: \"ans_lookup_v2\" */\n  update_ans_lookup_v2?: Maybe<AnsLookupV2MutationResponse>;\n  /** update single row of the table: \"ans_lookup_v2\" */\n  update_ans_lookup_v2_by_pk?: Maybe<AnsLookupV2>;\n  /** update multiples rows of table: \"ans_lookup_v2\" */\n  update_ans_lookup_v2_many?: Maybe<Array<Maybe<AnsLookupV2MutationResponse>>>;\n  /** update data of the table: \"ans_primary_name\" */\n  update_ans_primary_name?: Maybe<AnsPrimaryNameMutationResponse>;\n  /** update single row of the table: \"ans_primary_name\" */\n  update_ans_primary_name_by_pk?: Maybe<AnsPrimaryName>;\n  /** update multiples rows of table: \"ans_primary_name\" */\n  update_ans_primary_name_many?: Maybe<Array<Maybe<AnsPrimaryNameMutationResponse>>>;\n  /** update data of the table: \"ans_primary_name_v2\" */\n  update_ans_primary_name_v2?: Maybe<AnsPrimaryNameV2MutationResponse>;\n  /** update single row of the table: \"ans_primary_name_v2\" */\n  update_ans_primary_name_v2_by_pk?: Maybe<AnsPrimaryNameV2>;\n  /** update multiples rows of table: \"ans_primary_name_v2\" */\n  update_ans_primary_name_v2_many?: Maybe<Array<Maybe<AnsPrimaryNameV2MutationResponse>>>;\n  /** update data of the table: \"auth_key_account_addresses\" */\n  update_auth_key_account_addresses?: Maybe<AuthKeyAccountAddressesMutationResponse>;\n  /** update single row of the table: \"auth_key_account_addresses\" */\n  update_auth_key_account_addresses_by_pk?: Maybe<AuthKeyAccountAddresses>;\n  /** update multiples rows of table: \"auth_key_account_addresses\" */\n  update_auth_key_account_addresses_many?: Maybe<Array<Maybe<AuthKeyAccountAddressesMutationResponse>>>;\n  /** update data of the table: \"block_metadata_transactions\" */\n  update_block_metadata_transactions?: Maybe<BlockMetadataTransactionsMutationResponse>;\n  /** update single row of the table: \"block_metadata_transactions\" */\n  update_block_metadata_transactions_by_pk?: Maybe<BlockMetadataTransactions>;\n  /** update multiples rows of table: \"block_metadata_transactions\" */\n  update_block_metadata_transactions_many?: Maybe<Array<Maybe<BlockMetadataTransactionsMutationResponse>>>;\n  /** update data of the table: \"coin_activities\" */\n  update_coin_activities?: Maybe<CoinActivitiesMutationResponse>;\n  /** update single row of the table: \"coin_activities\" */\n  update_coin_activities_by_pk?: Maybe<CoinActivities>;\n  /** update multiples rows of table: \"coin_activities\" */\n  update_coin_activities_many?: Maybe<Array<Maybe<CoinActivitiesMutationResponse>>>;\n  /** update data of the table: \"coin_balances\" */\n  update_coin_balances?: Maybe<CoinBalancesMutationResponse>;\n  /** update single row of the table: \"coin_balances\" */\n  update_coin_balances_by_pk?: Maybe<CoinBalances>;\n  /** update multiples rows of table: \"coin_balances\" */\n  update_coin_balances_many?: Maybe<Array<Maybe<CoinBalancesMutationResponse>>>;\n  /** update data of the table: \"coin_infos\" */\n  update_coin_infos?: Maybe<CoinInfosMutationResponse>;\n  /** update single row of the table: \"coin_infos\" */\n  update_coin_infos_by_pk?: Maybe<CoinInfos>;\n  /** update multiples rows of table: \"coin_infos\" */\n  update_coin_infos_many?: Maybe<Array<Maybe<CoinInfosMutationResponse>>>;\n  /** update data of the table: \"coin_supply\" */\n  update_coin_supply?: Maybe<CoinSupplyMutationResponse>;\n  /** update single row of the table: \"coin_supply\" */\n  update_coin_supply_by_pk?: Maybe<CoinSupply>;\n  /** update multiples rows of table: \"coin_supply\" */\n  update_coin_supply_many?: Maybe<Array<Maybe<CoinSupplyMutationResponse>>>;\n  /** update data of the table: \"collection_datas\" */\n  update_collection_datas?: Maybe<CollectionDatasMutationResponse>;\n  /** update single row of the table: \"collection_datas\" */\n  update_collection_datas_by_pk?: Maybe<CollectionDatas>;\n  /** update multiples rows of table: \"collection_datas\" */\n  update_collection_datas_many?: Maybe<Array<Maybe<CollectionDatasMutationResponse>>>;\n  /** update data of the table: \"collections_v2\" */\n  update_collections_v2?: Maybe<CollectionsV2MutationResponse>;\n  /** update single row of the table: \"collections_v2\" */\n  update_collections_v2_by_pk?: Maybe<CollectionsV2>;\n  /** update multiples rows of table: \"collections_v2\" */\n  update_collections_v2_many?: Maybe<Array<Maybe<CollectionsV2MutationResponse>>>;\n  /** update data of the table: \"current_ans_lookup\" */\n  update_current_ans_lookup?: Maybe<CurrentAnsLookupMutationResponse>;\n  /** update single row of the table: \"current_ans_lookup\" */\n  update_current_ans_lookup_by_pk?: Maybe<CurrentAnsLookup>;\n  /** update multiples rows of table: \"current_ans_lookup\" */\n  update_current_ans_lookup_many?: Maybe<Array<Maybe<CurrentAnsLookupMutationResponse>>>;\n  /** update data of the table: \"current_ans_lookup_v2\" */\n  update_current_ans_lookup_v2?: Maybe<CurrentAnsLookupV2MutationResponse>;\n  /** update single row of the table: \"current_ans_lookup_v2\" */\n  update_current_ans_lookup_v2_by_pk?: Maybe<CurrentAnsLookupV2>;\n  /** update multiples rows of table: \"current_ans_lookup_v2\" */\n  update_current_ans_lookup_v2_many?: Maybe<Array<Maybe<CurrentAnsLookupV2MutationResponse>>>;\n  /** update data of the table: \"current_ans_primary_name\" */\n  update_current_ans_primary_name?: Maybe<CurrentAnsPrimaryNameMutationResponse>;\n  /** update single row of the table: \"current_ans_primary_name\" */\n  update_current_ans_primary_name_by_pk?: Maybe<CurrentAnsPrimaryName>;\n  /** update multiples rows of table: \"current_ans_primary_name\" */\n  update_current_ans_primary_name_many?: Maybe<Array<Maybe<CurrentAnsPrimaryNameMutationResponse>>>;\n  /** update data of the table: \"current_ans_primary_name_v2\" */\n  update_current_ans_primary_name_v2?: Maybe<CurrentAnsPrimaryNameV2MutationResponse>;\n  /** update single row of the table: \"current_ans_primary_name_v2\" */\n  update_current_ans_primary_name_v2_by_pk?: Maybe<CurrentAnsPrimaryNameV2>;\n  /** update multiples rows of table: \"current_ans_primary_name_v2\" */\n  update_current_ans_primary_name_v2_many?: Maybe<Array<Maybe<CurrentAnsPrimaryNameV2MutationResponse>>>;\n  /** update data of the table: \"current_coin_balances\" */\n  update_current_coin_balances?: Maybe<CurrentCoinBalancesMutationResponse>;\n  /** update single row of the table: \"current_coin_balances\" */\n  update_current_coin_balances_by_pk?: Maybe<CurrentCoinBalances>;\n  /** update multiples rows of table: \"current_coin_balances\" */\n  update_current_coin_balances_many?: Maybe<Array<Maybe<CurrentCoinBalancesMutationResponse>>>;\n  /** update data of the table: \"current_collection_datas\" */\n  update_current_collection_datas?: Maybe<CurrentCollectionDatasMutationResponse>;\n  /** update single row of the table: \"current_collection_datas\" */\n  update_current_collection_datas_by_pk?: Maybe<CurrentCollectionDatas>;\n  /** update multiples rows of table: \"current_collection_datas\" */\n  update_current_collection_datas_many?: Maybe<Array<Maybe<CurrentCollectionDatasMutationResponse>>>;\n  /** update data of the table: \"current_collections_v2\" */\n  update_current_collections_v2?: Maybe<CurrentCollectionsV2MutationResponse>;\n  /** update single row of the table: \"current_collections_v2\" */\n  update_current_collections_v2_by_pk?: Maybe<CurrentCollectionsV2>;\n  /** update multiples rows of table: \"current_collections_v2\" */\n  update_current_collections_v2_many?: Maybe<Array<Maybe<CurrentCollectionsV2MutationResponse>>>;\n  /** update data of the table: \"current_delegated_staking_pool_balances\" */\n  update_current_delegated_staking_pool_balances?: Maybe<CurrentDelegatedStakingPoolBalancesMutationResponse>;\n  /** update single row of the table: \"current_delegated_staking_pool_balances\" */\n  update_current_delegated_staking_pool_balances_by_pk?: Maybe<CurrentDelegatedStakingPoolBalances>;\n  /** update multiples rows of table: \"current_delegated_staking_pool_balances\" */\n  update_current_delegated_staking_pool_balances_many?: Maybe<\n    Array<Maybe<CurrentDelegatedStakingPoolBalancesMutationResponse>>\n  >;\n  /** update data of the table: \"current_delegated_voter\" */\n  update_current_delegated_voter?: Maybe<CurrentDelegatedVoterMutationResponse>;\n  /** update single row of the table: \"current_delegated_voter\" */\n  update_current_delegated_voter_by_pk?: Maybe<CurrentDelegatedVoter>;\n  /** update multiples rows of table: \"current_delegated_voter\" */\n  update_current_delegated_voter_many?: Maybe<Array<Maybe<CurrentDelegatedVoterMutationResponse>>>;\n  /** update data of the table: \"current_delegator_balances\" */\n  update_current_delegator_balances?: Maybe<CurrentDelegatorBalancesMutationResponse>;\n  /** update single row of the table: \"current_delegator_balances\" */\n  update_current_delegator_balances_by_pk?: Maybe<CurrentDelegatorBalances>;\n  /** update multiples rows of table: \"current_delegator_balances\" */\n  update_current_delegator_balances_many?: Maybe<Array<Maybe<CurrentDelegatorBalancesMutationResponse>>>;\n  /** update data of the table: \"current_fungible_asset_balances_legacy\" */\n  update_current_fungible_asset_balances?: Maybe<CurrentFungibleAssetBalancesMutationResponse>;\n  /** update single row of the table: \"current_fungible_asset_balances_legacy\" */\n  update_current_fungible_asset_balances_by_pk?: Maybe<CurrentFungibleAssetBalances>;\n  /** update multiples rows of table: \"current_fungible_asset_balances_legacy\" */\n  update_current_fungible_asset_balances_many?: Maybe<Array<Maybe<CurrentFungibleAssetBalancesMutationResponse>>>;\n  /** update data of the table: \"current_fungible_asset_balances\" */\n  update_current_fungible_asset_balances_new?: Maybe<CurrentFungibleAssetBalancesNewMutationResponse>;\n  /** update single row of the table: \"current_fungible_asset_balances\" */\n  update_current_fungible_asset_balances_new_by_pk?: Maybe<CurrentFungibleAssetBalancesNew>;\n  /** update multiples rows of table: \"current_fungible_asset_balances\" */\n  update_current_fungible_asset_balances_new_many?: Maybe<\n    Array<Maybe<CurrentFungibleAssetBalancesNewMutationResponse>>\n  >;\n  /** update data of the table: \"current_objects\" */\n  update_current_objects?: Maybe<CurrentObjectsMutationResponse>;\n  /** update single row of the table: \"current_objects\" */\n  update_current_objects_by_pk?: Maybe<CurrentObjects>;\n  /** update multiples rows of table: \"current_objects\" */\n  update_current_objects_many?: Maybe<Array<Maybe<CurrentObjectsMutationResponse>>>;\n  /** update data of the table: \"current_staking_pool_voter\" */\n  update_current_staking_pool_voter?: Maybe<CurrentStakingPoolVoterMutationResponse>;\n  /** update single row of the table: \"current_staking_pool_voter\" */\n  update_current_staking_pool_voter_by_pk?: Maybe<CurrentStakingPoolVoter>;\n  /** update multiples rows of table: \"current_staking_pool_voter\" */\n  update_current_staking_pool_voter_many?: Maybe<Array<Maybe<CurrentStakingPoolVoterMutationResponse>>>;\n  /** update data of the table: \"current_table_items\" */\n  update_current_table_items?: Maybe<CurrentTableItemsMutationResponse>;\n  /** update single row of the table: \"current_table_items\" */\n  update_current_table_items_by_pk?: Maybe<CurrentTableItems>;\n  /** update multiples rows of table: \"current_table_items\" */\n  update_current_table_items_many?: Maybe<Array<Maybe<CurrentTableItemsMutationResponse>>>;\n  /** update data of the table: \"current_table_items_view\" */\n  update_current_table_items_view?: Maybe<CurrentTableItemsViewMutationResponse>;\n  /** update multiples rows of table: \"current_table_items_view\" */\n  update_current_table_items_view_many?: Maybe<Array<Maybe<CurrentTableItemsViewMutationResponse>>>;\n  /** update data of the table: \"current_token_datas\" */\n  update_current_token_datas?: Maybe<CurrentTokenDatasMutationResponse>;\n  /** update single row of the table: \"current_token_datas\" */\n  update_current_token_datas_by_pk?: Maybe<CurrentTokenDatas>;\n  /** update multiples rows of table: \"current_token_datas\" */\n  update_current_token_datas_many?: Maybe<Array<Maybe<CurrentTokenDatasMutationResponse>>>;\n  /** update data of the table: \"current_token_datas_v2\" */\n  update_current_token_datas_v2?: Maybe<CurrentTokenDatasV2MutationResponse>;\n  /** update single row of the table: \"current_token_datas_v2\" */\n  update_current_token_datas_v2_by_pk?: Maybe<CurrentTokenDatasV2>;\n  /** update multiples rows of table: \"current_token_datas_v2\" */\n  update_current_token_datas_v2_many?: Maybe<Array<Maybe<CurrentTokenDatasV2MutationResponse>>>;\n  /** update data of the table: \"current_token_ownerships\" */\n  update_current_token_ownerships?: Maybe<CurrentTokenOwnershipsMutationResponse>;\n  /** update single row of the table: \"current_token_ownerships\" */\n  update_current_token_ownerships_by_pk?: Maybe<CurrentTokenOwnerships>;\n  /** update multiples rows of table: \"current_token_ownerships\" */\n  update_current_token_ownerships_many?: Maybe<Array<Maybe<CurrentTokenOwnershipsMutationResponse>>>;\n  /** update data of the table: \"current_token_ownerships_v2\" */\n  update_current_token_ownerships_v2?: Maybe<CurrentTokenOwnershipsV2MutationResponse>;\n  /** update single row of the table: \"current_token_ownerships_v2\" */\n  update_current_token_ownerships_v2_by_pk?: Maybe<CurrentTokenOwnershipsV2>;\n  /** update multiples rows of table: \"current_token_ownerships_v2\" */\n  update_current_token_ownerships_v2_many?: Maybe<Array<Maybe<CurrentTokenOwnershipsV2MutationResponse>>>;\n  /** update data of the table: \"current_token_pending_claims\" */\n  update_current_token_pending_claims?: Maybe<CurrentTokenPendingClaimsMutationResponse>;\n  /** update single row of the table: \"current_token_pending_claims\" */\n  update_current_token_pending_claims_by_pk?: Maybe<CurrentTokenPendingClaims>;\n  /** update multiples rows of table: \"current_token_pending_claims\" */\n  update_current_token_pending_claims_many?: Maybe<Array<Maybe<CurrentTokenPendingClaimsMutationResponse>>>;\n  /** update data of the table: \"current_token_royalty_v1\" */\n  update_current_token_royalty_v1?: Maybe<CurrentTokenRoyaltyV1MutationResponse>;\n  /** update single row of the table: \"current_token_royalty_v1\" */\n  update_current_token_royalty_v1_by_pk?: Maybe<CurrentTokenRoyaltyV1>;\n  /** update multiples rows of table: \"current_token_royalty_v1\" */\n  update_current_token_royalty_v1_many?: Maybe<Array<Maybe<CurrentTokenRoyaltyV1MutationResponse>>>;\n  /** update data of the table: \"current_token_v2_metadata\" */\n  update_current_token_v2_metadata?: Maybe<CurrentTokenV2MetadataMutationResponse>;\n  /** update single row of the table: \"current_token_v2_metadata\" */\n  update_current_token_v2_metadata_by_pk?: Maybe<CurrentTokenV2Metadata>;\n  /** update multiples rows of table: \"current_token_v2_metadata\" */\n  update_current_token_v2_metadata_many?: Maybe<Array<Maybe<CurrentTokenV2MetadataMutationResponse>>>;\n  /** update data of the table: \"delegated_staking_activities\" */\n  update_delegated_staking_activities?: Maybe<DelegatedStakingActivitiesMutationResponse>;\n  /** update single row of the table: \"delegated_staking_activities\" */\n  update_delegated_staking_activities_by_pk?: Maybe<DelegatedStakingActivities>;\n  /** update multiples rows of table: \"delegated_staking_activities\" */\n  update_delegated_staking_activities_many?: Maybe<Array<Maybe<DelegatedStakingActivitiesMutationResponse>>>;\n  /** update data of the table: \"delegated_staking_pool_balances\" */\n  update_delegated_staking_pool_balances?: Maybe<DelegatedStakingPoolBalancesMutationResponse>;\n  /** update single row of the table: \"delegated_staking_pool_balances\" */\n  update_delegated_staking_pool_balances_by_pk?: Maybe<DelegatedStakingPoolBalances>;\n  /** update multiples rows of table: \"delegated_staking_pool_balances\" */\n  update_delegated_staking_pool_balances_many?: Maybe<Array<Maybe<DelegatedStakingPoolBalancesMutationResponse>>>;\n  /** update data of the table: \"delegated_staking_pools\" */\n  update_delegated_staking_pools?: Maybe<DelegatedStakingPoolsMutationResponse>;\n  /** update single row of the table: \"delegated_staking_pools\" */\n  update_delegated_staking_pools_by_pk?: Maybe<DelegatedStakingPools>;\n  /** update multiples rows of table: \"delegated_staking_pools\" */\n  update_delegated_staking_pools_many?: Maybe<Array<Maybe<DelegatedStakingPoolsMutationResponse>>>;\n  /** update data of the table: \"delegator_balances\" */\n  update_delegator_balances?: Maybe<DelegatorBalancesMutationResponse>;\n  /** update single row of the table: \"delegator_balances\" */\n  update_delegator_balances_by_pk?: Maybe<DelegatorBalances>;\n  /** update multiples rows of table: \"delegator_balances\" */\n  update_delegator_balances_many?: Maybe<Array<Maybe<DelegatorBalancesMutationResponse>>>;\n  /** update data of the table: \"event_size_info\" */\n  update_event_size_info?: Maybe<EventSizeInfoMutationResponse>;\n  /** update single row of the table: \"event_size_info\" */\n  update_event_size_info_by_pk?: Maybe<EventSizeInfo>;\n  /** update multiples rows of table: \"event_size_info\" */\n  update_event_size_info_many?: Maybe<Array<Maybe<EventSizeInfoMutationResponse>>>;\n  /** update data of the table: \"events\" */\n  update_events?: Maybe<EventsMutationResponse>;\n  /** update single row of the table: \"events\" */\n  update_events_by_pk?: Maybe<Events>;\n  /** update multiples rows of table: \"events\" */\n  update_events_many?: Maybe<Array<Maybe<EventsMutationResponse>>>;\n  /** update data of the table: \"events_view\" */\n  update_events_view?: Maybe<EventsViewMutationResponse>;\n  /** update multiples rows of table: \"events_view\" */\n  update_events_view_many?: Maybe<Array<Maybe<EventsViewMutationResponse>>>;\n  /** update data of the table: \"fungible_asset_activities\" */\n  update_fungible_asset_activities?: Maybe<FungibleAssetActivitiesMutationResponse>;\n  /** update single row of the table: \"fungible_asset_activities\" */\n  update_fungible_asset_activities_by_pk?: Maybe<FungibleAssetActivities>;\n  /** update multiples rows of table: \"fungible_asset_activities\" */\n  update_fungible_asset_activities_many?: Maybe<Array<Maybe<FungibleAssetActivitiesMutationResponse>>>;\n  /** update data of the table: \"fungible_asset_balances\" */\n  update_fungible_asset_balances?: Maybe<FungibleAssetBalancesMutationResponse>;\n  /** update single row of the table: \"fungible_asset_balances\" */\n  update_fungible_asset_balances_by_pk?: Maybe<FungibleAssetBalances>;\n  /** update multiples rows of table: \"fungible_asset_balances\" */\n  update_fungible_asset_balances_many?: Maybe<Array<Maybe<FungibleAssetBalancesMutationResponse>>>;\n  /** update data of the table: \"fungible_asset_metadata\" */\n  update_fungible_asset_metadata?: Maybe<FungibleAssetMetadataMutationResponse>;\n  /** update single row of the table: \"fungible_asset_metadata\" */\n  update_fungible_asset_metadata_by_pk?: Maybe<FungibleAssetMetadata>;\n  /** update multiples rows of table: \"fungible_asset_metadata\" */\n  update_fungible_asset_metadata_many?: Maybe<Array<Maybe<FungibleAssetMetadataMutationResponse>>>;\n  /** update data of the table: \"fungible_asset_to_coin_mappings\" */\n  update_fungible_asset_to_coin_mappings?: Maybe<FungibleAssetToCoinMappingsMutationResponse>;\n  /** update single row of the table: \"fungible_asset_to_coin_mappings\" */\n  update_fungible_asset_to_coin_mappings_by_pk?: Maybe<FungibleAssetToCoinMappings>;\n  /** update multiples rows of table: \"fungible_asset_to_coin_mappings\" */\n  update_fungible_asset_to_coin_mappings_many?: Maybe<Array<Maybe<FungibleAssetToCoinMappingsMutationResponse>>>;\n  /** update data of the table: \"gas_fees\" */\n  update_gas_fees?: Maybe<GasFeesMutationResponse>;\n  /** update single row of the table: \"gas_fees\" */\n  update_gas_fees_by_pk?: Maybe<GasFees>;\n  /** update multiples rows of table: \"gas_fees\" */\n  update_gas_fees_many?: Maybe<Array<Maybe<GasFeesMutationResponse>>>;\n  /** update data of the table: \"indexer_status\" */\n  update_indexer_status?: Maybe<IndexerStatusMutationResponse>;\n  /** update single row of the table: \"indexer_status\" */\n  update_indexer_status_by_pk?: Maybe<IndexerStatus>;\n  /** update multiples rows of table: \"indexer_status\" */\n  update_indexer_status_many?: Maybe<Array<Maybe<IndexerStatusMutationResponse>>>;\n  /** update data of the table: \"move_modules\" */\n  update_move_modules?: Maybe<MoveModulesMutationResponse>;\n  /** update single row of the table: \"move_modules\" */\n  update_move_modules_by_pk?: Maybe<MoveModules>;\n  /** update multiples rows of table: \"move_modules\" */\n  update_move_modules_many?: Maybe<Array<Maybe<MoveModulesMutationResponse>>>;\n  /** update data of the table: \"move_resources\" */\n  update_move_resources?: Maybe<MoveResourcesMutationResponse>;\n  /** update single row of the table: \"move_resources\" */\n  update_move_resources_by_pk?: Maybe<MoveResources>;\n  /** update multiples rows of table: \"move_resources\" */\n  update_move_resources_many?: Maybe<Array<Maybe<MoveResourcesMutationResponse>>>;\n  /** update data of the table: \"move_resources_view\" */\n  update_move_resources_view?: Maybe<MoveResourcesViewMutationResponse>;\n  /** update multiples rows of table: \"move_resources_view\" */\n  update_move_resources_view_many?: Maybe<Array<Maybe<MoveResourcesViewMutationResponse>>>;\n  /** update data of the table: \"nft_metadata_crawler.parsed_asset_uris\" */\n  update_nft_metadata_crawler_parsed_asset_uris?: Maybe<NftMetadataCrawlerParsedAssetUrisMutationResponse>;\n  /** update single row of the table: \"nft_metadata_crawler.parsed_asset_uris\" */\n  update_nft_metadata_crawler_parsed_asset_uris_by_pk?: Maybe<NftMetadataCrawlerParsedAssetUris>;\n  /** update multiples rows of table: \"nft_metadata_crawler.parsed_asset_uris\" */\n  update_nft_metadata_crawler_parsed_asset_uris_many?: Maybe<\n    Array<Maybe<NftMetadataCrawlerParsedAssetUrisMutationResponse>>\n  >;\n  /** update data of the table: \"nft_points\" */\n  update_nft_points?: Maybe<NftPointsMutationResponse>;\n  /** update single row of the table: \"nft_points\" */\n  update_nft_points_by_pk?: Maybe<NftPoints>;\n  /** update multiples rows of table: \"nft_points\" */\n  update_nft_points_many?: Maybe<Array<Maybe<NftPointsMutationResponse>>>;\n  /** update data of the table: \"objects\" */\n  update_objects?: Maybe<ObjectsMutationResponse>;\n  /** update single row of the table: \"objects\" */\n  update_objects_by_pk?: Maybe<Objects>;\n  /** update multiples rows of table: \"objects\" */\n  update_objects_many?: Maybe<Array<Maybe<ObjectsMutationResponse>>>;\n  /** update data of the table: \"processor_metadata.processor_status\" */\n  update_processor_metadata_processor_status?: Maybe<ProcessorMetadataProcessorStatusMutationResponse>;\n  /** update single row of the table: \"processor_metadata.processor_status\" */\n  update_processor_metadata_processor_status_by_pk?: Maybe<ProcessorMetadataProcessorStatus>;\n  /** update multiples rows of table: \"processor_metadata.processor_status\" */\n  update_processor_metadata_processor_status_many?: Maybe<\n    Array<Maybe<ProcessorMetadataProcessorStatusMutationResponse>>\n  >;\n  /** update data of the table: \"processor_status\" */\n  update_processor_status?: Maybe<ProcessorStatusMutationResponse>;\n  /** update single row of the table: \"processor_status\" */\n  update_processor_status_by_pk?: Maybe<ProcessorStatus>;\n  /** update multiples rows of table: \"processor_status\" */\n  update_processor_status_many?: Maybe<Array<Maybe<ProcessorStatusMutationResponse>>>;\n  /** update data of the table: \"proposal_votes\" */\n  update_proposal_votes?: Maybe<ProposalVotesMutationResponse>;\n  /** update single row of the table: \"proposal_votes\" */\n  update_proposal_votes_by_pk?: Maybe<ProposalVotes>;\n  /** update multiples rows of table: \"proposal_votes\" */\n  update_proposal_votes_many?: Maybe<Array<Maybe<ProposalVotesMutationResponse>>>;\n  /** update data of the table: \"public_key_auth_keys\" */\n  update_public_key_auth_keys?: Maybe<PublicKeyAuthKeysMutationResponse>;\n  /** update single row of the table: \"public_key_auth_keys\" */\n  update_public_key_auth_keys_by_pk?: Maybe<PublicKeyAuthKeys>;\n  /** update multiples rows of table: \"public_key_auth_keys\" */\n  update_public_key_auth_keys_many?: Maybe<Array<Maybe<PublicKeyAuthKeysMutationResponse>>>;\n  /** update data of the table: \"signatures\" */\n  update_signatures?: Maybe<SignaturesMutationResponse>;\n  /** update single row of the table: \"signatures\" */\n  update_signatures_by_pk?: Maybe<Signatures>;\n  /** update multiples rows of table: \"signatures\" */\n  update_signatures_many?: Maybe<Array<Maybe<SignaturesMutationResponse>>>;\n  /** update data of the table: \"spam_assets\" */\n  update_spam_assets?: Maybe<SpamAssetsMutationResponse>;\n  /** update single row of the table: \"spam_assets\" */\n  update_spam_assets_by_pk?: Maybe<SpamAssets>;\n  /** update multiples rows of table: \"spam_assets\" */\n  update_spam_assets_many?: Maybe<Array<Maybe<SpamAssetsMutationResponse>>>;\n  /** update data of the table: \"table_items\" */\n  update_table_items?: Maybe<TableItemsMutationResponse>;\n  /** update single row of the table: \"table_items\" */\n  update_table_items_by_pk?: Maybe<TableItems>;\n  /** update multiples rows of table: \"table_items\" */\n  update_table_items_many?: Maybe<Array<Maybe<TableItemsMutationResponse>>>;\n  /** update data of the table: \"table_items_view\" */\n  update_table_items_view?: Maybe<TableItemsViewMutationResponse>;\n  /** update multiples rows of table: \"table_items_view\" */\n  update_table_items_view_many?: Maybe<Array<Maybe<TableItemsViewMutationResponse>>>;\n  /** update data of the table: \"table_metadatas\" */\n  update_table_metadatas?: Maybe<TableMetadatasMutationResponse>;\n  /** update single row of the table: \"table_metadatas\" */\n  update_table_metadatas_by_pk?: Maybe<TableMetadatas>;\n  /** update multiples rows of table: \"table_metadatas\" */\n  update_table_metadatas_many?: Maybe<Array<Maybe<TableMetadatasMutationResponse>>>;\n  /** update data of the table: \"token_activities\" */\n  update_token_activities?: Maybe<TokenActivitiesMutationResponse>;\n  /** update single row of the table: \"token_activities\" */\n  update_token_activities_by_pk?: Maybe<TokenActivities>;\n  /** update multiples rows of table: \"token_activities\" */\n  update_token_activities_many?: Maybe<Array<Maybe<TokenActivitiesMutationResponse>>>;\n  /** update data of the table: \"token_activities_v2\" */\n  update_token_activities_v2?: Maybe<TokenActivitiesV2MutationResponse>;\n  /** update single row of the table: \"token_activities_v2\" */\n  update_token_activities_v2_by_pk?: Maybe<TokenActivitiesV2>;\n  /** update multiples rows of table: \"token_activities_v2\" */\n  update_token_activities_v2_many?: Maybe<Array<Maybe<TokenActivitiesV2MutationResponse>>>;\n  /** update data of the table: \"token_datas\" */\n  update_token_datas?: Maybe<TokenDatasMutationResponse>;\n  /** update single row of the table: \"token_datas\" */\n  update_token_datas_by_pk?: Maybe<TokenDatas>;\n  /** update multiples rows of table: \"token_datas\" */\n  update_token_datas_many?: Maybe<Array<Maybe<TokenDatasMutationResponse>>>;\n  /** update data of the table: \"token_datas_v2\" */\n  update_token_datas_v2?: Maybe<TokenDatasV2MutationResponse>;\n  /** update single row of the table: \"token_datas_v2\" */\n  update_token_datas_v2_by_pk?: Maybe<TokenDatasV2>;\n  /** update multiples rows of table: \"token_datas_v2\" */\n  update_token_datas_v2_many?: Maybe<Array<Maybe<TokenDatasV2MutationResponse>>>;\n  /** update data of the table: \"token_ownerships\" */\n  update_token_ownerships?: Maybe<TokenOwnershipsMutationResponse>;\n  /** update single row of the table: \"token_ownerships\" */\n  update_token_ownerships_by_pk?: Maybe<TokenOwnerships>;\n  /** update multiples rows of table: \"token_ownerships\" */\n  update_token_ownerships_many?: Maybe<Array<Maybe<TokenOwnershipsMutationResponse>>>;\n  /** update data of the table: \"token_ownerships_v2\" */\n  update_token_ownerships_v2?: Maybe<TokenOwnershipsV2MutationResponse>;\n  /** update single row of the table: \"token_ownerships_v2\" */\n  update_token_ownerships_v2_by_pk?: Maybe<TokenOwnershipsV2>;\n  /** update multiples rows of table: \"token_ownerships_v2\" */\n  update_token_ownerships_v2_many?: Maybe<Array<Maybe<TokenOwnershipsV2MutationResponse>>>;\n  /** update data of the table: \"tokens\" */\n  update_tokens?: Maybe<TokensMutationResponse>;\n  /** update single row of the table: \"tokens\" */\n  update_tokens_by_pk?: Maybe<Tokens>;\n  /** update multiples rows of table: \"tokens\" */\n  update_tokens_many?: Maybe<Array<Maybe<TokensMutationResponse>>>;\n  /** update data of the table: \"transaction_size_info\" */\n  update_transaction_size_info?: Maybe<TransactionSizeInfoMutationResponse>;\n  /** update single row of the table: \"transaction_size_info\" */\n  update_transaction_size_info_by_pk?: Maybe<TransactionSizeInfo>;\n  /** update multiples rows of table: \"transaction_size_info\" */\n  update_transaction_size_info_many?: Maybe<Array<Maybe<TransactionSizeInfoMutationResponse>>>;\n  /** update data of the table: \"transactions_view\" */\n  update_transactions_view?: Maybe<TransactionsViewMutationResponse>;\n  /** update multiples rows of table: \"transactions_view\" */\n  update_transactions_view_many?: Maybe<Array<Maybe<TransactionsViewMutationResponse>>>;\n  /** update data of the table: \"user_transactions\" */\n  update_user_transactions?: Maybe<UserTransactionsMutationResponse>;\n  /** update single row of the table: \"user_transactions\" */\n  update_user_transactions_by_pk?: Maybe<UserTransactions>;\n  /** update multiples rows of table: \"user_transactions\" */\n  update_user_transactions_many?: Maybe<Array<Maybe<UserTransactionsMutationResponse>>>;\n};\n\n/** mutation root */\nexport type MutationRootDeleteAccountTransactionsArgs = {\n  where: AccountTransactionsBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootDeleteAccountTransactionsByPkArgs = {\n  account_address: Scalars[\"String\"][\"input\"];\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\n/** mutation root */\nexport type MutationRootDeleteAnsLookupArgs = {\n  where: AnsLookupBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootDeleteAnsLookupByPkArgs = {\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n  write_set_change_index: Scalars[\"bigint\"][\"input\"];\n};\n\n/** mutation root */\nexport type MutationRootDeleteAnsLookupV2Args = {\n  where: AnsLookupV2BoolExp;\n};\n\n/** mutation root */\nexport type MutationRootDeleteAnsLookupV2ByPkArgs = {\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n  write_set_change_index: Scalars[\"bigint\"][\"input\"];\n};\n\n/** mutation root */\nexport type MutationRootDeleteAnsPrimaryNameArgs = {\n  where: AnsPrimaryNameBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootDeleteAnsPrimaryNameByPkArgs = {\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n  write_set_change_index: Scalars[\"bigint\"][\"input\"];\n};\n\n/** mutation root */\nexport type MutationRootDeleteAnsPrimaryNameV2Args = {\n  where: AnsPrimaryNameV2BoolExp;\n};\n\n/** mutation root */\nexport type MutationRootDeleteAnsPrimaryNameV2ByPkArgs = {\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n  write_set_change_index: Scalars[\"bigint\"][\"input\"];\n};\n\n/** mutation root */\nexport type MutationRootDeleteAuthKeyAccountAddressesArgs = {\n  where: AuthKeyAccountAddressesBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootDeleteAuthKeyAccountAddressesByPkArgs = {\n  account_address: Scalars[\"String\"][\"input\"];\n};\n\n/** mutation root */\nexport type MutationRootDeleteBlockMetadataTransactionsArgs = {\n  where: BlockMetadataTransactionsBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootDeleteBlockMetadataTransactionsByPkArgs = {\n  version: Scalars[\"bigint\"][\"input\"];\n};\n\n/** mutation root */\nexport type MutationRootDeleteCoinActivitiesArgs = {\n  where: CoinActivitiesBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootDeleteCoinActivitiesByPkArgs = {\n  event_account_address: Scalars[\"String\"][\"input\"];\n  event_creation_number: Scalars[\"bigint\"][\"input\"];\n  event_sequence_number: Scalars[\"bigint\"][\"input\"];\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\n/** mutation root */\nexport type MutationRootDeleteCoinBalancesArgs = {\n  where: CoinBalancesBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootDeleteCoinBalancesByPkArgs = {\n  coin_type_hash: Scalars[\"String\"][\"input\"];\n  owner_address: Scalars[\"String\"][\"input\"];\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\n/** mutation root */\nexport type MutationRootDeleteCoinInfosArgs = {\n  where: CoinInfosBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootDeleteCoinInfosByPkArgs = {\n  coin_type_hash: Scalars[\"String\"][\"input\"];\n};\n\n/** mutation root */\nexport type MutationRootDeleteCoinSupplyArgs = {\n  where: CoinSupplyBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootDeleteCoinSupplyByPkArgs = {\n  coin_type_hash: Scalars[\"String\"][\"input\"];\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\n/** mutation root */\nexport type MutationRootDeleteCollectionDatasArgs = {\n  where: CollectionDatasBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootDeleteCollectionDatasByPkArgs = {\n  collection_data_id_hash: Scalars[\"String\"][\"input\"];\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\n/** mutation root */\nexport type MutationRootDeleteCollectionsV2Args = {\n  where: CollectionsV2BoolExp;\n};\n\n/** mutation root */\nexport type MutationRootDeleteCollectionsV2ByPkArgs = {\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n  write_set_change_index: Scalars[\"bigint\"][\"input\"];\n};\n\n/** mutation root */\nexport type MutationRootDeleteCurrentAnsLookupArgs = {\n  where: CurrentAnsLookupBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootDeleteCurrentAnsLookupByPkArgs = {\n  domain: Scalars[\"String\"][\"input\"];\n  subdomain: Scalars[\"String\"][\"input\"];\n};\n\n/** mutation root */\nexport type MutationRootDeleteCurrentAnsLookupV2Args = {\n  where: CurrentAnsLookupV2BoolExp;\n};\n\n/** mutation root */\nexport type MutationRootDeleteCurrentAnsLookupV2ByPkArgs = {\n  domain: Scalars[\"String\"][\"input\"];\n  subdomain: Scalars[\"String\"][\"input\"];\n  token_standard: Scalars[\"String\"][\"input\"];\n};\n\n/** mutation root */\nexport type MutationRootDeleteCurrentAnsPrimaryNameArgs = {\n  where: CurrentAnsPrimaryNameBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootDeleteCurrentAnsPrimaryNameByPkArgs = {\n  registered_address: Scalars[\"String\"][\"input\"];\n};\n\n/** mutation root */\nexport type MutationRootDeleteCurrentAnsPrimaryNameV2Args = {\n  where: CurrentAnsPrimaryNameV2BoolExp;\n};\n\n/** mutation root */\nexport type MutationRootDeleteCurrentAnsPrimaryNameV2ByPkArgs = {\n  registered_address: Scalars[\"String\"][\"input\"];\n  token_standard: Scalars[\"String\"][\"input\"];\n};\n\n/** mutation root */\nexport type MutationRootDeleteCurrentCoinBalancesArgs = {\n  where: CurrentCoinBalancesBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootDeleteCurrentCoinBalancesByPkArgs = {\n  coin_type_hash: Scalars[\"String\"][\"input\"];\n  owner_address: Scalars[\"String\"][\"input\"];\n};\n\n/** mutation root */\nexport type MutationRootDeleteCurrentCollectionDatasArgs = {\n  where: CurrentCollectionDatasBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootDeleteCurrentCollectionDatasByPkArgs = {\n  collection_data_id_hash: Scalars[\"String\"][\"input\"];\n};\n\n/** mutation root */\nexport type MutationRootDeleteCurrentCollectionsV2Args = {\n  where: CurrentCollectionsV2BoolExp;\n};\n\n/** mutation root */\nexport type MutationRootDeleteCurrentCollectionsV2ByPkArgs = {\n  collection_id: Scalars[\"String\"][\"input\"];\n};\n\n/** mutation root */\nexport type MutationRootDeleteCurrentDelegatedStakingPoolBalancesArgs = {\n  where: CurrentDelegatedStakingPoolBalancesBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootDeleteCurrentDelegatedStakingPoolBalancesByPkArgs = {\n  staking_pool_address: Scalars[\"String\"][\"input\"];\n};\n\n/** mutation root */\nexport type MutationRootDeleteCurrentDelegatedVoterArgs = {\n  where: CurrentDelegatedVoterBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootDeleteCurrentDelegatedVoterByPkArgs = {\n  delegation_pool_address: Scalars[\"String\"][\"input\"];\n  delegator_address: Scalars[\"String\"][\"input\"];\n};\n\n/** mutation root */\nexport type MutationRootDeleteCurrentDelegatorBalancesArgs = {\n  where: CurrentDelegatorBalancesBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootDeleteCurrentDelegatorBalancesByPkArgs = {\n  delegator_address: Scalars[\"String\"][\"input\"];\n  pool_address: Scalars[\"String\"][\"input\"];\n  pool_type: Scalars[\"String\"][\"input\"];\n  table_handle: Scalars[\"String\"][\"input\"];\n};\n\n/** mutation root */\nexport type MutationRootDeleteCurrentFungibleAssetBalancesArgs = {\n  where: CurrentFungibleAssetBalancesBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootDeleteCurrentFungibleAssetBalancesByPkArgs = {\n  storage_id: Scalars[\"String\"][\"input\"];\n};\n\n/** mutation root */\nexport type MutationRootDeleteCurrentFungibleAssetBalancesNewArgs = {\n  where: CurrentFungibleAssetBalancesNewBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootDeleteCurrentFungibleAssetBalancesNewByPkArgs = {\n  storage_id: Scalars[\"String\"][\"input\"];\n};\n\n/** mutation root */\nexport type MutationRootDeleteCurrentObjectsArgs = {\n  where: CurrentObjectsBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootDeleteCurrentObjectsByPkArgs = {\n  object_address: Scalars[\"String\"][\"input\"];\n};\n\n/** mutation root */\nexport type MutationRootDeleteCurrentStakingPoolVoterArgs = {\n  where: CurrentStakingPoolVoterBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootDeleteCurrentStakingPoolVoterByPkArgs = {\n  staking_pool_address: Scalars[\"String\"][\"input\"];\n};\n\n/** mutation root */\nexport type MutationRootDeleteCurrentTableItemsArgs = {\n  where: CurrentTableItemsBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootDeleteCurrentTableItemsByPkArgs = {\n  key_hash: Scalars[\"String\"][\"input\"];\n  table_handle: Scalars[\"String\"][\"input\"];\n};\n\n/** mutation root */\nexport type MutationRootDeleteCurrentTableItemsViewArgs = {\n  where: CurrentTableItemsViewBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootDeleteCurrentTokenDatasArgs = {\n  where: CurrentTokenDatasBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootDeleteCurrentTokenDatasByPkArgs = {\n  token_data_id_hash: Scalars[\"String\"][\"input\"];\n};\n\n/** mutation root */\nexport type MutationRootDeleteCurrentTokenDatasV2Args = {\n  where: CurrentTokenDatasV2BoolExp;\n};\n\n/** mutation root */\nexport type MutationRootDeleteCurrentTokenDatasV2ByPkArgs = {\n  token_data_id: Scalars[\"String\"][\"input\"];\n};\n\n/** mutation root */\nexport type MutationRootDeleteCurrentTokenOwnershipsArgs = {\n  where: CurrentTokenOwnershipsBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootDeleteCurrentTokenOwnershipsByPkArgs = {\n  owner_address: Scalars[\"String\"][\"input\"];\n  property_version: Scalars[\"numeric\"][\"input\"];\n  token_data_id_hash: Scalars[\"String\"][\"input\"];\n};\n\n/** mutation root */\nexport type MutationRootDeleteCurrentTokenOwnershipsV2Args = {\n  where: CurrentTokenOwnershipsV2BoolExp;\n};\n\n/** mutation root */\nexport type MutationRootDeleteCurrentTokenOwnershipsV2ByPkArgs = {\n  owner_address: Scalars[\"String\"][\"input\"];\n  property_version_v1: Scalars[\"numeric\"][\"input\"];\n  storage_id: Scalars[\"String\"][\"input\"];\n  token_data_id: Scalars[\"String\"][\"input\"];\n};\n\n/** mutation root */\nexport type MutationRootDeleteCurrentTokenPendingClaimsArgs = {\n  where: CurrentTokenPendingClaimsBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootDeleteCurrentTokenPendingClaimsByPkArgs = {\n  from_address: Scalars[\"String\"][\"input\"];\n  property_version: Scalars[\"numeric\"][\"input\"];\n  to_address: Scalars[\"String\"][\"input\"];\n  token_data_id_hash: Scalars[\"String\"][\"input\"];\n};\n\n/** mutation root */\nexport type MutationRootDeleteCurrentTokenRoyaltyV1Args = {\n  where: CurrentTokenRoyaltyV1BoolExp;\n};\n\n/** mutation root */\nexport type MutationRootDeleteCurrentTokenRoyaltyV1ByPkArgs = {\n  token_data_id: Scalars[\"String\"][\"input\"];\n};\n\n/** mutation root */\nexport type MutationRootDeleteCurrentTokenV2MetadataArgs = {\n  where: CurrentTokenV2MetadataBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootDeleteCurrentTokenV2MetadataByPkArgs = {\n  object_address: Scalars[\"String\"][\"input\"];\n  resource_type: Scalars[\"String\"][\"input\"];\n};\n\n/** mutation root */\nexport type MutationRootDeleteDelegatedStakingActivitiesArgs = {\n  where: DelegatedStakingActivitiesBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootDeleteDelegatedStakingActivitiesByPkArgs = {\n  event_index: Scalars[\"bigint\"][\"input\"];\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\n/** mutation root */\nexport type MutationRootDeleteDelegatedStakingPoolBalancesArgs = {\n  where: DelegatedStakingPoolBalancesBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootDeleteDelegatedStakingPoolBalancesByPkArgs = {\n  staking_pool_address: Scalars[\"String\"][\"input\"];\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\n/** mutation root */\nexport type MutationRootDeleteDelegatedStakingPoolsArgs = {\n  where: DelegatedStakingPoolsBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootDeleteDelegatedStakingPoolsByPkArgs = {\n  staking_pool_address: Scalars[\"String\"][\"input\"];\n};\n\n/** mutation root */\nexport type MutationRootDeleteDelegatorBalancesArgs = {\n  where: DelegatorBalancesBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootDeleteDelegatorBalancesByPkArgs = {\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n  write_set_change_index: Scalars[\"bigint\"][\"input\"];\n};\n\n/** mutation root */\nexport type MutationRootDeleteEventSizeInfoArgs = {\n  where: EventSizeInfoBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootDeleteEventSizeInfoByPkArgs = {\n  index: Scalars[\"bigint\"][\"input\"];\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\n/** mutation root */\nexport type MutationRootDeleteEventsArgs = {\n  where: EventsBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootDeleteEventsByPkArgs = {\n  event_index: Scalars[\"bigint\"][\"input\"];\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\n/** mutation root */\nexport type MutationRootDeleteEventsViewArgs = {\n  where: EventsViewBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootDeleteFungibleAssetActivitiesArgs = {\n  where: FungibleAssetActivitiesBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootDeleteFungibleAssetActivitiesByPkArgs = {\n  event_index: Scalars[\"bigint\"][\"input\"];\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\n/** mutation root */\nexport type MutationRootDeleteFungibleAssetBalancesArgs = {\n  where: FungibleAssetBalancesBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootDeleteFungibleAssetBalancesByPkArgs = {\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n  write_set_change_index: Scalars[\"bigint\"][\"input\"];\n};\n\n/** mutation root */\nexport type MutationRootDeleteFungibleAssetMetadataArgs = {\n  where: FungibleAssetMetadataBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootDeleteFungibleAssetMetadataByPkArgs = {\n  asset_type: Scalars[\"String\"][\"input\"];\n};\n\n/** mutation root */\nexport type MutationRootDeleteFungibleAssetToCoinMappingsArgs = {\n  where: FungibleAssetToCoinMappingsBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootDeleteFungibleAssetToCoinMappingsByPkArgs = {\n  fungible_asset_metadata_address: Scalars[\"String\"][\"input\"];\n};\n\n/** mutation root */\nexport type MutationRootDeleteGasFeesArgs = {\n  where: GasFeesBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootDeleteGasFeesByPkArgs = {\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\n/** mutation root */\nexport type MutationRootDeleteIndexerStatusArgs = {\n  where: IndexerStatusBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootDeleteIndexerStatusByPkArgs = {\n  db: Scalars[\"String\"][\"input\"];\n};\n\n/** mutation root */\nexport type MutationRootDeleteMoveModulesArgs = {\n  where: MoveModulesBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootDeleteMoveModulesByPkArgs = {\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n  write_set_change_index: Scalars[\"bigint\"][\"input\"];\n};\n\n/** mutation root */\nexport type MutationRootDeleteMoveResourcesArgs = {\n  where: MoveResourcesBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootDeleteMoveResourcesByPkArgs = {\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n  write_set_change_index: Scalars[\"bigint\"][\"input\"];\n};\n\n/** mutation root */\nexport type MutationRootDeleteMoveResourcesViewArgs = {\n  where: MoveResourcesViewBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootDeleteNftMetadataCrawlerParsedAssetUrisArgs = {\n  where: NftMetadataCrawlerParsedAssetUrisBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootDeleteNftMetadataCrawlerParsedAssetUrisByPkArgs = {\n  asset_uri: Scalars[\"String\"][\"input\"];\n};\n\n/** mutation root */\nexport type MutationRootDeleteNftPointsArgs = {\n  where: NftPointsBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootDeleteNftPointsByPkArgs = {\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\n/** mutation root */\nexport type MutationRootDeleteObjectsArgs = {\n  where: ObjectsBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootDeleteObjectsByPkArgs = {\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n  write_set_change_index: Scalars[\"bigint\"][\"input\"];\n};\n\n/** mutation root */\nexport type MutationRootDeleteProcessorMetadataProcessorStatusArgs = {\n  where: ProcessorMetadataProcessorStatusBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootDeleteProcessorMetadataProcessorStatusByPkArgs = {\n  processor: Scalars[\"String\"][\"input\"];\n};\n\n/** mutation root */\nexport type MutationRootDeleteProcessorStatusArgs = {\n  where: ProcessorStatusBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootDeleteProcessorStatusByPkArgs = {\n  processor: Scalars[\"String\"][\"input\"];\n};\n\n/** mutation root */\nexport type MutationRootDeleteProposalVotesArgs = {\n  where: ProposalVotesBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootDeleteProposalVotesByPkArgs = {\n  proposal_id: Scalars[\"bigint\"][\"input\"];\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n  voter_address: Scalars[\"String\"][\"input\"];\n};\n\n/** mutation root */\nexport type MutationRootDeletePublicKeyAuthKeysArgs = {\n  where: PublicKeyAuthKeysBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootDeletePublicKeyAuthKeysByPkArgs = {\n  auth_key: Scalars[\"String\"][\"input\"];\n  public_key: Scalars[\"String\"][\"input\"];\n  public_key_type: Scalars[\"String\"][\"input\"];\n};\n\n/** mutation root */\nexport type MutationRootDeleteSignaturesArgs = {\n  where: SignaturesBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootDeleteSignaturesByPkArgs = {\n  is_sender_primary: Scalars[\"Boolean\"][\"input\"];\n  multi_agent_index: Scalars[\"bigint\"][\"input\"];\n  multi_sig_index: Scalars[\"bigint\"][\"input\"];\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\n/** mutation root */\nexport type MutationRootDeleteSpamAssetsArgs = {\n  where: SpamAssetsBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootDeleteSpamAssetsByPkArgs = {\n  asset: Scalars[\"String\"][\"input\"];\n};\n\n/** mutation root */\nexport type MutationRootDeleteTableItemsArgs = {\n  where: TableItemsBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootDeleteTableItemsByPkArgs = {\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n  write_set_change_index: Scalars[\"bigint\"][\"input\"];\n};\n\n/** mutation root */\nexport type MutationRootDeleteTableItemsViewArgs = {\n  where: TableItemsViewBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootDeleteTableMetadatasArgs = {\n  where: TableMetadatasBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootDeleteTableMetadatasByPkArgs = {\n  handle: Scalars[\"String\"][\"input\"];\n};\n\n/** mutation root */\nexport type MutationRootDeleteTokenActivitiesArgs = {\n  where: TokenActivitiesBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootDeleteTokenActivitiesByPkArgs = {\n  event_account_address: Scalars[\"String\"][\"input\"];\n  event_creation_number: Scalars[\"bigint\"][\"input\"];\n  event_sequence_number: Scalars[\"bigint\"][\"input\"];\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\n/** mutation root */\nexport type MutationRootDeleteTokenActivitiesV2Args = {\n  where: TokenActivitiesV2BoolExp;\n};\n\n/** mutation root */\nexport type MutationRootDeleteTokenActivitiesV2ByPkArgs = {\n  event_index: Scalars[\"bigint\"][\"input\"];\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\n/** mutation root */\nexport type MutationRootDeleteTokenDatasArgs = {\n  where: TokenDatasBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootDeleteTokenDatasByPkArgs = {\n  token_data_id_hash: Scalars[\"String\"][\"input\"];\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\n/** mutation root */\nexport type MutationRootDeleteTokenDatasV2Args = {\n  where: TokenDatasV2BoolExp;\n};\n\n/** mutation root */\nexport type MutationRootDeleteTokenDatasV2ByPkArgs = {\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n  write_set_change_index: Scalars[\"bigint\"][\"input\"];\n};\n\n/** mutation root */\nexport type MutationRootDeleteTokenOwnershipsArgs = {\n  where: TokenOwnershipsBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootDeleteTokenOwnershipsByPkArgs = {\n  property_version: Scalars[\"numeric\"][\"input\"];\n  table_handle: Scalars[\"String\"][\"input\"];\n  token_data_id_hash: Scalars[\"String\"][\"input\"];\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\n/** mutation root */\nexport type MutationRootDeleteTokenOwnershipsV2Args = {\n  where: TokenOwnershipsV2BoolExp;\n};\n\n/** mutation root */\nexport type MutationRootDeleteTokenOwnershipsV2ByPkArgs = {\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n  write_set_change_index: Scalars[\"bigint\"][\"input\"];\n};\n\n/** mutation root */\nexport type MutationRootDeleteTokensArgs = {\n  where: TokensBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootDeleteTokensByPkArgs = {\n  property_version: Scalars[\"numeric\"][\"input\"];\n  token_data_id_hash: Scalars[\"String\"][\"input\"];\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\n/** mutation root */\nexport type MutationRootDeleteTransactionSizeInfoArgs = {\n  where: TransactionSizeInfoBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootDeleteTransactionSizeInfoByPkArgs = {\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\n/** mutation root */\nexport type MutationRootDeleteTransactionsViewArgs = {\n  where: TransactionsViewBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootDeleteUserTransactionsArgs = {\n  where: UserTransactionsBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootDeleteUserTransactionsByPkArgs = {\n  version: Scalars[\"bigint\"][\"input\"];\n};\n\n/** mutation root */\nexport type MutationRootInsertAccountTransactionsArgs = {\n  objects: Array<AccountTransactionsInsertInput>;\n  on_conflict?: InputMaybe<AccountTransactionsOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertAccountTransactionsOneArgs = {\n  object: AccountTransactionsInsertInput;\n  on_conflict?: InputMaybe<AccountTransactionsOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertAnsLookupArgs = {\n  objects: Array<AnsLookupInsertInput>;\n  on_conflict?: InputMaybe<AnsLookupOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertAnsLookupOneArgs = {\n  object: AnsLookupInsertInput;\n  on_conflict?: InputMaybe<AnsLookupOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertAnsLookupV2Args = {\n  objects: Array<AnsLookupV2InsertInput>;\n  on_conflict?: InputMaybe<AnsLookupV2OnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertAnsLookupV2OneArgs = {\n  object: AnsLookupV2InsertInput;\n  on_conflict?: InputMaybe<AnsLookupV2OnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertAnsPrimaryNameArgs = {\n  objects: Array<AnsPrimaryNameInsertInput>;\n  on_conflict?: InputMaybe<AnsPrimaryNameOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertAnsPrimaryNameOneArgs = {\n  object: AnsPrimaryNameInsertInput;\n  on_conflict?: InputMaybe<AnsPrimaryNameOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertAnsPrimaryNameV2Args = {\n  objects: Array<AnsPrimaryNameV2InsertInput>;\n  on_conflict?: InputMaybe<AnsPrimaryNameV2OnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertAnsPrimaryNameV2OneArgs = {\n  object: AnsPrimaryNameV2InsertInput;\n  on_conflict?: InputMaybe<AnsPrimaryNameV2OnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertAuthKeyAccountAddressesArgs = {\n  objects: Array<AuthKeyAccountAddressesInsertInput>;\n  on_conflict?: InputMaybe<AuthKeyAccountAddressesOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertAuthKeyAccountAddressesOneArgs = {\n  object: AuthKeyAccountAddressesInsertInput;\n  on_conflict?: InputMaybe<AuthKeyAccountAddressesOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertBlockMetadataTransactionsArgs = {\n  objects: Array<BlockMetadataTransactionsInsertInput>;\n  on_conflict?: InputMaybe<BlockMetadataTransactionsOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertBlockMetadataTransactionsOneArgs = {\n  object: BlockMetadataTransactionsInsertInput;\n  on_conflict?: InputMaybe<BlockMetadataTransactionsOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertCoinActivitiesArgs = {\n  objects: Array<CoinActivitiesInsertInput>;\n  on_conflict?: InputMaybe<CoinActivitiesOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertCoinActivitiesOneArgs = {\n  object: CoinActivitiesInsertInput;\n  on_conflict?: InputMaybe<CoinActivitiesOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertCoinBalancesArgs = {\n  objects: Array<CoinBalancesInsertInput>;\n  on_conflict?: InputMaybe<CoinBalancesOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertCoinBalancesOneArgs = {\n  object: CoinBalancesInsertInput;\n  on_conflict?: InputMaybe<CoinBalancesOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertCoinInfosArgs = {\n  objects: Array<CoinInfosInsertInput>;\n  on_conflict?: InputMaybe<CoinInfosOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertCoinInfosOneArgs = {\n  object: CoinInfosInsertInput;\n  on_conflict?: InputMaybe<CoinInfosOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertCoinSupplyArgs = {\n  objects: Array<CoinSupplyInsertInput>;\n  on_conflict?: InputMaybe<CoinSupplyOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertCoinSupplyOneArgs = {\n  object: CoinSupplyInsertInput;\n  on_conflict?: InputMaybe<CoinSupplyOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertCollectionDatasArgs = {\n  objects: Array<CollectionDatasInsertInput>;\n  on_conflict?: InputMaybe<CollectionDatasOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertCollectionDatasOneArgs = {\n  object: CollectionDatasInsertInput;\n  on_conflict?: InputMaybe<CollectionDatasOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertCollectionsV2Args = {\n  objects: Array<CollectionsV2InsertInput>;\n  on_conflict?: InputMaybe<CollectionsV2OnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertCollectionsV2OneArgs = {\n  object: CollectionsV2InsertInput;\n  on_conflict?: InputMaybe<CollectionsV2OnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertCurrentAnsLookupArgs = {\n  objects: Array<CurrentAnsLookupInsertInput>;\n  on_conflict?: InputMaybe<CurrentAnsLookupOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertCurrentAnsLookupOneArgs = {\n  object: CurrentAnsLookupInsertInput;\n  on_conflict?: InputMaybe<CurrentAnsLookupOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertCurrentAnsLookupV2Args = {\n  objects: Array<CurrentAnsLookupV2InsertInput>;\n  on_conflict?: InputMaybe<CurrentAnsLookupV2OnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertCurrentAnsLookupV2OneArgs = {\n  object: CurrentAnsLookupV2InsertInput;\n  on_conflict?: InputMaybe<CurrentAnsLookupV2OnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertCurrentAnsPrimaryNameArgs = {\n  objects: Array<CurrentAnsPrimaryNameInsertInput>;\n  on_conflict?: InputMaybe<CurrentAnsPrimaryNameOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertCurrentAnsPrimaryNameOneArgs = {\n  object: CurrentAnsPrimaryNameInsertInput;\n  on_conflict?: InputMaybe<CurrentAnsPrimaryNameOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertCurrentAnsPrimaryNameV2Args = {\n  objects: Array<CurrentAnsPrimaryNameV2InsertInput>;\n  on_conflict?: InputMaybe<CurrentAnsPrimaryNameV2OnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertCurrentAnsPrimaryNameV2OneArgs = {\n  object: CurrentAnsPrimaryNameV2InsertInput;\n  on_conflict?: InputMaybe<CurrentAnsPrimaryNameV2OnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertCurrentCoinBalancesArgs = {\n  objects: Array<CurrentCoinBalancesInsertInput>;\n  on_conflict?: InputMaybe<CurrentCoinBalancesOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertCurrentCoinBalancesOneArgs = {\n  object: CurrentCoinBalancesInsertInput;\n  on_conflict?: InputMaybe<CurrentCoinBalancesOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertCurrentCollectionDatasArgs = {\n  objects: Array<CurrentCollectionDatasInsertInput>;\n  on_conflict?: InputMaybe<CurrentCollectionDatasOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertCurrentCollectionDatasOneArgs = {\n  object: CurrentCollectionDatasInsertInput;\n  on_conflict?: InputMaybe<CurrentCollectionDatasOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertCurrentCollectionsV2Args = {\n  objects: Array<CurrentCollectionsV2InsertInput>;\n  on_conflict?: InputMaybe<CurrentCollectionsV2OnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertCurrentCollectionsV2OneArgs = {\n  object: CurrentCollectionsV2InsertInput;\n  on_conflict?: InputMaybe<CurrentCollectionsV2OnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertCurrentDelegatedStakingPoolBalancesArgs = {\n  objects: Array<CurrentDelegatedStakingPoolBalancesInsertInput>;\n  on_conflict?: InputMaybe<CurrentDelegatedStakingPoolBalancesOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertCurrentDelegatedStakingPoolBalancesOneArgs = {\n  object: CurrentDelegatedStakingPoolBalancesInsertInput;\n  on_conflict?: InputMaybe<CurrentDelegatedStakingPoolBalancesOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertCurrentDelegatedVoterArgs = {\n  objects: Array<CurrentDelegatedVoterInsertInput>;\n  on_conflict?: InputMaybe<CurrentDelegatedVoterOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertCurrentDelegatedVoterOneArgs = {\n  object: CurrentDelegatedVoterInsertInput;\n  on_conflict?: InputMaybe<CurrentDelegatedVoterOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertCurrentDelegatorBalancesArgs = {\n  objects: Array<CurrentDelegatorBalancesInsertInput>;\n  on_conflict?: InputMaybe<CurrentDelegatorBalancesOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertCurrentDelegatorBalancesOneArgs = {\n  object: CurrentDelegatorBalancesInsertInput;\n  on_conflict?: InputMaybe<CurrentDelegatorBalancesOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertCurrentFungibleAssetBalancesArgs = {\n  objects: Array<CurrentFungibleAssetBalancesInsertInput>;\n  on_conflict?: InputMaybe<CurrentFungibleAssetBalancesOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertCurrentFungibleAssetBalancesNewArgs = {\n  objects: Array<CurrentFungibleAssetBalancesNewInsertInput>;\n  on_conflict?: InputMaybe<CurrentFungibleAssetBalancesNewOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertCurrentFungibleAssetBalancesNewOneArgs = {\n  object: CurrentFungibleAssetBalancesNewInsertInput;\n  on_conflict?: InputMaybe<CurrentFungibleAssetBalancesNewOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertCurrentFungibleAssetBalancesOneArgs = {\n  object: CurrentFungibleAssetBalancesInsertInput;\n  on_conflict?: InputMaybe<CurrentFungibleAssetBalancesOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertCurrentObjectsArgs = {\n  objects: Array<CurrentObjectsInsertInput>;\n  on_conflict?: InputMaybe<CurrentObjectsOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertCurrentObjectsOneArgs = {\n  object: CurrentObjectsInsertInput;\n  on_conflict?: InputMaybe<CurrentObjectsOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertCurrentStakingPoolVoterArgs = {\n  objects: Array<CurrentStakingPoolVoterInsertInput>;\n  on_conflict?: InputMaybe<CurrentStakingPoolVoterOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertCurrentStakingPoolVoterOneArgs = {\n  object: CurrentStakingPoolVoterInsertInput;\n  on_conflict?: InputMaybe<CurrentStakingPoolVoterOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertCurrentTableItemsArgs = {\n  objects: Array<CurrentTableItemsInsertInput>;\n  on_conflict?: InputMaybe<CurrentTableItemsOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertCurrentTableItemsOneArgs = {\n  object: CurrentTableItemsInsertInput;\n  on_conflict?: InputMaybe<CurrentTableItemsOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertCurrentTableItemsViewArgs = {\n  objects: Array<CurrentTableItemsViewInsertInput>;\n};\n\n/** mutation root */\nexport type MutationRootInsertCurrentTableItemsViewOneArgs = {\n  object: CurrentTableItemsViewInsertInput;\n};\n\n/** mutation root */\nexport type MutationRootInsertCurrentTokenDatasArgs = {\n  objects: Array<CurrentTokenDatasInsertInput>;\n  on_conflict?: InputMaybe<CurrentTokenDatasOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertCurrentTokenDatasOneArgs = {\n  object: CurrentTokenDatasInsertInput;\n  on_conflict?: InputMaybe<CurrentTokenDatasOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertCurrentTokenDatasV2Args = {\n  objects: Array<CurrentTokenDatasV2InsertInput>;\n  on_conflict?: InputMaybe<CurrentTokenDatasV2OnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertCurrentTokenDatasV2OneArgs = {\n  object: CurrentTokenDatasV2InsertInput;\n  on_conflict?: InputMaybe<CurrentTokenDatasV2OnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertCurrentTokenOwnershipsArgs = {\n  objects: Array<CurrentTokenOwnershipsInsertInput>;\n  on_conflict?: InputMaybe<CurrentTokenOwnershipsOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertCurrentTokenOwnershipsOneArgs = {\n  object: CurrentTokenOwnershipsInsertInput;\n  on_conflict?: InputMaybe<CurrentTokenOwnershipsOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertCurrentTokenOwnershipsV2Args = {\n  objects: Array<CurrentTokenOwnershipsV2InsertInput>;\n  on_conflict?: InputMaybe<CurrentTokenOwnershipsV2OnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertCurrentTokenOwnershipsV2OneArgs = {\n  object: CurrentTokenOwnershipsV2InsertInput;\n  on_conflict?: InputMaybe<CurrentTokenOwnershipsV2OnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertCurrentTokenPendingClaimsArgs = {\n  objects: Array<CurrentTokenPendingClaimsInsertInput>;\n  on_conflict?: InputMaybe<CurrentTokenPendingClaimsOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertCurrentTokenPendingClaimsOneArgs = {\n  object: CurrentTokenPendingClaimsInsertInput;\n  on_conflict?: InputMaybe<CurrentTokenPendingClaimsOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertCurrentTokenRoyaltyV1Args = {\n  objects: Array<CurrentTokenRoyaltyV1InsertInput>;\n  on_conflict?: InputMaybe<CurrentTokenRoyaltyV1OnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertCurrentTokenRoyaltyV1OneArgs = {\n  object: CurrentTokenRoyaltyV1InsertInput;\n  on_conflict?: InputMaybe<CurrentTokenRoyaltyV1OnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertCurrentTokenV2MetadataArgs = {\n  objects: Array<CurrentTokenV2MetadataInsertInput>;\n  on_conflict?: InputMaybe<CurrentTokenV2MetadataOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertCurrentTokenV2MetadataOneArgs = {\n  object: CurrentTokenV2MetadataInsertInput;\n  on_conflict?: InputMaybe<CurrentTokenV2MetadataOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertDelegatedStakingActivitiesArgs = {\n  objects: Array<DelegatedStakingActivitiesInsertInput>;\n  on_conflict?: InputMaybe<DelegatedStakingActivitiesOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertDelegatedStakingActivitiesOneArgs = {\n  object: DelegatedStakingActivitiesInsertInput;\n  on_conflict?: InputMaybe<DelegatedStakingActivitiesOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertDelegatedStakingPoolBalancesArgs = {\n  objects: Array<DelegatedStakingPoolBalancesInsertInput>;\n  on_conflict?: InputMaybe<DelegatedStakingPoolBalancesOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertDelegatedStakingPoolBalancesOneArgs = {\n  object: DelegatedStakingPoolBalancesInsertInput;\n  on_conflict?: InputMaybe<DelegatedStakingPoolBalancesOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertDelegatedStakingPoolsArgs = {\n  objects: Array<DelegatedStakingPoolsInsertInput>;\n  on_conflict?: InputMaybe<DelegatedStakingPoolsOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertDelegatedStakingPoolsOneArgs = {\n  object: DelegatedStakingPoolsInsertInput;\n  on_conflict?: InputMaybe<DelegatedStakingPoolsOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertDelegatorBalancesArgs = {\n  objects: Array<DelegatorBalancesInsertInput>;\n  on_conflict?: InputMaybe<DelegatorBalancesOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertDelegatorBalancesOneArgs = {\n  object: DelegatorBalancesInsertInput;\n  on_conflict?: InputMaybe<DelegatorBalancesOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertEventSizeInfoArgs = {\n  objects: Array<EventSizeInfoInsertInput>;\n  on_conflict?: InputMaybe<EventSizeInfoOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertEventSizeInfoOneArgs = {\n  object: EventSizeInfoInsertInput;\n  on_conflict?: InputMaybe<EventSizeInfoOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertEventsArgs = {\n  objects: Array<EventsInsertInput>;\n  on_conflict?: InputMaybe<EventsOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertEventsOneArgs = {\n  object: EventsInsertInput;\n  on_conflict?: InputMaybe<EventsOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertEventsViewArgs = {\n  objects: Array<EventsViewInsertInput>;\n};\n\n/** mutation root */\nexport type MutationRootInsertEventsViewOneArgs = {\n  object: EventsViewInsertInput;\n};\n\n/** mutation root */\nexport type MutationRootInsertFungibleAssetActivitiesArgs = {\n  objects: Array<FungibleAssetActivitiesInsertInput>;\n  on_conflict?: InputMaybe<FungibleAssetActivitiesOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertFungibleAssetActivitiesOneArgs = {\n  object: FungibleAssetActivitiesInsertInput;\n  on_conflict?: InputMaybe<FungibleAssetActivitiesOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertFungibleAssetBalancesArgs = {\n  objects: Array<FungibleAssetBalancesInsertInput>;\n  on_conflict?: InputMaybe<FungibleAssetBalancesOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertFungibleAssetBalancesOneArgs = {\n  object: FungibleAssetBalancesInsertInput;\n  on_conflict?: InputMaybe<FungibleAssetBalancesOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertFungibleAssetMetadataArgs = {\n  objects: Array<FungibleAssetMetadataInsertInput>;\n  on_conflict?: InputMaybe<FungibleAssetMetadataOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertFungibleAssetMetadataOneArgs = {\n  object: FungibleAssetMetadataInsertInput;\n  on_conflict?: InputMaybe<FungibleAssetMetadataOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertFungibleAssetToCoinMappingsArgs = {\n  objects: Array<FungibleAssetToCoinMappingsInsertInput>;\n  on_conflict?: InputMaybe<FungibleAssetToCoinMappingsOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertFungibleAssetToCoinMappingsOneArgs = {\n  object: FungibleAssetToCoinMappingsInsertInput;\n  on_conflict?: InputMaybe<FungibleAssetToCoinMappingsOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertGasFeesArgs = {\n  objects: Array<GasFeesInsertInput>;\n  on_conflict?: InputMaybe<GasFeesOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertGasFeesOneArgs = {\n  object: GasFeesInsertInput;\n  on_conflict?: InputMaybe<GasFeesOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertIndexerStatusArgs = {\n  objects: Array<IndexerStatusInsertInput>;\n  on_conflict?: InputMaybe<IndexerStatusOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertIndexerStatusOneArgs = {\n  object: IndexerStatusInsertInput;\n  on_conflict?: InputMaybe<IndexerStatusOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertMoveModulesArgs = {\n  objects: Array<MoveModulesInsertInput>;\n  on_conflict?: InputMaybe<MoveModulesOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertMoveModulesOneArgs = {\n  object: MoveModulesInsertInput;\n  on_conflict?: InputMaybe<MoveModulesOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertMoveResourcesArgs = {\n  objects: Array<MoveResourcesInsertInput>;\n  on_conflict?: InputMaybe<MoveResourcesOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertMoveResourcesOneArgs = {\n  object: MoveResourcesInsertInput;\n  on_conflict?: InputMaybe<MoveResourcesOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertMoveResourcesViewArgs = {\n  objects: Array<MoveResourcesViewInsertInput>;\n};\n\n/** mutation root */\nexport type MutationRootInsertMoveResourcesViewOneArgs = {\n  object: MoveResourcesViewInsertInput;\n};\n\n/** mutation root */\nexport type MutationRootInsertNftMetadataCrawlerParsedAssetUrisArgs = {\n  objects: Array<NftMetadataCrawlerParsedAssetUrisInsertInput>;\n  on_conflict?: InputMaybe<NftMetadataCrawlerParsedAssetUrisOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertNftMetadataCrawlerParsedAssetUrisOneArgs = {\n  object: NftMetadataCrawlerParsedAssetUrisInsertInput;\n  on_conflict?: InputMaybe<NftMetadataCrawlerParsedAssetUrisOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertNftPointsArgs = {\n  objects: Array<NftPointsInsertInput>;\n  on_conflict?: InputMaybe<NftPointsOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertNftPointsOneArgs = {\n  object: NftPointsInsertInput;\n  on_conflict?: InputMaybe<NftPointsOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertObjectsArgs = {\n  objects: Array<ObjectsInsertInput>;\n  on_conflict?: InputMaybe<ObjectsOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertObjectsOneArgs = {\n  object: ObjectsInsertInput;\n  on_conflict?: InputMaybe<ObjectsOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertProcessorMetadataProcessorStatusArgs = {\n  objects: Array<ProcessorMetadataProcessorStatusInsertInput>;\n  on_conflict?: InputMaybe<ProcessorMetadataProcessorStatusOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertProcessorMetadataProcessorStatusOneArgs = {\n  object: ProcessorMetadataProcessorStatusInsertInput;\n  on_conflict?: InputMaybe<ProcessorMetadataProcessorStatusOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertProcessorStatusArgs = {\n  objects: Array<ProcessorStatusInsertInput>;\n  on_conflict?: InputMaybe<ProcessorStatusOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertProcessorStatusOneArgs = {\n  object: ProcessorStatusInsertInput;\n  on_conflict?: InputMaybe<ProcessorStatusOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertProposalVotesArgs = {\n  objects: Array<ProposalVotesInsertInput>;\n  on_conflict?: InputMaybe<ProposalVotesOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertProposalVotesOneArgs = {\n  object: ProposalVotesInsertInput;\n  on_conflict?: InputMaybe<ProposalVotesOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertPublicKeyAuthKeysArgs = {\n  objects: Array<PublicKeyAuthKeysInsertInput>;\n  on_conflict?: InputMaybe<PublicKeyAuthKeysOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertPublicKeyAuthKeysOneArgs = {\n  object: PublicKeyAuthKeysInsertInput;\n  on_conflict?: InputMaybe<PublicKeyAuthKeysOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertSignaturesArgs = {\n  objects: Array<SignaturesInsertInput>;\n  on_conflict?: InputMaybe<SignaturesOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertSignaturesOneArgs = {\n  object: SignaturesInsertInput;\n  on_conflict?: InputMaybe<SignaturesOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertSpamAssetsArgs = {\n  objects: Array<SpamAssetsInsertInput>;\n  on_conflict?: InputMaybe<SpamAssetsOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertSpamAssetsOneArgs = {\n  object: SpamAssetsInsertInput;\n  on_conflict?: InputMaybe<SpamAssetsOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertTableItemsArgs = {\n  objects: Array<TableItemsInsertInput>;\n  on_conflict?: InputMaybe<TableItemsOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertTableItemsOneArgs = {\n  object: TableItemsInsertInput;\n  on_conflict?: InputMaybe<TableItemsOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertTableItemsViewArgs = {\n  objects: Array<TableItemsViewInsertInput>;\n};\n\n/** mutation root */\nexport type MutationRootInsertTableItemsViewOneArgs = {\n  object: TableItemsViewInsertInput;\n};\n\n/** mutation root */\nexport type MutationRootInsertTableMetadatasArgs = {\n  objects: Array<TableMetadatasInsertInput>;\n  on_conflict?: InputMaybe<TableMetadatasOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertTableMetadatasOneArgs = {\n  object: TableMetadatasInsertInput;\n  on_conflict?: InputMaybe<TableMetadatasOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertTokenActivitiesArgs = {\n  objects: Array<TokenActivitiesInsertInput>;\n  on_conflict?: InputMaybe<TokenActivitiesOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertTokenActivitiesOneArgs = {\n  object: TokenActivitiesInsertInput;\n  on_conflict?: InputMaybe<TokenActivitiesOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertTokenActivitiesV2Args = {\n  objects: Array<TokenActivitiesV2InsertInput>;\n  on_conflict?: InputMaybe<TokenActivitiesV2OnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertTokenActivitiesV2OneArgs = {\n  object: TokenActivitiesV2InsertInput;\n  on_conflict?: InputMaybe<TokenActivitiesV2OnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertTokenDatasArgs = {\n  objects: Array<TokenDatasInsertInput>;\n  on_conflict?: InputMaybe<TokenDatasOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertTokenDatasOneArgs = {\n  object: TokenDatasInsertInput;\n  on_conflict?: InputMaybe<TokenDatasOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertTokenDatasV2Args = {\n  objects: Array<TokenDatasV2InsertInput>;\n  on_conflict?: InputMaybe<TokenDatasV2OnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertTokenDatasV2OneArgs = {\n  object: TokenDatasV2InsertInput;\n  on_conflict?: InputMaybe<TokenDatasV2OnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertTokenOwnershipsArgs = {\n  objects: Array<TokenOwnershipsInsertInput>;\n  on_conflict?: InputMaybe<TokenOwnershipsOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertTokenOwnershipsOneArgs = {\n  object: TokenOwnershipsInsertInput;\n  on_conflict?: InputMaybe<TokenOwnershipsOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertTokenOwnershipsV2Args = {\n  objects: Array<TokenOwnershipsV2InsertInput>;\n  on_conflict?: InputMaybe<TokenOwnershipsV2OnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertTokenOwnershipsV2OneArgs = {\n  object: TokenOwnershipsV2InsertInput;\n  on_conflict?: InputMaybe<TokenOwnershipsV2OnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertTokensArgs = {\n  objects: Array<TokensInsertInput>;\n  on_conflict?: InputMaybe<TokensOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertTokensOneArgs = {\n  object: TokensInsertInput;\n  on_conflict?: InputMaybe<TokensOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertTransactionSizeInfoArgs = {\n  objects: Array<TransactionSizeInfoInsertInput>;\n  on_conflict?: InputMaybe<TransactionSizeInfoOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertTransactionSizeInfoOneArgs = {\n  object: TransactionSizeInfoInsertInput;\n  on_conflict?: InputMaybe<TransactionSizeInfoOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertTransactionsViewArgs = {\n  objects: Array<TransactionsViewInsertInput>;\n};\n\n/** mutation root */\nexport type MutationRootInsertTransactionsViewOneArgs = {\n  object: TransactionsViewInsertInput;\n};\n\n/** mutation root */\nexport type MutationRootInsertUserTransactionsArgs = {\n  objects: Array<UserTransactionsInsertInput>;\n  on_conflict?: InputMaybe<UserTransactionsOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootInsertUserTransactionsOneArgs = {\n  object: UserTransactionsInsertInput;\n  on_conflict?: InputMaybe<UserTransactionsOnConflict>;\n};\n\n/** mutation root */\nexport type MutationRootUpdateAccountTransactionsArgs = {\n  _inc?: InputMaybe<AccountTransactionsIncInput>;\n  _set?: InputMaybe<AccountTransactionsSetInput>;\n  where: AccountTransactionsBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootUpdateAccountTransactionsByPkArgs = {\n  _inc?: InputMaybe<AccountTransactionsIncInput>;\n  _set?: InputMaybe<AccountTransactionsSetInput>;\n  pk_columns: AccountTransactionsPkColumnsInput;\n};\n\n/** mutation root */\nexport type MutationRootUpdateAccountTransactionsManyArgs = {\n  updates: Array<AccountTransactionsUpdates>;\n};\n\n/** mutation root */\nexport type MutationRootUpdateAnsLookupArgs = {\n  _inc?: InputMaybe<AnsLookupIncInput>;\n  _set?: InputMaybe<AnsLookupSetInput>;\n  where: AnsLookupBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootUpdateAnsLookupByPkArgs = {\n  _inc?: InputMaybe<AnsLookupIncInput>;\n  _set?: InputMaybe<AnsLookupSetInput>;\n  pk_columns: AnsLookupPkColumnsInput;\n};\n\n/** mutation root */\nexport type MutationRootUpdateAnsLookupManyArgs = {\n  updates: Array<AnsLookupUpdates>;\n};\n\n/** mutation root */\nexport type MutationRootUpdateAnsLookupV2Args = {\n  _inc?: InputMaybe<AnsLookupV2IncInput>;\n  _set?: InputMaybe<AnsLookupV2SetInput>;\n  where: AnsLookupV2BoolExp;\n};\n\n/** mutation root */\nexport type MutationRootUpdateAnsLookupV2ByPkArgs = {\n  _inc?: InputMaybe<AnsLookupV2IncInput>;\n  _set?: InputMaybe<AnsLookupV2SetInput>;\n  pk_columns: AnsLookupV2PkColumnsInput;\n};\n\n/** mutation root */\nexport type MutationRootUpdateAnsLookupV2ManyArgs = {\n  updates: Array<AnsLookupV2Updates>;\n};\n\n/** mutation root */\nexport type MutationRootUpdateAnsPrimaryNameArgs = {\n  _inc?: InputMaybe<AnsPrimaryNameIncInput>;\n  _set?: InputMaybe<AnsPrimaryNameSetInput>;\n  where: AnsPrimaryNameBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootUpdateAnsPrimaryNameByPkArgs = {\n  _inc?: InputMaybe<AnsPrimaryNameIncInput>;\n  _set?: InputMaybe<AnsPrimaryNameSetInput>;\n  pk_columns: AnsPrimaryNamePkColumnsInput;\n};\n\n/** mutation root */\nexport type MutationRootUpdateAnsPrimaryNameManyArgs = {\n  updates: Array<AnsPrimaryNameUpdates>;\n};\n\n/** mutation root */\nexport type MutationRootUpdateAnsPrimaryNameV2Args = {\n  _inc?: InputMaybe<AnsPrimaryNameV2IncInput>;\n  _set?: InputMaybe<AnsPrimaryNameV2SetInput>;\n  where: AnsPrimaryNameV2BoolExp;\n};\n\n/** mutation root */\nexport type MutationRootUpdateAnsPrimaryNameV2ByPkArgs = {\n  _inc?: InputMaybe<AnsPrimaryNameV2IncInput>;\n  _set?: InputMaybe<AnsPrimaryNameV2SetInput>;\n  pk_columns: AnsPrimaryNameV2PkColumnsInput;\n};\n\n/** mutation root */\nexport type MutationRootUpdateAnsPrimaryNameV2ManyArgs = {\n  updates: Array<AnsPrimaryNameV2Updates>;\n};\n\n/** mutation root */\nexport type MutationRootUpdateAuthKeyAccountAddressesArgs = {\n  _inc?: InputMaybe<AuthKeyAccountAddressesIncInput>;\n  _set?: InputMaybe<AuthKeyAccountAddressesSetInput>;\n  where: AuthKeyAccountAddressesBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootUpdateAuthKeyAccountAddressesByPkArgs = {\n  _inc?: InputMaybe<AuthKeyAccountAddressesIncInput>;\n  _set?: InputMaybe<AuthKeyAccountAddressesSetInput>;\n  pk_columns: AuthKeyAccountAddressesPkColumnsInput;\n};\n\n/** mutation root */\nexport type MutationRootUpdateAuthKeyAccountAddressesManyArgs = {\n  updates: Array<AuthKeyAccountAddressesUpdates>;\n};\n\n/** mutation root */\nexport type MutationRootUpdateBlockMetadataTransactionsArgs = {\n  _append?: InputMaybe<BlockMetadataTransactionsAppendInput>;\n  _delete_at_path?: InputMaybe<BlockMetadataTransactionsDeleteAtPathInput>;\n  _delete_elem?: InputMaybe<BlockMetadataTransactionsDeleteElemInput>;\n  _delete_key?: InputMaybe<BlockMetadataTransactionsDeleteKeyInput>;\n  _inc?: InputMaybe<BlockMetadataTransactionsIncInput>;\n  _prepend?: InputMaybe<BlockMetadataTransactionsPrependInput>;\n  _set?: InputMaybe<BlockMetadataTransactionsSetInput>;\n  where: BlockMetadataTransactionsBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootUpdateBlockMetadataTransactionsByPkArgs = {\n  _append?: InputMaybe<BlockMetadataTransactionsAppendInput>;\n  _delete_at_path?: InputMaybe<BlockMetadataTransactionsDeleteAtPathInput>;\n  _delete_elem?: InputMaybe<BlockMetadataTransactionsDeleteElemInput>;\n  _delete_key?: InputMaybe<BlockMetadataTransactionsDeleteKeyInput>;\n  _inc?: InputMaybe<BlockMetadataTransactionsIncInput>;\n  _prepend?: InputMaybe<BlockMetadataTransactionsPrependInput>;\n  _set?: InputMaybe<BlockMetadataTransactionsSetInput>;\n  pk_columns: BlockMetadataTransactionsPkColumnsInput;\n};\n\n/** mutation root */\nexport type MutationRootUpdateBlockMetadataTransactionsManyArgs = {\n  updates: Array<BlockMetadataTransactionsUpdates>;\n};\n\n/** mutation root */\nexport type MutationRootUpdateCoinActivitiesArgs = {\n  _inc?: InputMaybe<CoinActivitiesIncInput>;\n  _set?: InputMaybe<CoinActivitiesSetInput>;\n  where: CoinActivitiesBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootUpdateCoinActivitiesByPkArgs = {\n  _inc?: InputMaybe<CoinActivitiesIncInput>;\n  _set?: InputMaybe<CoinActivitiesSetInput>;\n  pk_columns: CoinActivitiesPkColumnsInput;\n};\n\n/** mutation root */\nexport type MutationRootUpdateCoinActivitiesManyArgs = {\n  updates: Array<CoinActivitiesUpdates>;\n};\n\n/** mutation root */\nexport type MutationRootUpdateCoinBalancesArgs = {\n  _inc?: InputMaybe<CoinBalancesIncInput>;\n  _set?: InputMaybe<CoinBalancesSetInput>;\n  where: CoinBalancesBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootUpdateCoinBalancesByPkArgs = {\n  _inc?: InputMaybe<CoinBalancesIncInput>;\n  _set?: InputMaybe<CoinBalancesSetInput>;\n  pk_columns: CoinBalancesPkColumnsInput;\n};\n\n/** mutation root */\nexport type MutationRootUpdateCoinBalancesManyArgs = {\n  updates: Array<CoinBalancesUpdates>;\n};\n\n/** mutation root */\nexport type MutationRootUpdateCoinInfosArgs = {\n  _inc?: InputMaybe<CoinInfosIncInput>;\n  _set?: InputMaybe<CoinInfosSetInput>;\n  where: CoinInfosBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootUpdateCoinInfosByPkArgs = {\n  _inc?: InputMaybe<CoinInfosIncInput>;\n  _set?: InputMaybe<CoinInfosSetInput>;\n  pk_columns: CoinInfosPkColumnsInput;\n};\n\n/** mutation root */\nexport type MutationRootUpdateCoinInfosManyArgs = {\n  updates: Array<CoinInfosUpdates>;\n};\n\n/** mutation root */\nexport type MutationRootUpdateCoinSupplyArgs = {\n  _inc?: InputMaybe<CoinSupplyIncInput>;\n  _set?: InputMaybe<CoinSupplySetInput>;\n  where: CoinSupplyBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootUpdateCoinSupplyByPkArgs = {\n  _inc?: InputMaybe<CoinSupplyIncInput>;\n  _set?: InputMaybe<CoinSupplySetInput>;\n  pk_columns: CoinSupplyPkColumnsInput;\n};\n\n/** mutation root */\nexport type MutationRootUpdateCoinSupplyManyArgs = {\n  updates: Array<CoinSupplyUpdates>;\n};\n\n/** mutation root */\nexport type MutationRootUpdateCollectionDatasArgs = {\n  _inc?: InputMaybe<CollectionDatasIncInput>;\n  _set?: InputMaybe<CollectionDatasSetInput>;\n  where: CollectionDatasBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootUpdateCollectionDatasByPkArgs = {\n  _inc?: InputMaybe<CollectionDatasIncInput>;\n  _set?: InputMaybe<CollectionDatasSetInput>;\n  pk_columns: CollectionDatasPkColumnsInput;\n};\n\n/** mutation root */\nexport type MutationRootUpdateCollectionDatasManyArgs = {\n  updates: Array<CollectionDatasUpdates>;\n};\n\n/** mutation root */\nexport type MutationRootUpdateCollectionsV2Args = {\n  _append?: InputMaybe<CollectionsV2AppendInput>;\n  _delete_at_path?: InputMaybe<CollectionsV2DeleteAtPathInput>;\n  _delete_elem?: InputMaybe<CollectionsV2DeleteElemInput>;\n  _delete_key?: InputMaybe<CollectionsV2DeleteKeyInput>;\n  _inc?: InputMaybe<CollectionsV2IncInput>;\n  _prepend?: InputMaybe<CollectionsV2PrependInput>;\n  _set?: InputMaybe<CollectionsV2SetInput>;\n  where: CollectionsV2BoolExp;\n};\n\n/** mutation root */\nexport type MutationRootUpdateCollectionsV2ByPkArgs = {\n  _append?: InputMaybe<CollectionsV2AppendInput>;\n  _delete_at_path?: InputMaybe<CollectionsV2DeleteAtPathInput>;\n  _delete_elem?: InputMaybe<CollectionsV2DeleteElemInput>;\n  _delete_key?: InputMaybe<CollectionsV2DeleteKeyInput>;\n  _inc?: InputMaybe<CollectionsV2IncInput>;\n  _prepend?: InputMaybe<CollectionsV2PrependInput>;\n  _set?: InputMaybe<CollectionsV2SetInput>;\n  pk_columns: CollectionsV2PkColumnsInput;\n};\n\n/** mutation root */\nexport type MutationRootUpdateCollectionsV2ManyArgs = {\n  updates: Array<CollectionsV2Updates>;\n};\n\n/** mutation root */\nexport type MutationRootUpdateCurrentAnsLookupArgs = {\n  _inc?: InputMaybe<CurrentAnsLookupIncInput>;\n  _set?: InputMaybe<CurrentAnsLookupSetInput>;\n  where: CurrentAnsLookupBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootUpdateCurrentAnsLookupByPkArgs = {\n  _inc?: InputMaybe<CurrentAnsLookupIncInput>;\n  _set?: InputMaybe<CurrentAnsLookupSetInput>;\n  pk_columns: CurrentAnsLookupPkColumnsInput;\n};\n\n/** mutation root */\nexport type MutationRootUpdateCurrentAnsLookupManyArgs = {\n  updates: Array<CurrentAnsLookupUpdates>;\n};\n\n/** mutation root */\nexport type MutationRootUpdateCurrentAnsLookupV2Args = {\n  _inc?: InputMaybe<CurrentAnsLookupV2IncInput>;\n  _set?: InputMaybe<CurrentAnsLookupV2SetInput>;\n  where: CurrentAnsLookupV2BoolExp;\n};\n\n/** mutation root */\nexport type MutationRootUpdateCurrentAnsLookupV2ByPkArgs = {\n  _inc?: InputMaybe<CurrentAnsLookupV2IncInput>;\n  _set?: InputMaybe<CurrentAnsLookupV2SetInput>;\n  pk_columns: CurrentAnsLookupV2PkColumnsInput;\n};\n\n/** mutation root */\nexport type MutationRootUpdateCurrentAnsLookupV2ManyArgs = {\n  updates: Array<CurrentAnsLookupV2Updates>;\n};\n\n/** mutation root */\nexport type MutationRootUpdateCurrentAnsPrimaryNameArgs = {\n  _inc?: InputMaybe<CurrentAnsPrimaryNameIncInput>;\n  _set?: InputMaybe<CurrentAnsPrimaryNameSetInput>;\n  where: CurrentAnsPrimaryNameBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootUpdateCurrentAnsPrimaryNameByPkArgs = {\n  _inc?: InputMaybe<CurrentAnsPrimaryNameIncInput>;\n  _set?: InputMaybe<CurrentAnsPrimaryNameSetInput>;\n  pk_columns: CurrentAnsPrimaryNamePkColumnsInput;\n};\n\n/** mutation root */\nexport type MutationRootUpdateCurrentAnsPrimaryNameManyArgs = {\n  updates: Array<CurrentAnsPrimaryNameUpdates>;\n};\n\n/** mutation root */\nexport type MutationRootUpdateCurrentAnsPrimaryNameV2Args = {\n  _inc?: InputMaybe<CurrentAnsPrimaryNameV2IncInput>;\n  _set?: InputMaybe<CurrentAnsPrimaryNameV2SetInput>;\n  where: CurrentAnsPrimaryNameV2BoolExp;\n};\n\n/** mutation root */\nexport type MutationRootUpdateCurrentAnsPrimaryNameV2ByPkArgs = {\n  _inc?: InputMaybe<CurrentAnsPrimaryNameV2IncInput>;\n  _set?: InputMaybe<CurrentAnsPrimaryNameV2SetInput>;\n  pk_columns: CurrentAnsPrimaryNameV2PkColumnsInput;\n};\n\n/** mutation root */\nexport type MutationRootUpdateCurrentAnsPrimaryNameV2ManyArgs = {\n  updates: Array<CurrentAnsPrimaryNameV2Updates>;\n};\n\n/** mutation root */\nexport type MutationRootUpdateCurrentCoinBalancesArgs = {\n  _inc?: InputMaybe<CurrentCoinBalancesIncInput>;\n  _set?: InputMaybe<CurrentCoinBalancesSetInput>;\n  where: CurrentCoinBalancesBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootUpdateCurrentCoinBalancesByPkArgs = {\n  _inc?: InputMaybe<CurrentCoinBalancesIncInput>;\n  _set?: InputMaybe<CurrentCoinBalancesSetInput>;\n  pk_columns: CurrentCoinBalancesPkColumnsInput;\n};\n\n/** mutation root */\nexport type MutationRootUpdateCurrentCoinBalancesManyArgs = {\n  updates: Array<CurrentCoinBalancesUpdates>;\n};\n\n/** mutation root */\nexport type MutationRootUpdateCurrentCollectionDatasArgs = {\n  _inc?: InputMaybe<CurrentCollectionDatasIncInput>;\n  _set?: InputMaybe<CurrentCollectionDatasSetInput>;\n  where: CurrentCollectionDatasBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootUpdateCurrentCollectionDatasByPkArgs = {\n  _inc?: InputMaybe<CurrentCollectionDatasIncInput>;\n  _set?: InputMaybe<CurrentCollectionDatasSetInput>;\n  pk_columns: CurrentCollectionDatasPkColumnsInput;\n};\n\n/** mutation root */\nexport type MutationRootUpdateCurrentCollectionDatasManyArgs = {\n  updates: Array<CurrentCollectionDatasUpdates>;\n};\n\n/** mutation root */\nexport type MutationRootUpdateCurrentCollectionsV2Args = {\n  _append?: InputMaybe<CurrentCollectionsV2AppendInput>;\n  _delete_at_path?: InputMaybe<CurrentCollectionsV2DeleteAtPathInput>;\n  _delete_elem?: InputMaybe<CurrentCollectionsV2DeleteElemInput>;\n  _delete_key?: InputMaybe<CurrentCollectionsV2DeleteKeyInput>;\n  _inc?: InputMaybe<CurrentCollectionsV2IncInput>;\n  _prepend?: InputMaybe<CurrentCollectionsV2PrependInput>;\n  _set?: InputMaybe<CurrentCollectionsV2SetInput>;\n  where: CurrentCollectionsV2BoolExp;\n};\n\n/** mutation root */\nexport type MutationRootUpdateCurrentCollectionsV2ByPkArgs = {\n  _append?: InputMaybe<CurrentCollectionsV2AppendInput>;\n  _delete_at_path?: InputMaybe<CurrentCollectionsV2DeleteAtPathInput>;\n  _delete_elem?: InputMaybe<CurrentCollectionsV2DeleteElemInput>;\n  _delete_key?: InputMaybe<CurrentCollectionsV2DeleteKeyInput>;\n  _inc?: InputMaybe<CurrentCollectionsV2IncInput>;\n  _prepend?: InputMaybe<CurrentCollectionsV2PrependInput>;\n  _set?: InputMaybe<CurrentCollectionsV2SetInput>;\n  pk_columns: CurrentCollectionsV2PkColumnsInput;\n};\n\n/** mutation root */\nexport type MutationRootUpdateCurrentCollectionsV2ManyArgs = {\n  updates: Array<CurrentCollectionsV2Updates>;\n};\n\n/** mutation root */\nexport type MutationRootUpdateCurrentDelegatedStakingPoolBalancesArgs = {\n  _inc?: InputMaybe<CurrentDelegatedStakingPoolBalancesIncInput>;\n  _set?: InputMaybe<CurrentDelegatedStakingPoolBalancesSetInput>;\n  where: CurrentDelegatedStakingPoolBalancesBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootUpdateCurrentDelegatedStakingPoolBalancesByPkArgs = {\n  _inc?: InputMaybe<CurrentDelegatedStakingPoolBalancesIncInput>;\n  _set?: InputMaybe<CurrentDelegatedStakingPoolBalancesSetInput>;\n  pk_columns: CurrentDelegatedStakingPoolBalancesPkColumnsInput;\n};\n\n/** mutation root */\nexport type MutationRootUpdateCurrentDelegatedStakingPoolBalancesManyArgs = {\n  updates: Array<CurrentDelegatedStakingPoolBalancesUpdates>;\n};\n\n/** mutation root */\nexport type MutationRootUpdateCurrentDelegatedVoterArgs = {\n  _inc?: InputMaybe<CurrentDelegatedVoterIncInput>;\n  _set?: InputMaybe<CurrentDelegatedVoterSetInput>;\n  where: CurrentDelegatedVoterBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootUpdateCurrentDelegatedVoterByPkArgs = {\n  _inc?: InputMaybe<CurrentDelegatedVoterIncInput>;\n  _set?: InputMaybe<CurrentDelegatedVoterSetInput>;\n  pk_columns: CurrentDelegatedVoterPkColumnsInput;\n};\n\n/** mutation root */\nexport type MutationRootUpdateCurrentDelegatedVoterManyArgs = {\n  updates: Array<CurrentDelegatedVoterUpdates>;\n};\n\n/** mutation root */\nexport type MutationRootUpdateCurrentDelegatorBalancesArgs = {\n  _inc?: InputMaybe<CurrentDelegatorBalancesIncInput>;\n  _set?: InputMaybe<CurrentDelegatorBalancesSetInput>;\n  where: CurrentDelegatorBalancesBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootUpdateCurrentDelegatorBalancesByPkArgs = {\n  _inc?: InputMaybe<CurrentDelegatorBalancesIncInput>;\n  _set?: InputMaybe<CurrentDelegatorBalancesSetInput>;\n  pk_columns: CurrentDelegatorBalancesPkColumnsInput;\n};\n\n/** mutation root */\nexport type MutationRootUpdateCurrentDelegatorBalancesManyArgs = {\n  updates: Array<CurrentDelegatorBalancesUpdates>;\n};\n\n/** mutation root */\nexport type MutationRootUpdateCurrentFungibleAssetBalancesArgs = {\n  _inc?: InputMaybe<CurrentFungibleAssetBalancesIncInput>;\n  _set?: InputMaybe<CurrentFungibleAssetBalancesSetInput>;\n  where: CurrentFungibleAssetBalancesBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootUpdateCurrentFungibleAssetBalancesByPkArgs = {\n  _inc?: InputMaybe<CurrentFungibleAssetBalancesIncInput>;\n  _set?: InputMaybe<CurrentFungibleAssetBalancesSetInput>;\n  pk_columns: CurrentFungibleAssetBalancesPkColumnsInput;\n};\n\n/** mutation root */\nexport type MutationRootUpdateCurrentFungibleAssetBalancesManyArgs = {\n  updates: Array<CurrentFungibleAssetBalancesUpdates>;\n};\n\n/** mutation root */\nexport type MutationRootUpdateCurrentFungibleAssetBalancesNewArgs = {\n  _inc?: InputMaybe<CurrentFungibleAssetBalancesNewIncInput>;\n  _set?: InputMaybe<CurrentFungibleAssetBalancesNewSetInput>;\n  where: CurrentFungibleAssetBalancesNewBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootUpdateCurrentFungibleAssetBalancesNewByPkArgs = {\n  _inc?: InputMaybe<CurrentFungibleAssetBalancesNewIncInput>;\n  _set?: InputMaybe<CurrentFungibleAssetBalancesNewSetInput>;\n  pk_columns: CurrentFungibleAssetBalancesNewPkColumnsInput;\n};\n\n/** mutation root */\nexport type MutationRootUpdateCurrentFungibleAssetBalancesNewManyArgs = {\n  updates: Array<CurrentFungibleAssetBalancesNewUpdates>;\n};\n\n/** mutation root */\nexport type MutationRootUpdateCurrentObjectsArgs = {\n  _inc?: InputMaybe<CurrentObjectsIncInput>;\n  _set?: InputMaybe<CurrentObjectsSetInput>;\n  where: CurrentObjectsBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootUpdateCurrentObjectsByPkArgs = {\n  _inc?: InputMaybe<CurrentObjectsIncInput>;\n  _set?: InputMaybe<CurrentObjectsSetInput>;\n  pk_columns: CurrentObjectsPkColumnsInput;\n};\n\n/** mutation root */\nexport type MutationRootUpdateCurrentObjectsManyArgs = {\n  updates: Array<CurrentObjectsUpdates>;\n};\n\n/** mutation root */\nexport type MutationRootUpdateCurrentStakingPoolVoterArgs = {\n  _inc?: InputMaybe<CurrentStakingPoolVoterIncInput>;\n  _set?: InputMaybe<CurrentStakingPoolVoterSetInput>;\n  where: CurrentStakingPoolVoterBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootUpdateCurrentStakingPoolVoterByPkArgs = {\n  _inc?: InputMaybe<CurrentStakingPoolVoterIncInput>;\n  _set?: InputMaybe<CurrentStakingPoolVoterSetInput>;\n  pk_columns: CurrentStakingPoolVoterPkColumnsInput;\n};\n\n/** mutation root */\nexport type MutationRootUpdateCurrentStakingPoolVoterManyArgs = {\n  updates: Array<CurrentStakingPoolVoterUpdates>;\n};\n\n/** mutation root */\nexport type MutationRootUpdateCurrentTableItemsArgs = {\n  _append?: InputMaybe<CurrentTableItemsAppendInput>;\n  _delete_at_path?: InputMaybe<CurrentTableItemsDeleteAtPathInput>;\n  _delete_elem?: InputMaybe<CurrentTableItemsDeleteElemInput>;\n  _delete_key?: InputMaybe<CurrentTableItemsDeleteKeyInput>;\n  _inc?: InputMaybe<CurrentTableItemsIncInput>;\n  _prepend?: InputMaybe<CurrentTableItemsPrependInput>;\n  _set?: InputMaybe<CurrentTableItemsSetInput>;\n  where: CurrentTableItemsBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootUpdateCurrentTableItemsByPkArgs = {\n  _append?: InputMaybe<CurrentTableItemsAppendInput>;\n  _delete_at_path?: InputMaybe<CurrentTableItemsDeleteAtPathInput>;\n  _delete_elem?: InputMaybe<CurrentTableItemsDeleteElemInput>;\n  _delete_key?: InputMaybe<CurrentTableItemsDeleteKeyInput>;\n  _inc?: InputMaybe<CurrentTableItemsIncInput>;\n  _prepend?: InputMaybe<CurrentTableItemsPrependInput>;\n  _set?: InputMaybe<CurrentTableItemsSetInput>;\n  pk_columns: CurrentTableItemsPkColumnsInput;\n};\n\n/** mutation root */\nexport type MutationRootUpdateCurrentTableItemsManyArgs = {\n  updates: Array<CurrentTableItemsUpdates>;\n};\n\n/** mutation root */\nexport type MutationRootUpdateCurrentTableItemsViewArgs = {\n  _inc?: InputMaybe<CurrentTableItemsViewIncInput>;\n  _set?: InputMaybe<CurrentTableItemsViewSetInput>;\n  where: CurrentTableItemsViewBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootUpdateCurrentTableItemsViewManyArgs = {\n  updates: Array<CurrentTableItemsViewUpdates>;\n};\n\n/** mutation root */\nexport type MutationRootUpdateCurrentTokenDatasArgs = {\n  _append?: InputMaybe<CurrentTokenDatasAppendInput>;\n  _delete_at_path?: InputMaybe<CurrentTokenDatasDeleteAtPathInput>;\n  _delete_elem?: InputMaybe<CurrentTokenDatasDeleteElemInput>;\n  _delete_key?: InputMaybe<CurrentTokenDatasDeleteKeyInput>;\n  _inc?: InputMaybe<CurrentTokenDatasIncInput>;\n  _prepend?: InputMaybe<CurrentTokenDatasPrependInput>;\n  _set?: InputMaybe<CurrentTokenDatasSetInput>;\n  where: CurrentTokenDatasBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootUpdateCurrentTokenDatasByPkArgs = {\n  _append?: InputMaybe<CurrentTokenDatasAppendInput>;\n  _delete_at_path?: InputMaybe<CurrentTokenDatasDeleteAtPathInput>;\n  _delete_elem?: InputMaybe<CurrentTokenDatasDeleteElemInput>;\n  _delete_key?: InputMaybe<CurrentTokenDatasDeleteKeyInput>;\n  _inc?: InputMaybe<CurrentTokenDatasIncInput>;\n  _prepend?: InputMaybe<CurrentTokenDatasPrependInput>;\n  _set?: InputMaybe<CurrentTokenDatasSetInput>;\n  pk_columns: CurrentTokenDatasPkColumnsInput;\n};\n\n/** mutation root */\nexport type MutationRootUpdateCurrentTokenDatasManyArgs = {\n  updates: Array<CurrentTokenDatasUpdates>;\n};\n\n/** mutation root */\nexport type MutationRootUpdateCurrentTokenDatasV2Args = {\n  _append?: InputMaybe<CurrentTokenDatasV2AppendInput>;\n  _delete_at_path?: InputMaybe<CurrentTokenDatasV2DeleteAtPathInput>;\n  _delete_elem?: InputMaybe<CurrentTokenDatasV2DeleteElemInput>;\n  _delete_key?: InputMaybe<CurrentTokenDatasV2DeleteKeyInput>;\n  _inc?: InputMaybe<CurrentTokenDatasV2IncInput>;\n  _prepend?: InputMaybe<CurrentTokenDatasV2PrependInput>;\n  _set?: InputMaybe<CurrentTokenDatasV2SetInput>;\n  where: CurrentTokenDatasV2BoolExp;\n};\n\n/** mutation root */\nexport type MutationRootUpdateCurrentTokenDatasV2ByPkArgs = {\n  _append?: InputMaybe<CurrentTokenDatasV2AppendInput>;\n  _delete_at_path?: InputMaybe<CurrentTokenDatasV2DeleteAtPathInput>;\n  _delete_elem?: InputMaybe<CurrentTokenDatasV2DeleteElemInput>;\n  _delete_key?: InputMaybe<CurrentTokenDatasV2DeleteKeyInput>;\n  _inc?: InputMaybe<CurrentTokenDatasV2IncInput>;\n  _prepend?: InputMaybe<CurrentTokenDatasV2PrependInput>;\n  _set?: InputMaybe<CurrentTokenDatasV2SetInput>;\n  pk_columns: CurrentTokenDatasV2PkColumnsInput;\n};\n\n/** mutation root */\nexport type MutationRootUpdateCurrentTokenDatasV2ManyArgs = {\n  updates: Array<CurrentTokenDatasV2Updates>;\n};\n\n/** mutation root */\nexport type MutationRootUpdateCurrentTokenOwnershipsArgs = {\n  _append?: InputMaybe<CurrentTokenOwnershipsAppendInput>;\n  _delete_at_path?: InputMaybe<CurrentTokenOwnershipsDeleteAtPathInput>;\n  _delete_elem?: InputMaybe<CurrentTokenOwnershipsDeleteElemInput>;\n  _delete_key?: InputMaybe<CurrentTokenOwnershipsDeleteKeyInput>;\n  _inc?: InputMaybe<CurrentTokenOwnershipsIncInput>;\n  _prepend?: InputMaybe<CurrentTokenOwnershipsPrependInput>;\n  _set?: InputMaybe<CurrentTokenOwnershipsSetInput>;\n  where: CurrentTokenOwnershipsBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootUpdateCurrentTokenOwnershipsByPkArgs = {\n  _append?: InputMaybe<CurrentTokenOwnershipsAppendInput>;\n  _delete_at_path?: InputMaybe<CurrentTokenOwnershipsDeleteAtPathInput>;\n  _delete_elem?: InputMaybe<CurrentTokenOwnershipsDeleteElemInput>;\n  _delete_key?: InputMaybe<CurrentTokenOwnershipsDeleteKeyInput>;\n  _inc?: InputMaybe<CurrentTokenOwnershipsIncInput>;\n  _prepend?: InputMaybe<CurrentTokenOwnershipsPrependInput>;\n  _set?: InputMaybe<CurrentTokenOwnershipsSetInput>;\n  pk_columns: CurrentTokenOwnershipsPkColumnsInput;\n};\n\n/** mutation root */\nexport type MutationRootUpdateCurrentTokenOwnershipsManyArgs = {\n  updates: Array<CurrentTokenOwnershipsUpdates>;\n};\n\n/** mutation root */\nexport type MutationRootUpdateCurrentTokenOwnershipsV2Args = {\n  _append?: InputMaybe<CurrentTokenOwnershipsV2AppendInput>;\n  _delete_at_path?: InputMaybe<CurrentTokenOwnershipsV2DeleteAtPathInput>;\n  _delete_elem?: InputMaybe<CurrentTokenOwnershipsV2DeleteElemInput>;\n  _delete_key?: InputMaybe<CurrentTokenOwnershipsV2DeleteKeyInput>;\n  _inc?: InputMaybe<CurrentTokenOwnershipsV2IncInput>;\n  _prepend?: InputMaybe<CurrentTokenOwnershipsV2PrependInput>;\n  _set?: InputMaybe<CurrentTokenOwnershipsV2SetInput>;\n  where: CurrentTokenOwnershipsV2BoolExp;\n};\n\n/** mutation root */\nexport type MutationRootUpdateCurrentTokenOwnershipsV2ByPkArgs = {\n  _append?: InputMaybe<CurrentTokenOwnershipsV2AppendInput>;\n  _delete_at_path?: InputMaybe<CurrentTokenOwnershipsV2DeleteAtPathInput>;\n  _delete_elem?: InputMaybe<CurrentTokenOwnershipsV2DeleteElemInput>;\n  _delete_key?: InputMaybe<CurrentTokenOwnershipsV2DeleteKeyInput>;\n  _inc?: InputMaybe<CurrentTokenOwnershipsV2IncInput>;\n  _prepend?: InputMaybe<CurrentTokenOwnershipsV2PrependInput>;\n  _set?: InputMaybe<CurrentTokenOwnershipsV2SetInput>;\n  pk_columns: CurrentTokenOwnershipsV2PkColumnsInput;\n};\n\n/** mutation root */\nexport type MutationRootUpdateCurrentTokenOwnershipsV2ManyArgs = {\n  updates: Array<CurrentTokenOwnershipsV2Updates>;\n};\n\n/** mutation root */\nexport type MutationRootUpdateCurrentTokenPendingClaimsArgs = {\n  _inc?: InputMaybe<CurrentTokenPendingClaimsIncInput>;\n  _set?: InputMaybe<CurrentTokenPendingClaimsSetInput>;\n  where: CurrentTokenPendingClaimsBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootUpdateCurrentTokenPendingClaimsByPkArgs = {\n  _inc?: InputMaybe<CurrentTokenPendingClaimsIncInput>;\n  _set?: InputMaybe<CurrentTokenPendingClaimsSetInput>;\n  pk_columns: CurrentTokenPendingClaimsPkColumnsInput;\n};\n\n/** mutation root */\nexport type MutationRootUpdateCurrentTokenPendingClaimsManyArgs = {\n  updates: Array<CurrentTokenPendingClaimsUpdates>;\n};\n\n/** mutation root */\nexport type MutationRootUpdateCurrentTokenRoyaltyV1Args = {\n  _inc?: InputMaybe<CurrentTokenRoyaltyV1IncInput>;\n  _set?: InputMaybe<CurrentTokenRoyaltyV1SetInput>;\n  where: CurrentTokenRoyaltyV1BoolExp;\n};\n\n/** mutation root */\nexport type MutationRootUpdateCurrentTokenRoyaltyV1ByPkArgs = {\n  _inc?: InputMaybe<CurrentTokenRoyaltyV1IncInput>;\n  _set?: InputMaybe<CurrentTokenRoyaltyV1SetInput>;\n  pk_columns: CurrentTokenRoyaltyV1PkColumnsInput;\n};\n\n/** mutation root */\nexport type MutationRootUpdateCurrentTokenRoyaltyV1ManyArgs = {\n  updates: Array<CurrentTokenRoyaltyV1Updates>;\n};\n\n/** mutation root */\nexport type MutationRootUpdateCurrentTokenV2MetadataArgs = {\n  _append?: InputMaybe<CurrentTokenV2MetadataAppendInput>;\n  _delete_at_path?: InputMaybe<CurrentTokenV2MetadataDeleteAtPathInput>;\n  _delete_elem?: InputMaybe<CurrentTokenV2MetadataDeleteElemInput>;\n  _delete_key?: InputMaybe<CurrentTokenV2MetadataDeleteKeyInput>;\n  _inc?: InputMaybe<CurrentTokenV2MetadataIncInput>;\n  _prepend?: InputMaybe<CurrentTokenV2MetadataPrependInput>;\n  _set?: InputMaybe<CurrentTokenV2MetadataSetInput>;\n  where: CurrentTokenV2MetadataBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootUpdateCurrentTokenV2MetadataByPkArgs = {\n  _append?: InputMaybe<CurrentTokenV2MetadataAppendInput>;\n  _delete_at_path?: InputMaybe<CurrentTokenV2MetadataDeleteAtPathInput>;\n  _delete_elem?: InputMaybe<CurrentTokenV2MetadataDeleteElemInput>;\n  _delete_key?: InputMaybe<CurrentTokenV2MetadataDeleteKeyInput>;\n  _inc?: InputMaybe<CurrentTokenV2MetadataIncInput>;\n  _prepend?: InputMaybe<CurrentTokenV2MetadataPrependInput>;\n  _set?: InputMaybe<CurrentTokenV2MetadataSetInput>;\n  pk_columns: CurrentTokenV2MetadataPkColumnsInput;\n};\n\n/** mutation root */\nexport type MutationRootUpdateCurrentTokenV2MetadataManyArgs = {\n  updates: Array<CurrentTokenV2MetadataUpdates>;\n};\n\n/** mutation root */\nexport type MutationRootUpdateDelegatedStakingActivitiesArgs = {\n  _inc?: InputMaybe<DelegatedStakingActivitiesIncInput>;\n  _set?: InputMaybe<DelegatedStakingActivitiesSetInput>;\n  where: DelegatedStakingActivitiesBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootUpdateDelegatedStakingActivitiesByPkArgs = {\n  _inc?: InputMaybe<DelegatedStakingActivitiesIncInput>;\n  _set?: InputMaybe<DelegatedStakingActivitiesSetInput>;\n  pk_columns: DelegatedStakingActivitiesPkColumnsInput;\n};\n\n/** mutation root */\nexport type MutationRootUpdateDelegatedStakingActivitiesManyArgs = {\n  updates: Array<DelegatedStakingActivitiesUpdates>;\n};\n\n/** mutation root */\nexport type MutationRootUpdateDelegatedStakingPoolBalancesArgs = {\n  _inc?: InputMaybe<DelegatedStakingPoolBalancesIncInput>;\n  _set?: InputMaybe<DelegatedStakingPoolBalancesSetInput>;\n  where: DelegatedStakingPoolBalancesBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootUpdateDelegatedStakingPoolBalancesByPkArgs = {\n  _inc?: InputMaybe<DelegatedStakingPoolBalancesIncInput>;\n  _set?: InputMaybe<DelegatedStakingPoolBalancesSetInput>;\n  pk_columns: DelegatedStakingPoolBalancesPkColumnsInput;\n};\n\n/** mutation root */\nexport type MutationRootUpdateDelegatedStakingPoolBalancesManyArgs = {\n  updates: Array<DelegatedStakingPoolBalancesUpdates>;\n};\n\n/** mutation root */\nexport type MutationRootUpdateDelegatedStakingPoolsArgs = {\n  _inc?: InputMaybe<DelegatedStakingPoolsIncInput>;\n  _set?: InputMaybe<DelegatedStakingPoolsSetInput>;\n  where: DelegatedStakingPoolsBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootUpdateDelegatedStakingPoolsByPkArgs = {\n  _inc?: InputMaybe<DelegatedStakingPoolsIncInput>;\n  _set?: InputMaybe<DelegatedStakingPoolsSetInput>;\n  pk_columns: DelegatedStakingPoolsPkColumnsInput;\n};\n\n/** mutation root */\nexport type MutationRootUpdateDelegatedStakingPoolsManyArgs = {\n  updates: Array<DelegatedStakingPoolsUpdates>;\n};\n\n/** mutation root */\nexport type MutationRootUpdateDelegatorBalancesArgs = {\n  _inc?: InputMaybe<DelegatorBalancesIncInput>;\n  _set?: InputMaybe<DelegatorBalancesSetInput>;\n  where: DelegatorBalancesBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootUpdateDelegatorBalancesByPkArgs = {\n  _inc?: InputMaybe<DelegatorBalancesIncInput>;\n  _set?: InputMaybe<DelegatorBalancesSetInput>;\n  pk_columns: DelegatorBalancesPkColumnsInput;\n};\n\n/** mutation root */\nexport type MutationRootUpdateDelegatorBalancesManyArgs = {\n  updates: Array<DelegatorBalancesUpdates>;\n};\n\n/** mutation root */\nexport type MutationRootUpdateEventSizeInfoArgs = {\n  _inc?: InputMaybe<EventSizeInfoIncInput>;\n  _set?: InputMaybe<EventSizeInfoSetInput>;\n  where: EventSizeInfoBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootUpdateEventSizeInfoByPkArgs = {\n  _inc?: InputMaybe<EventSizeInfoIncInput>;\n  _set?: InputMaybe<EventSizeInfoSetInput>;\n  pk_columns: EventSizeInfoPkColumnsInput;\n};\n\n/** mutation root */\nexport type MutationRootUpdateEventSizeInfoManyArgs = {\n  updates: Array<EventSizeInfoUpdates>;\n};\n\n/** mutation root */\nexport type MutationRootUpdateEventsArgs = {\n  _append?: InputMaybe<EventsAppendInput>;\n  _delete_at_path?: InputMaybe<EventsDeleteAtPathInput>;\n  _delete_elem?: InputMaybe<EventsDeleteElemInput>;\n  _delete_key?: InputMaybe<EventsDeleteKeyInput>;\n  _inc?: InputMaybe<EventsIncInput>;\n  _prepend?: InputMaybe<EventsPrependInput>;\n  _set?: InputMaybe<EventsSetInput>;\n  where: EventsBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootUpdateEventsByPkArgs = {\n  _append?: InputMaybe<EventsAppendInput>;\n  _delete_at_path?: InputMaybe<EventsDeleteAtPathInput>;\n  _delete_elem?: InputMaybe<EventsDeleteElemInput>;\n  _delete_key?: InputMaybe<EventsDeleteKeyInput>;\n  _inc?: InputMaybe<EventsIncInput>;\n  _prepend?: InputMaybe<EventsPrependInput>;\n  _set?: InputMaybe<EventsSetInput>;\n  pk_columns: EventsPkColumnsInput;\n};\n\n/** mutation root */\nexport type MutationRootUpdateEventsManyArgs = {\n  updates: Array<EventsUpdates>;\n};\n\n/** mutation root */\nexport type MutationRootUpdateEventsViewArgs = {\n  _inc?: InputMaybe<EventsViewIncInput>;\n  _set?: InputMaybe<EventsViewSetInput>;\n  where: EventsViewBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootUpdateEventsViewManyArgs = {\n  updates: Array<EventsViewUpdates>;\n};\n\n/** mutation root */\nexport type MutationRootUpdateFungibleAssetActivitiesArgs = {\n  _inc?: InputMaybe<FungibleAssetActivitiesIncInput>;\n  _set?: InputMaybe<FungibleAssetActivitiesSetInput>;\n  where: FungibleAssetActivitiesBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootUpdateFungibleAssetActivitiesByPkArgs = {\n  _inc?: InputMaybe<FungibleAssetActivitiesIncInput>;\n  _set?: InputMaybe<FungibleAssetActivitiesSetInput>;\n  pk_columns: FungibleAssetActivitiesPkColumnsInput;\n};\n\n/** mutation root */\nexport type MutationRootUpdateFungibleAssetActivitiesManyArgs = {\n  updates: Array<FungibleAssetActivitiesUpdates>;\n};\n\n/** mutation root */\nexport type MutationRootUpdateFungibleAssetBalancesArgs = {\n  _inc?: InputMaybe<FungibleAssetBalancesIncInput>;\n  _set?: InputMaybe<FungibleAssetBalancesSetInput>;\n  where: FungibleAssetBalancesBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootUpdateFungibleAssetBalancesByPkArgs = {\n  _inc?: InputMaybe<FungibleAssetBalancesIncInput>;\n  _set?: InputMaybe<FungibleAssetBalancesSetInput>;\n  pk_columns: FungibleAssetBalancesPkColumnsInput;\n};\n\n/** mutation root */\nexport type MutationRootUpdateFungibleAssetBalancesManyArgs = {\n  updates: Array<FungibleAssetBalancesUpdates>;\n};\n\n/** mutation root */\nexport type MutationRootUpdateFungibleAssetMetadataArgs = {\n  _inc?: InputMaybe<FungibleAssetMetadataIncInput>;\n  _set?: InputMaybe<FungibleAssetMetadataSetInput>;\n  where: FungibleAssetMetadataBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootUpdateFungibleAssetMetadataByPkArgs = {\n  _inc?: InputMaybe<FungibleAssetMetadataIncInput>;\n  _set?: InputMaybe<FungibleAssetMetadataSetInput>;\n  pk_columns: FungibleAssetMetadataPkColumnsInput;\n};\n\n/** mutation root */\nexport type MutationRootUpdateFungibleAssetMetadataManyArgs = {\n  updates: Array<FungibleAssetMetadataUpdates>;\n};\n\n/** mutation root */\nexport type MutationRootUpdateFungibleAssetToCoinMappingsArgs = {\n  _inc?: InputMaybe<FungibleAssetToCoinMappingsIncInput>;\n  _set?: InputMaybe<FungibleAssetToCoinMappingsSetInput>;\n  where: FungibleAssetToCoinMappingsBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootUpdateFungibleAssetToCoinMappingsByPkArgs = {\n  _inc?: InputMaybe<FungibleAssetToCoinMappingsIncInput>;\n  _set?: InputMaybe<FungibleAssetToCoinMappingsSetInput>;\n  pk_columns: FungibleAssetToCoinMappingsPkColumnsInput;\n};\n\n/** mutation root */\nexport type MutationRootUpdateFungibleAssetToCoinMappingsManyArgs = {\n  updates: Array<FungibleAssetToCoinMappingsUpdates>;\n};\n\n/** mutation root */\nexport type MutationRootUpdateGasFeesArgs = {\n  _inc?: InputMaybe<GasFeesIncInput>;\n  _set?: InputMaybe<GasFeesSetInput>;\n  where: GasFeesBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootUpdateGasFeesByPkArgs = {\n  _inc?: InputMaybe<GasFeesIncInput>;\n  _set?: InputMaybe<GasFeesSetInput>;\n  pk_columns: GasFeesPkColumnsInput;\n};\n\n/** mutation root */\nexport type MutationRootUpdateGasFeesManyArgs = {\n  updates: Array<GasFeesUpdates>;\n};\n\n/** mutation root */\nexport type MutationRootUpdateIndexerStatusArgs = {\n  _set?: InputMaybe<IndexerStatusSetInput>;\n  where: IndexerStatusBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootUpdateIndexerStatusByPkArgs = {\n  _set?: InputMaybe<IndexerStatusSetInput>;\n  pk_columns: IndexerStatusPkColumnsInput;\n};\n\n/** mutation root */\nexport type MutationRootUpdateIndexerStatusManyArgs = {\n  updates: Array<IndexerStatusUpdates>;\n};\n\n/** mutation root */\nexport type MutationRootUpdateMoveModulesArgs = {\n  _append?: InputMaybe<MoveModulesAppendInput>;\n  _delete_at_path?: InputMaybe<MoveModulesDeleteAtPathInput>;\n  _delete_elem?: InputMaybe<MoveModulesDeleteElemInput>;\n  _delete_key?: InputMaybe<MoveModulesDeleteKeyInput>;\n  _inc?: InputMaybe<MoveModulesIncInput>;\n  _prepend?: InputMaybe<MoveModulesPrependInput>;\n  _set?: InputMaybe<MoveModulesSetInput>;\n  where: MoveModulesBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootUpdateMoveModulesByPkArgs = {\n  _append?: InputMaybe<MoveModulesAppendInput>;\n  _delete_at_path?: InputMaybe<MoveModulesDeleteAtPathInput>;\n  _delete_elem?: InputMaybe<MoveModulesDeleteElemInput>;\n  _delete_key?: InputMaybe<MoveModulesDeleteKeyInput>;\n  _inc?: InputMaybe<MoveModulesIncInput>;\n  _prepend?: InputMaybe<MoveModulesPrependInput>;\n  _set?: InputMaybe<MoveModulesSetInput>;\n  pk_columns: MoveModulesPkColumnsInput;\n};\n\n/** mutation root */\nexport type MutationRootUpdateMoveModulesManyArgs = {\n  updates: Array<MoveModulesUpdates>;\n};\n\n/** mutation root */\nexport type MutationRootUpdateMoveResourcesArgs = {\n  _append?: InputMaybe<MoveResourcesAppendInput>;\n  _delete_at_path?: InputMaybe<MoveResourcesDeleteAtPathInput>;\n  _delete_elem?: InputMaybe<MoveResourcesDeleteElemInput>;\n  _delete_key?: InputMaybe<MoveResourcesDeleteKeyInput>;\n  _inc?: InputMaybe<MoveResourcesIncInput>;\n  _prepend?: InputMaybe<MoveResourcesPrependInput>;\n  _set?: InputMaybe<MoveResourcesSetInput>;\n  where: MoveResourcesBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootUpdateMoveResourcesByPkArgs = {\n  _append?: InputMaybe<MoveResourcesAppendInput>;\n  _delete_at_path?: InputMaybe<MoveResourcesDeleteAtPathInput>;\n  _delete_elem?: InputMaybe<MoveResourcesDeleteElemInput>;\n  _delete_key?: InputMaybe<MoveResourcesDeleteKeyInput>;\n  _inc?: InputMaybe<MoveResourcesIncInput>;\n  _prepend?: InputMaybe<MoveResourcesPrependInput>;\n  _set?: InputMaybe<MoveResourcesSetInput>;\n  pk_columns: MoveResourcesPkColumnsInput;\n};\n\n/** mutation root */\nexport type MutationRootUpdateMoveResourcesManyArgs = {\n  updates: Array<MoveResourcesUpdates>;\n};\n\n/** mutation root */\nexport type MutationRootUpdateMoveResourcesViewArgs = {\n  _append?: InputMaybe<MoveResourcesViewAppendInput>;\n  _delete_at_path?: InputMaybe<MoveResourcesViewDeleteAtPathInput>;\n  _delete_elem?: InputMaybe<MoveResourcesViewDeleteElemInput>;\n  _delete_key?: InputMaybe<MoveResourcesViewDeleteKeyInput>;\n  _inc?: InputMaybe<MoveResourcesViewIncInput>;\n  _prepend?: InputMaybe<MoveResourcesViewPrependInput>;\n  _set?: InputMaybe<MoveResourcesViewSetInput>;\n  where: MoveResourcesViewBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootUpdateMoveResourcesViewManyArgs = {\n  updates: Array<MoveResourcesViewUpdates>;\n};\n\n/** mutation root */\nexport type MutationRootUpdateNftMetadataCrawlerParsedAssetUrisArgs = {\n  _inc?: InputMaybe<NftMetadataCrawlerParsedAssetUrisIncInput>;\n  _set?: InputMaybe<NftMetadataCrawlerParsedAssetUrisSetInput>;\n  where: NftMetadataCrawlerParsedAssetUrisBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootUpdateNftMetadataCrawlerParsedAssetUrisByPkArgs = {\n  _inc?: InputMaybe<NftMetadataCrawlerParsedAssetUrisIncInput>;\n  _set?: InputMaybe<NftMetadataCrawlerParsedAssetUrisSetInput>;\n  pk_columns: NftMetadataCrawlerParsedAssetUrisPkColumnsInput;\n};\n\n/** mutation root */\nexport type MutationRootUpdateNftMetadataCrawlerParsedAssetUrisManyArgs = {\n  updates: Array<NftMetadataCrawlerParsedAssetUrisUpdates>;\n};\n\n/** mutation root */\nexport type MutationRootUpdateNftPointsArgs = {\n  _inc?: InputMaybe<NftPointsIncInput>;\n  _set?: InputMaybe<NftPointsSetInput>;\n  where: NftPointsBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootUpdateNftPointsByPkArgs = {\n  _inc?: InputMaybe<NftPointsIncInput>;\n  _set?: InputMaybe<NftPointsSetInput>;\n  pk_columns: NftPointsPkColumnsInput;\n};\n\n/** mutation root */\nexport type MutationRootUpdateNftPointsManyArgs = {\n  updates: Array<NftPointsUpdates>;\n};\n\n/** mutation root */\nexport type MutationRootUpdateObjectsArgs = {\n  _inc?: InputMaybe<ObjectsIncInput>;\n  _set?: InputMaybe<ObjectsSetInput>;\n  where: ObjectsBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootUpdateObjectsByPkArgs = {\n  _inc?: InputMaybe<ObjectsIncInput>;\n  _set?: InputMaybe<ObjectsSetInput>;\n  pk_columns: ObjectsPkColumnsInput;\n};\n\n/** mutation root */\nexport type MutationRootUpdateObjectsManyArgs = {\n  updates: Array<ObjectsUpdates>;\n};\n\n/** mutation root */\nexport type MutationRootUpdateProcessorMetadataProcessorStatusArgs = {\n  _inc?: InputMaybe<ProcessorMetadataProcessorStatusIncInput>;\n  _set?: InputMaybe<ProcessorMetadataProcessorStatusSetInput>;\n  where: ProcessorMetadataProcessorStatusBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootUpdateProcessorMetadataProcessorStatusByPkArgs = {\n  _inc?: InputMaybe<ProcessorMetadataProcessorStatusIncInput>;\n  _set?: InputMaybe<ProcessorMetadataProcessorStatusSetInput>;\n  pk_columns: ProcessorMetadataProcessorStatusPkColumnsInput;\n};\n\n/** mutation root */\nexport type MutationRootUpdateProcessorMetadataProcessorStatusManyArgs = {\n  updates: Array<ProcessorMetadataProcessorStatusUpdates>;\n};\n\n/** mutation root */\nexport type MutationRootUpdateProcessorStatusArgs = {\n  _inc?: InputMaybe<ProcessorStatusIncInput>;\n  _set?: InputMaybe<ProcessorStatusSetInput>;\n  where: ProcessorStatusBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootUpdateProcessorStatusByPkArgs = {\n  _inc?: InputMaybe<ProcessorStatusIncInput>;\n  _set?: InputMaybe<ProcessorStatusSetInput>;\n  pk_columns: ProcessorStatusPkColumnsInput;\n};\n\n/** mutation root */\nexport type MutationRootUpdateProcessorStatusManyArgs = {\n  updates: Array<ProcessorStatusUpdates>;\n};\n\n/** mutation root */\nexport type MutationRootUpdateProposalVotesArgs = {\n  _inc?: InputMaybe<ProposalVotesIncInput>;\n  _set?: InputMaybe<ProposalVotesSetInput>;\n  where: ProposalVotesBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootUpdateProposalVotesByPkArgs = {\n  _inc?: InputMaybe<ProposalVotesIncInput>;\n  _set?: InputMaybe<ProposalVotesSetInput>;\n  pk_columns: ProposalVotesPkColumnsInput;\n};\n\n/** mutation root */\nexport type MutationRootUpdateProposalVotesManyArgs = {\n  updates: Array<ProposalVotesUpdates>;\n};\n\n/** mutation root */\nexport type MutationRootUpdatePublicKeyAuthKeysArgs = {\n  _inc?: InputMaybe<PublicKeyAuthKeysIncInput>;\n  _set?: InputMaybe<PublicKeyAuthKeysSetInput>;\n  where: PublicKeyAuthKeysBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootUpdatePublicKeyAuthKeysByPkArgs = {\n  _inc?: InputMaybe<PublicKeyAuthKeysIncInput>;\n  _set?: InputMaybe<PublicKeyAuthKeysSetInput>;\n  pk_columns: PublicKeyAuthKeysPkColumnsInput;\n};\n\n/** mutation root */\nexport type MutationRootUpdatePublicKeyAuthKeysManyArgs = {\n  updates: Array<PublicKeyAuthKeysUpdates>;\n};\n\n/** mutation root */\nexport type MutationRootUpdateSignaturesArgs = {\n  _append?: InputMaybe<SignaturesAppendInput>;\n  _delete_at_path?: InputMaybe<SignaturesDeleteAtPathInput>;\n  _delete_elem?: InputMaybe<SignaturesDeleteElemInput>;\n  _delete_key?: InputMaybe<SignaturesDeleteKeyInput>;\n  _inc?: InputMaybe<SignaturesIncInput>;\n  _prepend?: InputMaybe<SignaturesPrependInput>;\n  _set?: InputMaybe<SignaturesSetInput>;\n  where: SignaturesBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootUpdateSignaturesByPkArgs = {\n  _append?: InputMaybe<SignaturesAppendInput>;\n  _delete_at_path?: InputMaybe<SignaturesDeleteAtPathInput>;\n  _delete_elem?: InputMaybe<SignaturesDeleteElemInput>;\n  _delete_key?: InputMaybe<SignaturesDeleteKeyInput>;\n  _inc?: InputMaybe<SignaturesIncInput>;\n  _prepend?: InputMaybe<SignaturesPrependInput>;\n  _set?: InputMaybe<SignaturesSetInput>;\n  pk_columns: SignaturesPkColumnsInput;\n};\n\n/** mutation root */\nexport type MutationRootUpdateSignaturesManyArgs = {\n  updates: Array<SignaturesUpdates>;\n};\n\n/** mutation root */\nexport type MutationRootUpdateSpamAssetsArgs = {\n  _set?: InputMaybe<SpamAssetsSetInput>;\n  where: SpamAssetsBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootUpdateSpamAssetsByPkArgs = {\n  _set?: InputMaybe<SpamAssetsSetInput>;\n  pk_columns: SpamAssetsPkColumnsInput;\n};\n\n/** mutation root */\nexport type MutationRootUpdateSpamAssetsManyArgs = {\n  updates: Array<SpamAssetsUpdates>;\n};\n\n/** mutation root */\nexport type MutationRootUpdateTableItemsArgs = {\n  _append?: InputMaybe<TableItemsAppendInput>;\n  _delete_at_path?: InputMaybe<TableItemsDeleteAtPathInput>;\n  _delete_elem?: InputMaybe<TableItemsDeleteElemInput>;\n  _delete_key?: InputMaybe<TableItemsDeleteKeyInput>;\n  _inc?: InputMaybe<TableItemsIncInput>;\n  _prepend?: InputMaybe<TableItemsPrependInput>;\n  _set?: InputMaybe<TableItemsSetInput>;\n  where: TableItemsBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootUpdateTableItemsByPkArgs = {\n  _append?: InputMaybe<TableItemsAppendInput>;\n  _delete_at_path?: InputMaybe<TableItemsDeleteAtPathInput>;\n  _delete_elem?: InputMaybe<TableItemsDeleteElemInput>;\n  _delete_key?: InputMaybe<TableItemsDeleteKeyInput>;\n  _inc?: InputMaybe<TableItemsIncInput>;\n  _prepend?: InputMaybe<TableItemsPrependInput>;\n  _set?: InputMaybe<TableItemsSetInput>;\n  pk_columns: TableItemsPkColumnsInput;\n};\n\n/** mutation root */\nexport type MutationRootUpdateTableItemsManyArgs = {\n  updates: Array<TableItemsUpdates>;\n};\n\n/** mutation root */\nexport type MutationRootUpdateTableItemsViewArgs = {\n  _inc?: InputMaybe<TableItemsViewIncInput>;\n  _set?: InputMaybe<TableItemsViewSetInput>;\n  where: TableItemsViewBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootUpdateTableItemsViewManyArgs = {\n  updates: Array<TableItemsViewUpdates>;\n};\n\n/** mutation root */\nexport type MutationRootUpdateTableMetadatasArgs = {\n  _set?: InputMaybe<TableMetadatasSetInput>;\n  where: TableMetadatasBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootUpdateTableMetadatasByPkArgs = {\n  _set?: InputMaybe<TableMetadatasSetInput>;\n  pk_columns: TableMetadatasPkColumnsInput;\n};\n\n/** mutation root */\nexport type MutationRootUpdateTableMetadatasManyArgs = {\n  updates: Array<TableMetadatasUpdates>;\n};\n\n/** mutation root */\nexport type MutationRootUpdateTokenActivitiesArgs = {\n  _inc?: InputMaybe<TokenActivitiesIncInput>;\n  _set?: InputMaybe<TokenActivitiesSetInput>;\n  where: TokenActivitiesBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootUpdateTokenActivitiesByPkArgs = {\n  _inc?: InputMaybe<TokenActivitiesIncInput>;\n  _set?: InputMaybe<TokenActivitiesSetInput>;\n  pk_columns: TokenActivitiesPkColumnsInput;\n};\n\n/** mutation root */\nexport type MutationRootUpdateTokenActivitiesManyArgs = {\n  updates: Array<TokenActivitiesUpdates>;\n};\n\n/** mutation root */\nexport type MutationRootUpdateTokenActivitiesV2Args = {\n  _inc?: InputMaybe<TokenActivitiesV2IncInput>;\n  _set?: InputMaybe<TokenActivitiesV2SetInput>;\n  where: TokenActivitiesV2BoolExp;\n};\n\n/** mutation root */\nexport type MutationRootUpdateTokenActivitiesV2ByPkArgs = {\n  _inc?: InputMaybe<TokenActivitiesV2IncInput>;\n  _set?: InputMaybe<TokenActivitiesV2SetInput>;\n  pk_columns: TokenActivitiesV2PkColumnsInput;\n};\n\n/** mutation root */\nexport type MutationRootUpdateTokenActivitiesV2ManyArgs = {\n  updates: Array<TokenActivitiesV2Updates>;\n};\n\n/** mutation root */\nexport type MutationRootUpdateTokenDatasArgs = {\n  _append?: InputMaybe<TokenDatasAppendInput>;\n  _delete_at_path?: InputMaybe<TokenDatasDeleteAtPathInput>;\n  _delete_elem?: InputMaybe<TokenDatasDeleteElemInput>;\n  _delete_key?: InputMaybe<TokenDatasDeleteKeyInput>;\n  _inc?: InputMaybe<TokenDatasIncInput>;\n  _prepend?: InputMaybe<TokenDatasPrependInput>;\n  _set?: InputMaybe<TokenDatasSetInput>;\n  where: TokenDatasBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootUpdateTokenDatasByPkArgs = {\n  _append?: InputMaybe<TokenDatasAppendInput>;\n  _delete_at_path?: InputMaybe<TokenDatasDeleteAtPathInput>;\n  _delete_elem?: InputMaybe<TokenDatasDeleteElemInput>;\n  _delete_key?: InputMaybe<TokenDatasDeleteKeyInput>;\n  _inc?: InputMaybe<TokenDatasIncInput>;\n  _prepend?: InputMaybe<TokenDatasPrependInput>;\n  _set?: InputMaybe<TokenDatasSetInput>;\n  pk_columns: TokenDatasPkColumnsInput;\n};\n\n/** mutation root */\nexport type MutationRootUpdateTokenDatasManyArgs = {\n  updates: Array<TokenDatasUpdates>;\n};\n\n/** mutation root */\nexport type MutationRootUpdateTokenDatasV2Args = {\n  _append?: InputMaybe<TokenDatasV2AppendInput>;\n  _delete_at_path?: InputMaybe<TokenDatasV2DeleteAtPathInput>;\n  _delete_elem?: InputMaybe<TokenDatasV2DeleteElemInput>;\n  _delete_key?: InputMaybe<TokenDatasV2DeleteKeyInput>;\n  _inc?: InputMaybe<TokenDatasV2IncInput>;\n  _prepend?: InputMaybe<TokenDatasV2PrependInput>;\n  _set?: InputMaybe<TokenDatasV2SetInput>;\n  where: TokenDatasV2BoolExp;\n};\n\n/** mutation root */\nexport type MutationRootUpdateTokenDatasV2ByPkArgs = {\n  _append?: InputMaybe<TokenDatasV2AppendInput>;\n  _delete_at_path?: InputMaybe<TokenDatasV2DeleteAtPathInput>;\n  _delete_elem?: InputMaybe<TokenDatasV2DeleteElemInput>;\n  _delete_key?: InputMaybe<TokenDatasV2DeleteKeyInput>;\n  _inc?: InputMaybe<TokenDatasV2IncInput>;\n  _prepend?: InputMaybe<TokenDatasV2PrependInput>;\n  _set?: InputMaybe<TokenDatasV2SetInput>;\n  pk_columns: TokenDatasV2PkColumnsInput;\n};\n\n/** mutation root */\nexport type MutationRootUpdateTokenDatasV2ManyArgs = {\n  updates: Array<TokenDatasV2Updates>;\n};\n\n/** mutation root */\nexport type MutationRootUpdateTokenOwnershipsArgs = {\n  _inc?: InputMaybe<TokenOwnershipsIncInput>;\n  _set?: InputMaybe<TokenOwnershipsSetInput>;\n  where: TokenOwnershipsBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootUpdateTokenOwnershipsByPkArgs = {\n  _inc?: InputMaybe<TokenOwnershipsIncInput>;\n  _set?: InputMaybe<TokenOwnershipsSetInput>;\n  pk_columns: TokenOwnershipsPkColumnsInput;\n};\n\n/** mutation root */\nexport type MutationRootUpdateTokenOwnershipsManyArgs = {\n  updates: Array<TokenOwnershipsUpdates>;\n};\n\n/** mutation root */\nexport type MutationRootUpdateTokenOwnershipsV2Args = {\n  _append?: InputMaybe<TokenOwnershipsV2AppendInput>;\n  _delete_at_path?: InputMaybe<TokenOwnershipsV2DeleteAtPathInput>;\n  _delete_elem?: InputMaybe<TokenOwnershipsV2DeleteElemInput>;\n  _delete_key?: InputMaybe<TokenOwnershipsV2DeleteKeyInput>;\n  _inc?: InputMaybe<TokenOwnershipsV2IncInput>;\n  _prepend?: InputMaybe<TokenOwnershipsV2PrependInput>;\n  _set?: InputMaybe<TokenOwnershipsV2SetInput>;\n  where: TokenOwnershipsV2BoolExp;\n};\n\n/** mutation root */\nexport type MutationRootUpdateTokenOwnershipsV2ByPkArgs = {\n  _append?: InputMaybe<TokenOwnershipsV2AppendInput>;\n  _delete_at_path?: InputMaybe<TokenOwnershipsV2DeleteAtPathInput>;\n  _delete_elem?: InputMaybe<TokenOwnershipsV2DeleteElemInput>;\n  _delete_key?: InputMaybe<TokenOwnershipsV2DeleteKeyInput>;\n  _inc?: InputMaybe<TokenOwnershipsV2IncInput>;\n  _prepend?: InputMaybe<TokenOwnershipsV2PrependInput>;\n  _set?: InputMaybe<TokenOwnershipsV2SetInput>;\n  pk_columns: TokenOwnershipsV2PkColumnsInput;\n};\n\n/** mutation root */\nexport type MutationRootUpdateTokenOwnershipsV2ManyArgs = {\n  updates: Array<TokenOwnershipsV2Updates>;\n};\n\n/** mutation root */\nexport type MutationRootUpdateTokensArgs = {\n  _append?: InputMaybe<TokensAppendInput>;\n  _delete_at_path?: InputMaybe<TokensDeleteAtPathInput>;\n  _delete_elem?: InputMaybe<TokensDeleteElemInput>;\n  _delete_key?: InputMaybe<TokensDeleteKeyInput>;\n  _inc?: InputMaybe<TokensIncInput>;\n  _prepend?: InputMaybe<TokensPrependInput>;\n  _set?: InputMaybe<TokensSetInput>;\n  where: TokensBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootUpdateTokensByPkArgs = {\n  _append?: InputMaybe<TokensAppendInput>;\n  _delete_at_path?: InputMaybe<TokensDeleteAtPathInput>;\n  _delete_elem?: InputMaybe<TokensDeleteElemInput>;\n  _delete_key?: InputMaybe<TokensDeleteKeyInput>;\n  _inc?: InputMaybe<TokensIncInput>;\n  _prepend?: InputMaybe<TokensPrependInput>;\n  _set?: InputMaybe<TokensSetInput>;\n  pk_columns: TokensPkColumnsInput;\n};\n\n/** mutation root */\nexport type MutationRootUpdateTokensManyArgs = {\n  updates: Array<TokensUpdates>;\n};\n\n/** mutation root */\nexport type MutationRootUpdateTransactionSizeInfoArgs = {\n  _inc?: InputMaybe<TransactionSizeInfoIncInput>;\n  _set?: InputMaybe<TransactionSizeInfoSetInput>;\n  where: TransactionSizeInfoBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootUpdateTransactionSizeInfoByPkArgs = {\n  _inc?: InputMaybe<TransactionSizeInfoIncInput>;\n  _set?: InputMaybe<TransactionSizeInfoSetInput>;\n  pk_columns: TransactionSizeInfoPkColumnsInput;\n};\n\n/** mutation root */\nexport type MutationRootUpdateTransactionSizeInfoManyArgs = {\n  updates: Array<TransactionSizeInfoUpdates>;\n};\n\n/** mutation root */\nexport type MutationRootUpdateTransactionsViewArgs = {\n  _inc?: InputMaybe<TransactionsViewIncInput>;\n  _set?: InputMaybe<TransactionsViewSetInput>;\n  where: TransactionsViewBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootUpdateTransactionsViewManyArgs = {\n  updates: Array<TransactionsViewUpdates>;\n};\n\n/** mutation root */\nexport type MutationRootUpdateUserTransactionsArgs = {\n  _inc?: InputMaybe<UserTransactionsIncInput>;\n  _set?: InputMaybe<UserTransactionsSetInput>;\n  where: UserTransactionsBoolExp;\n};\n\n/** mutation root */\nexport type MutationRootUpdateUserTransactionsByPkArgs = {\n  _inc?: InputMaybe<UserTransactionsIncInput>;\n  _set?: InputMaybe<UserTransactionsSetInput>;\n  pk_columns: UserTransactionsPkColumnsInput;\n};\n\n/** mutation root */\nexport type MutationRootUpdateUserTransactionsManyArgs = {\n  updates: Array<UserTransactionsUpdates>;\n};\n\n/** columns and relationships of \"nft_metadata_crawler.parsed_asset_uris\" */\nexport type NftMetadataCrawlerParsedAssetUris = {\n  animation_optimizer_retry_count: Scalars[\"Int\"][\"output\"];\n  asset_uri: Scalars[\"String\"][\"output\"];\n  cdn_animation_uri?: Maybe<Scalars[\"String\"][\"output\"]>;\n  cdn_image_uri?: Maybe<Scalars[\"String\"][\"output\"]>;\n  cdn_json_uri?: Maybe<Scalars[\"String\"][\"output\"]>;\n  image_optimizer_retry_count: Scalars[\"Int\"][\"output\"];\n  inserted_at: Scalars[\"timestamp\"][\"output\"];\n  json_parser_retry_count: Scalars[\"Int\"][\"output\"];\n  raw_animation_uri?: Maybe<Scalars[\"String\"][\"output\"]>;\n  raw_image_uri?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** aggregated selection of \"nft_metadata_crawler.parsed_asset_uris\" */\nexport type NftMetadataCrawlerParsedAssetUrisAggregate = {\n  aggregate?: Maybe<NftMetadataCrawlerParsedAssetUrisAggregateFields>;\n  nodes: Array<NftMetadataCrawlerParsedAssetUris>;\n};\n\n/** aggregate fields of \"nft_metadata_crawler.parsed_asset_uris\" */\nexport type NftMetadataCrawlerParsedAssetUrisAggregateFields = {\n  avg?: Maybe<NftMetadataCrawlerParsedAssetUrisAvgFields>;\n  count: Scalars[\"Int\"][\"output\"];\n  max?: Maybe<NftMetadataCrawlerParsedAssetUrisMaxFields>;\n  min?: Maybe<NftMetadataCrawlerParsedAssetUrisMinFields>;\n  stddev?: Maybe<NftMetadataCrawlerParsedAssetUrisStddevFields>;\n  stddev_pop?: Maybe<NftMetadataCrawlerParsedAssetUrisStddevPopFields>;\n  stddev_samp?: Maybe<NftMetadataCrawlerParsedAssetUrisStddevSampFields>;\n  sum?: Maybe<NftMetadataCrawlerParsedAssetUrisSumFields>;\n  var_pop?: Maybe<NftMetadataCrawlerParsedAssetUrisVarPopFields>;\n  var_samp?: Maybe<NftMetadataCrawlerParsedAssetUrisVarSampFields>;\n  variance?: Maybe<NftMetadataCrawlerParsedAssetUrisVarianceFields>;\n};\n\n/** aggregate fields of \"nft_metadata_crawler.parsed_asset_uris\" */\nexport type NftMetadataCrawlerParsedAssetUrisAggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<NftMetadataCrawlerParsedAssetUrisSelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** aggregate avg on columns */\nexport type NftMetadataCrawlerParsedAssetUrisAvgFields = {\n  animation_optimizer_retry_count?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  image_optimizer_retry_count?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  json_parser_retry_count?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Boolean expression to filter rows from the table \"nft_metadata_crawler.parsed_asset_uris\". All fields are combined with a logical 'AND'. */\nexport type NftMetadataCrawlerParsedAssetUrisBoolExp = {\n  _and?: InputMaybe<Array<NftMetadataCrawlerParsedAssetUrisBoolExp>>;\n  _not?: InputMaybe<NftMetadataCrawlerParsedAssetUrisBoolExp>;\n  _or?: InputMaybe<Array<NftMetadataCrawlerParsedAssetUrisBoolExp>>;\n  animation_optimizer_retry_count?: InputMaybe<IntComparisonExp>;\n  asset_uri?: InputMaybe<StringComparisonExp>;\n  cdn_animation_uri?: InputMaybe<StringComparisonExp>;\n  cdn_image_uri?: InputMaybe<StringComparisonExp>;\n  cdn_json_uri?: InputMaybe<StringComparisonExp>;\n  image_optimizer_retry_count?: InputMaybe<IntComparisonExp>;\n  inserted_at?: InputMaybe<TimestampComparisonExp>;\n  json_parser_retry_count?: InputMaybe<IntComparisonExp>;\n  raw_animation_uri?: InputMaybe<StringComparisonExp>;\n  raw_image_uri?: InputMaybe<StringComparisonExp>;\n};\n\n/** unique or primary key constraints on table \"nft_metadata_crawler.parsed_asset_uris\" */\nexport enum NftMetadataCrawlerParsedAssetUrisConstraint {\n  /** unique or primary key constraint on columns \"asset_uri\" */\n  ParsedAssetUrisPkey = \"parsed_asset_uris_pkey\",\n}\n\n/** input type for incrementing numeric columns in table \"nft_metadata_crawler.parsed_asset_uris\" */\nexport type NftMetadataCrawlerParsedAssetUrisIncInput = {\n  animation_optimizer_retry_count?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  image_optimizer_retry_count?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  json_parser_retry_count?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n};\n\n/** input type for inserting data into table \"nft_metadata_crawler.parsed_asset_uris\" */\nexport type NftMetadataCrawlerParsedAssetUrisInsertInput = {\n  animation_optimizer_retry_count?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  asset_uri?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  cdn_animation_uri?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  cdn_image_uri?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  cdn_json_uri?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  image_optimizer_retry_count?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  json_parser_retry_count?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  raw_animation_uri?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  raw_image_uri?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate max on columns */\nexport type NftMetadataCrawlerParsedAssetUrisMaxFields = {\n  animation_optimizer_retry_count?: Maybe<Scalars[\"Int\"][\"output\"]>;\n  asset_uri?: Maybe<Scalars[\"String\"][\"output\"]>;\n  cdn_animation_uri?: Maybe<Scalars[\"String\"][\"output\"]>;\n  cdn_image_uri?: Maybe<Scalars[\"String\"][\"output\"]>;\n  cdn_json_uri?: Maybe<Scalars[\"String\"][\"output\"]>;\n  image_optimizer_retry_count?: Maybe<Scalars[\"Int\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  json_parser_retry_count?: Maybe<Scalars[\"Int\"][\"output\"]>;\n  raw_animation_uri?: Maybe<Scalars[\"String\"][\"output\"]>;\n  raw_image_uri?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** aggregate min on columns */\nexport type NftMetadataCrawlerParsedAssetUrisMinFields = {\n  animation_optimizer_retry_count?: Maybe<Scalars[\"Int\"][\"output\"]>;\n  asset_uri?: Maybe<Scalars[\"String\"][\"output\"]>;\n  cdn_animation_uri?: Maybe<Scalars[\"String\"][\"output\"]>;\n  cdn_image_uri?: Maybe<Scalars[\"String\"][\"output\"]>;\n  cdn_json_uri?: Maybe<Scalars[\"String\"][\"output\"]>;\n  image_optimizer_retry_count?: Maybe<Scalars[\"Int\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  json_parser_retry_count?: Maybe<Scalars[\"Int\"][\"output\"]>;\n  raw_animation_uri?: Maybe<Scalars[\"String\"][\"output\"]>;\n  raw_image_uri?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** response of any mutation on the table \"nft_metadata_crawler.parsed_asset_uris\" */\nexport type NftMetadataCrawlerParsedAssetUrisMutationResponse = {\n  /** number of rows affected by the mutation */\n  affected_rows: Scalars[\"Int\"][\"output\"];\n  /** data from the rows affected by the mutation */\n  returning: Array<NftMetadataCrawlerParsedAssetUris>;\n};\n\n/** input type for inserting object relation for remote table \"nft_metadata_crawler.parsed_asset_uris\" */\nexport type NftMetadataCrawlerParsedAssetUrisObjRelInsertInput = {\n  data: NftMetadataCrawlerParsedAssetUrisInsertInput;\n  /** upsert condition */\n  on_conflict?: InputMaybe<NftMetadataCrawlerParsedAssetUrisOnConflict>;\n};\n\n/** on_conflict condition type for table \"nft_metadata_crawler.parsed_asset_uris\" */\nexport type NftMetadataCrawlerParsedAssetUrisOnConflict = {\n  constraint: NftMetadataCrawlerParsedAssetUrisConstraint;\n  update_columns?: Array<NftMetadataCrawlerParsedAssetUrisUpdateColumn>;\n  where?: InputMaybe<NftMetadataCrawlerParsedAssetUrisBoolExp>;\n};\n\n/** Ordering options when selecting data from \"nft_metadata_crawler.parsed_asset_uris\". */\nexport type NftMetadataCrawlerParsedAssetUrisOrderBy = {\n  animation_optimizer_retry_count?: InputMaybe<OrderBy>;\n  asset_uri?: InputMaybe<OrderBy>;\n  cdn_animation_uri?: InputMaybe<OrderBy>;\n  cdn_image_uri?: InputMaybe<OrderBy>;\n  cdn_json_uri?: InputMaybe<OrderBy>;\n  image_optimizer_retry_count?: InputMaybe<OrderBy>;\n  inserted_at?: InputMaybe<OrderBy>;\n  json_parser_retry_count?: InputMaybe<OrderBy>;\n  raw_animation_uri?: InputMaybe<OrderBy>;\n  raw_image_uri?: InputMaybe<OrderBy>;\n};\n\n/** primary key columns input for table: nft_metadata_crawler.parsed_asset_uris */\nexport type NftMetadataCrawlerParsedAssetUrisPkColumnsInput = {\n  asset_uri: Scalars[\"String\"][\"input\"];\n};\n\n/** select columns of table \"nft_metadata_crawler.parsed_asset_uris\" */\nexport enum NftMetadataCrawlerParsedAssetUrisSelectColumn {\n  /** column name */\n  AnimationOptimizerRetryCount = \"animation_optimizer_retry_count\",\n  /** column name */\n  AssetUri = \"asset_uri\",\n  /** column name */\n  CdnAnimationUri = \"cdn_animation_uri\",\n  /** column name */\n  CdnImageUri = \"cdn_image_uri\",\n  /** column name */\n  CdnJsonUri = \"cdn_json_uri\",\n  /** column name */\n  ImageOptimizerRetryCount = \"image_optimizer_retry_count\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  JsonParserRetryCount = \"json_parser_retry_count\",\n  /** column name */\n  RawAnimationUri = \"raw_animation_uri\",\n  /** column name */\n  RawImageUri = \"raw_image_uri\",\n}\n\n/** input type for updating data in table \"nft_metadata_crawler.parsed_asset_uris\" */\nexport type NftMetadataCrawlerParsedAssetUrisSetInput = {\n  animation_optimizer_retry_count?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  asset_uri?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  cdn_animation_uri?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  cdn_image_uri?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  cdn_json_uri?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  image_optimizer_retry_count?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  json_parser_retry_count?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  raw_animation_uri?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  raw_image_uri?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate stddev on columns */\nexport type NftMetadataCrawlerParsedAssetUrisStddevFields = {\n  animation_optimizer_retry_count?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  image_optimizer_retry_count?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  json_parser_retry_count?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_pop on columns */\nexport type NftMetadataCrawlerParsedAssetUrisStddevPopFields = {\n  animation_optimizer_retry_count?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  image_optimizer_retry_count?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  json_parser_retry_count?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_samp on columns */\nexport type NftMetadataCrawlerParsedAssetUrisStddevSampFields = {\n  animation_optimizer_retry_count?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  image_optimizer_retry_count?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  json_parser_retry_count?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Streaming cursor of the table \"nft_metadata_crawler_parsed_asset_uris\" */\nexport type NftMetadataCrawlerParsedAssetUrisStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: NftMetadataCrawlerParsedAssetUrisStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type NftMetadataCrawlerParsedAssetUrisStreamCursorValueInput = {\n  animation_optimizer_retry_count?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  asset_uri?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  cdn_animation_uri?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  cdn_image_uri?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  cdn_json_uri?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  image_optimizer_retry_count?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  json_parser_retry_count?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  raw_animation_uri?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  raw_image_uri?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate sum on columns */\nexport type NftMetadataCrawlerParsedAssetUrisSumFields = {\n  animation_optimizer_retry_count?: Maybe<Scalars[\"Int\"][\"output\"]>;\n  image_optimizer_retry_count?: Maybe<Scalars[\"Int\"][\"output\"]>;\n  json_parser_retry_count?: Maybe<Scalars[\"Int\"][\"output\"]>;\n};\n\n/** update columns of table \"nft_metadata_crawler.parsed_asset_uris\" */\nexport enum NftMetadataCrawlerParsedAssetUrisUpdateColumn {\n  /** column name */\n  AnimationOptimizerRetryCount = \"animation_optimizer_retry_count\",\n  /** column name */\n  AssetUri = \"asset_uri\",\n  /** column name */\n  CdnAnimationUri = \"cdn_animation_uri\",\n  /** column name */\n  CdnImageUri = \"cdn_image_uri\",\n  /** column name */\n  CdnJsonUri = \"cdn_json_uri\",\n  /** column name */\n  ImageOptimizerRetryCount = \"image_optimizer_retry_count\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  JsonParserRetryCount = \"json_parser_retry_count\",\n  /** column name */\n  RawAnimationUri = \"raw_animation_uri\",\n  /** column name */\n  RawImageUri = \"raw_image_uri\",\n}\n\nexport type NftMetadataCrawlerParsedAssetUrisUpdates = {\n  /** increments the numeric columns with given value of the filtered values */\n  _inc?: InputMaybe<NftMetadataCrawlerParsedAssetUrisIncInput>;\n  /** sets the columns of the filtered rows to the given values */\n  _set?: InputMaybe<NftMetadataCrawlerParsedAssetUrisSetInput>;\n  /** filter the rows which have to be updated */\n  where: NftMetadataCrawlerParsedAssetUrisBoolExp;\n};\n\n/** aggregate var_pop on columns */\nexport type NftMetadataCrawlerParsedAssetUrisVarPopFields = {\n  animation_optimizer_retry_count?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  image_optimizer_retry_count?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  json_parser_retry_count?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate var_samp on columns */\nexport type NftMetadataCrawlerParsedAssetUrisVarSampFields = {\n  animation_optimizer_retry_count?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  image_optimizer_retry_count?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  json_parser_retry_count?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate variance on columns */\nexport type NftMetadataCrawlerParsedAssetUrisVarianceFields = {\n  animation_optimizer_retry_count?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  image_optimizer_retry_count?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  json_parser_retry_count?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** columns and relationships of \"nft_points\" */\nexport type NftPoints = {\n  amount: Scalars[\"numeric\"][\"output\"];\n  inserted_at: Scalars[\"timestamp\"][\"output\"];\n  owner_address: Scalars[\"String\"][\"output\"];\n  point_type: Scalars[\"String\"][\"output\"];\n  token_name: Scalars[\"String\"][\"output\"];\n  transaction_timestamp: Scalars[\"timestamp\"][\"output\"];\n  transaction_version: Scalars[\"bigint\"][\"output\"];\n};\n\n/** aggregated selection of \"nft_points\" */\nexport type NftPointsAggregate = {\n  aggregate?: Maybe<NftPointsAggregateFields>;\n  nodes: Array<NftPoints>;\n};\n\n/** aggregate fields of \"nft_points\" */\nexport type NftPointsAggregateFields = {\n  avg?: Maybe<NftPointsAvgFields>;\n  count: Scalars[\"Int\"][\"output\"];\n  max?: Maybe<NftPointsMaxFields>;\n  min?: Maybe<NftPointsMinFields>;\n  stddev?: Maybe<NftPointsStddevFields>;\n  stddev_pop?: Maybe<NftPointsStddevPopFields>;\n  stddev_samp?: Maybe<NftPointsStddevSampFields>;\n  sum?: Maybe<NftPointsSumFields>;\n  var_pop?: Maybe<NftPointsVarPopFields>;\n  var_samp?: Maybe<NftPointsVarSampFields>;\n  variance?: Maybe<NftPointsVarianceFields>;\n};\n\n/** aggregate fields of \"nft_points\" */\nexport type NftPointsAggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<NftPointsSelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** aggregate avg on columns */\nexport type NftPointsAvgFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Boolean expression to filter rows from the table \"nft_points\". All fields are combined with a logical 'AND'. */\nexport type NftPointsBoolExp = {\n  _and?: InputMaybe<Array<NftPointsBoolExp>>;\n  _not?: InputMaybe<NftPointsBoolExp>;\n  _or?: InputMaybe<Array<NftPointsBoolExp>>;\n  amount?: InputMaybe<NumericComparisonExp>;\n  inserted_at?: InputMaybe<TimestampComparisonExp>;\n  owner_address?: InputMaybe<StringComparisonExp>;\n  point_type?: InputMaybe<StringComparisonExp>;\n  token_name?: InputMaybe<StringComparisonExp>;\n  transaction_timestamp?: InputMaybe<TimestampComparisonExp>;\n  transaction_version?: InputMaybe<BigintComparisonExp>;\n};\n\n/** unique or primary key constraints on table \"nft_points\" */\nexport enum NftPointsConstraint {\n  /** unique or primary key constraint on columns \"transaction_version\" */\n  NftPointsPkey = \"nft_points_pkey\",\n}\n\n/** input type for incrementing numeric columns in table \"nft_points\" */\nexport type NftPointsIncInput = {\n  amount?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** input type for inserting data into table \"nft_points\" */\nexport type NftPointsInsertInput = {\n  amount?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  owner_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  point_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** aggregate max on columns */\nexport type NftPointsMaxFields = {\n  amount?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  owner_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  point_type?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_name?: Maybe<Scalars[\"String\"][\"output\"]>;\n  transaction_timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** aggregate min on columns */\nexport type NftPointsMinFields = {\n  amount?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  owner_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  point_type?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_name?: Maybe<Scalars[\"String\"][\"output\"]>;\n  transaction_timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** response of any mutation on the table \"nft_points\" */\nexport type NftPointsMutationResponse = {\n  /** number of rows affected by the mutation */\n  affected_rows: Scalars[\"Int\"][\"output\"];\n  /** data from the rows affected by the mutation */\n  returning: Array<NftPoints>;\n};\n\n/** on_conflict condition type for table \"nft_points\" */\nexport type NftPointsOnConflict = {\n  constraint: NftPointsConstraint;\n  update_columns?: Array<NftPointsUpdateColumn>;\n  where?: InputMaybe<NftPointsBoolExp>;\n};\n\n/** Ordering options when selecting data from \"nft_points\". */\nexport type NftPointsOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  inserted_at?: InputMaybe<OrderBy>;\n  owner_address?: InputMaybe<OrderBy>;\n  point_type?: InputMaybe<OrderBy>;\n  token_name?: InputMaybe<OrderBy>;\n  transaction_timestamp?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n};\n\n/** primary key columns input for table: nft_points */\nexport type NftPointsPkColumnsInput = {\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\n/** select columns of table \"nft_points\" */\nexport enum NftPointsSelectColumn {\n  /** column name */\n  Amount = \"amount\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  OwnerAddress = \"owner_address\",\n  /** column name */\n  PointType = \"point_type\",\n  /** column name */\n  TokenName = \"token_name\",\n  /** column name */\n  TransactionTimestamp = \"transaction_timestamp\",\n  /** column name */\n  TransactionVersion = \"transaction_version\",\n}\n\n/** input type for updating data in table \"nft_points\" */\nexport type NftPointsSetInput = {\n  amount?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  owner_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  point_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** aggregate stddev on columns */\nexport type NftPointsStddevFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_pop on columns */\nexport type NftPointsStddevPopFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_samp on columns */\nexport type NftPointsStddevSampFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Streaming cursor of the table \"nft_points\" */\nexport type NftPointsStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: NftPointsStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type NftPointsStreamCursorValueInput = {\n  amount?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  owner_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  point_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** aggregate sum on columns */\nexport type NftPointsSumFields = {\n  amount?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** update columns of table \"nft_points\" */\nexport enum NftPointsUpdateColumn {\n  /** column name */\n  Amount = \"amount\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  OwnerAddress = \"owner_address\",\n  /** column name */\n  PointType = \"point_type\",\n  /** column name */\n  TokenName = \"token_name\",\n  /** column name */\n  TransactionTimestamp = \"transaction_timestamp\",\n  /** column name */\n  TransactionVersion = \"transaction_version\",\n}\n\nexport type NftPointsUpdates = {\n  /** increments the numeric columns with given value of the filtered values */\n  _inc?: InputMaybe<NftPointsIncInput>;\n  /** sets the columns of the filtered rows to the given values */\n  _set?: InputMaybe<NftPointsSetInput>;\n  /** filter the rows which have to be updated */\n  where: NftPointsBoolExp;\n};\n\n/** aggregate var_pop on columns */\nexport type NftPointsVarPopFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate var_samp on columns */\nexport type NftPointsVarSampFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate variance on columns */\nexport type NftPointsVarianceFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** columns and relationships of \"num_active_delegator_per_pool\" */\nexport type NumActiveDelegatorPerPool = {\n  num_active_delegator?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  pool_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** aggregated selection of \"num_active_delegator_per_pool\" */\nexport type NumActiveDelegatorPerPoolAggregate = {\n  aggregate?: Maybe<NumActiveDelegatorPerPoolAggregateFields>;\n  nodes: Array<NumActiveDelegatorPerPool>;\n};\n\n/** aggregate fields of \"num_active_delegator_per_pool\" */\nexport type NumActiveDelegatorPerPoolAggregateFields = {\n  avg?: Maybe<NumActiveDelegatorPerPoolAvgFields>;\n  count: Scalars[\"Int\"][\"output\"];\n  max?: Maybe<NumActiveDelegatorPerPoolMaxFields>;\n  min?: Maybe<NumActiveDelegatorPerPoolMinFields>;\n  stddev?: Maybe<NumActiveDelegatorPerPoolStddevFields>;\n  stddev_pop?: Maybe<NumActiveDelegatorPerPoolStddevPopFields>;\n  stddev_samp?: Maybe<NumActiveDelegatorPerPoolStddevSampFields>;\n  sum?: Maybe<NumActiveDelegatorPerPoolSumFields>;\n  var_pop?: Maybe<NumActiveDelegatorPerPoolVarPopFields>;\n  var_samp?: Maybe<NumActiveDelegatorPerPoolVarSampFields>;\n  variance?: Maybe<NumActiveDelegatorPerPoolVarianceFields>;\n};\n\n/** aggregate fields of \"num_active_delegator_per_pool\" */\nexport type NumActiveDelegatorPerPoolAggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<NumActiveDelegatorPerPoolSelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** aggregate avg on columns */\nexport type NumActiveDelegatorPerPoolAvgFields = {\n  num_active_delegator?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Boolean expression to filter rows from the table \"num_active_delegator_per_pool\". All fields are combined with a logical 'AND'. */\nexport type NumActiveDelegatorPerPoolBoolExp = {\n  _and?: InputMaybe<Array<NumActiveDelegatorPerPoolBoolExp>>;\n  _not?: InputMaybe<NumActiveDelegatorPerPoolBoolExp>;\n  _or?: InputMaybe<Array<NumActiveDelegatorPerPoolBoolExp>>;\n  num_active_delegator?: InputMaybe<BigintComparisonExp>;\n  pool_address?: InputMaybe<StringComparisonExp>;\n};\n\n/** aggregate max on columns */\nexport type NumActiveDelegatorPerPoolMaxFields = {\n  num_active_delegator?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  pool_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** aggregate min on columns */\nexport type NumActiveDelegatorPerPoolMinFields = {\n  num_active_delegator?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  pool_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** Ordering options when selecting data from \"num_active_delegator_per_pool\". */\nexport type NumActiveDelegatorPerPoolOrderBy = {\n  num_active_delegator?: InputMaybe<OrderBy>;\n  pool_address?: InputMaybe<OrderBy>;\n};\n\n/** select columns of table \"num_active_delegator_per_pool\" */\nexport enum NumActiveDelegatorPerPoolSelectColumn {\n  /** column name */\n  NumActiveDelegator = \"num_active_delegator\",\n  /** column name */\n  PoolAddress = \"pool_address\",\n}\n\n/** aggregate stddev on columns */\nexport type NumActiveDelegatorPerPoolStddevFields = {\n  num_active_delegator?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_pop on columns */\nexport type NumActiveDelegatorPerPoolStddevPopFields = {\n  num_active_delegator?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_samp on columns */\nexport type NumActiveDelegatorPerPoolStddevSampFields = {\n  num_active_delegator?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Streaming cursor of the table \"num_active_delegator_per_pool\" */\nexport type NumActiveDelegatorPerPoolStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: NumActiveDelegatorPerPoolStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type NumActiveDelegatorPerPoolStreamCursorValueInput = {\n  num_active_delegator?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  pool_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate sum on columns */\nexport type NumActiveDelegatorPerPoolSumFields = {\n  num_active_delegator?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** aggregate var_pop on columns */\nexport type NumActiveDelegatorPerPoolVarPopFields = {\n  num_active_delegator?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate var_samp on columns */\nexport type NumActiveDelegatorPerPoolVarSampFields = {\n  num_active_delegator?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate variance on columns */\nexport type NumActiveDelegatorPerPoolVarianceFields = {\n  num_active_delegator?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Boolean expression to compare columns of type \"numeric\". All fields are combined with logical 'AND'. */\nexport type NumericComparisonExp = {\n  _eq?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  _gt?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  _gte?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  _in?: InputMaybe<Array<Scalars[\"numeric\"][\"input\"]>>;\n  _is_null?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  _lt?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  _lte?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  _neq?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  _nin?: InputMaybe<Array<Scalars[\"numeric\"][\"input\"]>>;\n};\n\n/** columns and relationships of \"objects\" */\nexport type Objects = {\n  allow_ungated_transfer: Scalars[\"Boolean\"][\"output\"];\n  guid_creation_num: Scalars[\"numeric\"][\"output\"];\n  inserted_at: Scalars[\"timestamp\"][\"output\"];\n  is_deleted: Scalars[\"Boolean\"][\"output\"];\n  object_address: Scalars[\"String\"][\"output\"];\n  owner_address: Scalars[\"String\"][\"output\"];\n  state_key_hash: Scalars[\"String\"][\"output\"];\n  transaction_version: Scalars[\"bigint\"][\"output\"];\n  untransferrable: Scalars[\"Boolean\"][\"output\"];\n  write_set_change_index: Scalars[\"bigint\"][\"output\"];\n};\n\n/** aggregated selection of \"objects\" */\nexport type ObjectsAggregate = {\n  aggregate?: Maybe<ObjectsAggregateFields>;\n  nodes: Array<Objects>;\n};\n\n/** aggregate fields of \"objects\" */\nexport type ObjectsAggregateFields = {\n  avg?: Maybe<ObjectsAvgFields>;\n  count: Scalars[\"Int\"][\"output\"];\n  max?: Maybe<ObjectsMaxFields>;\n  min?: Maybe<ObjectsMinFields>;\n  stddev?: Maybe<ObjectsStddevFields>;\n  stddev_pop?: Maybe<ObjectsStddevPopFields>;\n  stddev_samp?: Maybe<ObjectsStddevSampFields>;\n  sum?: Maybe<ObjectsSumFields>;\n  var_pop?: Maybe<ObjectsVarPopFields>;\n  var_samp?: Maybe<ObjectsVarSampFields>;\n  variance?: Maybe<ObjectsVarianceFields>;\n};\n\n/** aggregate fields of \"objects\" */\nexport type ObjectsAggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<ObjectsSelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** aggregate avg on columns */\nexport type ObjectsAvgFields = {\n  guid_creation_num?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Boolean expression to filter rows from the table \"objects\". All fields are combined with a logical 'AND'. */\nexport type ObjectsBoolExp = {\n  _and?: InputMaybe<Array<ObjectsBoolExp>>;\n  _not?: InputMaybe<ObjectsBoolExp>;\n  _or?: InputMaybe<Array<ObjectsBoolExp>>;\n  allow_ungated_transfer?: InputMaybe<BooleanComparisonExp>;\n  guid_creation_num?: InputMaybe<NumericComparisonExp>;\n  inserted_at?: InputMaybe<TimestampComparisonExp>;\n  is_deleted?: InputMaybe<BooleanComparisonExp>;\n  object_address?: InputMaybe<StringComparisonExp>;\n  owner_address?: InputMaybe<StringComparisonExp>;\n  state_key_hash?: InputMaybe<StringComparisonExp>;\n  transaction_version?: InputMaybe<BigintComparisonExp>;\n  untransferrable?: InputMaybe<BooleanComparisonExp>;\n  write_set_change_index?: InputMaybe<BigintComparisonExp>;\n};\n\n/** unique or primary key constraints on table \"objects\" */\nexport enum ObjectsConstraint {\n  /** unique or primary key constraint on columns \"write_set_change_index\", \"transaction_version\" */\n  ObjectsPkey = \"objects_pkey\",\n}\n\n/** input type for incrementing numeric columns in table \"objects\" */\nexport type ObjectsIncInput = {\n  guid_creation_num?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  write_set_change_index?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** input type for inserting data into table \"objects\" */\nexport type ObjectsInsertInput = {\n  allow_ungated_transfer?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  guid_creation_num?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  is_deleted?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  object_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  owner_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  state_key_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  untransferrable?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  write_set_change_index?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** aggregate max on columns */\nexport type ObjectsMaxFields = {\n  guid_creation_num?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  object_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  owner_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  state_key_hash?: Maybe<Scalars[\"String\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** aggregate min on columns */\nexport type ObjectsMinFields = {\n  guid_creation_num?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  object_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  owner_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  state_key_hash?: Maybe<Scalars[\"String\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** response of any mutation on the table \"objects\" */\nexport type ObjectsMutationResponse = {\n  /** number of rows affected by the mutation */\n  affected_rows: Scalars[\"Int\"][\"output\"];\n  /** data from the rows affected by the mutation */\n  returning: Array<Objects>;\n};\n\n/** on_conflict condition type for table \"objects\" */\nexport type ObjectsOnConflict = {\n  constraint: ObjectsConstraint;\n  update_columns?: Array<ObjectsUpdateColumn>;\n  where?: InputMaybe<ObjectsBoolExp>;\n};\n\n/** Ordering options when selecting data from \"objects\". */\nexport type ObjectsOrderBy = {\n  allow_ungated_transfer?: InputMaybe<OrderBy>;\n  guid_creation_num?: InputMaybe<OrderBy>;\n  inserted_at?: InputMaybe<OrderBy>;\n  is_deleted?: InputMaybe<OrderBy>;\n  object_address?: InputMaybe<OrderBy>;\n  owner_address?: InputMaybe<OrderBy>;\n  state_key_hash?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n  untransferrable?: InputMaybe<OrderBy>;\n  write_set_change_index?: InputMaybe<OrderBy>;\n};\n\n/** primary key columns input for table: objects */\nexport type ObjectsPkColumnsInput = {\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n  write_set_change_index: Scalars[\"bigint\"][\"input\"];\n};\n\n/** select columns of table \"objects\" */\nexport enum ObjectsSelectColumn {\n  /** column name */\n  AllowUngatedTransfer = \"allow_ungated_transfer\",\n  /** column name */\n  GuidCreationNum = \"guid_creation_num\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  IsDeleted = \"is_deleted\",\n  /** column name */\n  ObjectAddress = \"object_address\",\n  /** column name */\n  OwnerAddress = \"owner_address\",\n  /** column name */\n  StateKeyHash = \"state_key_hash\",\n  /** column name */\n  TransactionVersion = \"transaction_version\",\n  /** column name */\n  Untransferrable = \"untransferrable\",\n  /** column name */\n  WriteSetChangeIndex = \"write_set_change_index\",\n}\n\n/** input type for updating data in table \"objects\" */\nexport type ObjectsSetInput = {\n  allow_ungated_transfer?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  guid_creation_num?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  is_deleted?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  object_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  owner_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  state_key_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  untransferrable?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  write_set_change_index?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** aggregate stddev on columns */\nexport type ObjectsStddevFields = {\n  guid_creation_num?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_pop on columns */\nexport type ObjectsStddevPopFields = {\n  guid_creation_num?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_samp on columns */\nexport type ObjectsStddevSampFields = {\n  guid_creation_num?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Streaming cursor of the table \"objects\" */\nexport type ObjectsStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: ObjectsStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type ObjectsStreamCursorValueInput = {\n  allow_ungated_transfer?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  guid_creation_num?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  is_deleted?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  object_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  owner_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  state_key_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  untransferrable?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  write_set_change_index?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** aggregate sum on columns */\nexport type ObjectsSumFields = {\n  guid_creation_num?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** update columns of table \"objects\" */\nexport enum ObjectsUpdateColumn {\n  /** column name */\n  AllowUngatedTransfer = \"allow_ungated_transfer\",\n  /** column name */\n  GuidCreationNum = \"guid_creation_num\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  IsDeleted = \"is_deleted\",\n  /** column name */\n  ObjectAddress = \"object_address\",\n  /** column name */\n  OwnerAddress = \"owner_address\",\n  /** column name */\n  StateKeyHash = \"state_key_hash\",\n  /** column name */\n  TransactionVersion = \"transaction_version\",\n  /** column name */\n  Untransferrable = \"untransferrable\",\n  /** column name */\n  WriteSetChangeIndex = \"write_set_change_index\",\n}\n\nexport type ObjectsUpdates = {\n  /** increments the numeric columns with given value of the filtered values */\n  _inc?: InputMaybe<ObjectsIncInput>;\n  /** sets the columns of the filtered rows to the given values */\n  _set?: InputMaybe<ObjectsSetInput>;\n  /** filter the rows which have to be updated */\n  where: ObjectsBoolExp;\n};\n\n/** aggregate var_pop on columns */\nexport type ObjectsVarPopFields = {\n  guid_creation_num?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate var_samp on columns */\nexport type ObjectsVarSampFields = {\n  guid_creation_num?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate variance on columns */\nexport type ObjectsVarianceFields = {\n  guid_creation_num?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** column ordering options */\nexport enum OrderBy {\n  /** in ascending order, nulls last */\n  Asc = \"asc\",\n  /** in ascending order, nulls first */\n  AscNullsFirst = \"asc_nulls_first\",\n  /** in ascending order, nulls last */\n  AscNullsLast = \"asc_nulls_last\",\n  /** in descending order, nulls first */\n  Desc = \"desc\",\n  /** in descending order, nulls first */\n  DescNullsFirst = \"desc_nulls_first\",\n  /** in descending order, nulls last */\n  DescNullsLast = \"desc_nulls_last\",\n}\n\n/** columns and relationships of \"processor_metadata.processor_status\" */\nexport type ProcessorMetadataProcessorStatus = {\n  last_success_version: Scalars[\"bigint\"][\"output\"];\n  last_transaction_timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  last_updated: Scalars[\"timestamp\"][\"output\"];\n  processor: Scalars[\"String\"][\"output\"];\n};\n\n/** aggregated selection of \"processor_metadata.processor_status\" */\nexport type ProcessorMetadataProcessorStatusAggregate = {\n  aggregate?: Maybe<ProcessorMetadataProcessorStatusAggregateFields>;\n  nodes: Array<ProcessorMetadataProcessorStatus>;\n};\n\n/** aggregate fields of \"processor_metadata.processor_status\" */\nexport type ProcessorMetadataProcessorStatusAggregateFields = {\n  avg?: Maybe<ProcessorMetadataProcessorStatusAvgFields>;\n  count: Scalars[\"Int\"][\"output\"];\n  max?: Maybe<ProcessorMetadataProcessorStatusMaxFields>;\n  min?: Maybe<ProcessorMetadataProcessorStatusMinFields>;\n  stddev?: Maybe<ProcessorMetadataProcessorStatusStddevFields>;\n  stddev_pop?: Maybe<ProcessorMetadataProcessorStatusStddevPopFields>;\n  stddev_samp?: Maybe<ProcessorMetadataProcessorStatusStddevSampFields>;\n  sum?: Maybe<ProcessorMetadataProcessorStatusSumFields>;\n  var_pop?: Maybe<ProcessorMetadataProcessorStatusVarPopFields>;\n  var_samp?: Maybe<ProcessorMetadataProcessorStatusVarSampFields>;\n  variance?: Maybe<ProcessorMetadataProcessorStatusVarianceFields>;\n};\n\n/** aggregate fields of \"processor_metadata.processor_status\" */\nexport type ProcessorMetadataProcessorStatusAggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<ProcessorMetadataProcessorStatusSelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** aggregate avg on columns */\nexport type ProcessorMetadataProcessorStatusAvgFields = {\n  last_success_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Boolean expression to filter rows from the table \"processor_metadata.processor_status\". All fields are combined with a logical 'AND'. */\nexport type ProcessorMetadataProcessorStatusBoolExp = {\n  _and?: InputMaybe<Array<ProcessorMetadataProcessorStatusBoolExp>>;\n  _not?: InputMaybe<ProcessorMetadataProcessorStatusBoolExp>;\n  _or?: InputMaybe<Array<ProcessorMetadataProcessorStatusBoolExp>>;\n  last_success_version?: InputMaybe<BigintComparisonExp>;\n  last_transaction_timestamp?: InputMaybe<TimestampComparisonExp>;\n  last_updated?: InputMaybe<TimestampComparisonExp>;\n  processor?: InputMaybe<StringComparisonExp>;\n};\n\n/** unique or primary key constraints on table \"processor_metadata.processor_status\" */\nexport enum ProcessorMetadataProcessorStatusConstraint {\n  /** unique or primary key constraint on columns \"processor\" */\n  ProcessorStatusPkey = \"processor_status_pkey\",\n}\n\n/** input type for incrementing numeric columns in table \"processor_metadata.processor_status\" */\nexport type ProcessorMetadataProcessorStatusIncInput = {\n  last_success_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** input type for inserting data into table \"processor_metadata.processor_status\" */\nexport type ProcessorMetadataProcessorStatusInsertInput = {\n  last_success_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  last_transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  last_updated?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  processor?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate max on columns */\nexport type ProcessorMetadataProcessorStatusMaxFields = {\n  last_success_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  last_transaction_timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  last_updated?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  processor?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** aggregate min on columns */\nexport type ProcessorMetadataProcessorStatusMinFields = {\n  last_success_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  last_transaction_timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  last_updated?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  processor?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** response of any mutation on the table \"processor_metadata.processor_status\" */\nexport type ProcessorMetadataProcessorStatusMutationResponse = {\n  /** number of rows affected by the mutation */\n  affected_rows: Scalars[\"Int\"][\"output\"];\n  /** data from the rows affected by the mutation */\n  returning: Array<ProcessorMetadataProcessorStatus>;\n};\n\n/** on_conflict condition type for table \"processor_metadata.processor_status\" */\nexport type ProcessorMetadataProcessorStatusOnConflict = {\n  constraint: ProcessorMetadataProcessorStatusConstraint;\n  update_columns?: Array<ProcessorMetadataProcessorStatusUpdateColumn>;\n  where?: InputMaybe<ProcessorMetadataProcessorStatusBoolExp>;\n};\n\n/** Ordering options when selecting data from \"processor_metadata.processor_status\". */\nexport type ProcessorMetadataProcessorStatusOrderBy = {\n  last_success_version?: InputMaybe<OrderBy>;\n  last_transaction_timestamp?: InputMaybe<OrderBy>;\n  last_updated?: InputMaybe<OrderBy>;\n  processor?: InputMaybe<OrderBy>;\n};\n\n/** primary key columns input for table: processor_metadata.processor_status */\nexport type ProcessorMetadataProcessorStatusPkColumnsInput = {\n  processor: Scalars[\"String\"][\"input\"];\n};\n\n/** select columns of table \"processor_metadata.processor_status\" */\nexport enum ProcessorMetadataProcessorStatusSelectColumn {\n  /** column name */\n  LastSuccessVersion = \"last_success_version\",\n  /** column name */\n  LastTransactionTimestamp = \"last_transaction_timestamp\",\n  /** column name */\n  LastUpdated = \"last_updated\",\n  /** column name */\n  Processor = \"processor\",\n}\n\n/** input type for updating data in table \"processor_metadata.processor_status\" */\nexport type ProcessorMetadataProcessorStatusSetInput = {\n  last_success_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  last_transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  last_updated?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  processor?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate stddev on columns */\nexport type ProcessorMetadataProcessorStatusStddevFields = {\n  last_success_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_pop on columns */\nexport type ProcessorMetadataProcessorStatusStddevPopFields = {\n  last_success_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_samp on columns */\nexport type ProcessorMetadataProcessorStatusStddevSampFields = {\n  last_success_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Streaming cursor of the table \"processor_metadata_processor_status\" */\nexport type ProcessorMetadataProcessorStatusStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: ProcessorMetadataProcessorStatusStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type ProcessorMetadataProcessorStatusStreamCursorValueInput = {\n  last_success_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  last_transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  last_updated?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  processor?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate sum on columns */\nexport type ProcessorMetadataProcessorStatusSumFields = {\n  last_success_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** update columns of table \"processor_metadata.processor_status\" */\nexport enum ProcessorMetadataProcessorStatusUpdateColumn {\n  /** column name */\n  LastSuccessVersion = \"last_success_version\",\n  /** column name */\n  LastTransactionTimestamp = \"last_transaction_timestamp\",\n  /** column name */\n  LastUpdated = \"last_updated\",\n  /** column name */\n  Processor = \"processor\",\n}\n\nexport type ProcessorMetadataProcessorStatusUpdates = {\n  /** increments the numeric columns with given value of the filtered values */\n  _inc?: InputMaybe<ProcessorMetadataProcessorStatusIncInput>;\n  /** sets the columns of the filtered rows to the given values */\n  _set?: InputMaybe<ProcessorMetadataProcessorStatusSetInput>;\n  /** filter the rows which have to be updated */\n  where: ProcessorMetadataProcessorStatusBoolExp;\n};\n\n/** aggregate var_pop on columns */\nexport type ProcessorMetadataProcessorStatusVarPopFields = {\n  last_success_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate var_samp on columns */\nexport type ProcessorMetadataProcessorStatusVarSampFields = {\n  last_success_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate variance on columns */\nexport type ProcessorMetadataProcessorStatusVarianceFields = {\n  last_success_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** columns and relationships of \"processor_status\" */\nexport type ProcessorStatus = {\n  last_success_version: Scalars[\"bigint\"][\"output\"];\n  last_transaction_timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  last_updated: Scalars[\"timestamp\"][\"output\"];\n  processor: Scalars[\"String\"][\"output\"];\n};\n\n/** aggregated selection of \"processor_status\" */\nexport type ProcessorStatusAggregate = {\n  aggregate?: Maybe<ProcessorStatusAggregateFields>;\n  nodes: Array<ProcessorStatus>;\n};\n\n/** aggregate fields of \"processor_status\" */\nexport type ProcessorStatusAggregateFields = {\n  avg?: Maybe<ProcessorStatusAvgFields>;\n  count: Scalars[\"Int\"][\"output\"];\n  max?: Maybe<ProcessorStatusMaxFields>;\n  min?: Maybe<ProcessorStatusMinFields>;\n  stddev?: Maybe<ProcessorStatusStddevFields>;\n  stddev_pop?: Maybe<ProcessorStatusStddevPopFields>;\n  stddev_samp?: Maybe<ProcessorStatusStddevSampFields>;\n  sum?: Maybe<ProcessorStatusSumFields>;\n  var_pop?: Maybe<ProcessorStatusVarPopFields>;\n  var_samp?: Maybe<ProcessorStatusVarSampFields>;\n  variance?: Maybe<ProcessorStatusVarianceFields>;\n};\n\n/** aggregate fields of \"processor_status\" */\nexport type ProcessorStatusAggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<ProcessorStatusSelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** aggregate avg on columns */\nexport type ProcessorStatusAvgFields = {\n  last_success_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Boolean expression to filter rows from the table \"processor_status\". All fields are combined with a logical 'AND'. */\nexport type ProcessorStatusBoolExp = {\n  _and?: InputMaybe<Array<ProcessorStatusBoolExp>>;\n  _not?: InputMaybe<ProcessorStatusBoolExp>;\n  _or?: InputMaybe<Array<ProcessorStatusBoolExp>>;\n  last_success_version?: InputMaybe<BigintComparisonExp>;\n  last_transaction_timestamp?: InputMaybe<TimestampComparisonExp>;\n  last_updated?: InputMaybe<TimestampComparisonExp>;\n  processor?: InputMaybe<StringComparisonExp>;\n};\n\n/** unique or primary key constraints on table \"processor_status\" */\nexport enum ProcessorStatusConstraint {\n  /** unique or primary key constraint on columns \"processor\" */\n  ProcessorStatusPkey = \"processor_status_pkey\",\n  /** unique or primary key constraint on columns \"processor\" */\n  ProcessorStatusPkey1 = \"processor_status_pkey1\",\n}\n\n/** input type for incrementing numeric columns in table \"processor_status\" */\nexport type ProcessorStatusIncInput = {\n  last_success_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** input type for inserting data into table \"processor_status\" */\nexport type ProcessorStatusInsertInput = {\n  last_success_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  last_transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  last_updated?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  processor?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate max on columns */\nexport type ProcessorStatusMaxFields = {\n  last_success_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  last_transaction_timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  last_updated?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  processor?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** aggregate min on columns */\nexport type ProcessorStatusMinFields = {\n  last_success_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  last_transaction_timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  last_updated?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  processor?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** response of any mutation on the table \"processor_status\" */\nexport type ProcessorStatusMutationResponse = {\n  /** number of rows affected by the mutation */\n  affected_rows: Scalars[\"Int\"][\"output\"];\n  /** data from the rows affected by the mutation */\n  returning: Array<ProcessorStatus>;\n};\n\n/** on_conflict condition type for table \"processor_status\" */\nexport type ProcessorStatusOnConflict = {\n  constraint: ProcessorStatusConstraint;\n  update_columns?: Array<ProcessorStatusUpdateColumn>;\n  where?: InputMaybe<ProcessorStatusBoolExp>;\n};\n\n/** Ordering options when selecting data from \"processor_status\". */\nexport type ProcessorStatusOrderBy = {\n  last_success_version?: InputMaybe<OrderBy>;\n  last_transaction_timestamp?: InputMaybe<OrderBy>;\n  last_updated?: InputMaybe<OrderBy>;\n  processor?: InputMaybe<OrderBy>;\n};\n\n/** primary key columns input for table: processor_status */\nexport type ProcessorStatusPkColumnsInput = {\n  processor: Scalars[\"String\"][\"input\"];\n};\n\n/** select columns of table \"processor_status\" */\nexport enum ProcessorStatusSelectColumn {\n  /** column name */\n  LastSuccessVersion = \"last_success_version\",\n  /** column name */\n  LastTransactionTimestamp = \"last_transaction_timestamp\",\n  /** column name */\n  LastUpdated = \"last_updated\",\n  /** column name */\n  Processor = \"processor\",\n}\n\n/** input type for updating data in table \"processor_status\" */\nexport type ProcessorStatusSetInput = {\n  last_success_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  last_transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  last_updated?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  processor?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate stddev on columns */\nexport type ProcessorStatusStddevFields = {\n  last_success_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_pop on columns */\nexport type ProcessorStatusStddevPopFields = {\n  last_success_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_samp on columns */\nexport type ProcessorStatusStddevSampFields = {\n  last_success_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Streaming cursor of the table \"processor_status\" */\nexport type ProcessorStatusStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: ProcessorStatusStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type ProcessorStatusStreamCursorValueInput = {\n  last_success_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  last_transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  last_updated?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  processor?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate sum on columns */\nexport type ProcessorStatusSumFields = {\n  last_success_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** update columns of table \"processor_status\" */\nexport enum ProcessorStatusUpdateColumn {\n  /** column name */\n  LastSuccessVersion = \"last_success_version\",\n  /** column name */\n  LastTransactionTimestamp = \"last_transaction_timestamp\",\n  /** column name */\n  LastUpdated = \"last_updated\",\n  /** column name */\n  Processor = \"processor\",\n}\n\nexport type ProcessorStatusUpdates = {\n  /** increments the numeric columns with given value of the filtered values */\n  _inc?: InputMaybe<ProcessorStatusIncInput>;\n  /** sets the columns of the filtered rows to the given values */\n  _set?: InputMaybe<ProcessorStatusSetInput>;\n  /** filter the rows which have to be updated */\n  where: ProcessorStatusBoolExp;\n};\n\n/** aggregate var_pop on columns */\nexport type ProcessorStatusVarPopFields = {\n  last_success_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate var_samp on columns */\nexport type ProcessorStatusVarSampFields = {\n  last_success_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate variance on columns */\nexport type ProcessorStatusVarianceFields = {\n  last_success_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** columns and relationships of \"proposal_votes\" */\nexport type ProposalVotes = {\n  inserted_at: Scalars[\"timestamp\"][\"output\"];\n  num_votes: Scalars[\"numeric\"][\"output\"];\n  proposal_id: Scalars[\"bigint\"][\"output\"];\n  should_pass: Scalars[\"Boolean\"][\"output\"];\n  staking_pool_address: Scalars[\"String\"][\"output\"];\n  transaction_timestamp: Scalars[\"timestamp\"][\"output\"];\n  transaction_version: Scalars[\"bigint\"][\"output\"];\n  voter_address: Scalars[\"String\"][\"output\"];\n};\n\n/** aggregated selection of \"proposal_votes\" */\nexport type ProposalVotesAggregate = {\n  aggregate?: Maybe<ProposalVotesAggregateFields>;\n  nodes: Array<ProposalVotes>;\n};\n\n/** aggregate fields of \"proposal_votes\" */\nexport type ProposalVotesAggregateFields = {\n  avg?: Maybe<ProposalVotesAvgFields>;\n  count: Scalars[\"Int\"][\"output\"];\n  max?: Maybe<ProposalVotesMaxFields>;\n  min?: Maybe<ProposalVotesMinFields>;\n  stddev?: Maybe<ProposalVotesStddevFields>;\n  stddev_pop?: Maybe<ProposalVotesStddevPopFields>;\n  stddev_samp?: Maybe<ProposalVotesStddevSampFields>;\n  sum?: Maybe<ProposalVotesSumFields>;\n  var_pop?: Maybe<ProposalVotesVarPopFields>;\n  var_samp?: Maybe<ProposalVotesVarSampFields>;\n  variance?: Maybe<ProposalVotesVarianceFields>;\n};\n\n/** aggregate fields of \"proposal_votes\" */\nexport type ProposalVotesAggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<ProposalVotesSelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** aggregate avg on columns */\nexport type ProposalVotesAvgFields = {\n  num_votes?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  proposal_id?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Boolean expression to filter rows from the table \"proposal_votes\". All fields are combined with a logical 'AND'. */\nexport type ProposalVotesBoolExp = {\n  _and?: InputMaybe<Array<ProposalVotesBoolExp>>;\n  _not?: InputMaybe<ProposalVotesBoolExp>;\n  _or?: InputMaybe<Array<ProposalVotesBoolExp>>;\n  inserted_at?: InputMaybe<TimestampComparisonExp>;\n  num_votes?: InputMaybe<NumericComparisonExp>;\n  proposal_id?: InputMaybe<BigintComparisonExp>;\n  should_pass?: InputMaybe<BooleanComparisonExp>;\n  staking_pool_address?: InputMaybe<StringComparisonExp>;\n  transaction_timestamp?: InputMaybe<TimestampComparisonExp>;\n  transaction_version?: InputMaybe<BigintComparisonExp>;\n  voter_address?: InputMaybe<StringComparisonExp>;\n};\n\n/** unique or primary key constraints on table \"proposal_votes\" */\nexport enum ProposalVotesConstraint {\n  /** unique or primary key constraint on columns \"voter_address\", \"transaction_version\", \"proposal_id\" */\n  ProposalVotesPkey = \"proposal_votes_pkey\",\n}\n\n/** input type for incrementing numeric columns in table \"proposal_votes\" */\nexport type ProposalVotesIncInput = {\n  num_votes?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  proposal_id?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** input type for inserting data into table \"proposal_votes\" */\nexport type ProposalVotesInsertInput = {\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  num_votes?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  proposal_id?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  should_pass?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  staking_pool_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  voter_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate max on columns */\nexport type ProposalVotesMaxFields = {\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  num_votes?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  proposal_id?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  staking_pool_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  transaction_timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  voter_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** aggregate min on columns */\nexport type ProposalVotesMinFields = {\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  num_votes?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  proposal_id?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  staking_pool_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  transaction_timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  voter_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** response of any mutation on the table \"proposal_votes\" */\nexport type ProposalVotesMutationResponse = {\n  /** number of rows affected by the mutation */\n  affected_rows: Scalars[\"Int\"][\"output\"];\n  /** data from the rows affected by the mutation */\n  returning: Array<ProposalVotes>;\n};\n\n/** on_conflict condition type for table \"proposal_votes\" */\nexport type ProposalVotesOnConflict = {\n  constraint: ProposalVotesConstraint;\n  update_columns?: Array<ProposalVotesUpdateColumn>;\n  where?: InputMaybe<ProposalVotesBoolExp>;\n};\n\n/** Ordering options when selecting data from \"proposal_votes\". */\nexport type ProposalVotesOrderBy = {\n  inserted_at?: InputMaybe<OrderBy>;\n  num_votes?: InputMaybe<OrderBy>;\n  proposal_id?: InputMaybe<OrderBy>;\n  should_pass?: InputMaybe<OrderBy>;\n  staking_pool_address?: InputMaybe<OrderBy>;\n  transaction_timestamp?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n  voter_address?: InputMaybe<OrderBy>;\n};\n\n/** primary key columns input for table: proposal_votes */\nexport type ProposalVotesPkColumnsInput = {\n  proposal_id: Scalars[\"bigint\"][\"input\"];\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n  voter_address: Scalars[\"String\"][\"input\"];\n};\n\n/** select columns of table \"proposal_votes\" */\nexport enum ProposalVotesSelectColumn {\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  NumVotes = \"num_votes\",\n  /** column name */\n  ProposalId = \"proposal_id\",\n  /** column name */\n  ShouldPass = \"should_pass\",\n  /** column name */\n  StakingPoolAddress = \"staking_pool_address\",\n  /** column name */\n  TransactionTimestamp = \"transaction_timestamp\",\n  /** column name */\n  TransactionVersion = \"transaction_version\",\n  /** column name */\n  VoterAddress = \"voter_address\",\n}\n\n/** input type for updating data in table \"proposal_votes\" */\nexport type ProposalVotesSetInput = {\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  num_votes?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  proposal_id?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  should_pass?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  staking_pool_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  voter_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate stddev on columns */\nexport type ProposalVotesStddevFields = {\n  num_votes?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  proposal_id?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_pop on columns */\nexport type ProposalVotesStddevPopFields = {\n  num_votes?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  proposal_id?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_samp on columns */\nexport type ProposalVotesStddevSampFields = {\n  num_votes?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  proposal_id?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Streaming cursor of the table \"proposal_votes\" */\nexport type ProposalVotesStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: ProposalVotesStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type ProposalVotesStreamCursorValueInput = {\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  num_votes?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  proposal_id?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  should_pass?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  staking_pool_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  voter_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate sum on columns */\nexport type ProposalVotesSumFields = {\n  num_votes?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  proposal_id?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** update columns of table \"proposal_votes\" */\nexport enum ProposalVotesUpdateColumn {\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  NumVotes = \"num_votes\",\n  /** column name */\n  ProposalId = \"proposal_id\",\n  /** column name */\n  ShouldPass = \"should_pass\",\n  /** column name */\n  StakingPoolAddress = \"staking_pool_address\",\n  /** column name */\n  TransactionTimestamp = \"transaction_timestamp\",\n  /** column name */\n  TransactionVersion = \"transaction_version\",\n  /** column name */\n  VoterAddress = \"voter_address\",\n}\n\nexport type ProposalVotesUpdates = {\n  /** increments the numeric columns with given value of the filtered values */\n  _inc?: InputMaybe<ProposalVotesIncInput>;\n  /** sets the columns of the filtered rows to the given values */\n  _set?: InputMaybe<ProposalVotesSetInput>;\n  /** filter the rows which have to be updated */\n  where: ProposalVotesBoolExp;\n};\n\n/** aggregate var_pop on columns */\nexport type ProposalVotesVarPopFields = {\n  num_votes?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  proposal_id?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate var_samp on columns */\nexport type ProposalVotesVarSampFields = {\n  num_votes?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  proposal_id?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate variance on columns */\nexport type ProposalVotesVarianceFields = {\n  num_votes?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  proposal_id?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** columns and relationships of \"public_key_auth_keys\" */\nexport type PublicKeyAuthKeys = {\n  account_public_key?: Maybe<Scalars[\"String\"][\"output\"]>;\n  auth_key: Scalars[\"String\"][\"output\"];\n  is_public_key_used: Scalars[\"Boolean\"][\"output\"];\n  last_transaction_version: Scalars[\"bigint\"][\"output\"];\n  public_key: Scalars[\"String\"][\"output\"];\n  public_key_type: Scalars[\"String\"][\"output\"];\n  signature_type: Scalars[\"String\"][\"output\"];\n};\n\n/** aggregated selection of \"public_key_auth_keys\" */\nexport type PublicKeyAuthKeysAggregate = {\n  aggregate?: Maybe<PublicKeyAuthKeysAggregateFields>;\n  nodes: Array<PublicKeyAuthKeys>;\n};\n\n/** aggregate fields of \"public_key_auth_keys\" */\nexport type PublicKeyAuthKeysAggregateFields = {\n  avg?: Maybe<PublicKeyAuthKeysAvgFields>;\n  count: Scalars[\"Int\"][\"output\"];\n  max?: Maybe<PublicKeyAuthKeysMaxFields>;\n  min?: Maybe<PublicKeyAuthKeysMinFields>;\n  stddev?: Maybe<PublicKeyAuthKeysStddevFields>;\n  stddev_pop?: Maybe<PublicKeyAuthKeysStddevPopFields>;\n  stddev_samp?: Maybe<PublicKeyAuthKeysStddevSampFields>;\n  sum?: Maybe<PublicKeyAuthKeysSumFields>;\n  var_pop?: Maybe<PublicKeyAuthKeysVarPopFields>;\n  var_samp?: Maybe<PublicKeyAuthKeysVarSampFields>;\n  variance?: Maybe<PublicKeyAuthKeysVarianceFields>;\n};\n\n/** aggregate fields of \"public_key_auth_keys\" */\nexport type PublicKeyAuthKeysAggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<PublicKeyAuthKeysSelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** aggregate avg on columns */\nexport type PublicKeyAuthKeysAvgFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Boolean expression to filter rows from the table \"public_key_auth_keys\". All fields are combined with a logical 'AND'. */\nexport type PublicKeyAuthKeysBoolExp = {\n  _and?: InputMaybe<Array<PublicKeyAuthKeysBoolExp>>;\n  _not?: InputMaybe<PublicKeyAuthKeysBoolExp>;\n  _or?: InputMaybe<Array<PublicKeyAuthKeysBoolExp>>;\n  account_public_key?: InputMaybe<StringComparisonExp>;\n  auth_key?: InputMaybe<StringComparisonExp>;\n  is_public_key_used?: InputMaybe<BooleanComparisonExp>;\n  last_transaction_version?: InputMaybe<BigintComparisonExp>;\n  public_key?: InputMaybe<StringComparisonExp>;\n  public_key_type?: InputMaybe<StringComparisonExp>;\n  signature_type?: InputMaybe<StringComparisonExp>;\n};\n\n/** unique or primary key constraints on table \"public_key_auth_keys\" */\nexport enum PublicKeyAuthKeysConstraint {\n  /** unique or primary key constraint on columns \"public_key_type\", \"auth_key\", \"public_key\" */\n  PublicKeyAuthKeysPkey = \"public_key_auth_keys_pkey\",\n}\n\n/** input type for incrementing numeric columns in table \"public_key_auth_keys\" */\nexport type PublicKeyAuthKeysIncInput = {\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** input type for inserting data into table \"public_key_auth_keys\" */\nexport type PublicKeyAuthKeysInsertInput = {\n  account_public_key?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  auth_key?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  is_public_key_used?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  public_key?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  public_key_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  signature_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate max on columns */\nexport type PublicKeyAuthKeysMaxFields = {\n  account_public_key?: Maybe<Scalars[\"String\"][\"output\"]>;\n  auth_key?: Maybe<Scalars[\"String\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  public_key?: Maybe<Scalars[\"String\"][\"output\"]>;\n  public_key_type?: Maybe<Scalars[\"String\"][\"output\"]>;\n  signature_type?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** aggregate min on columns */\nexport type PublicKeyAuthKeysMinFields = {\n  account_public_key?: Maybe<Scalars[\"String\"][\"output\"]>;\n  auth_key?: Maybe<Scalars[\"String\"][\"output\"]>;\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  public_key?: Maybe<Scalars[\"String\"][\"output\"]>;\n  public_key_type?: Maybe<Scalars[\"String\"][\"output\"]>;\n  signature_type?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** response of any mutation on the table \"public_key_auth_keys\" */\nexport type PublicKeyAuthKeysMutationResponse = {\n  /** number of rows affected by the mutation */\n  affected_rows: Scalars[\"Int\"][\"output\"];\n  /** data from the rows affected by the mutation */\n  returning: Array<PublicKeyAuthKeys>;\n};\n\n/** on_conflict condition type for table \"public_key_auth_keys\" */\nexport type PublicKeyAuthKeysOnConflict = {\n  constraint: PublicKeyAuthKeysConstraint;\n  update_columns?: Array<PublicKeyAuthKeysUpdateColumn>;\n  where?: InputMaybe<PublicKeyAuthKeysBoolExp>;\n};\n\n/** Ordering options when selecting data from \"public_key_auth_keys\". */\nexport type PublicKeyAuthKeysOrderBy = {\n  account_public_key?: InputMaybe<OrderBy>;\n  auth_key?: InputMaybe<OrderBy>;\n  is_public_key_used?: InputMaybe<OrderBy>;\n  last_transaction_version?: InputMaybe<OrderBy>;\n  public_key?: InputMaybe<OrderBy>;\n  public_key_type?: InputMaybe<OrderBy>;\n  signature_type?: InputMaybe<OrderBy>;\n};\n\n/** primary key columns input for table: public_key_auth_keys */\nexport type PublicKeyAuthKeysPkColumnsInput = {\n  auth_key: Scalars[\"String\"][\"input\"];\n  public_key: Scalars[\"String\"][\"input\"];\n  public_key_type: Scalars[\"String\"][\"input\"];\n};\n\n/** select columns of table \"public_key_auth_keys\" */\nexport enum PublicKeyAuthKeysSelectColumn {\n  /** column name */\n  AccountPublicKey = \"account_public_key\",\n  /** column name */\n  AuthKey = \"auth_key\",\n  /** column name */\n  IsPublicKeyUsed = \"is_public_key_used\",\n  /** column name */\n  LastTransactionVersion = \"last_transaction_version\",\n  /** column name */\n  PublicKey = \"public_key\",\n  /** column name */\n  PublicKeyType = \"public_key_type\",\n  /** column name */\n  SignatureType = \"signature_type\",\n}\n\n/** input type for updating data in table \"public_key_auth_keys\" */\nexport type PublicKeyAuthKeysSetInput = {\n  account_public_key?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  auth_key?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  is_public_key_used?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  public_key?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  public_key_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  signature_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate stddev on columns */\nexport type PublicKeyAuthKeysStddevFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_pop on columns */\nexport type PublicKeyAuthKeysStddevPopFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_samp on columns */\nexport type PublicKeyAuthKeysStddevSampFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Streaming cursor of the table \"public_key_auth_keys\" */\nexport type PublicKeyAuthKeysStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: PublicKeyAuthKeysStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type PublicKeyAuthKeysStreamCursorValueInput = {\n  account_public_key?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  auth_key?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  is_public_key_used?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  last_transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  public_key?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  public_key_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  signature_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate sum on columns */\nexport type PublicKeyAuthKeysSumFields = {\n  last_transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** update columns of table \"public_key_auth_keys\" */\nexport enum PublicKeyAuthKeysUpdateColumn {\n  /** column name */\n  AccountPublicKey = \"account_public_key\",\n  /** column name */\n  AuthKey = \"auth_key\",\n  /** column name */\n  IsPublicKeyUsed = \"is_public_key_used\",\n  /** column name */\n  LastTransactionVersion = \"last_transaction_version\",\n  /** column name */\n  PublicKey = \"public_key\",\n  /** column name */\n  PublicKeyType = \"public_key_type\",\n  /** column name */\n  SignatureType = \"signature_type\",\n}\n\nexport type PublicKeyAuthKeysUpdates = {\n  /** increments the numeric columns with given value of the filtered values */\n  _inc?: InputMaybe<PublicKeyAuthKeysIncInput>;\n  /** sets the columns of the filtered rows to the given values */\n  _set?: InputMaybe<PublicKeyAuthKeysSetInput>;\n  /** filter the rows which have to be updated */\n  where: PublicKeyAuthKeysBoolExp;\n};\n\n/** aggregate var_pop on columns */\nexport type PublicKeyAuthKeysVarPopFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate var_samp on columns */\nexport type PublicKeyAuthKeysVarSampFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate variance on columns */\nexport type PublicKeyAuthKeysVarianceFields = {\n  last_transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\nexport type QueryRoot = {\n  /** fetch data from the table: \"account_transactions\" */\n  account_transactions: Array<AccountTransactions>;\n  /** fetch aggregated fields from the table: \"account_transactions\" */\n  account_transactions_aggregate: AccountTransactionsAggregate;\n  /** fetch data from the table: \"account_transactions\" using primary key columns */\n  account_transactions_by_pk?: Maybe<AccountTransactions>;\n  /** fetch data from the table: \"address_events_summary\" */\n  address_events_summary: Array<AddressEventsSummary>;\n  /** fetch aggregated fields from the table: \"address_events_summary\" */\n  address_events_summary_aggregate: AddressEventsSummaryAggregate;\n  /** fetch data from the table: \"address_version_from_events\" */\n  address_version_from_events: Array<AddressVersionFromEvents>;\n  /** fetch aggregated fields from the table: \"address_version_from_events\" */\n  address_version_from_events_aggregate: AddressVersionFromEventsAggregate;\n  /** fetch data from the table: \"address_version_from_move_resources\" */\n  address_version_from_move_resources: Array<AddressVersionFromMoveResources>;\n  /** fetch aggregated fields from the table: \"address_version_from_move_resources\" */\n  address_version_from_move_resources_aggregate: AddressVersionFromMoveResourcesAggregate;\n  /** fetch data from the table: \"ans_lookup\" */\n  ans_lookup: Array<AnsLookup>;\n  /** fetch aggregated fields from the table: \"ans_lookup\" */\n  ans_lookup_aggregate: AnsLookupAggregate;\n  /** fetch data from the table: \"ans_lookup\" using primary key columns */\n  ans_lookup_by_pk?: Maybe<AnsLookup>;\n  /** fetch data from the table: \"ans_lookup_v2\" */\n  ans_lookup_v2: Array<AnsLookupV2>;\n  /** fetch aggregated fields from the table: \"ans_lookup_v2\" */\n  ans_lookup_v2_aggregate: AnsLookupV2Aggregate;\n  /** fetch data from the table: \"ans_lookup_v2\" using primary key columns */\n  ans_lookup_v2_by_pk?: Maybe<AnsLookupV2>;\n  /** fetch data from the table: \"ans_primary_name\" */\n  ans_primary_name: Array<AnsPrimaryName>;\n  /** fetch aggregated fields from the table: \"ans_primary_name\" */\n  ans_primary_name_aggregate: AnsPrimaryNameAggregate;\n  /** fetch data from the table: \"ans_primary_name\" using primary key columns */\n  ans_primary_name_by_pk?: Maybe<AnsPrimaryName>;\n  /** fetch data from the table: \"ans_primary_name_v2\" */\n  ans_primary_name_v2: Array<AnsPrimaryNameV2>;\n  /** fetch aggregated fields from the table: \"ans_primary_name_v2\" */\n  ans_primary_name_v2_aggregate: AnsPrimaryNameV2Aggregate;\n  /** fetch data from the table: \"ans_primary_name_v2\" using primary key columns */\n  ans_primary_name_v2_by_pk?: Maybe<AnsPrimaryNameV2>;\n  /** fetch data from the table: \"auth_key_account_addresses\" */\n  auth_key_account_addresses: Array<AuthKeyAccountAddresses>;\n  /** fetch aggregated fields from the table: \"auth_key_account_addresses\" */\n  auth_key_account_addresses_aggregate: AuthKeyAccountAddressesAggregate;\n  /** fetch data from the table: \"auth_key_account_addresses\" using primary key columns */\n  auth_key_account_addresses_by_pk?: Maybe<AuthKeyAccountAddresses>;\n  /** fetch data from the table: \"block_metadata_transactions\" */\n  block_metadata_transactions: Array<BlockMetadataTransactions>;\n  /** fetch aggregated fields from the table: \"block_metadata_transactions\" */\n  block_metadata_transactions_aggregate: BlockMetadataTransactionsAggregate;\n  /** fetch data from the table: \"block_metadata_transactions\" using primary key columns */\n  block_metadata_transactions_by_pk?: Maybe<BlockMetadataTransactions>;\n  /** fetch data from the table: \"coin_activities\" */\n  coin_activities: Array<CoinActivities>;\n  /** fetch aggregated fields from the table: \"coin_activities\" */\n  coin_activities_aggregate: CoinActivitiesAggregate;\n  /** fetch data from the table: \"coin_activities\" using primary key columns */\n  coin_activities_by_pk?: Maybe<CoinActivities>;\n  /** fetch data from the table: \"coin_balances\" */\n  coin_balances: Array<CoinBalances>;\n  /** fetch aggregated fields from the table: \"coin_balances\" */\n  coin_balances_aggregate: CoinBalancesAggregate;\n  /** fetch data from the table: \"coin_balances\" using primary key columns */\n  coin_balances_by_pk?: Maybe<CoinBalances>;\n  /** fetch data from the table: \"coin_infos\" */\n  coin_infos: Array<CoinInfos>;\n  /** fetch aggregated fields from the table: \"coin_infos\" */\n  coin_infos_aggregate: CoinInfosAggregate;\n  /** fetch data from the table: \"coin_infos\" using primary key columns */\n  coin_infos_by_pk?: Maybe<CoinInfos>;\n  /** fetch data from the table: \"coin_supply\" */\n  coin_supply: Array<CoinSupply>;\n  /** fetch aggregated fields from the table: \"coin_supply\" */\n  coin_supply_aggregate: CoinSupplyAggregate;\n  /** fetch data from the table: \"coin_supply\" using primary key columns */\n  coin_supply_by_pk?: Maybe<CoinSupply>;\n  /** fetch data from the table: \"collection_datas\" */\n  collection_datas: Array<CollectionDatas>;\n  /** fetch aggregated fields from the table: \"collection_datas\" */\n  collection_datas_aggregate: CollectionDatasAggregate;\n  /** fetch data from the table: \"collection_datas\" using primary key columns */\n  collection_datas_by_pk?: Maybe<CollectionDatas>;\n  /** fetch data from the table: \"collections_v2\" */\n  collections_v2: Array<CollectionsV2>;\n  /** fetch aggregated fields from the table: \"collections_v2\" */\n  collections_v2_aggregate: CollectionsV2Aggregate;\n  /** fetch data from the table: \"collections_v2\" using primary key columns */\n  collections_v2_by_pk?: Maybe<CollectionsV2>;\n  /** fetch data from the table: \"current_ans_lookup\" */\n  current_ans_lookup: Array<CurrentAnsLookup>;\n  /** fetch aggregated fields from the table: \"current_ans_lookup\" */\n  current_ans_lookup_aggregate: CurrentAnsLookupAggregate;\n  /** fetch data from the table: \"current_ans_lookup\" using primary key columns */\n  current_ans_lookup_by_pk?: Maybe<CurrentAnsLookup>;\n  /** fetch data from the table: \"current_ans_lookup_v2\" */\n  current_ans_lookup_v2: Array<CurrentAnsLookupV2>;\n  /** fetch aggregated fields from the table: \"current_ans_lookup_v2\" */\n  current_ans_lookup_v2_aggregate: CurrentAnsLookupV2Aggregate;\n  /** fetch data from the table: \"current_ans_lookup_v2\" using primary key columns */\n  current_ans_lookup_v2_by_pk?: Maybe<CurrentAnsLookupV2>;\n  /** fetch data from the table: \"current_ans_primary_name\" */\n  current_ans_primary_name: Array<CurrentAnsPrimaryName>;\n  /** fetch aggregated fields from the table: \"current_ans_primary_name\" */\n  current_ans_primary_name_aggregate: CurrentAnsPrimaryNameAggregate;\n  /** fetch data from the table: \"current_ans_primary_name\" using primary key columns */\n  current_ans_primary_name_by_pk?: Maybe<CurrentAnsPrimaryName>;\n  /** fetch data from the table: \"current_ans_primary_name_v2\" */\n  current_ans_primary_name_v2: Array<CurrentAnsPrimaryNameV2>;\n  /** fetch aggregated fields from the table: \"current_ans_primary_name_v2\" */\n  current_ans_primary_name_v2_aggregate: CurrentAnsPrimaryNameV2Aggregate;\n  /** fetch data from the table: \"current_ans_primary_name_v2\" using primary key columns */\n  current_ans_primary_name_v2_by_pk?: Maybe<CurrentAnsPrimaryNameV2>;\n  /** fetch data from the table: \"current_cedra_names\" */\n  current_cedra_names: Array<CurrentCedraNames>;\n  /** fetch aggregated fields from the table: \"current_cedra_names\" */\n  current_cedra_names_aggregate: CurrentCedraNamesAggregate;\n  /** fetch data from the table: \"current_coin_balances\" */\n  current_coin_balances: Array<CurrentCoinBalances>;\n  /** fetch aggregated fields from the table: \"current_coin_balances\" */\n  current_coin_balances_aggregate: CurrentCoinBalancesAggregate;\n  /** fetch data from the table: \"current_coin_balances\" using primary key columns */\n  current_coin_balances_by_pk?: Maybe<CurrentCoinBalances>;\n  /** fetch data from the table: \"current_collection_datas\" */\n  current_collection_datas: Array<CurrentCollectionDatas>;\n  /** fetch aggregated fields from the table: \"current_collection_datas\" */\n  current_collection_datas_aggregate: CurrentCollectionDatasAggregate;\n  /** fetch data from the table: \"current_collection_datas\" using primary key columns */\n  current_collection_datas_by_pk?: Maybe<CurrentCollectionDatas>;\n  /** fetch data from the table: \"current_collection_ownership_v2_view\" */\n  current_collection_ownership_v2_view: Array<CurrentCollectionOwnershipV2View>;\n  /** fetch aggregated fields from the table: \"current_collection_ownership_v2_view\" */\n  current_collection_ownership_v2_view_aggregate: CurrentCollectionOwnershipV2ViewAggregate;\n  /** fetch data from the table: \"current_collection_ownership_view\" */\n  current_collection_ownership_view: Array<CurrentCollectionOwnershipView>;\n  /** fetch aggregated fields from the table: \"current_collection_ownership_view\" */\n  current_collection_ownership_view_aggregate: CurrentCollectionOwnershipViewAggregate;\n  /** fetch data from the table: \"current_collections_v2\" */\n  current_collections_v2: Array<CurrentCollectionsV2>;\n  /** fetch aggregated fields from the table: \"current_collections_v2\" */\n  current_collections_v2_aggregate: CurrentCollectionsV2Aggregate;\n  /** fetch data from the table: \"current_collections_v2\" using primary key columns */\n  current_collections_v2_by_pk?: Maybe<CurrentCollectionsV2>;\n  /** fetch data from the table: \"current_delegated_staking_pool_balances\" */\n  current_delegated_staking_pool_balances: Array<CurrentDelegatedStakingPoolBalances>;\n  /** fetch aggregated fields from the table: \"current_delegated_staking_pool_balances\" */\n  current_delegated_staking_pool_balances_aggregate: CurrentDelegatedStakingPoolBalancesAggregate;\n  /** fetch data from the table: \"current_delegated_staking_pool_balances\" using primary key columns */\n  current_delegated_staking_pool_balances_by_pk?: Maybe<CurrentDelegatedStakingPoolBalances>;\n  /** fetch data from the table: \"current_delegated_voter\" */\n  current_delegated_voter: Array<CurrentDelegatedVoter>;\n  /** fetch aggregated fields from the table: \"current_delegated_voter\" */\n  current_delegated_voter_aggregate: CurrentDelegatedVoterAggregate;\n  /** fetch data from the table: \"current_delegated_voter\" using primary key columns */\n  current_delegated_voter_by_pk?: Maybe<CurrentDelegatedVoter>;\n  /** fetch data from the table: \"current_delegator_balances\" */\n  current_delegator_balances: Array<CurrentDelegatorBalances>;\n  /** fetch aggregated fields from the table: \"current_delegator_balances\" */\n  current_delegator_balances_aggregate: CurrentDelegatorBalancesAggregate;\n  /** fetch data from the table: \"current_delegator_balances\" using primary key columns */\n  current_delegator_balances_by_pk?: Maybe<CurrentDelegatorBalances>;\n  /** fetch data from the table: \"current_fungible_asset_balances_legacy\" */\n  current_fungible_asset_balances: Array<CurrentFungibleAssetBalances>;\n  /** fetch aggregated fields from the table: \"current_fungible_asset_balances_legacy\" */\n  current_fungible_asset_balances_aggregate: CurrentFungibleAssetBalancesAggregate;\n  /** fetch data from the table: \"current_fungible_asset_balances_legacy\" using primary key columns */\n  current_fungible_asset_balances_by_pk?: Maybe<CurrentFungibleAssetBalances>;\n  /** fetch data from the table: \"current_fungible_asset_balances\" */\n  current_fungible_asset_balances_new: Array<CurrentFungibleAssetBalancesNew>;\n  /** fetch aggregated fields from the table: \"current_fungible_asset_balances\" */\n  current_fungible_asset_balances_new_aggregate: CurrentFungibleAssetBalancesNewAggregate;\n  /** fetch data from the table: \"current_fungible_asset_balances\" using primary key columns */\n  current_fungible_asset_balances_new_by_pk?: Maybe<CurrentFungibleAssetBalancesNew>;\n  /** fetch data from the table: \"current_objects\" */\n  current_objects: Array<CurrentObjects>;\n  /** fetch aggregated fields from the table: \"current_objects\" */\n  current_objects_aggregate: CurrentObjectsAggregate;\n  /** fetch data from the table: \"current_objects\" using primary key columns */\n  current_objects_by_pk?: Maybe<CurrentObjects>;\n  /** fetch data from the table: \"current_staking_pool_voter\" */\n  current_staking_pool_voter: Array<CurrentStakingPoolVoter>;\n  /** fetch aggregated fields from the table: \"current_staking_pool_voter\" */\n  current_staking_pool_voter_aggregate: CurrentStakingPoolVoterAggregate;\n  /** fetch data from the table: \"current_staking_pool_voter\" using primary key columns */\n  current_staking_pool_voter_by_pk?: Maybe<CurrentStakingPoolVoter>;\n  /** fetch data from the table: \"current_table_items\" */\n  current_table_items: Array<CurrentTableItems>;\n  /** fetch aggregated fields from the table: \"current_table_items\" */\n  current_table_items_aggregate: CurrentTableItemsAggregate;\n  /** fetch data from the table: \"current_table_items\" using primary key columns */\n  current_table_items_by_pk?: Maybe<CurrentTableItems>;\n  /** fetch data from the table: \"current_table_items_view\" */\n  current_table_items_view: Array<CurrentTableItemsView>;\n  /** fetch aggregated fields from the table: \"current_table_items_view\" */\n  current_table_items_view_aggregate: CurrentTableItemsViewAggregate;\n  /** fetch data from the table: \"current_token_datas\" */\n  current_token_datas: Array<CurrentTokenDatas>;\n  /** fetch aggregated fields from the table: \"current_token_datas\" */\n  current_token_datas_aggregate: CurrentTokenDatasAggregate;\n  /** fetch data from the table: \"current_token_datas\" using primary key columns */\n  current_token_datas_by_pk?: Maybe<CurrentTokenDatas>;\n  /** fetch data from the table: \"current_token_datas_v2\" */\n  current_token_datas_v2: Array<CurrentTokenDatasV2>;\n  /** fetch aggregated fields from the table: \"current_token_datas_v2\" */\n  current_token_datas_v2_aggregate: CurrentTokenDatasV2Aggregate;\n  /** fetch data from the table: \"current_token_datas_v2\" using primary key columns */\n  current_token_datas_v2_by_pk?: Maybe<CurrentTokenDatasV2>;\n  /** fetch data from the table: \"current_token_ownerships\" */\n  current_token_ownerships: Array<CurrentTokenOwnerships>;\n  /** fetch aggregated fields from the table: \"current_token_ownerships\" */\n  current_token_ownerships_aggregate: CurrentTokenOwnershipsAggregate;\n  /** fetch data from the table: \"current_token_ownerships\" using primary key columns */\n  current_token_ownerships_by_pk?: Maybe<CurrentTokenOwnerships>;\n  /** fetch data from the table: \"current_token_ownerships_v2\" */\n  current_token_ownerships_v2: Array<CurrentTokenOwnershipsV2>;\n  /** fetch aggregated fields from the table: \"current_token_ownerships_v2\" */\n  current_token_ownerships_v2_aggregate: CurrentTokenOwnershipsV2Aggregate;\n  /** fetch data from the table: \"current_token_ownerships_v2\" using primary key columns */\n  current_token_ownerships_v2_by_pk?: Maybe<CurrentTokenOwnershipsV2>;\n  /** fetch data from the table: \"current_token_pending_claims\" */\n  current_token_pending_claims: Array<CurrentTokenPendingClaims>;\n  /** fetch aggregated fields from the table: \"current_token_pending_claims\" */\n  current_token_pending_claims_aggregate: CurrentTokenPendingClaimsAggregate;\n  /** fetch data from the table: \"current_token_pending_claims\" using primary key columns */\n  current_token_pending_claims_by_pk?: Maybe<CurrentTokenPendingClaims>;\n  /** fetch data from the table: \"current_token_royalty_v1\" */\n  current_token_royalty_v1: Array<CurrentTokenRoyaltyV1>;\n  /** fetch aggregated fields from the table: \"current_token_royalty_v1\" */\n  current_token_royalty_v1_aggregate: CurrentTokenRoyaltyV1Aggregate;\n  /** fetch data from the table: \"current_token_royalty_v1\" using primary key columns */\n  current_token_royalty_v1_by_pk?: Maybe<CurrentTokenRoyaltyV1>;\n  /** fetch data from the table: \"current_token_v2_metadata\" */\n  current_token_v2_metadata: Array<CurrentTokenV2Metadata>;\n  /** fetch aggregated fields from the table: \"current_token_v2_metadata\" */\n  current_token_v2_metadata_aggregate: CurrentTokenV2MetadataAggregate;\n  /** fetch data from the table: \"current_token_v2_metadata\" using primary key columns */\n  current_token_v2_metadata_by_pk?: Maybe<CurrentTokenV2Metadata>;\n  /** fetch data from the table: \"delegated_staking_activities\" */\n  delegated_staking_activities: Array<DelegatedStakingActivities>;\n  /** fetch aggregated fields from the table: \"delegated_staking_activities\" */\n  delegated_staking_activities_aggregate: DelegatedStakingActivitiesAggregate;\n  /** fetch data from the table: \"delegated_staking_activities\" using primary key columns */\n  delegated_staking_activities_by_pk?: Maybe<DelegatedStakingActivities>;\n  /** fetch data from the table: \"delegated_staking_pool_balances\" */\n  delegated_staking_pool_balances: Array<DelegatedStakingPoolBalances>;\n  /** fetch aggregated fields from the table: \"delegated_staking_pool_balances\" */\n  delegated_staking_pool_balances_aggregate: DelegatedStakingPoolBalancesAggregate;\n  /** fetch data from the table: \"delegated_staking_pool_balances\" using primary key columns */\n  delegated_staking_pool_balances_by_pk?: Maybe<DelegatedStakingPoolBalances>;\n  /** fetch data from the table: \"delegated_staking_pools\" */\n  delegated_staking_pools: Array<DelegatedStakingPools>;\n  /** fetch aggregated fields from the table: \"delegated_staking_pools\" */\n  delegated_staking_pools_aggregate: DelegatedStakingPoolsAggregate;\n  /** fetch data from the table: \"delegated_staking_pools\" using primary key columns */\n  delegated_staking_pools_by_pk?: Maybe<DelegatedStakingPools>;\n  /** fetch data from the table: \"delegator_balances\" */\n  delegator_balances: Array<DelegatorBalances>;\n  /** fetch aggregated fields from the table: \"delegator_balances\" */\n  delegator_balances_aggregate: DelegatorBalancesAggregate;\n  /** fetch data from the table: \"delegator_balances\" using primary key columns */\n  delegator_balances_by_pk?: Maybe<DelegatorBalances>;\n  /** fetch data from the table: \"delegator_distinct_pool\" */\n  delegator_distinct_pool: Array<DelegatorDistinctPool>;\n  /** fetch aggregated fields from the table: \"delegator_distinct_pool\" */\n  delegator_distinct_pool_aggregate: DelegatorDistinctPoolAggregate;\n  /** fetch data from the table: \"event_size_info\" */\n  event_size_info: Array<EventSizeInfo>;\n  /** fetch aggregated fields from the table: \"event_size_info\" */\n  event_size_info_aggregate: EventSizeInfoAggregate;\n  /** fetch data from the table: \"event_size_info\" using primary key columns */\n  event_size_info_by_pk?: Maybe<EventSizeInfo>;\n  /** fetch data from the table: \"events\" */\n  events: Array<Events>;\n  /** fetch aggregated fields from the table: \"events\" */\n  events_aggregate: EventsAggregate;\n  /** fetch data from the table: \"events\" using primary key columns */\n  events_by_pk?: Maybe<Events>;\n  /** fetch data from the table: \"events_view\" */\n  events_view: Array<EventsView>;\n  /** fetch aggregated fields from the table: \"events_view\" */\n  events_view_aggregate: EventsViewAggregate;\n  /** fetch data from the table: \"fungible_asset_activities\" */\n  fungible_asset_activities: Array<FungibleAssetActivities>;\n  /** fetch aggregated fields from the table: \"fungible_asset_activities\" */\n  fungible_asset_activities_aggregate: FungibleAssetActivitiesAggregate;\n  /** fetch data from the table: \"fungible_asset_activities\" using primary key columns */\n  fungible_asset_activities_by_pk?: Maybe<FungibleAssetActivities>;\n  /** fetch data from the table: \"fungible_asset_balances\" */\n  fungible_asset_balances: Array<FungibleAssetBalances>;\n  /** fetch aggregated fields from the table: \"fungible_asset_balances\" */\n  fungible_asset_balances_aggregate: FungibleAssetBalancesAggregate;\n  /** fetch data from the table: \"fungible_asset_balances\" using primary key columns */\n  fungible_asset_balances_by_pk?: Maybe<FungibleAssetBalances>;\n  /** fetch data from the table: \"fungible_asset_metadata\" */\n  fungible_asset_metadata: Array<FungibleAssetMetadata>;\n  /** fetch aggregated fields from the table: \"fungible_asset_metadata\" */\n  fungible_asset_metadata_aggregate: FungibleAssetMetadataAggregate;\n  /** fetch data from the table: \"fungible_asset_metadata\" using primary key columns */\n  fungible_asset_metadata_by_pk?: Maybe<FungibleAssetMetadata>;\n  /** fetch data from the table: \"fungible_asset_to_coin_mappings\" */\n  fungible_asset_to_coin_mappings: Array<FungibleAssetToCoinMappings>;\n  /** fetch aggregated fields from the table: \"fungible_asset_to_coin_mappings\" */\n  fungible_asset_to_coin_mappings_aggregate: FungibleAssetToCoinMappingsAggregate;\n  /** fetch data from the table: \"fungible_asset_to_coin_mappings\" using primary key columns */\n  fungible_asset_to_coin_mappings_by_pk?: Maybe<FungibleAssetToCoinMappings>;\n  /** fetch data from the table: \"gas_fees\" */\n  gas_fees: Array<GasFees>;\n  /** fetch aggregated fields from the table: \"gas_fees\" */\n  gas_fees_aggregate: GasFeesAggregate;\n  /** fetch data from the table: \"gas_fees\" using primary key columns */\n  gas_fees_by_pk?: Maybe<GasFees>;\n  /** fetch data from the table: \"indexer_status\" */\n  indexer_status: Array<IndexerStatus>;\n  /** fetch aggregated fields from the table: \"indexer_status\" */\n  indexer_status_aggregate: IndexerStatusAggregate;\n  /** fetch data from the table: \"indexer_status\" using primary key columns */\n  indexer_status_by_pk?: Maybe<IndexerStatus>;\n  /** fetch data from the table: \"move_modules\" */\n  move_modules: Array<MoveModules>;\n  /** fetch aggregated fields from the table: \"move_modules\" */\n  move_modules_aggregate: MoveModulesAggregate;\n  /** fetch data from the table: \"move_modules\" using primary key columns */\n  move_modules_by_pk?: Maybe<MoveModules>;\n  /** fetch data from the table: \"move_resources\" */\n  move_resources: Array<MoveResources>;\n  /** fetch aggregated fields from the table: \"move_resources\" */\n  move_resources_aggregate: MoveResourcesAggregate;\n  /** fetch data from the table: \"move_resources\" using primary key columns */\n  move_resources_by_pk?: Maybe<MoveResources>;\n  /** fetch data from the table: \"move_resources_view\" */\n  move_resources_view: Array<MoveResourcesView>;\n  /** fetch aggregated fields from the table: \"move_resources_view\" */\n  move_resources_view_aggregate: MoveResourcesViewAggregate;\n  /** fetch data from the table: \"nft_metadata_crawler.parsed_asset_uris\" */\n  nft_metadata_crawler_parsed_asset_uris: Array<NftMetadataCrawlerParsedAssetUris>;\n  /** fetch aggregated fields from the table: \"nft_metadata_crawler.parsed_asset_uris\" */\n  nft_metadata_crawler_parsed_asset_uris_aggregate: NftMetadataCrawlerParsedAssetUrisAggregate;\n  /** fetch data from the table: \"nft_metadata_crawler.parsed_asset_uris\" using primary key columns */\n  nft_metadata_crawler_parsed_asset_uris_by_pk?: Maybe<NftMetadataCrawlerParsedAssetUris>;\n  /** fetch data from the table: \"nft_points\" */\n  nft_points: Array<NftPoints>;\n  /** fetch aggregated fields from the table: \"nft_points\" */\n  nft_points_aggregate: NftPointsAggregate;\n  /** fetch data from the table: \"nft_points\" using primary key columns */\n  nft_points_by_pk?: Maybe<NftPoints>;\n  /** fetch data from the table: \"num_active_delegator_per_pool\" */\n  num_active_delegator_per_pool: Array<NumActiveDelegatorPerPool>;\n  /** fetch aggregated fields from the table: \"num_active_delegator_per_pool\" */\n  num_active_delegator_per_pool_aggregate: NumActiveDelegatorPerPoolAggregate;\n  /** fetch data from the table: \"objects\" */\n  objects: Array<Objects>;\n  /** fetch aggregated fields from the table: \"objects\" */\n  objects_aggregate: ObjectsAggregate;\n  /** fetch data from the table: \"objects\" using primary key columns */\n  objects_by_pk?: Maybe<Objects>;\n  /** fetch data from the table: \"processor_metadata.processor_status\" */\n  processor_metadata_processor_status: Array<ProcessorMetadataProcessorStatus>;\n  /** fetch aggregated fields from the table: \"processor_metadata.processor_status\" */\n  processor_metadata_processor_status_aggregate: ProcessorMetadataProcessorStatusAggregate;\n  /** fetch data from the table: \"processor_metadata.processor_status\" using primary key columns */\n  processor_metadata_processor_status_by_pk?: Maybe<ProcessorMetadataProcessorStatus>;\n  /** fetch data from the table: \"processor_status\" */\n  processor_status: Array<ProcessorStatus>;\n  /** fetch aggregated fields from the table: \"processor_status\" */\n  processor_status_aggregate: ProcessorStatusAggregate;\n  /** fetch data from the table: \"processor_status\" using primary key columns */\n  processor_status_by_pk?: Maybe<ProcessorStatus>;\n  /** fetch data from the table: \"proposal_votes\" */\n  proposal_votes: Array<ProposalVotes>;\n  /** fetch aggregated fields from the table: \"proposal_votes\" */\n  proposal_votes_aggregate: ProposalVotesAggregate;\n  /** fetch data from the table: \"proposal_votes\" using primary key columns */\n  proposal_votes_by_pk?: Maybe<ProposalVotes>;\n  /** fetch data from the table: \"public_key_auth_keys\" */\n  public_key_auth_keys: Array<PublicKeyAuthKeys>;\n  /** fetch aggregated fields from the table: \"public_key_auth_keys\" */\n  public_key_auth_keys_aggregate: PublicKeyAuthKeysAggregate;\n  /** fetch data from the table: \"public_key_auth_keys\" using primary key columns */\n  public_key_auth_keys_by_pk?: Maybe<PublicKeyAuthKeys>;\n  /** fetch data from the table: \"signatures\" */\n  signatures: Array<Signatures>;\n  /** fetch aggregated fields from the table: \"signatures\" */\n  signatures_aggregate: SignaturesAggregate;\n  /** fetch data from the table: \"signatures\" using primary key columns */\n  signatures_by_pk?: Maybe<Signatures>;\n  /** fetch data from the table: \"spam_assets\" */\n  spam_assets: Array<SpamAssets>;\n  /** fetch aggregated fields from the table: \"spam_assets\" */\n  spam_assets_aggregate: SpamAssetsAggregate;\n  /** fetch data from the table: \"spam_assets\" using primary key columns */\n  spam_assets_by_pk?: Maybe<SpamAssets>;\n  /** fetch data from the table: \"table_items\" */\n  table_items: Array<TableItems>;\n  /** fetch aggregated fields from the table: \"table_items\" */\n  table_items_aggregate: TableItemsAggregate;\n  /** fetch data from the table: \"table_items\" using primary key columns */\n  table_items_by_pk?: Maybe<TableItems>;\n  /** fetch data from the table: \"table_items_view\" */\n  table_items_view: Array<TableItemsView>;\n  /** fetch aggregated fields from the table: \"table_items_view\" */\n  table_items_view_aggregate: TableItemsViewAggregate;\n  /** fetch data from the table: \"table_metadatas\" */\n  table_metadatas: Array<TableMetadatas>;\n  /** fetch aggregated fields from the table: \"table_metadatas\" */\n  table_metadatas_aggregate: TableMetadatasAggregate;\n  /** fetch data from the table: \"table_metadatas\" using primary key columns */\n  table_metadatas_by_pk?: Maybe<TableMetadatas>;\n  /** fetch data from the table: \"token_activities\" */\n  token_activities: Array<TokenActivities>;\n  /** fetch aggregated fields from the table: \"token_activities\" */\n  token_activities_aggregate: TokenActivitiesAggregate;\n  /** fetch data from the table: \"token_activities\" using primary key columns */\n  token_activities_by_pk?: Maybe<TokenActivities>;\n  /** fetch data from the table: \"token_activities_v2\" */\n  token_activities_v2: Array<TokenActivitiesV2>;\n  /** fetch aggregated fields from the table: \"token_activities_v2\" */\n  token_activities_v2_aggregate: TokenActivitiesV2Aggregate;\n  /** fetch data from the table: \"token_activities_v2\" using primary key columns */\n  token_activities_v2_by_pk?: Maybe<TokenActivitiesV2>;\n  /** fetch data from the table: \"token_datas\" */\n  token_datas: Array<TokenDatas>;\n  /** fetch aggregated fields from the table: \"token_datas\" */\n  token_datas_aggregate: TokenDatasAggregate;\n  /** fetch data from the table: \"token_datas\" using primary key columns */\n  token_datas_by_pk?: Maybe<TokenDatas>;\n  /** fetch data from the table: \"token_datas_v2\" */\n  token_datas_v2: Array<TokenDatasV2>;\n  /** fetch aggregated fields from the table: \"token_datas_v2\" */\n  token_datas_v2_aggregate: TokenDatasV2Aggregate;\n  /** fetch data from the table: \"token_datas_v2\" using primary key columns */\n  token_datas_v2_by_pk?: Maybe<TokenDatasV2>;\n  /** fetch data from the table: \"token_ownerships\" */\n  token_ownerships: Array<TokenOwnerships>;\n  /** fetch aggregated fields from the table: \"token_ownerships\" */\n  token_ownerships_aggregate: TokenOwnershipsAggregate;\n  /** fetch data from the table: \"token_ownerships\" using primary key columns */\n  token_ownerships_by_pk?: Maybe<TokenOwnerships>;\n  /** fetch data from the table: \"token_ownerships_v2\" */\n  token_ownerships_v2: Array<TokenOwnershipsV2>;\n  /** fetch aggregated fields from the table: \"token_ownerships_v2\" */\n  token_ownerships_v2_aggregate: TokenOwnershipsV2Aggregate;\n  /** fetch data from the table: \"token_ownerships_v2\" using primary key columns */\n  token_ownerships_v2_by_pk?: Maybe<TokenOwnershipsV2>;\n  /** fetch data from the table: \"tokens\" */\n  tokens: Array<Tokens>;\n  /** fetch aggregated fields from the table: \"tokens\" */\n  tokens_aggregate: TokensAggregate;\n  /** fetch data from the table: \"tokens\" using primary key columns */\n  tokens_by_pk?: Maybe<Tokens>;\n  /** fetch data from the table: \"transaction_size_info\" */\n  transaction_size_info: Array<TransactionSizeInfo>;\n  /** fetch aggregated fields from the table: \"transaction_size_info\" */\n  transaction_size_info_aggregate: TransactionSizeInfoAggregate;\n  /** fetch data from the table: \"transaction_size_info\" using primary key columns */\n  transaction_size_info_by_pk?: Maybe<TransactionSizeInfo>;\n  /** fetch data from the table: \"transactions_view\" */\n  transactions_view: Array<TransactionsView>;\n  /** fetch aggregated fields from the table: \"transactions_view\" */\n  transactions_view_aggregate: TransactionsViewAggregate;\n  /** fetch data from the table: \"user_transactions\" */\n  user_transactions: Array<UserTransactions>;\n  /** fetch aggregated fields from the table: \"user_transactions\" */\n  user_transactions_aggregate: UserTransactionsAggregate;\n  /** fetch data from the table: \"user_transactions\" using primary key columns */\n  user_transactions_by_pk?: Maybe<UserTransactions>;\n};\n\nexport type QueryRootAccountTransactionsArgs = {\n  distinct_on?: InputMaybe<Array<AccountTransactionsSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<AccountTransactionsOrderBy>>;\n  where?: InputMaybe<AccountTransactionsBoolExp>;\n};\n\nexport type QueryRootAccountTransactionsAggregateArgs = {\n  distinct_on?: InputMaybe<Array<AccountTransactionsSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<AccountTransactionsOrderBy>>;\n  where?: InputMaybe<AccountTransactionsBoolExp>;\n};\n\nexport type QueryRootAccountTransactionsByPkArgs = {\n  account_address: Scalars[\"String\"][\"input\"];\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\nexport type QueryRootAddressEventsSummaryArgs = {\n  distinct_on?: InputMaybe<Array<AddressEventsSummarySelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<AddressEventsSummaryOrderBy>>;\n  where?: InputMaybe<AddressEventsSummaryBoolExp>;\n};\n\nexport type QueryRootAddressEventsSummaryAggregateArgs = {\n  distinct_on?: InputMaybe<Array<AddressEventsSummarySelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<AddressEventsSummaryOrderBy>>;\n  where?: InputMaybe<AddressEventsSummaryBoolExp>;\n};\n\nexport type QueryRootAddressVersionFromEventsArgs = {\n  distinct_on?: InputMaybe<Array<AddressVersionFromEventsSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<AddressVersionFromEventsOrderBy>>;\n  where?: InputMaybe<AddressVersionFromEventsBoolExp>;\n};\n\nexport type QueryRootAddressVersionFromEventsAggregateArgs = {\n  distinct_on?: InputMaybe<Array<AddressVersionFromEventsSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<AddressVersionFromEventsOrderBy>>;\n  where?: InputMaybe<AddressVersionFromEventsBoolExp>;\n};\n\nexport type QueryRootAddressVersionFromMoveResourcesArgs = {\n  distinct_on?: InputMaybe<Array<AddressVersionFromMoveResourcesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<AddressVersionFromMoveResourcesOrderBy>>;\n  where?: InputMaybe<AddressVersionFromMoveResourcesBoolExp>;\n};\n\nexport type QueryRootAddressVersionFromMoveResourcesAggregateArgs = {\n  distinct_on?: InputMaybe<Array<AddressVersionFromMoveResourcesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<AddressVersionFromMoveResourcesOrderBy>>;\n  where?: InputMaybe<AddressVersionFromMoveResourcesBoolExp>;\n};\n\nexport type QueryRootAnsLookupArgs = {\n  distinct_on?: InputMaybe<Array<AnsLookupSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<AnsLookupOrderBy>>;\n  where?: InputMaybe<AnsLookupBoolExp>;\n};\n\nexport type QueryRootAnsLookupAggregateArgs = {\n  distinct_on?: InputMaybe<Array<AnsLookupSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<AnsLookupOrderBy>>;\n  where?: InputMaybe<AnsLookupBoolExp>;\n};\n\nexport type QueryRootAnsLookupByPkArgs = {\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n  write_set_change_index: Scalars[\"bigint\"][\"input\"];\n};\n\nexport type QueryRootAnsLookupV2Args = {\n  distinct_on?: InputMaybe<Array<AnsLookupV2SelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<AnsLookupV2OrderBy>>;\n  where?: InputMaybe<AnsLookupV2BoolExp>;\n};\n\nexport type QueryRootAnsLookupV2AggregateArgs = {\n  distinct_on?: InputMaybe<Array<AnsLookupV2SelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<AnsLookupV2OrderBy>>;\n  where?: InputMaybe<AnsLookupV2BoolExp>;\n};\n\nexport type QueryRootAnsLookupV2ByPkArgs = {\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n  write_set_change_index: Scalars[\"bigint\"][\"input\"];\n};\n\nexport type QueryRootAnsPrimaryNameArgs = {\n  distinct_on?: InputMaybe<Array<AnsPrimaryNameSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<AnsPrimaryNameOrderBy>>;\n  where?: InputMaybe<AnsPrimaryNameBoolExp>;\n};\n\nexport type QueryRootAnsPrimaryNameAggregateArgs = {\n  distinct_on?: InputMaybe<Array<AnsPrimaryNameSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<AnsPrimaryNameOrderBy>>;\n  where?: InputMaybe<AnsPrimaryNameBoolExp>;\n};\n\nexport type QueryRootAnsPrimaryNameByPkArgs = {\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n  write_set_change_index: Scalars[\"bigint\"][\"input\"];\n};\n\nexport type QueryRootAnsPrimaryNameV2Args = {\n  distinct_on?: InputMaybe<Array<AnsPrimaryNameV2SelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<AnsPrimaryNameV2OrderBy>>;\n  where?: InputMaybe<AnsPrimaryNameV2BoolExp>;\n};\n\nexport type QueryRootAnsPrimaryNameV2AggregateArgs = {\n  distinct_on?: InputMaybe<Array<AnsPrimaryNameV2SelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<AnsPrimaryNameV2OrderBy>>;\n  where?: InputMaybe<AnsPrimaryNameV2BoolExp>;\n};\n\nexport type QueryRootAnsPrimaryNameV2ByPkArgs = {\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n  write_set_change_index: Scalars[\"bigint\"][\"input\"];\n};\n\nexport type QueryRootAuthKeyAccountAddressesArgs = {\n  distinct_on?: InputMaybe<Array<AuthKeyAccountAddressesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<AuthKeyAccountAddressesOrderBy>>;\n  where?: InputMaybe<AuthKeyAccountAddressesBoolExp>;\n};\n\nexport type QueryRootAuthKeyAccountAddressesAggregateArgs = {\n  distinct_on?: InputMaybe<Array<AuthKeyAccountAddressesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<AuthKeyAccountAddressesOrderBy>>;\n  where?: InputMaybe<AuthKeyAccountAddressesBoolExp>;\n};\n\nexport type QueryRootAuthKeyAccountAddressesByPkArgs = {\n  account_address: Scalars[\"String\"][\"input\"];\n};\n\nexport type QueryRootBlockMetadataTransactionsArgs = {\n  distinct_on?: InputMaybe<Array<BlockMetadataTransactionsSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<BlockMetadataTransactionsOrderBy>>;\n  where?: InputMaybe<BlockMetadataTransactionsBoolExp>;\n};\n\nexport type QueryRootBlockMetadataTransactionsAggregateArgs = {\n  distinct_on?: InputMaybe<Array<BlockMetadataTransactionsSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<BlockMetadataTransactionsOrderBy>>;\n  where?: InputMaybe<BlockMetadataTransactionsBoolExp>;\n};\n\nexport type QueryRootBlockMetadataTransactionsByPkArgs = {\n  version: Scalars[\"bigint\"][\"input\"];\n};\n\nexport type QueryRootCoinActivitiesArgs = {\n  distinct_on?: InputMaybe<Array<CoinActivitiesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CoinActivitiesOrderBy>>;\n  where?: InputMaybe<CoinActivitiesBoolExp>;\n};\n\nexport type QueryRootCoinActivitiesAggregateArgs = {\n  distinct_on?: InputMaybe<Array<CoinActivitiesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CoinActivitiesOrderBy>>;\n  where?: InputMaybe<CoinActivitiesBoolExp>;\n};\n\nexport type QueryRootCoinActivitiesByPkArgs = {\n  event_account_address: Scalars[\"String\"][\"input\"];\n  event_creation_number: Scalars[\"bigint\"][\"input\"];\n  event_sequence_number: Scalars[\"bigint\"][\"input\"];\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\nexport type QueryRootCoinBalancesArgs = {\n  distinct_on?: InputMaybe<Array<CoinBalancesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CoinBalancesOrderBy>>;\n  where?: InputMaybe<CoinBalancesBoolExp>;\n};\n\nexport type QueryRootCoinBalancesAggregateArgs = {\n  distinct_on?: InputMaybe<Array<CoinBalancesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CoinBalancesOrderBy>>;\n  where?: InputMaybe<CoinBalancesBoolExp>;\n};\n\nexport type QueryRootCoinBalancesByPkArgs = {\n  coin_type_hash: Scalars[\"String\"][\"input\"];\n  owner_address: Scalars[\"String\"][\"input\"];\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\nexport type QueryRootCoinInfosArgs = {\n  distinct_on?: InputMaybe<Array<CoinInfosSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CoinInfosOrderBy>>;\n  where?: InputMaybe<CoinInfosBoolExp>;\n};\n\nexport type QueryRootCoinInfosAggregateArgs = {\n  distinct_on?: InputMaybe<Array<CoinInfosSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CoinInfosOrderBy>>;\n  where?: InputMaybe<CoinInfosBoolExp>;\n};\n\nexport type QueryRootCoinInfosByPkArgs = {\n  coin_type_hash: Scalars[\"String\"][\"input\"];\n};\n\nexport type QueryRootCoinSupplyArgs = {\n  distinct_on?: InputMaybe<Array<CoinSupplySelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CoinSupplyOrderBy>>;\n  where?: InputMaybe<CoinSupplyBoolExp>;\n};\n\nexport type QueryRootCoinSupplyAggregateArgs = {\n  distinct_on?: InputMaybe<Array<CoinSupplySelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CoinSupplyOrderBy>>;\n  where?: InputMaybe<CoinSupplyBoolExp>;\n};\n\nexport type QueryRootCoinSupplyByPkArgs = {\n  coin_type_hash: Scalars[\"String\"][\"input\"];\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\nexport type QueryRootCollectionDatasArgs = {\n  distinct_on?: InputMaybe<Array<CollectionDatasSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CollectionDatasOrderBy>>;\n  where?: InputMaybe<CollectionDatasBoolExp>;\n};\n\nexport type QueryRootCollectionDatasAggregateArgs = {\n  distinct_on?: InputMaybe<Array<CollectionDatasSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CollectionDatasOrderBy>>;\n  where?: InputMaybe<CollectionDatasBoolExp>;\n};\n\nexport type QueryRootCollectionDatasByPkArgs = {\n  collection_data_id_hash: Scalars[\"String\"][\"input\"];\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\nexport type QueryRootCollectionsV2Args = {\n  distinct_on?: InputMaybe<Array<CollectionsV2SelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CollectionsV2OrderBy>>;\n  where?: InputMaybe<CollectionsV2BoolExp>;\n};\n\nexport type QueryRootCollectionsV2AggregateArgs = {\n  distinct_on?: InputMaybe<Array<CollectionsV2SelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CollectionsV2OrderBy>>;\n  where?: InputMaybe<CollectionsV2BoolExp>;\n};\n\nexport type QueryRootCollectionsV2ByPkArgs = {\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n  write_set_change_index: Scalars[\"bigint\"][\"input\"];\n};\n\nexport type QueryRootCurrentAnsLookupArgs = {\n  distinct_on?: InputMaybe<Array<CurrentAnsLookupSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentAnsLookupOrderBy>>;\n  where?: InputMaybe<CurrentAnsLookupBoolExp>;\n};\n\nexport type QueryRootCurrentAnsLookupAggregateArgs = {\n  distinct_on?: InputMaybe<Array<CurrentAnsLookupSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentAnsLookupOrderBy>>;\n  where?: InputMaybe<CurrentAnsLookupBoolExp>;\n};\n\nexport type QueryRootCurrentAnsLookupByPkArgs = {\n  domain: Scalars[\"String\"][\"input\"];\n  subdomain: Scalars[\"String\"][\"input\"];\n};\n\nexport type QueryRootCurrentAnsLookupV2Args = {\n  distinct_on?: InputMaybe<Array<CurrentAnsLookupV2SelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentAnsLookupV2OrderBy>>;\n  where?: InputMaybe<CurrentAnsLookupV2BoolExp>;\n};\n\nexport type QueryRootCurrentAnsLookupV2AggregateArgs = {\n  distinct_on?: InputMaybe<Array<CurrentAnsLookupV2SelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentAnsLookupV2OrderBy>>;\n  where?: InputMaybe<CurrentAnsLookupV2BoolExp>;\n};\n\nexport type QueryRootCurrentAnsLookupV2ByPkArgs = {\n  domain: Scalars[\"String\"][\"input\"];\n  subdomain: Scalars[\"String\"][\"input\"];\n  token_standard: Scalars[\"String\"][\"input\"];\n};\n\nexport type QueryRootCurrentAnsPrimaryNameArgs = {\n  distinct_on?: InputMaybe<Array<CurrentAnsPrimaryNameSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentAnsPrimaryNameOrderBy>>;\n  where?: InputMaybe<CurrentAnsPrimaryNameBoolExp>;\n};\n\nexport type QueryRootCurrentAnsPrimaryNameAggregateArgs = {\n  distinct_on?: InputMaybe<Array<CurrentAnsPrimaryNameSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentAnsPrimaryNameOrderBy>>;\n  where?: InputMaybe<CurrentAnsPrimaryNameBoolExp>;\n};\n\nexport type QueryRootCurrentAnsPrimaryNameByPkArgs = {\n  registered_address: Scalars[\"String\"][\"input\"];\n};\n\nexport type QueryRootCurrentAnsPrimaryNameV2Args = {\n  distinct_on?: InputMaybe<Array<CurrentAnsPrimaryNameV2SelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentAnsPrimaryNameV2OrderBy>>;\n  where?: InputMaybe<CurrentAnsPrimaryNameV2BoolExp>;\n};\n\nexport type QueryRootCurrentAnsPrimaryNameV2AggregateArgs = {\n  distinct_on?: InputMaybe<Array<CurrentAnsPrimaryNameV2SelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentAnsPrimaryNameV2OrderBy>>;\n  where?: InputMaybe<CurrentAnsPrimaryNameV2BoolExp>;\n};\n\nexport type QueryRootCurrentAnsPrimaryNameV2ByPkArgs = {\n  registered_address: Scalars[\"String\"][\"input\"];\n  token_standard: Scalars[\"String\"][\"input\"];\n};\n\nexport type QueryRootCurrentCedraNamesArgs = {\n  distinct_on?: InputMaybe<Array<CurrentCedraNamesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentCedraNamesOrderBy>>;\n  where?: InputMaybe<CurrentCedraNamesBoolExp>;\n};\n\nexport type QueryRootCurrentCedraNamesAggregateArgs = {\n  distinct_on?: InputMaybe<Array<CurrentCedraNamesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentCedraNamesOrderBy>>;\n  where?: InputMaybe<CurrentCedraNamesBoolExp>;\n};\n\nexport type QueryRootCurrentCoinBalancesArgs = {\n  distinct_on?: InputMaybe<Array<CurrentCoinBalancesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentCoinBalancesOrderBy>>;\n  where?: InputMaybe<CurrentCoinBalancesBoolExp>;\n};\n\nexport type QueryRootCurrentCoinBalancesAggregateArgs = {\n  distinct_on?: InputMaybe<Array<CurrentCoinBalancesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentCoinBalancesOrderBy>>;\n  where?: InputMaybe<CurrentCoinBalancesBoolExp>;\n};\n\nexport type QueryRootCurrentCoinBalancesByPkArgs = {\n  coin_type_hash: Scalars[\"String\"][\"input\"];\n  owner_address: Scalars[\"String\"][\"input\"];\n};\n\nexport type QueryRootCurrentCollectionDatasArgs = {\n  distinct_on?: InputMaybe<Array<CurrentCollectionDatasSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentCollectionDatasOrderBy>>;\n  where?: InputMaybe<CurrentCollectionDatasBoolExp>;\n};\n\nexport type QueryRootCurrentCollectionDatasAggregateArgs = {\n  distinct_on?: InputMaybe<Array<CurrentCollectionDatasSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentCollectionDatasOrderBy>>;\n  where?: InputMaybe<CurrentCollectionDatasBoolExp>;\n};\n\nexport type QueryRootCurrentCollectionDatasByPkArgs = {\n  collection_data_id_hash: Scalars[\"String\"][\"input\"];\n};\n\nexport type QueryRootCurrentCollectionOwnershipV2ViewArgs = {\n  distinct_on?: InputMaybe<Array<CurrentCollectionOwnershipV2ViewSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentCollectionOwnershipV2ViewOrderBy>>;\n  where?: InputMaybe<CurrentCollectionOwnershipV2ViewBoolExp>;\n};\n\nexport type QueryRootCurrentCollectionOwnershipV2ViewAggregateArgs = {\n  distinct_on?: InputMaybe<Array<CurrentCollectionOwnershipV2ViewSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentCollectionOwnershipV2ViewOrderBy>>;\n  where?: InputMaybe<CurrentCollectionOwnershipV2ViewBoolExp>;\n};\n\nexport type QueryRootCurrentCollectionOwnershipViewArgs = {\n  distinct_on?: InputMaybe<Array<CurrentCollectionOwnershipViewSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentCollectionOwnershipViewOrderBy>>;\n  where?: InputMaybe<CurrentCollectionOwnershipViewBoolExp>;\n};\n\nexport type QueryRootCurrentCollectionOwnershipViewAggregateArgs = {\n  distinct_on?: InputMaybe<Array<CurrentCollectionOwnershipViewSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentCollectionOwnershipViewOrderBy>>;\n  where?: InputMaybe<CurrentCollectionOwnershipViewBoolExp>;\n};\n\nexport type QueryRootCurrentCollectionsV2Args = {\n  distinct_on?: InputMaybe<Array<CurrentCollectionsV2SelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentCollectionsV2OrderBy>>;\n  where?: InputMaybe<CurrentCollectionsV2BoolExp>;\n};\n\nexport type QueryRootCurrentCollectionsV2AggregateArgs = {\n  distinct_on?: InputMaybe<Array<CurrentCollectionsV2SelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentCollectionsV2OrderBy>>;\n  where?: InputMaybe<CurrentCollectionsV2BoolExp>;\n};\n\nexport type QueryRootCurrentCollectionsV2ByPkArgs = {\n  collection_id: Scalars[\"String\"][\"input\"];\n};\n\nexport type QueryRootCurrentDelegatedStakingPoolBalancesArgs = {\n  distinct_on?: InputMaybe<Array<CurrentDelegatedStakingPoolBalancesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentDelegatedStakingPoolBalancesOrderBy>>;\n  where?: InputMaybe<CurrentDelegatedStakingPoolBalancesBoolExp>;\n};\n\nexport type QueryRootCurrentDelegatedStakingPoolBalancesAggregateArgs = {\n  distinct_on?: InputMaybe<Array<CurrentDelegatedStakingPoolBalancesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentDelegatedStakingPoolBalancesOrderBy>>;\n  where?: InputMaybe<CurrentDelegatedStakingPoolBalancesBoolExp>;\n};\n\nexport type QueryRootCurrentDelegatedStakingPoolBalancesByPkArgs = {\n  staking_pool_address: Scalars[\"String\"][\"input\"];\n};\n\nexport type QueryRootCurrentDelegatedVoterArgs = {\n  distinct_on?: InputMaybe<Array<CurrentDelegatedVoterSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentDelegatedVoterOrderBy>>;\n  where?: InputMaybe<CurrentDelegatedVoterBoolExp>;\n};\n\nexport type QueryRootCurrentDelegatedVoterAggregateArgs = {\n  distinct_on?: InputMaybe<Array<CurrentDelegatedVoterSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentDelegatedVoterOrderBy>>;\n  where?: InputMaybe<CurrentDelegatedVoterBoolExp>;\n};\n\nexport type QueryRootCurrentDelegatedVoterByPkArgs = {\n  delegation_pool_address: Scalars[\"String\"][\"input\"];\n  delegator_address: Scalars[\"String\"][\"input\"];\n};\n\nexport type QueryRootCurrentDelegatorBalancesArgs = {\n  distinct_on?: InputMaybe<Array<CurrentDelegatorBalancesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentDelegatorBalancesOrderBy>>;\n  where?: InputMaybe<CurrentDelegatorBalancesBoolExp>;\n};\n\nexport type QueryRootCurrentDelegatorBalancesAggregateArgs = {\n  distinct_on?: InputMaybe<Array<CurrentDelegatorBalancesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentDelegatorBalancesOrderBy>>;\n  where?: InputMaybe<CurrentDelegatorBalancesBoolExp>;\n};\n\nexport type QueryRootCurrentDelegatorBalancesByPkArgs = {\n  delegator_address: Scalars[\"String\"][\"input\"];\n  pool_address: Scalars[\"String\"][\"input\"];\n  pool_type: Scalars[\"String\"][\"input\"];\n  table_handle: Scalars[\"String\"][\"input\"];\n};\n\nexport type QueryRootCurrentFungibleAssetBalancesArgs = {\n  distinct_on?: InputMaybe<Array<CurrentFungibleAssetBalancesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentFungibleAssetBalancesOrderBy>>;\n  where?: InputMaybe<CurrentFungibleAssetBalancesBoolExp>;\n};\n\nexport type QueryRootCurrentFungibleAssetBalancesAggregateArgs = {\n  distinct_on?: InputMaybe<Array<CurrentFungibleAssetBalancesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentFungibleAssetBalancesOrderBy>>;\n  where?: InputMaybe<CurrentFungibleAssetBalancesBoolExp>;\n};\n\nexport type QueryRootCurrentFungibleAssetBalancesByPkArgs = {\n  storage_id: Scalars[\"String\"][\"input\"];\n};\n\nexport type QueryRootCurrentFungibleAssetBalancesNewArgs = {\n  distinct_on?: InputMaybe<Array<CurrentFungibleAssetBalancesNewSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentFungibleAssetBalancesNewOrderBy>>;\n  where?: InputMaybe<CurrentFungibleAssetBalancesNewBoolExp>;\n};\n\nexport type QueryRootCurrentFungibleAssetBalancesNewAggregateArgs = {\n  distinct_on?: InputMaybe<Array<CurrentFungibleAssetBalancesNewSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentFungibleAssetBalancesNewOrderBy>>;\n  where?: InputMaybe<CurrentFungibleAssetBalancesNewBoolExp>;\n};\n\nexport type QueryRootCurrentFungibleAssetBalancesNewByPkArgs = {\n  storage_id: Scalars[\"String\"][\"input\"];\n};\n\nexport type QueryRootCurrentObjectsArgs = {\n  distinct_on?: InputMaybe<Array<CurrentObjectsSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentObjectsOrderBy>>;\n  where?: InputMaybe<CurrentObjectsBoolExp>;\n};\n\nexport type QueryRootCurrentObjectsAggregateArgs = {\n  distinct_on?: InputMaybe<Array<CurrentObjectsSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentObjectsOrderBy>>;\n  where?: InputMaybe<CurrentObjectsBoolExp>;\n};\n\nexport type QueryRootCurrentObjectsByPkArgs = {\n  object_address: Scalars[\"String\"][\"input\"];\n};\n\nexport type QueryRootCurrentStakingPoolVoterArgs = {\n  distinct_on?: InputMaybe<Array<CurrentStakingPoolVoterSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentStakingPoolVoterOrderBy>>;\n  where?: InputMaybe<CurrentStakingPoolVoterBoolExp>;\n};\n\nexport type QueryRootCurrentStakingPoolVoterAggregateArgs = {\n  distinct_on?: InputMaybe<Array<CurrentStakingPoolVoterSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentStakingPoolVoterOrderBy>>;\n  where?: InputMaybe<CurrentStakingPoolVoterBoolExp>;\n};\n\nexport type QueryRootCurrentStakingPoolVoterByPkArgs = {\n  staking_pool_address: Scalars[\"String\"][\"input\"];\n};\n\nexport type QueryRootCurrentTableItemsArgs = {\n  distinct_on?: InputMaybe<Array<CurrentTableItemsSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentTableItemsOrderBy>>;\n  where?: InputMaybe<CurrentTableItemsBoolExp>;\n};\n\nexport type QueryRootCurrentTableItemsAggregateArgs = {\n  distinct_on?: InputMaybe<Array<CurrentTableItemsSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentTableItemsOrderBy>>;\n  where?: InputMaybe<CurrentTableItemsBoolExp>;\n};\n\nexport type QueryRootCurrentTableItemsByPkArgs = {\n  key_hash: Scalars[\"String\"][\"input\"];\n  table_handle: Scalars[\"String\"][\"input\"];\n};\n\nexport type QueryRootCurrentTableItemsViewArgs = {\n  distinct_on?: InputMaybe<Array<CurrentTableItemsViewSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentTableItemsViewOrderBy>>;\n  where?: InputMaybe<CurrentTableItemsViewBoolExp>;\n};\n\nexport type QueryRootCurrentTableItemsViewAggregateArgs = {\n  distinct_on?: InputMaybe<Array<CurrentTableItemsViewSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentTableItemsViewOrderBy>>;\n  where?: InputMaybe<CurrentTableItemsViewBoolExp>;\n};\n\nexport type QueryRootCurrentTokenDatasArgs = {\n  distinct_on?: InputMaybe<Array<CurrentTokenDatasSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentTokenDatasOrderBy>>;\n  where?: InputMaybe<CurrentTokenDatasBoolExp>;\n};\n\nexport type QueryRootCurrentTokenDatasAggregateArgs = {\n  distinct_on?: InputMaybe<Array<CurrentTokenDatasSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentTokenDatasOrderBy>>;\n  where?: InputMaybe<CurrentTokenDatasBoolExp>;\n};\n\nexport type QueryRootCurrentTokenDatasByPkArgs = {\n  token_data_id_hash: Scalars[\"String\"][\"input\"];\n};\n\nexport type QueryRootCurrentTokenDatasV2Args = {\n  distinct_on?: InputMaybe<Array<CurrentTokenDatasV2SelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentTokenDatasV2OrderBy>>;\n  where?: InputMaybe<CurrentTokenDatasV2BoolExp>;\n};\n\nexport type QueryRootCurrentTokenDatasV2AggregateArgs = {\n  distinct_on?: InputMaybe<Array<CurrentTokenDatasV2SelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentTokenDatasV2OrderBy>>;\n  where?: InputMaybe<CurrentTokenDatasV2BoolExp>;\n};\n\nexport type QueryRootCurrentTokenDatasV2ByPkArgs = {\n  token_data_id: Scalars[\"String\"][\"input\"];\n};\n\nexport type QueryRootCurrentTokenOwnershipsArgs = {\n  distinct_on?: InputMaybe<Array<CurrentTokenOwnershipsSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentTokenOwnershipsOrderBy>>;\n  where?: InputMaybe<CurrentTokenOwnershipsBoolExp>;\n};\n\nexport type QueryRootCurrentTokenOwnershipsAggregateArgs = {\n  distinct_on?: InputMaybe<Array<CurrentTokenOwnershipsSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentTokenOwnershipsOrderBy>>;\n  where?: InputMaybe<CurrentTokenOwnershipsBoolExp>;\n};\n\nexport type QueryRootCurrentTokenOwnershipsByPkArgs = {\n  owner_address: Scalars[\"String\"][\"input\"];\n  property_version: Scalars[\"numeric\"][\"input\"];\n  token_data_id_hash: Scalars[\"String\"][\"input\"];\n};\n\nexport type QueryRootCurrentTokenOwnershipsV2Args = {\n  distinct_on?: InputMaybe<Array<CurrentTokenOwnershipsV2SelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentTokenOwnershipsV2OrderBy>>;\n  where?: InputMaybe<CurrentTokenOwnershipsV2BoolExp>;\n};\n\nexport type QueryRootCurrentTokenOwnershipsV2AggregateArgs = {\n  distinct_on?: InputMaybe<Array<CurrentTokenOwnershipsV2SelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentTokenOwnershipsV2OrderBy>>;\n  where?: InputMaybe<CurrentTokenOwnershipsV2BoolExp>;\n};\n\nexport type QueryRootCurrentTokenOwnershipsV2ByPkArgs = {\n  owner_address: Scalars[\"String\"][\"input\"];\n  property_version_v1: Scalars[\"numeric\"][\"input\"];\n  storage_id: Scalars[\"String\"][\"input\"];\n  token_data_id: Scalars[\"String\"][\"input\"];\n};\n\nexport type QueryRootCurrentTokenPendingClaimsArgs = {\n  distinct_on?: InputMaybe<Array<CurrentTokenPendingClaimsSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentTokenPendingClaimsOrderBy>>;\n  where?: InputMaybe<CurrentTokenPendingClaimsBoolExp>;\n};\n\nexport type QueryRootCurrentTokenPendingClaimsAggregateArgs = {\n  distinct_on?: InputMaybe<Array<CurrentTokenPendingClaimsSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentTokenPendingClaimsOrderBy>>;\n  where?: InputMaybe<CurrentTokenPendingClaimsBoolExp>;\n};\n\nexport type QueryRootCurrentTokenPendingClaimsByPkArgs = {\n  from_address: Scalars[\"String\"][\"input\"];\n  property_version: Scalars[\"numeric\"][\"input\"];\n  to_address: Scalars[\"String\"][\"input\"];\n  token_data_id_hash: Scalars[\"String\"][\"input\"];\n};\n\nexport type QueryRootCurrentTokenRoyaltyV1Args = {\n  distinct_on?: InputMaybe<Array<CurrentTokenRoyaltyV1SelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentTokenRoyaltyV1OrderBy>>;\n  where?: InputMaybe<CurrentTokenRoyaltyV1BoolExp>;\n};\n\nexport type QueryRootCurrentTokenRoyaltyV1AggregateArgs = {\n  distinct_on?: InputMaybe<Array<CurrentTokenRoyaltyV1SelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentTokenRoyaltyV1OrderBy>>;\n  where?: InputMaybe<CurrentTokenRoyaltyV1BoolExp>;\n};\n\nexport type QueryRootCurrentTokenRoyaltyV1ByPkArgs = {\n  token_data_id: Scalars[\"String\"][\"input\"];\n};\n\nexport type QueryRootCurrentTokenV2MetadataArgs = {\n  distinct_on?: InputMaybe<Array<CurrentTokenV2MetadataSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentTokenV2MetadataOrderBy>>;\n  where?: InputMaybe<CurrentTokenV2MetadataBoolExp>;\n};\n\nexport type QueryRootCurrentTokenV2MetadataAggregateArgs = {\n  distinct_on?: InputMaybe<Array<CurrentTokenV2MetadataSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentTokenV2MetadataOrderBy>>;\n  where?: InputMaybe<CurrentTokenV2MetadataBoolExp>;\n};\n\nexport type QueryRootCurrentTokenV2MetadataByPkArgs = {\n  object_address: Scalars[\"String\"][\"input\"];\n  resource_type: Scalars[\"String\"][\"input\"];\n};\n\nexport type QueryRootDelegatedStakingActivitiesArgs = {\n  distinct_on?: InputMaybe<Array<DelegatedStakingActivitiesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<DelegatedStakingActivitiesOrderBy>>;\n  where?: InputMaybe<DelegatedStakingActivitiesBoolExp>;\n};\n\nexport type QueryRootDelegatedStakingActivitiesAggregateArgs = {\n  distinct_on?: InputMaybe<Array<DelegatedStakingActivitiesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<DelegatedStakingActivitiesOrderBy>>;\n  where?: InputMaybe<DelegatedStakingActivitiesBoolExp>;\n};\n\nexport type QueryRootDelegatedStakingActivitiesByPkArgs = {\n  event_index: Scalars[\"bigint\"][\"input\"];\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\nexport type QueryRootDelegatedStakingPoolBalancesArgs = {\n  distinct_on?: InputMaybe<Array<DelegatedStakingPoolBalancesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<DelegatedStakingPoolBalancesOrderBy>>;\n  where?: InputMaybe<DelegatedStakingPoolBalancesBoolExp>;\n};\n\nexport type QueryRootDelegatedStakingPoolBalancesAggregateArgs = {\n  distinct_on?: InputMaybe<Array<DelegatedStakingPoolBalancesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<DelegatedStakingPoolBalancesOrderBy>>;\n  where?: InputMaybe<DelegatedStakingPoolBalancesBoolExp>;\n};\n\nexport type QueryRootDelegatedStakingPoolBalancesByPkArgs = {\n  staking_pool_address: Scalars[\"String\"][\"input\"];\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\nexport type QueryRootDelegatedStakingPoolsArgs = {\n  distinct_on?: InputMaybe<Array<DelegatedStakingPoolsSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<DelegatedStakingPoolsOrderBy>>;\n  where?: InputMaybe<DelegatedStakingPoolsBoolExp>;\n};\n\nexport type QueryRootDelegatedStakingPoolsAggregateArgs = {\n  distinct_on?: InputMaybe<Array<DelegatedStakingPoolsSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<DelegatedStakingPoolsOrderBy>>;\n  where?: InputMaybe<DelegatedStakingPoolsBoolExp>;\n};\n\nexport type QueryRootDelegatedStakingPoolsByPkArgs = {\n  staking_pool_address: Scalars[\"String\"][\"input\"];\n};\n\nexport type QueryRootDelegatorBalancesArgs = {\n  distinct_on?: InputMaybe<Array<DelegatorBalancesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<DelegatorBalancesOrderBy>>;\n  where?: InputMaybe<DelegatorBalancesBoolExp>;\n};\n\nexport type QueryRootDelegatorBalancesAggregateArgs = {\n  distinct_on?: InputMaybe<Array<DelegatorBalancesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<DelegatorBalancesOrderBy>>;\n  where?: InputMaybe<DelegatorBalancesBoolExp>;\n};\n\nexport type QueryRootDelegatorBalancesByPkArgs = {\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n  write_set_change_index: Scalars[\"bigint\"][\"input\"];\n};\n\nexport type QueryRootDelegatorDistinctPoolArgs = {\n  distinct_on?: InputMaybe<Array<DelegatorDistinctPoolSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<DelegatorDistinctPoolOrderBy>>;\n  where?: InputMaybe<DelegatorDistinctPoolBoolExp>;\n};\n\nexport type QueryRootDelegatorDistinctPoolAggregateArgs = {\n  distinct_on?: InputMaybe<Array<DelegatorDistinctPoolSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<DelegatorDistinctPoolOrderBy>>;\n  where?: InputMaybe<DelegatorDistinctPoolBoolExp>;\n};\n\nexport type QueryRootEventSizeInfoArgs = {\n  distinct_on?: InputMaybe<Array<EventSizeInfoSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<EventSizeInfoOrderBy>>;\n  where?: InputMaybe<EventSizeInfoBoolExp>;\n};\n\nexport type QueryRootEventSizeInfoAggregateArgs = {\n  distinct_on?: InputMaybe<Array<EventSizeInfoSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<EventSizeInfoOrderBy>>;\n  where?: InputMaybe<EventSizeInfoBoolExp>;\n};\n\nexport type QueryRootEventSizeInfoByPkArgs = {\n  index: Scalars[\"bigint\"][\"input\"];\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\nexport type QueryRootEventsArgs = {\n  distinct_on?: InputMaybe<Array<EventsSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<EventsOrderBy>>;\n  where?: InputMaybe<EventsBoolExp>;\n};\n\nexport type QueryRootEventsAggregateArgs = {\n  distinct_on?: InputMaybe<Array<EventsSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<EventsOrderBy>>;\n  where?: InputMaybe<EventsBoolExp>;\n};\n\nexport type QueryRootEventsByPkArgs = {\n  event_index: Scalars[\"bigint\"][\"input\"];\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\nexport type QueryRootEventsViewArgs = {\n  distinct_on?: InputMaybe<Array<EventsViewSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<EventsViewOrderBy>>;\n  where?: InputMaybe<EventsViewBoolExp>;\n};\n\nexport type QueryRootEventsViewAggregateArgs = {\n  distinct_on?: InputMaybe<Array<EventsViewSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<EventsViewOrderBy>>;\n  where?: InputMaybe<EventsViewBoolExp>;\n};\n\nexport type QueryRootFungibleAssetActivitiesArgs = {\n  distinct_on?: InputMaybe<Array<FungibleAssetActivitiesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<FungibleAssetActivitiesOrderBy>>;\n  where?: InputMaybe<FungibleAssetActivitiesBoolExp>;\n};\n\nexport type QueryRootFungibleAssetActivitiesAggregateArgs = {\n  distinct_on?: InputMaybe<Array<FungibleAssetActivitiesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<FungibleAssetActivitiesOrderBy>>;\n  where?: InputMaybe<FungibleAssetActivitiesBoolExp>;\n};\n\nexport type QueryRootFungibleAssetActivitiesByPkArgs = {\n  event_index: Scalars[\"bigint\"][\"input\"];\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\nexport type QueryRootFungibleAssetBalancesArgs = {\n  distinct_on?: InputMaybe<Array<FungibleAssetBalancesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<FungibleAssetBalancesOrderBy>>;\n  where?: InputMaybe<FungibleAssetBalancesBoolExp>;\n};\n\nexport type QueryRootFungibleAssetBalancesAggregateArgs = {\n  distinct_on?: InputMaybe<Array<FungibleAssetBalancesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<FungibleAssetBalancesOrderBy>>;\n  where?: InputMaybe<FungibleAssetBalancesBoolExp>;\n};\n\nexport type QueryRootFungibleAssetBalancesByPkArgs = {\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n  write_set_change_index: Scalars[\"bigint\"][\"input\"];\n};\n\nexport type QueryRootFungibleAssetMetadataArgs = {\n  distinct_on?: InputMaybe<Array<FungibleAssetMetadataSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<FungibleAssetMetadataOrderBy>>;\n  where?: InputMaybe<FungibleAssetMetadataBoolExp>;\n};\n\nexport type QueryRootFungibleAssetMetadataAggregateArgs = {\n  distinct_on?: InputMaybe<Array<FungibleAssetMetadataSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<FungibleAssetMetadataOrderBy>>;\n  where?: InputMaybe<FungibleAssetMetadataBoolExp>;\n};\n\nexport type QueryRootFungibleAssetMetadataByPkArgs = {\n  asset_type: Scalars[\"String\"][\"input\"];\n};\n\nexport type QueryRootFungibleAssetToCoinMappingsArgs = {\n  distinct_on?: InputMaybe<Array<FungibleAssetToCoinMappingsSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<FungibleAssetToCoinMappingsOrderBy>>;\n  where?: InputMaybe<FungibleAssetToCoinMappingsBoolExp>;\n};\n\nexport type QueryRootFungibleAssetToCoinMappingsAggregateArgs = {\n  distinct_on?: InputMaybe<Array<FungibleAssetToCoinMappingsSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<FungibleAssetToCoinMappingsOrderBy>>;\n  where?: InputMaybe<FungibleAssetToCoinMappingsBoolExp>;\n};\n\nexport type QueryRootFungibleAssetToCoinMappingsByPkArgs = {\n  fungible_asset_metadata_address: Scalars[\"String\"][\"input\"];\n};\n\nexport type QueryRootGasFeesArgs = {\n  distinct_on?: InputMaybe<Array<GasFeesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<GasFeesOrderBy>>;\n  where?: InputMaybe<GasFeesBoolExp>;\n};\n\nexport type QueryRootGasFeesAggregateArgs = {\n  distinct_on?: InputMaybe<Array<GasFeesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<GasFeesOrderBy>>;\n  where?: InputMaybe<GasFeesBoolExp>;\n};\n\nexport type QueryRootGasFeesByPkArgs = {\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\nexport type QueryRootIndexerStatusArgs = {\n  distinct_on?: InputMaybe<Array<IndexerStatusSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<IndexerStatusOrderBy>>;\n  where?: InputMaybe<IndexerStatusBoolExp>;\n};\n\nexport type QueryRootIndexerStatusAggregateArgs = {\n  distinct_on?: InputMaybe<Array<IndexerStatusSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<IndexerStatusOrderBy>>;\n  where?: InputMaybe<IndexerStatusBoolExp>;\n};\n\nexport type QueryRootIndexerStatusByPkArgs = {\n  db: Scalars[\"String\"][\"input\"];\n};\n\nexport type QueryRootMoveModulesArgs = {\n  distinct_on?: InputMaybe<Array<MoveModulesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<MoveModulesOrderBy>>;\n  where?: InputMaybe<MoveModulesBoolExp>;\n};\n\nexport type QueryRootMoveModulesAggregateArgs = {\n  distinct_on?: InputMaybe<Array<MoveModulesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<MoveModulesOrderBy>>;\n  where?: InputMaybe<MoveModulesBoolExp>;\n};\n\nexport type QueryRootMoveModulesByPkArgs = {\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n  write_set_change_index: Scalars[\"bigint\"][\"input\"];\n};\n\nexport type QueryRootMoveResourcesArgs = {\n  distinct_on?: InputMaybe<Array<MoveResourcesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<MoveResourcesOrderBy>>;\n  where?: InputMaybe<MoveResourcesBoolExp>;\n};\n\nexport type QueryRootMoveResourcesAggregateArgs = {\n  distinct_on?: InputMaybe<Array<MoveResourcesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<MoveResourcesOrderBy>>;\n  where?: InputMaybe<MoveResourcesBoolExp>;\n};\n\nexport type QueryRootMoveResourcesByPkArgs = {\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n  write_set_change_index: Scalars[\"bigint\"][\"input\"];\n};\n\nexport type QueryRootMoveResourcesViewArgs = {\n  distinct_on?: InputMaybe<Array<MoveResourcesViewSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<MoveResourcesViewOrderBy>>;\n  where?: InputMaybe<MoveResourcesViewBoolExp>;\n};\n\nexport type QueryRootMoveResourcesViewAggregateArgs = {\n  distinct_on?: InputMaybe<Array<MoveResourcesViewSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<MoveResourcesViewOrderBy>>;\n  where?: InputMaybe<MoveResourcesViewBoolExp>;\n};\n\nexport type QueryRootNftMetadataCrawlerParsedAssetUrisArgs = {\n  distinct_on?: InputMaybe<Array<NftMetadataCrawlerParsedAssetUrisSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<NftMetadataCrawlerParsedAssetUrisOrderBy>>;\n  where?: InputMaybe<NftMetadataCrawlerParsedAssetUrisBoolExp>;\n};\n\nexport type QueryRootNftMetadataCrawlerParsedAssetUrisAggregateArgs = {\n  distinct_on?: InputMaybe<Array<NftMetadataCrawlerParsedAssetUrisSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<NftMetadataCrawlerParsedAssetUrisOrderBy>>;\n  where?: InputMaybe<NftMetadataCrawlerParsedAssetUrisBoolExp>;\n};\n\nexport type QueryRootNftMetadataCrawlerParsedAssetUrisByPkArgs = {\n  asset_uri: Scalars[\"String\"][\"input\"];\n};\n\nexport type QueryRootNftPointsArgs = {\n  distinct_on?: InputMaybe<Array<NftPointsSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<NftPointsOrderBy>>;\n  where?: InputMaybe<NftPointsBoolExp>;\n};\n\nexport type QueryRootNftPointsAggregateArgs = {\n  distinct_on?: InputMaybe<Array<NftPointsSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<NftPointsOrderBy>>;\n  where?: InputMaybe<NftPointsBoolExp>;\n};\n\nexport type QueryRootNftPointsByPkArgs = {\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\nexport type QueryRootNumActiveDelegatorPerPoolArgs = {\n  distinct_on?: InputMaybe<Array<NumActiveDelegatorPerPoolSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<NumActiveDelegatorPerPoolOrderBy>>;\n  where?: InputMaybe<NumActiveDelegatorPerPoolBoolExp>;\n};\n\nexport type QueryRootNumActiveDelegatorPerPoolAggregateArgs = {\n  distinct_on?: InputMaybe<Array<NumActiveDelegatorPerPoolSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<NumActiveDelegatorPerPoolOrderBy>>;\n  where?: InputMaybe<NumActiveDelegatorPerPoolBoolExp>;\n};\n\nexport type QueryRootObjectsArgs = {\n  distinct_on?: InputMaybe<Array<ObjectsSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<ObjectsOrderBy>>;\n  where?: InputMaybe<ObjectsBoolExp>;\n};\n\nexport type QueryRootObjectsAggregateArgs = {\n  distinct_on?: InputMaybe<Array<ObjectsSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<ObjectsOrderBy>>;\n  where?: InputMaybe<ObjectsBoolExp>;\n};\n\nexport type QueryRootObjectsByPkArgs = {\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n  write_set_change_index: Scalars[\"bigint\"][\"input\"];\n};\n\nexport type QueryRootProcessorMetadataProcessorStatusArgs = {\n  distinct_on?: InputMaybe<Array<ProcessorMetadataProcessorStatusSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<ProcessorMetadataProcessorStatusOrderBy>>;\n  where?: InputMaybe<ProcessorMetadataProcessorStatusBoolExp>;\n};\n\nexport type QueryRootProcessorMetadataProcessorStatusAggregateArgs = {\n  distinct_on?: InputMaybe<Array<ProcessorMetadataProcessorStatusSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<ProcessorMetadataProcessorStatusOrderBy>>;\n  where?: InputMaybe<ProcessorMetadataProcessorStatusBoolExp>;\n};\n\nexport type QueryRootProcessorMetadataProcessorStatusByPkArgs = {\n  processor: Scalars[\"String\"][\"input\"];\n};\n\nexport type QueryRootProcessorStatusArgs = {\n  distinct_on?: InputMaybe<Array<ProcessorStatusSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<ProcessorStatusOrderBy>>;\n  where?: InputMaybe<ProcessorStatusBoolExp>;\n};\n\nexport type QueryRootProcessorStatusAggregateArgs = {\n  distinct_on?: InputMaybe<Array<ProcessorStatusSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<ProcessorStatusOrderBy>>;\n  where?: InputMaybe<ProcessorStatusBoolExp>;\n};\n\nexport type QueryRootProcessorStatusByPkArgs = {\n  processor: Scalars[\"String\"][\"input\"];\n};\n\nexport type QueryRootProposalVotesArgs = {\n  distinct_on?: InputMaybe<Array<ProposalVotesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<ProposalVotesOrderBy>>;\n  where?: InputMaybe<ProposalVotesBoolExp>;\n};\n\nexport type QueryRootProposalVotesAggregateArgs = {\n  distinct_on?: InputMaybe<Array<ProposalVotesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<ProposalVotesOrderBy>>;\n  where?: InputMaybe<ProposalVotesBoolExp>;\n};\n\nexport type QueryRootProposalVotesByPkArgs = {\n  proposal_id: Scalars[\"bigint\"][\"input\"];\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n  voter_address: Scalars[\"String\"][\"input\"];\n};\n\nexport type QueryRootPublicKeyAuthKeysArgs = {\n  distinct_on?: InputMaybe<Array<PublicKeyAuthKeysSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<PublicKeyAuthKeysOrderBy>>;\n  where?: InputMaybe<PublicKeyAuthKeysBoolExp>;\n};\n\nexport type QueryRootPublicKeyAuthKeysAggregateArgs = {\n  distinct_on?: InputMaybe<Array<PublicKeyAuthKeysSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<PublicKeyAuthKeysOrderBy>>;\n  where?: InputMaybe<PublicKeyAuthKeysBoolExp>;\n};\n\nexport type QueryRootPublicKeyAuthKeysByPkArgs = {\n  auth_key: Scalars[\"String\"][\"input\"];\n  public_key: Scalars[\"String\"][\"input\"];\n  public_key_type: Scalars[\"String\"][\"input\"];\n};\n\nexport type QueryRootSignaturesArgs = {\n  distinct_on?: InputMaybe<Array<SignaturesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<SignaturesOrderBy>>;\n  where?: InputMaybe<SignaturesBoolExp>;\n};\n\nexport type QueryRootSignaturesAggregateArgs = {\n  distinct_on?: InputMaybe<Array<SignaturesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<SignaturesOrderBy>>;\n  where?: InputMaybe<SignaturesBoolExp>;\n};\n\nexport type QueryRootSignaturesByPkArgs = {\n  is_sender_primary: Scalars[\"Boolean\"][\"input\"];\n  multi_agent_index: Scalars[\"bigint\"][\"input\"];\n  multi_sig_index: Scalars[\"bigint\"][\"input\"];\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\nexport type QueryRootSpamAssetsArgs = {\n  distinct_on?: InputMaybe<Array<SpamAssetsSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<SpamAssetsOrderBy>>;\n  where?: InputMaybe<SpamAssetsBoolExp>;\n};\n\nexport type QueryRootSpamAssetsAggregateArgs = {\n  distinct_on?: InputMaybe<Array<SpamAssetsSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<SpamAssetsOrderBy>>;\n  where?: InputMaybe<SpamAssetsBoolExp>;\n};\n\nexport type QueryRootSpamAssetsByPkArgs = {\n  asset: Scalars[\"String\"][\"input\"];\n};\n\nexport type QueryRootTableItemsArgs = {\n  distinct_on?: InputMaybe<Array<TableItemsSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<TableItemsOrderBy>>;\n  where?: InputMaybe<TableItemsBoolExp>;\n};\n\nexport type QueryRootTableItemsAggregateArgs = {\n  distinct_on?: InputMaybe<Array<TableItemsSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<TableItemsOrderBy>>;\n  where?: InputMaybe<TableItemsBoolExp>;\n};\n\nexport type QueryRootTableItemsByPkArgs = {\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n  write_set_change_index: Scalars[\"bigint\"][\"input\"];\n};\n\nexport type QueryRootTableItemsViewArgs = {\n  distinct_on?: InputMaybe<Array<TableItemsViewSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<TableItemsViewOrderBy>>;\n  where?: InputMaybe<TableItemsViewBoolExp>;\n};\n\nexport type QueryRootTableItemsViewAggregateArgs = {\n  distinct_on?: InputMaybe<Array<TableItemsViewSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<TableItemsViewOrderBy>>;\n  where?: InputMaybe<TableItemsViewBoolExp>;\n};\n\nexport type QueryRootTableMetadatasArgs = {\n  distinct_on?: InputMaybe<Array<TableMetadatasSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<TableMetadatasOrderBy>>;\n  where?: InputMaybe<TableMetadatasBoolExp>;\n};\n\nexport type QueryRootTableMetadatasAggregateArgs = {\n  distinct_on?: InputMaybe<Array<TableMetadatasSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<TableMetadatasOrderBy>>;\n  where?: InputMaybe<TableMetadatasBoolExp>;\n};\n\nexport type QueryRootTableMetadatasByPkArgs = {\n  handle: Scalars[\"String\"][\"input\"];\n};\n\nexport type QueryRootTokenActivitiesArgs = {\n  distinct_on?: InputMaybe<Array<TokenActivitiesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<TokenActivitiesOrderBy>>;\n  where?: InputMaybe<TokenActivitiesBoolExp>;\n};\n\nexport type QueryRootTokenActivitiesAggregateArgs = {\n  distinct_on?: InputMaybe<Array<TokenActivitiesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<TokenActivitiesOrderBy>>;\n  where?: InputMaybe<TokenActivitiesBoolExp>;\n};\n\nexport type QueryRootTokenActivitiesByPkArgs = {\n  event_account_address: Scalars[\"String\"][\"input\"];\n  event_creation_number: Scalars[\"bigint\"][\"input\"];\n  event_sequence_number: Scalars[\"bigint\"][\"input\"];\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\nexport type QueryRootTokenActivitiesV2Args = {\n  distinct_on?: InputMaybe<Array<TokenActivitiesV2SelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<TokenActivitiesV2OrderBy>>;\n  where?: InputMaybe<TokenActivitiesV2BoolExp>;\n};\n\nexport type QueryRootTokenActivitiesV2AggregateArgs = {\n  distinct_on?: InputMaybe<Array<TokenActivitiesV2SelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<TokenActivitiesV2OrderBy>>;\n  where?: InputMaybe<TokenActivitiesV2BoolExp>;\n};\n\nexport type QueryRootTokenActivitiesV2ByPkArgs = {\n  event_index: Scalars[\"bigint\"][\"input\"];\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\nexport type QueryRootTokenDatasArgs = {\n  distinct_on?: InputMaybe<Array<TokenDatasSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<TokenDatasOrderBy>>;\n  where?: InputMaybe<TokenDatasBoolExp>;\n};\n\nexport type QueryRootTokenDatasAggregateArgs = {\n  distinct_on?: InputMaybe<Array<TokenDatasSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<TokenDatasOrderBy>>;\n  where?: InputMaybe<TokenDatasBoolExp>;\n};\n\nexport type QueryRootTokenDatasByPkArgs = {\n  token_data_id_hash: Scalars[\"String\"][\"input\"];\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\nexport type QueryRootTokenDatasV2Args = {\n  distinct_on?: InputMaybe<Array<TokenDatasV2SelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<TokenDatasV2OrderBy>>;\n  where?: InputMaybe<TokenDatasV2BoolExp>;\n};\n\nexport type QueryRootTokenDatasV2AggregateArgs = {\n  distinct_on?: InputMaybe<Array<TokenDatasV2SelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<TokenDatasV2OrderBy>>;\n  where?: InputMaybe<TokenDatasV2BoolExp>;\n};\n\nexport type QueryRootTokenDatasV2ByPkArgs = {\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n  write_set_change_index: Scalars[\"bigint\"][\"input\"];\n};\n\nexport type QueryRootTokenOwnershipsArgs = {\n  distinct_on?: InputMaybe<Array<TokenOwnershipsSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<TokenOwnershipsOrderBy>>;\n  where?: InputMaybe<TokenOwnershipsBoolExp>;\n};\n\nexport type QueryRootTokenOwnershipsAggregateArgs = {\n  distinct_on?: InputMaybe<Array<TokenOwnershipsSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<TokenOwnershipsOrderBy>>;\n  where?: InputMaybe<TokenOwnershipsBoolExp>;\n};\n\nexport type QueryRootTokenOwnershipsByPkArgs = {\n  property_version: Scalars[\"numeric\"][\"input\"];\n  table_handle: Scalars[\"String\"][\"input\"];\n  token_data_id_hash: Scalars[\"String\"][\"input\"];\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\nexport type QueryRootTokenOwnershipsV2Args = {\n  distinct_on?: InputMaybe<Array<TokenOwnershipsV2SelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<TokenOwnershipsV2OrderBy>>;\n  where?: InputMaybe<TokenOwnershipsV2BoolExp>;\n};\n\nexport type QueryRootTokenOwnershipsV2AggregateArgs = {\n  distinct_on?: InputMaybe<Array<TokenOwnershipsV2SelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<TokenOwnershipsV2OrderBy>>;\n  where?: InputMaybe<TokenOwnershipsV2BoolExp>;\n};\n\nexport type QueryRootTokenOwnershipsV2ByPkArgs = {\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n  write_set_change_index: Scalars[\"bigint\"][\"input\"];\n};\n\nexport type QueryRootTokensArgs = {\n  distinct_on?: InputMaybe<Array<TokensSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<TokensOrderBy>>;\n  where?: InputMaybe<TokensBoolExp>;\n};\n\nexport type QueryRootTokensAggregateArgs = {\n  distinct_on?: InputMaybe<Array<TokensSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<TokensOrderBy>>;\n  where?: InputMaybe<TokensBoolExp>;\n};\n\nexport type QueryRootTokensByPkArgs = {\n  property_version: Scalars[\"numeric\"][\"input\"];\n  token_data_id_hash: Scalars[\"String\"][\"input\"];\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\nexport type QueryRootTransactionSizeInfoArgs = {\n  distinct_on?: InputMaybe<Array<TransactionSizeInfoSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<TransactionSizeInfoOrderBy>>;\n  where?: InputMaybe<TransactionSizeInfoBoolExp>;\n};\n\nexport type QueryRootTransactionSizeInfoAggregateArgs = {\n  distinct_on?: InputMaybe<Array<TransactionSizeInfoSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<TransactionSizeInfoOrderBy>>;\n  where?: InputMaybe<TransactionSizeInfoBoolExp>;\n};\n\nexport type QueryRootTransactionSizeInfoByPkArgs = {\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\nexport type QueryRootTransactionsViewArgs = {\n  distinct_on?: InputMaybe<Array<TransactionsViewSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<TransactionsViewOrderBy>>;\n  where?: InputMaybe<TransactionsViewBoolExp>;\n};\n\nexport type QueryRootTransactionsViewAggregateArgs = {\n  distinct_on?: InputMaybe<Array<TransactionsViewSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<TransactionsViewOrderBy>>;\n  where?: InputMaybe<TransactionsViewBoolExp>;\n};\n\nexport type QueryRootUserTransactionsArgs = {\n  distinct_on?: InputMaybe<Array<UserTransactionsSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<UserTransactionsOrderBy>>;\n  where?: InputMaybe<UserTransactionsBoolExp>;\n};\n\nexport type QueryRootUserTransactionsAggregateArgs = {\n  distinct_on?: InputMaybe<Array<UserTransactionsSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<UserTransactionsOrderBy>>;\n  where?: InputMaybe<UserTransactionsBoolExp>;\n};\n\nexport type QueryRootUserTransactionsByPkArgs = {\n  version: Scalars[\"bigint\"][\"input\"];\n};\n\n/** columns and relationships of \"signatures\" */\nexport type Signatures = {\n  any_signature_type?: Maybe<Scalars[\"String\"][\"output\"]>;\n  inserted_at: Scalars[\"timestamp\"][\"output\"];\n  is_sender_primary: Scalars[\"Boolean\"][\"output\"];\n  multi_agent_index: Scalars[\"bigint\"][\"output\"];\n  multi_sig_index: Scalars[\"bigint\"][\"output\"];\n  public_key: Scalars[\"String\"][\"output\"];\n  public_key_indices: Scalars[\"jsonb\"][\"output\"];\n  public_key_type?: Maybe<Scalars[\"String\"][\"output\"]>;\n  signature: Scalars[\"String\"][\"output\"];\n  signer: Scalars[\"String\"][\"output\"];\n  threshold: Scalars[\"bigint\"][\"output\"];\n  transaction_block_height: Scalars[\"bigint\"][\"output\"];\n  transaction_version: Scalars[\"bigint\"][\"output\"];\n  type: Scalars[\"String\"][\"output\"];\n};\n\n/** columns and relationships of \"signatures\" */\nexport type SignaturesPublicKeyIndicesArgs = {\n  path?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregated selection of \"signatures\" */\nexport type SignaturesAggregate = {\n  aggregate?: Maybe<SignaturesAggregateFields>;\n  nodes: Array<Signatures>;\n};\n\n/** aggregate fields of \"signatures\" */\nexport type SignaturesAggregateFields = {\n  avg?: Maybe<SignaturesAvgFields>;\n  count: Scalars[\"Int\"][\"output\"];\n  max?: Maybe<SignaturesMaxFields>;\n  min?: Maybe<SignaturesMinFields>;\n  stddev?: Maybe<SignaturesStddevFields>;\n  stddev_pop?: Maybe<SignaturesStddevPopFields>;\n  stddev_samp?: Maybe<SignaturesStddevSampFields>;\n  sum?: Maybe<SignaturesSumFields>;\n  var_pop?: Maybe<SignaturesVarPopFields>;\n  var_samp?: Maybe<SignaturesVarSampFields>;\n  variance?: Maybe<SignaturesVarianceFields>;\n};\n\n/** aggregate fields of \"signatures\" */\nexport type SignaturesAggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<SignaturesSelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** append existing jsonb value of filtered columns with new jsonb value */\nexport type SignaturesAppendInput = {\n  public_key_indices?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n};\n\n/** aggregate avg on columns */\nexport type SignaturesAvgFields = {\n  multi_agent_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  multi_sig_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  threshold?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Boolean expression to filter rows from the table \"signatures\". All fields are combined with a logical 'AND'. */\nexport type SignaturesBoolExp = {\n  _and?: InputMaybe<Array<SignaturesBoolExp>>;\n  _not?: InputMaybe<SignaturesBoolExp>;\n  _or?: InputMaybe<Array<SignaturesBoolExp>>;\n  any_signature_type?: InputMaybe<StringComparisonExp>;\n  inserted_at?: InputMaybe<TimestampComparisonExp>;\n  is_sender_primary?: InputMaybe<BooleanComparisonExp>;\n  multi_agent_index?: InputMaybe<BigintComparisonExp>;\n  multi_sig_index?: InputMaybe<BigintComparisonExp>;\n  public_key?: InputMaybe<StringComparisonExp>;\n  public_key_indices?: InputMaybe<JsonbComparisonExp>;\n  public_key_type?: InputMaybe<StringComparisonExp>;\n  signature?: InputMaybe<StringComparisonExp>;\n  signer?: InputMaybe<StringComparisonExp>;\n  threshold?: InputMaybe<BigintComparisonExp>;\n  transaction_block_height?: InputMaybe<BigintComparisonExp>;\n  transaction_version?: InputMaybe<BigintComparisonExp>;\n  type?: InputMaybe<StringComparisonExp>;\n};\n\n/** unique or primary key constraints on table \"signatures\" */\nexport enum SignaturesConstraint {\n  /** unique or primary key constraint on columns \"multi_agent_index\", \"is_sender_primary\", \"transaction_version\", \"multi_sig_index\" */\n  SignaturesPkey = \"signatures_pkey\",\n}\n\n/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */\nexport type SignaturesDeleteAtPathInput = {\n  public_key_indices?: InputMaybe<Array<Scalars[\"String\"][\"input\"]>>;\n};\n\n/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */\nexport type SignaturesDeleteElemInput = {\n  public_key_indices?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n};\n\n/** delete key/value pair or string element. key/value pairs are matched based on their key value */\nexport type SignaturesDeleteKeyInput = {\n  public_key_indices?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** input type for incrementing numeric columns in table \"signatures\" */\nexport type SignaturesIncInput = {\n  multi_agent_index?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  multi_sig_index?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  threshold?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  transaction_block_height?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** input type for inserting data into table \"signatures\" */\nexport type SignaturesInsertInput = {\n  any_signature_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  is_sender_primary?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  multi_agent_index?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  multi_sig_index?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  public_key?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  public_key_indices?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  public_key_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  signature?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  signer?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  threshold?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  transaction_block_height?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate max on columns */\nexport type SignaturesMaxFields = {\n  any_signature_type?: Maybe<Scalars[\"String\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  multi_agent_index?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  multi_sig_index?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  public_key?: Maybe<Scalars[\"String\"][\"output\"]>;\n  public_key_type?: Maybe<Scalars[\"String\"][\"output\"]>;\n  signature?: Maybe<Scalars[\"String\"][\"output\"]>;\n  signer?: Maybe<Scalars[\"String\"][\"output\"]>;\n  threshold?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  transaction_block_height?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  type?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** aggregate min on columns */\nexport type SignaturesMinFields = {\n  any_signature_type?: Maybe<Scalars[\"String\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  multi_agent_index?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  multi_sig_index?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  public_key?: Maybe<Scalars[\"String\"][\"output\"]>;\n  public_key_type?: Maybe<Scalars[\"String\"][\"output\"]>;\n  signature?: Maybe<Scalars[\"String\"][\"output\"]>;\n  signer?: Maybe<Scalars[\"String\"][\"output\"]>;\n  threshold?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  transaction_block_height?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  type?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** response of any mutation on the table \"signatures\" */\nexport type SignaturesMutationResponse = {\n  /** number of rows affected by the mutation */\n  affected_rows: Scalars[\"Int\"][\"output\"];\n  /** data from the rows affected by the mutation */\n  returning: Array<Signatures>;\n};\n\n/** on_conflict condition type for table \"signatures\" */\nexport type SignaturesOnConflict = {\n  constraint: SignaturesConstraint;\n  update_columns?: Array<SignaturesUpdateColumn>;\n  where?: InputMaybe<SignaturesBoolExp>;\n};\n\n/** Ordering options when selecting data from \"signatures\". */\nexport type SignaturesOrderBy = {\n  any_signature_type?: InputMaybe<OrderBy>;\n  inserted_at?: InputMaybe<OrderBy>;\n  is_sender_primary?: InputMaybe<OrderBy>;\n  multi_agent_index?: InputMaybe<OrderBy>;\n  multi_sig_index?: InputMaybe<OrderBy>;\n  public_key?: InputMaybe<OrderBy>;\n  public_key_indices?: InputMaybe<OrderBy>;\n  public_key_type?: InputMaybe<OrderBy>;\n  signature?: InputMaybe<OrderBy>;\n  signer?: InputMaybe<OrderBy>;\n  threshold?: InputMaybe<OrderBy>;\n  transaction_block_height?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n  type?: InputMaybe<OrderBy>;\n};\n\n/** primary key columns input for table: signatures */\nexport type SignaturesPkColumnsInput = {\n  is_sender_primary: Scalars[\"Boolean\"][\"input\"];\n  multi_agent_index: Scalars[\"bigint\"][\"input\"];\n  multi_sig_index: Scalars[\"bigint\"][\"input\"];\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\n/** prepend existing jsonb value of filtered columns with new jsonb value */\nexport type SignaturesPrependInput = {\n  public_key_indices?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n};\n\n/** select columns of table \"signatures\" */\nexport enum SignaturesSelectColumn {\n  /** column name */\n  AnySignatureType = \"any_signature_type\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  IsSenderPrimary = \"is_sender_primary\",\n  /** column name */\n  MultiAgentIndex = \"multi_agent_index\",\n  /** column name */\n  MultiSigIndex = \"multi_sig_index\",\n  /** column name */\n  PublicKey = \"public_key\",\n  /** column name */\n  PublicKeyIndices = \"public_key_indices\",\n  /** column name */\n  PublicKeyType = \"public_key_type\",\n  /** column name */\n  Signature = \"signature\",\n  /** column name */\n  Signer = \"signer\",\n  /** column name */\n  Threshold = \"threshold\",\n  /** column name */\n  TransactionBlockHeight = \"transaction_block_height\",\n  /** column name */\n  TransactionVersion = \"transaction_version\",\n  /** column name */\n  Type = \"type\",\n}\n\n/** input type for updating data in table \"signatures\" */\nexport type SignaturesSetInput = {\n  any_signature_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  is_sender_primary?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  multi_agent_index?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  multi_sig_index?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  public_key?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  public_key_indices?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  public_key_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  signature?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  signer?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  threshold?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  transaction_block_height?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate stddev on columns */\nexport type SignaturesStddevFields = {\n  multi_agent_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  multi_sig_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  threshold?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_pop on columns */\nexport type SignaturesStddevPopFields = {\n  multi_agent_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  multi_sig_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  threshold?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_samp on columns */\nexport type SignaturesStddevSampFields = {\n  multi_agent_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  multi_sig_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  threshold?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Streaming cursor of the table \"signatures\" */\nexport type SignaturesStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: SignaturesStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type SignaturesStreamCursorValueInput = {\n  any_signature_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  is_sender_primary?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  multi_agent_index?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  multi_sig_index?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  public_key?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  public_key_indices?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  public_key_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  signature?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  signer?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  threshold?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  transaction_block_height?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate sum on columns */\nexport type SignaturesSumFields = {\n  multi_agent_index?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  multi_sig_index?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  threshold?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  transaction_block_height?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** update columns of table \"signatures\" */\nexport enum SignaturesUpdateColumn {\n  /** column name */\n  AnySignatureType = \"any_signature_type\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  IsSenderPrimary = \"is_sender_primary\",\n  /** column name */\n  MultiAgentIndex = \"multi_agent_index\",\n  /** column name */\n  MultiSigIndex = \"multi_sig_index\",\n  /** column name */\n  PublicKey = \"public_key\",\n  /** column name */\n  PublicKeyIndices = \"public_key_indices\",\n  /** column name */\n  PublicKeyType = \"public_key_type\",\n  /** column name */\n  Signature = \"signature\",\n  /** column name */\n  Signer = \"signer\",\n  /** column name */\n  Threshold = \"threshold\",\n  /** column name */\n  TransactionBlockHeight = \"transaction_block_height\",\n  /** column name */\n  TransactionVersion = \"transaction_version\",\n  /** column name */\n  Type = \"type\",\n}\n\nexport type SignaturesUpdates = {\n  /** append existing jsonb value of filtered columns with new jsonb value */\n  _append?: InputMaybe<SignaturesAppendInput>;\n  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */\n  _delete_at_path?: InputMaybe<SignaturesDeleteAtPathInput>;\n  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */\n  _delete_elem?: InputMaybe<SignaturesDeleteElemInput>;\n  /** delete key/value pair or string element. key/value pairs are matched based on their key value */\n  _delete_key?: InputMaybe<SignaturesDeleteKeyInput>;\n  /** increments the numeric columns with given value of the filtered values */\n  _inc?: InputMaybe<SignaturesIncInput>;\n  /** prepend existing jsonb value of filtered columns with new jsonb value */\n  _prepend?: InputMaybe<SignaturesPrependInput>;\n  /** sets the columns of the filtered rows to the given values */\n  _set?: InputMaybe<SignaturesSetInput>;\n  /** filter the rows which have to be updated */\n  where: SignaturesBoolExp;\n};\n\n/** aggregate var_pop on columns */\nexport type SignaturesVarPopFields = {\n  multi_agent_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  multi_sig_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  threshold?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate var_samp on columns */\nexport type SignaturesVarSampFields = {\n  multi_agent_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  multi_sig_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  threshold?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate variance on columns */\nexport type SignaturesVarianceFields = {\n  multi_agent_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  multi_sig_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  threshold?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** columns and relationships of \"spam_assets\" */\nexport type SpamAssets = {\n  asset: Scalars[\"String\"][\"output\"];\n  is_spam: Scalars[\"Boolean\"][\"output\"];\n  last_updated: Scalars[\"timestamp\"][\"output\"];\n};\n\n/** aggregated selection of \"spam_assets\" */\nexport type SpamAssetsAggregate = {\n  aggregate?: Maybe<SpamAssetsAggregateFields>;\n  nodes: Array<SpamAssets>;\n};\n\n/** aggregate fields of \"spam_assets\" */\nexport type SpamAssetsAggregateFields = {\n  count: Scalars[\"Int\"][\"output\"];\n  max?: Maybe<SpamAssetsMaxFields>;\n  min?: Maybe<SpamAssetsMinFields>;\n};\n\n/** aggregate fields of \"spam_assets\" */\nexport type SpamAssetsAggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<SpamAssetsSelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** Boolean expression to filter rows from the table \"spam_assets\". All fields are combined with a logical 'AND'. */\nexport type SpamAssetsBoolExp = {\n  _and?: InputMaybe<Array<SpamAssetsBoolExp>>;\n  _not?: InputMaybe<SpamAssetsBoolExp>;\n  _or?: InputMaybe<Array<SpamAssetsBoolExp>>;\n  asset?: InputMaybe<StringComparisonExp>;\n  is_spam?: InputMaybe<BooleanComparisonExp>;\n  last_updated?: InputMaybe<TimestampComparisonExp>;\n};\n\n/** unique or primary key constraints on table \"spam_assets\" */\nexport enum SpamAssetsConstraint {\n  /** unique or primary key constraint on columns \"asset\" */\n  SpamAssetsPkey = \"spam_assets_pkey\",\n}\n\n/** input type for inserting data into table \"spam_assets\" */\nexport type SpamAssetsInsertInput = {\n  asset?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  is_spam?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  last_updated?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n};\n\n/** aggregate max on columns */\nexport type SpamAssetsMaxFields = {\n  asset?: Maybe<Scalars[\"String\"][\"output\"]>;\n  last_updated?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n};\n\n/** aggregate min on columns */\nexport type SpamAssetsMinFields = {\n  asset?: Maybe<Scalars[\"String\"][\"output\"]>;\n  last_updated?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n};\n\n/** response of any mutation on the table \"spam_assets\" */\nexport type SpamAssetsMutationResponse = {\n  /** number of rows affected by the mutation */\n  affected_rows: Scalars[\"Int\"][\"output\"];\n  /** data from the rows affected by the mutation */\n  returning: Array<SpamAssets>;\n};\n\n/** on_conflict condition type for table \"spam_assets\" */\nexport type SpamAssetsOnConflict = {\n  constraint: SpamAssetsConstraint;\n  update_columns?: Array<SpamAssetsUpdateColumn>;\n  where?: InputMaybe<SpamAssetsBoolExp>;\n};\n\n/** Ordering options when selecting data from \"spam_assets\". */\nexport type SpamAssetsOrderBy = {\n  asset?: InputMaybe<OrderBy>;\n  is_spam?: InputMaybe<OrderBy>;\n  last_updated?: InputMaybe<OrderBy>;\n};\n\n/** primary key columns input for table: spam_assets */\nexport type SpamAssetsPkColumnsInput = {\n  asset: Scalars[\"String\"][\"input\"];\n};\n\n/** select columns of table \"spam_assets\" */\nexport enum SpamAssetsSelectColumn {\n  /** column name */\n  Asset = \"asset\",\n  /** column name */\n  IsSpam = \"is_spam\",\n  /** column name */\n  LastUpdated = \"last_updated\",\n}\n\n/** input type for updating data in table \"spam_assets\" */\nexport type SpamAssetsSetInput = {\n  asset?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  is_spam?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  last_updated?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n};\n\n/** Streaming cursor of the table \"spam_assets\" */\nexport type SpamAssetsStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: SpamAssetsStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type SpamAssetsStreamCursorValueInput = {\n  asset?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  is_spam?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  last_updated?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n};\n\n/** update columns of table \"spam_assets\" */\nexport enum SpamAssetsUpdateColumn {\n  /** column name */\n  Asset = \"asset\",\n  /** column name */\n  IsSpam = \"is_spam\",\n  /** column name */\n  LastUpdated = \"last_updated\",\n}\n\nexport type SpamAssetsUpdates = {\n  /** sets the columns of the filtered rows to the given values */\n  _set?: InputMaybe<SpamAssetsSetInput>;\n  /** filter the rows which have to be updated */\n  where: SpamAssetsBoolExp;\n};\n\nexport type SubscriptionRoot = {\n  /** fetch data from the table: \"account_transactions\" */\n  account_transactions: Array<AccountTransactions>;\n  /** fetch aggregated fields from the table: \"account_transactions\" */\n  account_transactions_aggregate: AccountTransactionsAggregate;\n  /** fetch data from the table: \"account_transactions\" using primary key columns */\n  account_transactions_by_pk?: Maybe<AccountTransactions>;\n  /** fetch data from the table in a streaming manner: \"account_transactions\" */\n  account_transactions_stream: Array<AccountTransactions>;\n  /** fetch data from the table: \"address_events_summary\" */\n  address_events_summary: Array<AddressEventsSummary>;\n  /** fetch aggregated fields from the table: \"address_events_summary\" */\n  address_events_summary_aggregate: AddressEventsSummaryAggregate;\n  /** fetch data from the table in a streaming manner: \"address_events_summary\" */\n  address_events_summary_stream: Array<AddressEventsSummary>;\n  /** fetch data from the table: \"address_version_from_events\" */\n  address_version_from_events: Array<AddressVersionFromEvents>;\n  /** fetch aggregated fields from the table: \"address_version_from_events\" */\n  address_version_from_events_aggregate: AddressVersionFromEventsAggregate;\n  /** fetch data from the table in a streaming manner: \"address_version_from_events\" */\n  address_version_from_events_stream: Array<AddressVersionFromEvents>;\n  /** fetch data from the table: \"address_version_from_move_resources\" */\n  address_version_from_move_resources: Array<AddressVersionFromMoveResources>;\n  /** fetch aggregated fields from the table: \"address_version_from_move_resources\" */\n  address_version_from_move_resources_aggregate: AddressVersionFromMoveResourcesAggregate;\n  /** fetch data from the table in a streaming manner: \"address_version_from_move_resources\" */\n  address_version_from_move_resources_stream: Array<AddressVersionFromMoveResources>;\n  /** fetch data from the table: \"ans_lookup\" */\n  ans_lookup: Array<AnsLookup>;\n  /** fetch aggregated fields from the table: \"ans_lookup\" */\n  ans_lookup_aggregate: AnsLookupAggregate;\n  /** fetch data from the table: \"ans_lookup\" using primary key columns */\n  ans_lookup_by_pk?: Maybe<AnsLookup>;\n  /** fetch data from the table in a streaming manner: \"ans_lookup\" */\n  ans_lookup_stream: Array<AnsLookup>;\n  /** fetch data from the table: \"ans_lookup_v2\" */\n  ans_lookup_v2: Array<AnsLookupV2>;\n  /** fetch aggregated fields from the table: \"ans_lookup_v2\" */\n  ans_lookup_v2_aggregate: AnsLookupV2Aggregate;\n  /** fetch data from the table: \"ans_lookup_v2\" using primary key columns */\n  ans_lookup_v2_by_pk?: Maybe<AnsLookupV2>;\n  /** fetch data from the table in a streaming manner: \"ans_lookup_v2\" */\n  ans_lookup_v2_stream: Array<AnsLookupV2>;\n  /** fetch data from the table: \"ans_primary_name\" */\n  ans_primary_name: Array<AnsPrimaryName>;\n  /** fetch aggregated fields from the table: \"ans_primary_name\" */\n  ans_primary_name_aggregate: AnsPrimaryNameAggregate;\n  /** fetch data from the table: \"ans_primary_name\" using primary key columns */\n  ans_primary_name_by_pk?: Maybe<AnsPrimaryName>;\n  /** fetch data from the table in a streaming manner: \"ans_primary_name\" */\n  ans_primary_name_stream: Array<AnsPrimaryName>;\n  /** fetch data from the table: \"ans_primary_name_v2\" */\n  ans_primary_name_v2: Array<AnsPrimaryNameV2>;\n  /** fetch aggregated fields from the table: \"ans_primary_name_v2\" */\n  ans_primary_name_v2_aggregate: AnsPrimaryNameV2Aggregate;\n  /** fetch data from the table: \"ans_primary_name_v2\" using primary key columns */\n  ans_primary_name_v2_by_pk?: Maybe<AnsPrimaryNameV2>;\n  /** fetch data from the table in a streaming manner: \"ans_primary_name_v2\" */\n  ans_primary_name_v2_stream: Array<AnsPrimaryNameV2>;\n  /** fetch data from the table: \"auth_key_account_addresses\" */\n  auth_key_account_addresses: Array<AuthKeyAccountAddresses>;\n  /** fetch aggregated fields from the table: \"auth_key_account_addresses\" */\n  auth_key_account_addresses_aggregate: AuthKeyAccountAddressesAggregate;\n  /** fetch data from the table: \"auth_key_account_addresses\" using primary key columns */\n  auth_key_account_addresses_by_pk?: Maybe<AuthKeyAccountAddresses>;\n  /** fetch data from the table in a streaming manner: \"auth_key_account_addresses\" */\n  auth_key_account_addresses_stream: Array<AuthKeyAccountAddresses>;\n  /** fetch data from the table: \"block_metadata_transactions\" */\n  block_metadata_transactions: Array<BlockMetadataTransactions>;\n  /** fetch aggregated fields from the table: \"block_metadata_transactions\" */\n  block_metadata_transactions_aggregate: BlockMetadataTransactionsAggregate;\n  /** fetch data from the table: \"block_metadata_transactions\" using primary key columns */\n  block_metadata_transactions_by_pk?: Maybe<BlockMetadataTransactions>;\n  /** fetch data from the table in a streaming manner: \"block_metadata_transactions\" */\n  block_metadata_transactions_stream: Array<BlockMetadataTransactions>;\n  /** fetch data from the table: \"coin_activities\" */\n  coin_activities: Array<CoinActivities>;\n  /** fetch aggregated fields from the table: \"coin_activities\" */\n  coin_activities_aggregate: CoinActivitiesAggregate;\n  /** fetch data from the table: \"coin_activities\" using primary key columns */\n  coin_activities_by_pk?: Maybe<CoinActivities>;\n  /** fetch data from the table in a streaming manner: \"coin_activities\" */\n  coin_activities_stream: Array<CoinActivities>;\n  /** fetch data from the table: \"coin_balances\" */\n  coin_balances: Array<CoinBalances>;\n  /** fetch aggregated fields from the table: \"coin_balances\" */\n  coin_balances_aggregate: CoinBalancesAggregate;\n  /** fetch data from the table: \"coin_balances\" using primary key columns */\n  coin_balances_by_pk?: Maybe<CoinBalances>;\n  /** fetch data from the table in a streaming manner: \"coin_balances\" */\n  coin_balances_stream: Array<CoinBalances>;\n  /** fetch data from the table: \"coin_infos\" */\n  coin_infos: Array<CoinInfos>;\n  /** fetch aggregated fields from the table: \"coin_infos\" */\n  coin_infos_aggregate: CoinInfosAggregate;\n  /** fetch data from the table: \"coin_infos\" using primary key columns */\n  coin_infos_by_pk?: Maybe<CoinInfos>;\n  /** fetch data from the table in a streaming manner: \"coin_infos\" */\n  coin_infos_stream: Array<CoinInfos>;\n  /** fetch data from the table: \"coin_supply\" */\n  coin_supply: Array<CoinSupply>;\n  /** fetch aggregated fields from the table: \"coin_supply\" */\n  coin_supply_aggregate: CoinSupplyAggregate;\n  /** fetch data from the table: \"coin_supply\" using primary key columns */\n  coin_supply_by_pk?: Maybe<CoinSupply>;\n  /** fetch data from the table in a streaming manner: \"coin_supply\" */\n  coin_supply_stream: Array<CoinSupply>;\n  /** fetch data from the table: \"collection_datas\" */\n  collection_datas: Array<CollectionDatas>;\n  /** fetch aggregated fields from the table: \"collection_datas\" */\n  collection_datas_aggregate: CollectionDatasAggregate;\n  /** fetch data from the table: \"collection_datas\" using primary key columns */\n  collection_datas_by_pk?: Maybe<CollectionDatas>;\n  /** fetch data from the table in a streaming manner: \"collection_datas\" */\n  collection_datas_stream: Array<CollectionDatas>;\n  /** fetch data from the table: \"collections_v2\" */\n  collections_v2: Array<CollectionsV2>;\n  /** fetch aggregated fields from the table: \"collections_v2\" */\n  collections_v2_aggregate: CollectionsV2Aggregate;\n  /** fetch data from the table: \"collections_v2\" using primary key columns */\n  collections_v2_by_pk?: Maybe<CollectionsV2>;\n  /** fetch data from the table in a streaming manner: \"collections_v2\" */\n  collections_v2_stream: Array<CollectionsV2>;\n  /** fetch data from the table: \"current_ans_lookup\" */\n  current_ans_lookup: Array<CurrentAnsLookup>;\n  /** fetch aggregated fields from the table: \"current_ans_lookup\" */\n  current_ans_lookup_aggregate: CurrentAnsLookupAggregate;\n  /** fetch data from the table: \"current_ans_lookup\" using primary key columns */\n  current_ans_lookup_by_pk?: Maybe<CurrentAnsLookup>;\n  /** fetch data from the table in a streaming manner: \"current_ans_lookup\" */\n  current_ans_lookup_stream: Array<CurrentAnsLookup>;\n  /** fetch data from the table: \"current_ans_lookup_v2\" */\n  current_ans_lookup_v2: Array<CurrentAnsLookupV2>;\n  /** fetch aggregated fields from the table: \"current_ans_lookup_v2\" */\n  current_ans_lookup_v2_aggregate: CurrentAnsLookupV2Aggregate;\n  /** fetch data from the table: \"current_ans_lookup_v2\" using primary key columns */\n  current_ans_lookup_v2_by_pk?: Maybe<CurrentAnsLookupV2>;\n  /** fetch data from the table in a streaming manner: \"current_ans_lookup_v2\" */\n  current_ans_lookup_v2_stream: Array<CurrentAnsLookupV2>;\n  /** fetch data from the table: \"current_ans_primary_name\" */\n  current_ans_primary_name: Array<CurrentAnsPrimaryName>;\n  /** fetch aggregated fields from the table: \"current_ans_primary_name\" */\n  current_ans_primary_name_aggregate: CurrentAnsPrimaryNameAggregate;\n  /** fetch data from the table: \"current_ans_primary_name\" using primary key columns */\n  current_ans_primary_name_by_pk?: Maybe<CurrentAnsPrimaryName>;\n  /** fetch data from the table in a streaming manner: \"current_ans_primary_name\" */\n  current_ans_primary_name_stream: Array<CurrentAnsPrimaryName>;\n  /** fetch data from the table: \"current_ans_primary_name_v2\" */\n  current_ans_primary_name_v2: Array<CurrentAnsPrimaryNameV2>;\n  /** fetch aggregated fields from the table: \"current_ans_primary_name_v2\" */\n  current_ans_primary_name_v2_aggregate: CurrentAnsPrimaryNameV2Aggregate;\n  /** fetch data from the table: \"current_ans_primary_name_v2\" using primary key columns */\n  current_ans_primary_name_v2_by_pk?: Maybe<CurrentAnsPrimaryNameV2>;\n  /** fetch data from the table in a streaming manner: \"current_ans_primary_name_v2\" */\n  current_ans_primary_name_v2_stream: Array<CurrentAnsPrimaryNameV2>;\n  /** fetch data from the table: \"current_cedra_names\" */\n  current_cedra_names: Array<CurrentCedraNames>;\n  /** fetch aggregated fields from the table: \"current_cedra_names\" */\n  current_cedra_names_aggregate: CurrentCedraNamesAggregate;\n  /** fetch data from the table in a streaming manner: \"current_cedra_names\" */\n  current_cedra_names_stream: Array<CurrentCedraNames>;\n  /** fetch data from the table: \"current_coin_balances\" */\n  current_coin_balances: Array<CurrentCoinBalances>;\n  /** fetch aggregated fields from the table: \"current_coin_balances\" */\n  current_coin_balances_aggregate: CurrentCoinBalancesAggregate;\n  /** fetch data from the table: \"current_coin_balances\" using primary key columns */\n  current_coin_balances_by_pk?: Maybe<CurrentCoinBalances>;\n  /** fetch data from the table in a streaming manner: \"current_coin_balances\" */\n  current_coin_balances_stream: Array<CurrentCoinBalances>;\n  /** fetch data from the table: \"current_collection_datas\" */\n  current_collection_datas: Array<CurrentCollectionDatas>;\n  /** fetch aggregated fields from the table: \"current_collection_datas\" */\n  current_collection_datas_aggregate: CurrentCollectionDatasAggregate;\n  /** fetch data from the table: \"current_collection_datas\" using primary key columns */\n  current_collection_datas_by_pk?: Maybe<CurrentCollectionDatas>;\n  /** fetch data from the table in a streaming manner: \"current_collection_datas\" */\n  current_collection_datas_stream: Array<CurrentCollectionDatas>;\n  /** fetch data from the table: \"current_collection_ownership_v2_view\" */\n  current_collection_ownership_v2_view: Array<CurrentCollectionOwnershipV2View>;\n  /** fetch aggregated fields from the table: \"current_collection_ownership_v2_view\" */\n  current_collection_ownership_v2_view_aggregate: CurrentCollectionOwnershipV2ViewAggregate;\n  /** fetch data from the table in a streaming manner: \"current_collection_ownership_v2_view\" */\n  current_collection_ownership_v2_view_stream: Array<CurrentCollectionOwnershipV2View>;\n  /** fetch data from the table: \"current_collection_ownership_view\" */\n  current_collection_ownership_view: Array<CurrentCollectionOwnershipView>;\n  /** fetch aggregated fields from the table: \"current_collection_ownership_view\" */\n  current_collection_ownership_view_aggregate: CurrentCollectionOwnershipViewAggregate;\n  /** fetch data from the table in a streaming manner: \"current_collection_ownership_view\" */\n  current_collection_ownership_view_stream: Array<CurrentCollectionOwnershipView>;\n  /** fetch data from the table: \"current_collections_v2\" */\n  current_collections_v2: Array<CurrentCollectionsV2>;\n  /** fetch aggregated fields from the table: \"current_collections_v2\" */\n  current_collections_v2_aggregate: CurrentCollectionsV2Aggregate;\n  /** fetch data from the table: \"current_collections_v2\" using primary key columns */\n  current_collections_v2_by_pk?: Maybe<CurrentCollectionsV2>;\n  /** fetch data from the table in a streaming manner: \"current_collections_v2\" */\n  current_collections_v2_stream: Array<CurrentCollectionsV2>;\n  /** fetch data from the table: \"current_delegated_staking_pool_balances\" */\n  current_delegated_staking_pool_balances: Array<CurrentDelegatedStakingPoolBalances>;\n  /** fetch aggregated fields from the table: \"current_delegated_staking_pool_balances\" */\n  current_delegated_staking_pool_balances_aggregate: CurrentDelegatedStakingPoolBalancesAggregate;\n  /** fetch data from the table: \"current_delegated_staking_pool_balances\" using primary key columns */\n  current_delegated_staking_pool_balances_by_pk?: Maybe<CurrentDelegatedStakingPoolBalances>;\n  /** fetch data from the table in a streaming manner: \"current_delegated_staking_pool_balances\" */\n  current_delegated_staking_pool_balances_stream: Array<CurrentDelegatedStakingPoolBalances>;\n  /** fetch data from the table: \"current_delegated_voter\" */\n  current_delegated_voter: Array<CurrentDelegatedVoter>;\n  /** fetch aggregated fields from the table: \"current_delegated_voter\" */\n  current_delegated_voter_aggregate: CurrentDelegatedVoterAggregate;\n  /** fetch data from the table: \"current_delegated_voter\" using primary key columns */\n  current_delegated_voter_by_pk?: Maybe<CurrentDelegatedVoter>;\n  /** fetch data from the table in a streaming manner: \"current_delegated_voter\" */\n  current_delegated_voter_stream: Array<CurrentDelegatedVoter>;\n  /** fetch data from the table: \"current_delegator_balances\" */\n  current_delegator_balances: Array<CurrentDelegatorBalances>;\n  /** fetch aggregated fields from the table: \"current_delegator_balances\" */\n  current_delegator_balances_aggregate: CurrentDelegatorBalancesAggregate;\n  /** fetch data from the table: \"current_delegator_balances\" using primary key columns */\n  current_delegator_balances_by_pk?: Maybe<CurrentDelegatorBalances>;\n  /** fetch data from the table in a streaming manner: \"current_delegator_balances\" */\n  current_delegator_balances_stream: Array<CurrentDelegatorBalances>;\n  /** fetch data from the table: \"current_fungible_asset_balances_legacy\" */\n  current_fungible_asset_balances: Array<CurrentFungibleAssetBalances>;\n  /** fetch aggregated fields from the table: \"current_fungible_asset_balances_legacy\" */\n  current_fungible_asset_balances_aggregate: CurrentFungibleAssetBalancesAggregate;\n  /** fetch data from the table: \"current_fungible_asset_balances_legacy\" using primary key columns */\n  current_fungible_asset_balances_by_pk?: Maybe<CurrentFungibleAssetBalances>;\n  /** fetch data from the table: \"current_fungible_asset_balances\" */\n  current_fungible_asset_balances_new: Array<CurrentFungibleAssetBalancesNew>;\n  /** fetch aggregated fields from the table: \"current_fungible_asset_balances\" */\n  current_fungible_asset_balances_new_aggregate: CurrentFungibleAssetBalancesNewAggregate;\n  /** fetch data from the table: \"current_fungible_asset_balances\" using primary key columns */\n  current_fungible_asset_balances_new_by_pk?: Maybe<CurrentFungibleAssetBalancesNew>;\n  /** fetch data from the table in a streaming manner: \"current_fungible_asset_balances\" */\n  current_fungible_asset_balances_new_stream: Array<CurrentFungibleAssetBalancesNew>;\n  /** fetch data from the table in a streaming manner: \"current_fungible_asset_balances_legacy\" */\n  current_fungible_asset_balances_stream: Array<CurrentFungibleAssetBalances>;\n  /** fetch data from the table: \"current_objects\" */\n  current_objects: Array<CurrentObjects>;\n  /** fetch aggregated fields from the table: \"current_objects\" */\n  current_objects_aggregate: CurrentObjectsAggregate;\n  /** fetch data from the table: \"current_objects\" using primary key columns */\n  current_objects_by_pk?: Maybe<CurrentObjects>;\n  /** fetch data from the table in a streaming manner: \"current_objects\" */\n  current_objects_stream: Array<CurrentObjects>;\n  /** fetch data from the table: \"current_staking_pool_voter\" */\n  current_staking_pool_voter: Array<CurrentStakingPoolVoter>;\n  /** fetch aggregated fields from the table: \"current_staking_pool_voter\" */\n  current_staking_pool_voter_aggregate: CurrentStakingPoolVoterAggregate;\n  /** fetch data from the table: \"current_staking_pool_voter\" using primary key columns */\n  current_staking_pool_voter_by_pk?: Maybe<CurrentStakingPoolVoter>;\n  /** fetch data from the table in a streaming manner: \"current_staking_pool_voter\" */\n  current_staking_pool_voter_stream: Array<CurrentStakingPoolVoter>;\n  /** fetch data from the table: \"current_table_items\" */\n  current_table_items: Array<CurrentTableItems>;\n  /** fetch aggregated fields from the table: \"current_table_items\" */\n  current_table_items_aggregate: CurrentTableItemsAggregate;\n  /** fetch data from the table: \"current_table_items\" using primary key columns */\n  current_table_items_by_pk?: Maybe<CurrentTableItems>;\n  /** fetch data from the table in a streaming manner: \"current_table_items\" */\n  current_table_items_stream: Array<CurrentTableItems>;\n  /** fetch data from the table: \"current_table_items_view\" */\n  current_table_items_view: Array<CurrentTableItemsView>;\n  /** fetch aggregated fields from the table: \"current_table_items_view\" */\n  current_table_items_view_aggregate: CurrentTableItemsViewAggregate;\n  /** fetch data from the table in a streaming manner: \"current_table_items_view\" */\n  current_table_items_view_stream: Array<CurrentTableItemsView>;\n  /** fetch data from the table: \"current_token_datas\" */\n  current_token_datas: Array<CurrentTokenDatas>;\n  /** fetch aggregated fields from the table: \"current_token_datas\" */\n  current_token_datas_aggregate: CurrentTokenDatasAggregate;\n  /** fetch data from the table: \"current_token_datas\" using primary key columns */\n  current_token_datas_by_pk?: Maybe<CurrentTokenDatas>;\n  /** fetch data from the table in a streaming manner: \"current_token_datas\" */\n  current_token_datas_stream: Array<CurrentTokenDatas>;\n  /** fetch data from the table: \"current_token_datas_v2\" */\n  current_token_datas_v2: Array<CurrentTokenDatasV2>;\n  /** fetch aggregated fields from the table: \"current_token_datas_v2\" */\n  current_token_datas_v2_aggregate: CurrentTokenDatasV2Aggregate;\n  /** fetch data from the table: \"current_token_datas_v2\" using primary key columns */\n  current_token_datas_v2_by_pk?: Maybe<CurrentTokenDatasV2>;\n  /** fetch data from the table in a streaming manner: \"current_token_datas_v2\" */\n  current_token_datas_v2_stream: Array<CurrentTokenDatasV2>;\n  /** fetch data from the table: \"current_token_ownerships\" */\n  current_token_ownerships: Array<CurrentTokenOwnerships>;\n  /** fetch aggregated fields from the table: \"current_token_ownerships\" */\n  current_token_ownerships_aggregate: CurrentTokenOwnershipsAggregate;\n  /** fetch data from the table: \"current_token_ownerships\" using primary key columns */\n  current_token_ownerships_by_pk?: Maybe<CurrentTokenOwnerships>;\n  /** fetch data from the table in a streaming manner: \"current_token_ownerships\" */\n  current_token_ownerships_stream: Array<CurrentTokenOwnerships>;\n  /** fetch data from the table: \"current_token_ownerships_v2\" */\n  current_token_ownerships_v2: Array<CurrentTokenOwnershipsV2>;\n  /** fetch aggregated fields from the table: \"current_token_ownerships_v2\" */\n  current_token_ownerships_v2_aggregate: CurrentTokenOwnershipsV2Aggregate;\n  /** fetch data from the table: \"current_token_ownerships_v2\" using primary key columns */\n  current_token_ownerships_v2_by_pk?: Maybe<CurrentTokenOwnershipsV2>;\n  /** fetch data from the table in a streaming manner: \"current_token_ownerships_v2\" */\n  current_token_ownerships_v2_stream: Array<CurrentTokenOwnershipsV2>;\n  /** fetch data from the table: \"current_token_pending_claims\" */\n  current_token_pending_claims: Array<CurrentTokenPendingClaims>;\n  /** fetch aggregated fields from the table: \"current_token_pending_claims\" */\n  current_token_pending_claims_aggregate: CurrentTokenPendingClaimsAggregate;\n  /** fetch data from the table: \"current_token_pending_claims\" using primary key columns */\n  current_token_pending_claims_by_pk?: Maybe<CurrentTokenPendingClaims>;\n  /** fetch data from the table in a streaming manner: \"current_token_pending_claims\" */\n  current_token_pending_claims_stream: Array<CurrentTokenPendingClaims>;\n  /** fetch data from the table: \"current_token_royalty_v1\" */\n  current_token_royalty_v1: Array<CurrentTokenRoyaltyV1>;\n  /** fetch aggregated fields from the table: \"current_token_royalty_v1\" */\n  current_token_royalty_v1_aggregate: CurrentTokenRoyaltyV1Aggregate;\n  /** fetch data from the table: \"current_token_royalty_v1\" using primary key columns */\n  current_token_royalty_v1_by_pk?: Maybe<CurrentTokenRoyaltyV1>;\n  /** fetch data from the table in a streaming manner: \"current_token_royalty_v1\" */\n  current_token_royalty_v1_stream: Array<CurrentTokenRoyaltyV1>;\n  /** fetch data from the table: \"current_token_v2_metadata\" */\n  current_token_v2_metadata: Array<CurrentTokenV2Metadata>;\n  /** fetch aggregated fields from the table: \"current_token_v2_metadata\" */\n  current_token_v2_metadata_aggregate: CurrentTokenV2MetadataAggregate;\n  /** fetch data from the table: \"current_token_v2_metadata\" using primary key columns */\n  current_token_v2_metadata_by_pk?: Maybe<CurrentTokenV2Metadata>;\n  /** fetch data from the table in a streaming manner: \"current_token_v2_metadata\" */\n  current_token_v2_metadata_stream: Array<CurrentTokenV2Metadata>;\n  /** fetch data from the table: \"delegated_staking_activities\" */\n  delegated_staking_activities: Array<DelegatedStakingActivities>;\n  /** fetch aggregated fields from the table: \"delegated_staking_activities\" */\n  delegated_staking_activities_aggregate: DelegatedStakingActivitiesAggregate;\n  /** fetch data from the table: \"delegated_staking_activities\" using primary key columns */\n  delegated_staking_activities_by_pk?: Maybe<DelegatedStakingActivities>;\n  /** fetch data from the table in a streaming manner: \"delegated_staking_activities\" */\n  delegated_staking_activities_stream: Array<DelegatedStakingActivities>;\n  /** fetch data from the table: \"delegated_staking_pool_balances\" */\n  delegated_staking_pool_balances: Array<DelegatedStakingPoolBalances>;\n  /** fetch aggregated fields from the table: \"delegated_staking_pool_balances\" */\n  delegated_staking_pool_balances_aggregate: DelegatedStakingPoolBalancesAggregate;\n  /** fetch data from the table: \"delegated_staking_pool_balances\" using primary key columns */\n  delegated_staking_pool_balances_by_pk?: Maybe<DelegatedStakingPoolBalances>;\n  /** fetch data from the table in a streaming manner: \"delegated_staking_pool_balances\" */\n  delegated_staking_pool_balances_stream: Array<DelegatedStakingPoolBalances>;\n  /** fetch data from the table: \"delegated_staking_pools\" */\n  delegated_staking_pools: Array<DelegatedStakingPools>;\n  /** fetch aggregated fields from the table: \"delegated_staking_pools\" */\n  delegated_staking_pools_aggregate: DelegatedStakingPoolsAggregate;\n  /** fetch data from the table: \"delegated_staking_pools\" using primary key columns */\n  delegated_staking_pools_by_pk?: Maybe<DelegatedStakingPools>;\n  /** fetch data from the table in a streaming manner: \"delegated_staking_pools\" */\n  delegated_staking_pools_stream: Array<DelegatedStakingPools>;\n  /** fetch data from the table: \"delegator_balances\" */\n  delegator_balances: Array<DelegatorBalances>;\n  /** fetch aggregated fields from the table: \"delegator_balances\" */\n  delegator_balances_aggregate: DelegatorBalancesAggregate;\n  /** fetch data from the table: \"delegator_balances\" using primary key columns */\n  delegator_balances_by_pk?: Maybe<DelegatorBalances>;\n  /** fetch data from the table in a streaming manner: \"delegator_balances\" */\n  delegator_balances_stream: Array<DelegatorBalances>;\n  /** fetch data from the table: \"delegator_distinct_pool\" */\n  delegator_distinct_pool: Array<DelegatorDistinctPool>;\n  /** fetch aggregated fields from the table: \"delegator_distinct_pool\" */\n  delegator_distinct_pool_aggregate: DelegatorDistinctPoolAggregate;\n  /** fetch data from the table in a streaming manner: \"delegator_distinct_pool\" */\n  delegator_distinct_pool_stream: Array<DelegatorDistinctPool>;\n  /** fetch data from the table: \"event_size_info\" */\n  event_size_info: Array<EventSizeInfo>;\n  /** fetch aggregated fields from the table: \"event_size_info\" */\n  event_size_info_aggregate: EventSizeInfoAggregate;\n  /** fetch data from the table: \"event_size_info\" using primary key columns */\n  event_size_info_by_pk?: Maybe<EventSizeInfo>;\n  /** fetch data from the table in a streaming manner: \"event_size_info\" */\n  event_size_info_stream: Array<EventSizeInfo>;\n  /** fetch data from the table: \"events\" */\n  events: Array<Events>;\n  /** fetch aggregated fields from the table: \"events\" */\n  events_aggregate: EventsAggregate;\n  /** fetch data from the table: \"events\" using primary key columns */\n  events_by_pk?: Maybe<Events>;\n  /** fetch data from the table in a streaming manner: \"events\" */\n  events_stream: Array<Events>;\n  /** fetch data from the table: \"events_view\" */\n  events_view: Array<EventsView>;\n  /** fetch aggregated fields from the table: \"events_view\" */\n  events_view_aggregate: EventsViewAggregate;\n  /** fetch data from the table in a streaming manner: \"events_view\" */\n  events_view_stream: Array<EventsView>;\n  /** fetch data from the table: \"fungible_asset_activities\" */\n  fungible_asset_activities: Array<FungibleAssetActivities>;\n  /** fetch aggregated fields from the table: \"fungible_asset_activities\" */\n  fungible_asset_activities_aggregate: FungibleAssetActivitiesAggregate;\n  /** fetch data from the table: \"fungible_asset_activities\" using primary key columns */\n  fungible_asset_activities_by_pk?: Maybe<FungibleAssetActivities>;\n  /** fetch data from the table in a streaming manner: \"fungible_asset_activities\" */\n  fungible_asset_activities_stream: Array<FungibleAssetActivities>;\n  /** fetch data from the table: \"fungible_asset_balances\" */\n  fungible_asset_balances: Array<FungibleAssetBalances>;\n  /** fetch aggregated fields from the table: \"fungible_asset_balances\" */\n  fungible_asset_balances_aggregate: FungibleAssetBalancesAggregate;\n  /** fetch data from the table: \"fungible_asset_balances\" using primary key columns */\n  fungible_asset_balances_by_pk?: Maybe<FungibleAssetBalances>;\n  /** fetch data from the table in a streaming manner: \"fungible_asset_balances\" */\n  fungible_asset_balances_stream: Array<FungibleAssetBalances>;\n  /** fetch data from the table: \"fungible_asset_metadata\" */\n  fungible_asset_metadata: Array<FungibleAssetMetadata>;\n  /** fetch aggregated fields from the table: \"fungible_asset_metadata\" */\n  fungible_asset_metadata_aggregate: FungibleAssetMetadataAggregate;\n  /** fetch data from the table: \"fungible_asset_metadata\" using primary key columns */\n  fungible_asset_metadata_by_pk?: Maybe<FungibleAssetMetadata>;\n  /** fetch data from the table in a streaming manner: \"fungible_asset_metadata\" */\n  fungible_asset_metadata_stream: Array<FungibleAssetMetadata>;\n  /** fetch data from the table: \"fungible_asset_to_coin_mappings\" */\n  fungible_asset_to_coin_mappings: Array<FungibleAssetToCoinMappings>;\n  /** fetch aggregated fields from the table: \"fungible_asset_to_coin_mappings\" */\n  fungible_asset_to_coin_mappings_aggregate: FungibleAssetToCoinMappingsAggregate;\n  /** fetch data from the table: \"fungible_asset_to_coin_mappings\" using primary key columns */\n  fungible_asset_to_coin_mappings_by_pk?: Maybe<FungibleAssetToCoinMappings>;\n  /** fetch data from the table in a streaming manner: \"fungible_asset_to_coin_mappings\" */\n  fungible_asset_to_coin_mappings_stream: Array<FungibleAssetToCoinMappings>;\n  /** fetch data from the table: \"gas_fees\" */\n  gas_fees: Array<GasFees>;\n  /** fetch aggregated fields from the table: \"gas_fees\" */\n  gas_fees_aggregate: GasFeesAggregate;\n  /** fetch data from the table: \"gas_fees\" using primary key columns */\n  gas_fees_by_pk?: Maybe<GasFees>;\n  /** fetch data from the table in a streaming manner: \"gas_fees\" */\n  gas_fees_stream: Array<GasFees>;\n  /** fetch data from the table: \"indexer_status\" */\n  indexer_status: Array<IndexerStatus>;\n  /** fetch aggregated fields from the table: \"indexer_status\" */\n  indexer_status_aggregate: IndexerStatusAggregate;\n  /** fetch data from the table: \"indexer_status\" using primary key columns */\n  indexer_status_by_pk?: Maybe<IndexerStatus>;\n  /** fetch data from the table in a streaming manner: \"indexer_status\" */\n  indexer_status_stream: Array<IndexerStatus>;\n  /** fetch data from the table: \"move_modules\" */\n  move_modules: Array<MoveModules>;\n  /** fetch aggregated fields from the table: \"move_modules\" */\n  move_modules_aggregate: MoveModulesAggregate;\n  /** fetch data from the table: \"move_modules\" using primary key columns */\n  move_modules_by_pk?: Maybe<MoveModules>;\n  /** fetch data from the table in a streaming manner: \"move_modules\" */\n  move_modules_stream: Array<MoveModules>;\n  /** fetch data from the table: \"move_resources\" */\n  move_resources: Array<MoveResources>;\n  /** fetch aggregated fields from the table: \"move_resources\" */\n  move_resources_aggregate: MoveResourcesAggregate;\n  /** fetch data from the table: \"move_resources\" using primary key columns */\n  move_resources_by_pk?: Maybe<MoveResources>;\n  /** fetch data from the table in a streaming manner: \"move_resources\" */\n  move_resources_stream: Array<MoveResources>;\n  /** fetch data from the table: \"move_resources_view\" */\n  move_resources_view: Array<MoveResourcesView>;\n  /** fetch aggregated fields from the table: \"move_resources_view\" */\n  move_resources_view_aggregate: MoveResourcesViewAggregate;\n  /** fetch data from the table in a streaming manner: \"move_resources_view\" */\n  move_resources_view_stream: Array<MoveResourcesView>;\n  /** fetch data from the table: \"nft_metadata_crawler.parsed_asset_uris\" */\n  nft_metadata_crawler_parsed_asset_uris: Array<NftMetadataCrawlerParsedAssetUris>;\n  /** fetch aggregated fields from the table: \"nft_metadata_crawler.parsed_asset_uris\" */\n  nft_metadata_crawler_parsed_asset_uris_aggregate: NftMetadataCrawlerParsedAssetUrisAggregate;\n  /** fetch data from the table: \"nft_metadata_crawler.parsed_asset_uris\" using primary key columns */\n  nft_metadata_crawler_parsed_asset_uris_by_pk?: Maybe<NftMetadataCrawlerParsedAssetUris>;\n  /** fetch data from the table in a streaming manner: \"nft_metadata_crawler.parsed_asset_uris\" */\n  nft_metadata_crawler_parsed_asset_uris_stream: Array<NftMetadataCrawlerParsedAssetUris>;\n  /** fetch data from the table: \"nft_points\" */\n  nft_points: Array<NftPoints>;\n  /** fetch aggregated fields from the table: \"nft_points\" */\n  nft_points_aggregate: NftPointsAggregate;\n  /** fetch data from the table: \"nft_points\" using primary key columns */\n  nft_points_by_pk?: Maybe<NftPoints>;\n  /** fetch data from the table in a streaming manner: \"nft_points\" */\n  nft_points_stream: Array<NftPoints>;\n  /** fetch data from the table: \"num_active_delegator_per_pool\" */\n  num_active_delegator_per_pool: Array<NumActiveDelegatorPerPool>;\n  /** fetch aggregated fields from the table: \"num_active_delegator_per_pool\" */\n  num_active_delegator_per_pool_aggregate: NumActiveDelegatorPerPoolAggregate;\n  /** fetch data from the table in a streaming manner: \"num_active_delegator_per_pool\" */\n  num_active_delegator_per_pool_stream: Array<NumActiveDelegatorPerPool>;\n  /** fetch data from the table: \"objects\" */\n  objects: Array<Objects>;\n  /** fetch aggregated fields from the table: \"objects\" */\n  objects_aggregate: ObjectsAggregate;\n  /** fetch data from the table: \"objects\" using primary key columns */\n  objects_by_pk?: Maybe<Objects>;\n  /** fetch data from the table in a streaming manner: \"objects\" */\n  objects_stream: Array<Objects>;\n  /** fetch data from the table: \"processor_metadata.processor_status\" */\n  processor_metadata_processor_status: Array<ProcessorMetadataProcessorStatus>;\n  /** fetch aggregated fields from the table: \"processor_metadata.processor_status\" */\n  processor_metadata_processor_status_aggregate: ProcessorMetadataProcessorStatusAggregate;\n  /** fetch data from the table: \"processor_metadata.processor_status\" using primary key columns */\n  processor_metadata_processor_status_by_pk?: Maybe<ProcessorMetadataProcessorStatus>;\n  /** fetch data from the table in a streaming manner: \"processor_metadata.processor_status\" */\n  processor_metadata_processor_status_stream: Array<ProcessorMetadataProcessorStatus>;\n  /** fetch data from the table: \"processor_status\" */\n  processor_status: Array<ProcessorStatus>;\n  /** fetch aggregated fields from the table: \"processor_status\" */\n  processor_status_aggregate: ProcessorStatusAggregate;\n  /** fetch data from the table: \"processor_status\" using primary key columns */\n  processor_status_by_pk?: Maybe<ProcessorStatus>;\n  /** fetch data from the table in a streaming manner: \"processor_status\" */\n  processor_status_stream: Array<ProcessorStatus>;\n  /** fetch data from the table: \"proposal_votes\" */\n  proposal_votes: Array<ProposalVotes>;\n  /** fetch aggregated fields from the table: \"proposal_votes\" */\n  proposal_votes_aggregate: ProposalVotesAggregate;\n  /** fetch data from the table: \"proposal_votes\" using primary key columns */\n  proposal_votes_by_pk?: Maybe<ProposalVotes>;\n  /** fetch data from the table in a streaming manner: \"proposal_votes\" */\n  proposal_votes_stream: Array<ProposalVotes>;\n  /** fetch data from the table: \"public_key_auth_keys\" */\n  public_key_auth_keys: Array<PublicKeyAuthKeys>;\n  /** fetch aggregated fields from the table: \"public_key_auth_keys\" */\n  public_key_auth_keys_aggregate: PublicKeyAuthKeysAggregate;\n  /** fetch data from the table: \"public_key_auth_keys\" using primary key columns */\n  public_key_auth_keys_by_pk?: Maybe<PublicKeyAuthKeys>;\n  /** fetch data from the table in a streaming manner: \"public_key_auth_keys\" */\n  public_key_auth_keys_stream: Array<PublicKeyAuthKeys>;\n  /** fetch data from the table: \"signatures\" */\n  signatures: Array<Signatures>;\n  /** fetch aggregated fields from the table: \"signatures\" */\n  signatures_aggregate: SignaturesAggregate;\n  /** fetch data from the table: \"signatures\" using primary key columns */\n  signatures_by_pk?: Maybe<Signatures>;\n  /** fetch data from the table in a streaming manner: \"signatures\" */\n  signatures_stream: Array<Signatures>;\n  /** fetch data from the table: \"spam_assets\" */\n  spam_assets: Array<SpamAssets>;\n  /** fetch aggregated fields from the table: \"spam_assets\" */\n  spam_assets_aggregate: SpamAssetsAggregate;\n  /** fetch data from the table: \"spam_assets\" using primary key columns */\n  spam_assets_by_pk?: Maybe<SpamAssets>;\n  /** fetch data from the table in a streaming manner: \"spam_assets\" */\n  spam_assets_stream: Array<SpamAssets>;\n  /** fetch data from the table: \"table_items\" */\n  table_items: Array<TableItems>;\n  /** fetch aggregated fields from the table: \"table_items\" */\n  table_items_aggregate: TableItemsAggregate;\n  /** fetch data from the table: \"table_items\" using primary key columns */\n  table_items_by_pk?: Maybe<TableItems>;\n  /** fetch data from the table in a streaming manner: \"table_items\" */\n  table_items_stream: Array<TableItems>;\n  /** fetch data from the table: \"table_items_view\" */\n  table_items_view: Array<TableItemsView>;\n  /** fetch aggregated fields from the table: \"table_items_view\" */\n  table_items_view_aggregate: TableItemsViewAggregate;\n  /** fetch data from the table in a streaming manner: \"table_items_view\" */\n  table_items_view_stream: Array<TableItemsView>;\n  /** fetch data from the table: \"table_metadatas\" */\n  table_metadatas: Array<TableMetadatas>;\n  /** fetch aggregated fields from the table: \"table_metadatas\" */\n  table_metadatas_aggregate: TableMetadatasAggregate;\n  /** fetch data from the table: \"table_metadatas\" using primary key columns */\n  table_metadatas_by_pk?: Maybe<TableMetadatas>;\n  /** fetch data from the table in a streaming manner: \"table_metadatas\" */\n  table_metadatas_stream: Array<TableMetadatas>;\n  /** fetch data from the table: \"token_activities\" */\n  token_activities: Array<TokenActivities>;\n  /** fetch aggregated fields from the table: \"token_activities\" */\n  token_activities_aggregate: TokenActivitiesAggregate;\n  /** fetch data from the table: \"token_activities\" using primary key columns */\n  token_activities_by_pk?: Maybe<TokenActivities>;\n  /** fetch data from the table in a streaming manner: \"token_activities\" */\n  token_activities_stream: Array<TokenActivities>;\n  /** fetch data from the table: \"token_activities_v2\" */\n  token_activities_v2: Array<TokenActivitiesV2>;\n  /** fetch aggregated fields from the table: \"token_activities_v2\" */\n  token_activities_v2_aggregate: TokenActivitiesV2Aggregate;\n  /** fetch data from the table: \"token_activities_v2\" using primary key columns */\n  token_activities_v2_by_pk?: Maybe<TokenActivitiesV2>;\n  /** fetch data from the table in a streaming manner: \"token_activities_v2\" */\n  token_activities_v2_stream: Array<TokenActivitiesV2>;\n  /** fetch data from the table: \"token_datas\" */\n  token_datas: Array<TokenDatas>;\n  /** fetch aggregated fields from the table: \"token_datas\" */\n  token_datas_aggregate: TokenDatasAggregate;\n  /** fetch data from the table: \"token_datas\" using primary key columns */\n  token_datas_by_pk?: Maybe<TokenDatas>;\n  /** fetch data from the table in a streaming manner: \"token_datas\" */\n  token_datas_stream: Array<TokenDatas>;\n  /** fetch data from the table: \"token_datas_v2\" */\n  token_datas_v2: Array<TokenDatasV2>;\n  /** fetch aggregated fields from the table: \"token_datas_v2\" */\n  token_datas_v2_aggregate: TokenDatasV2Aggregate;\n  /** fetch data from the table: \"token_datas_v2\" using primary key columns */\n  token_datas_v2_by_pk?: Maybe<TokenDatasV2>;\n  /** fetch data from the table in a streaming manner: \"token_datas_v2\" */\n  token_datas_v2_stream: Array<TokenDatasV2>;\n  /** fetch data from the table: \"token_ownerships\" */\n  token_ownerships: Array<TokenOwnerships>;\n  /** fetch aggregated fields from the table: \"token_ownerships\" */\n  token_ownerships_aggregate: TokenOwnershipsAggregate;\n  /** fetch data from the table: \"token_ownerships\" using primary key columns */\n  token_ownerships_by_pk?: Maybe<TokenOwnerships>;\n  /** fetch data from the table in a streaming manner: \"token_ownerships\" */\n  token_ownerships_stream: Array<TokenOwnerships>;\n  /** fetch data from the table: \"token_ownerships_v2\" */\n  token_ownerships_v2: Array<TokenOwnershipsV2>;\n  /** fetch aggregated fields from the table: \"token_ownerships_v2\" */\n  token_ownerships_v2_aggregate: TokenOwnershipsV2Aggregate;\n  /** fetch data from the table: \"token_ownerships_v2\" using primary key columns */\n  token_ownerships_v2_by_pk?: Maybe<TokenOwnershipsV2>;\n  /** fetch data from the table in a streaming manner: \"token_ownerships_v2\" */\n  token_ownerships_v2_stream: Array<TokenOwnershipsV2>;\n  /** fetch data from the table: \"tokens\" */\n  tokens: Array<Tokens>;\n  /** fetch aggregated fields from the table: \"tokens\" */\n  tokens_aggregate: TokensAggregate;\n  /** fetch data from the table: \"tokens\" using primary key columns */\n  tokens_by_pk?: Maybe<Tokens>;\n  /** fetch data from the table in a streaming manner: \"tokens\" */\n  tokens_stream: Array<Tokens>;\n  /** fetch data from the table: \"transaction_size_info\" */\n  transaction_size_info: Array<TransactionSizeInfo>;\n  /** fetch aggregated fields from the table: \"transaction_size_info\" */\n  transaction_size_info_aggregate: TransactionSizeInfoAggregate;\n  /** fetch data from the table: \"transaction_size_info\" using primary key columns */\n  transaction_size_info_by_pk?: Maybe<TransactionSizeInfo>;\n  /** fetch data from the table in a streaming manner: \"transaction_size_info\" */\n  transaction_size_info_stream: Array<TransactionSizeInfo>;\n  /** fetch data from the table: \"transactions_view\" */\n  transactions_view: Array<TransactionsView>;\n  /** fetch aggregated fields from the table: \"transactions_view\" */\n  transactions_view_aggregate: TransactionsViewAggregate;\n  /** fetch data from the table in a streaming manner: \"transactions_view\" */\n  transactions_view_stream: Array<TransactionsView>;\n  /** fetch data from the table: \"user_transactions\" */\n  user_transactions: Array<UserTransactions>;\n  /** fetch aggregated fields from the table: \"user_transactions\" */\n  user_transactions_aggregate: UserTransactionsAggregate;\n  /** fetch data from the table: \"user_transactions\" using primary key columns */\n  user_transactions_by_pk?: Maybe<UserTransactions>;\n  /** fetch data from the table in a streaming manner: \"user_transactions\" */\n  user_transactions_stream: Array<UserTransactions>;\n};\n\nexport type SubscriptionRootAccountTransactionsArgs = {\n  distinct_on?: InputMaybe<Array<AccountTransactionsSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<AccountTransactionsOrderBy>>;\n  where?: InputMaybe<AccountTransactionsBoolExp>;\n};\n\nexport type SubscriptionRootAccountTransactionsAggregateArgs = {\n  distinct_on?: InputMaybe<Array<AccountTransactionsSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<AccountTransactionsOrderBy>>;\n  where?: InputMaybe<AccountTransactionsBoolExp>;\n};\n\nexport type SubscriptionRootAccountTransactionsByPkArgs = {\n  account_address: Scalars[\"String\"][\"input\"];\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\nexport type SubscriptionRootAccountTransactionsStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<AccountTransactionsStreamCursorInput>>;\n  where?: InputMaybe<AccountTransactionsBoolExp>;\n};\n\nexport type SubscriptionRootAddressEventsSummaryArgs = {\n  distinct_on?: InputMaybe<Array<AddressEventsSummarySelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<AddressEventsSummaryOrderBy>>;\n  where?: InputMaybe<AddressEventsSummaryBoolExp>;\n};\n\nexport type SubscriptionRootAddressEventsSummaryAggregateArgs = {\n  distinct_on?: InputMaybe<Array<AddressEventsSummarySelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<AddressEventsSummaryOrderBy>>;\n  where?: InputMaybe<AddressEventsSummaryBoolExp>;\n};\n\nexport type SubscriptionRootAddressEventsSummaryStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<AddressEventsSummaryStreamCursorInput>>;\n  where?: InputMaybe<AddressEventsSummaryBoolExp>;\n};\n\nexport type SubscriptionRootAddressVersionFromEventsArgs = {\n  distinct_on?: InputMaybe<Array<AddressVersionFromEventsSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<AddressVersionFromEventsOrderBy>>;\n  where?: InputMaybe<AddressVersionFromEventsBoolExp>;\n};\n\nexport type SubscriptionRootAddressVersionFromEventsAggregateArgs = {\n  distinct_on?: InputMaybe<Array<AddressVersionFromEventsSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<AddressVersionFromEventsOrderBy>>;\n  where?: InputMaybe<AddressVersionFromEventsBoolExp>;\n};\n\nexport type SubscriptionRootAddressVersionFromEventsStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<AddressVersionFromEventsStreamCursorInput>>;\n  where?: InputMaybe<AddressVersionFromEventsBoolExp>;\n};\n\nexport type SubscriptionRootAddressVersionFromMoveResourcesArgs = {\n  distinct_on?: InputMaybe<Array<AddressVersionFromMoveResourcesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<AddressVersionFromMoveResourcesOrderBy>>;\n  where?: InputMaybe<AddressVersionFromMoveResourcesBoolExp>;\n};\n\nexport type SubscriptionRootAddressVersionFromMoveResourcesAggregateArgs = {\n  distinct_on?: InputMaybe<Array<AddressVersionFromMoveResourcesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<AddressVersionFromMoveResourcesOrderBy>>;\n  where?: InputMaybe<AddressVersionFromMoveResourcesBoolExp>;\n};\n\nexport type SubscriptionRootAddressVersionFromMoveResourcesStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<AddressVersionFromMoveResourcesStreamCursorInput>>;\n  where?: InputMaybe<AddressVersionFromMoveResourcesBoolExp>;\n};\n\nexport type SubscriptionRootAnsLookupArgs = {\n  distinct_on?: InputMaybe<Array<AnsLookupSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<AnsLookupOrderBy>>;\n  where?: InputMaybe<AnsLookupBoolExp>;\n};\n\nexport type SubscriptionRootAnsLookupAggregateArgs = {\n  distinct_on?: InputMaybe<Array<AnsLookupSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<AnsLookupOrderBy>>;\n  where?: InputMaybe<AnsLookupBoolExp>;\n};\n\nexport type SubscriptionRootAnsLookupByPkArgs = {\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n  write_set_change_index: Scalars[\"bigint\"][\"input\"];\n};\n\nexport type SubscriptionRootAnsLookupStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<AnsLookupStreamCursorInput>>;\n  where?: InputMaybe<AnsLookupBoolExp>;\n};\n\nexport type SubscriptionRootAnsLookupV2Args = {\n  distinct_on?: InputMaybe<Array<AnsLookupV2SelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<AnsLookupV2OrderBy>>;\n  where?: InputMaybe<AnsLookupV2BoolExp>;\n};\n\nexport type SubscriptionRootAnsLookupV2AggregateArgs = {\n  distinct_on?: InputMaybe<Array<AnsLookupV2SelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<AnsLookupV2OrderBy>>;\n  where?: InputMaybe<AnsLookupV2BoolExp>;\n};\n\nexport type SubscriptionRootAnsLookupV2ByPkArgs = {\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n  write_set_change_index: Scalars[\"bigint\"][\"input\"];\n};\n\nexport type SubscriptionRootAnsLookupV2StreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<AnsLookupV2StreamCursorInput>>;\n  where?: InputMaybe<AnsLookupV2BoolExp>;\n};\n\nexport type SubscriptionRootAnsPrimaryNameArgs = {\n  distinct_on?: InputMaybe<Array<AnsPrimaryNameSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<AnsPrimaryNameOrderBy>>;\n  where?: InputMaybe<AnsPrimaryNameBoolExp>;\n};\n\nexport type SubscriptionRootAnsPrimaryNameAggregateArgs = {\n  distinct_on?: InputMaybe<Array<AnsPrimaryNameSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<AnsPrimaryNameOrderBy>>;\n  where?: InputMaybe<AnsPrimaryNameBoolExp>;\n};\n\nexport type SubscriptionRootAnsPrimaryNameByPkArgs = {\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n  write_set_change_index: Scalars[\"bigint\"][\"input\"];\n};\n\nexport type SubscriptionRootAnsPrimaryNameStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<AnsPrimaryNameStreamCursorInput>>;\n  where?: InputMaybe<AnsPrimaryNameBoolExp>;\n};\n\nexport type SubscriptionRootAnsPrimaryNameV2Args = {\n  distinct_on?: InputMaybe<Array<AnsPrimaryNameV2SelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<AnsPrimaryNameV2OrderBy>>;\n  where?: InputMaybe<AnsPrimaryNameV2BoolExp>;\n};\n\nexport type SubscriptionRootAnsPrimaryNameV2AggregateArgs = {\n  distinct_on?: InputMaybe<Array<AnsPrimaryNameV2SelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<AnsPrimaryNameV2OrderBy>>;\n  where?: InputMaybe<AnsPrimaryNameV2BoolExp>;\n};\n\nexport type SubscriptionRootAnsPrimaryNameV2ByPkArgs = {\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n  write_set_change_index: Scalars[\"bigint\"][\"input\"];\n};\n\nexport type SubscriptionRootAnsPrimaryNameV2StreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<AnsPrimaryNameV2StreamCursorInput>>;\n  where?: InputMaybe<AnsPrimaryNameV2BoolExp>;\n};\n\nexport type SubscriptionRootAuthKeyAccountAddressesArgs = {\n  distinct_on?: InputMaybe<Array<AuthKeyAccountAddressesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<AuthKeyAccountAddressesOrderBy>>;\n  where?: InputMaybe<AuthKeyAccountAddressesBoolExp>;\n};\n\nexport type SubscriptionRootAuthKeyAccountAddressesAggregateArgs = {\n  distinct_on?: InputMaybe<Array<AuthKeyAccountAddressesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<AuthKeyAccountAddressesOrderBy>>;\n  where?: InputMaybe<AuthKeyAccountAddressesBoolExp>;\n};\n\nexport type SubscriptionRootAuthKeyAccountAddressesByPkArgs = {\n  account_address: Scalars[\"String\"][\"input\"];\n};\n\nexport type SubscriptionRootAuthKeyAccountAddressesStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<AuthKeyAccountAddressesStreamCursorInput>>;\n  where?: InputMaybe<AuthKeyAccountAddressesBoolExp>;\n};\n\nexport type SubscriptionRootBlockMetadataTransactionsArgs = {\n  distinct_on?: InputMaybe<Array<BlockMetadataTransactionsSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<BlockMetadataTransactionsOrderBy>>;\n  where?: InputMaybe<BlockMetadataTransactionsBoolExp>;\n};\n\nexport type SubscriptionRootBlockMetadataTransactionsAggregateArgs = {\n  distinct_on?: InputMaybe<Array<BlockMetadataTransactionsSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<BlockMetadataTransactionsOrderBy>>;\n  where?: InputMaybe<BlockMetadataTransactionsBoolExp>;\n};\n\nexport type SubscriptionRootBlockMetadataTransactionsByPkArgs = {\n  version: Scalars[\"bigint\"][\"input\"];\n};\n\nexport type SubscriptionRootBlockMetadataTransactionsStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<BlockMetadataTransactionsStreamCursorInput>>;\n  where?: InputMaybe<BlockMetadataTransactionsBoolExp>;\n};\n\nexport type SubscriptionRootCoinActivitiesArgs = {\n  distinct_on?: InputMaybe<Array<CoinActivitiesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CoinActivitiesOrderBy>>;\n  where?: InputMaybe<CoinActivitiesBoolExp>;\n};\n\nexport type SubscriptionRootCoinActivitiesAggregateArgs = {\n  distinct_on?: InputMaybe<Array<CoinActivitiesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CoinActivitiesOrderBy>>;\n  where?: InputMaybe<CoinActivitiesBoolExp>;\n};\n\nexport type SubscriptionRootCoinActivitiesByPkArgs = {\n  event_account_address: Scalars[\"String\"][\"input\"];\n  event_creation_number: Scalars[\"bigint\"][\"input\"];\n  event_sequence_number: Scalars[\"bigint\"][\"input\"];\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\nexport type SubscriptionRootCoinActivitiesStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<CoinActivitiesStreamCursorInput>>;\n  where?: InputMaybe<CoinActivitiesBoolExp>;\n};\n\nexport type SubscriptionRootCoinBalancesArgs = {\n  distinct_on?: InputMaybe<Array<CoinBalancesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CoinBalancesOrderBy>>;\n  where?: InputMaybe<CoinBalancesBoolExp>;\n};\n\nexport type SubscriptionRootCoinBalancesAggregateArgs = {\n  distinct_on?: InputMaybe<Array<CoinBalancesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CoinBalancesOrderBy>>;\n  where?: InputMaybe<CoinBalancesBoolExp>;\n};\n\nexport type SubscriptionRootCoinBalancesByPkArgs = {\n  coin_type_hash: Scalars[\"String\"][\"input\"];\n  owner_address: Scalars[\"String\"][\"input\"];\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\nexport type SubscriptionRootCoinBalancesStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<CoinBalancesStreamCursorInput>>;\n  where?: InputMaybe<CoinBalancesBoolExp>;\n};\n\nexport type SubscriptionRootCoinInfosArgs = {\n  distinct_on?: InputMaybe<Array<CoinInfosSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CoinInfosOrderBy>>;\n  where?: InputMaybe<CoinInfosBoolExp>;\n};\n\nexport type SubscriptionRootCoinInfosAggregateArgs = {\n  distinct_on?: InputMaybe<Array<CoinInfosSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CoinInfosOrderBy>>;\n  where?: InputMaybe<CoinInfosBoolExp>;\n};\n\nexport type SubscriptionRootCoinInfosByPkArgs = {\n  coin_type_hash: Scalars[\"String\"][\"input\"];\n};\n\nexport type SubscriptionRootCoinInfosStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<CoinInfosStreamCursorInput>>;\n  where?: InputMaybe<CoinInfosBoolExp>;\n};\n\nexport type SubscriptionRootCoinSupplyArgs = {\n  distinct_on?: InputMaybe<Array<CoinSupplySelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CoinSupplyOrderBy>>;\n  where?: InputMaybe<CoinSupplyBoolExp>;\n};\n\nexport type SubscriptionRootCoinSupplyAggregateArgs = {\n  distinct_on?: InputMaybe<Array<CoinSupplySelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CoinSupplyOrderBy>>;\n  where?: InputMaybe<CoinSupplyBoolExp>;\n};\n\nexport type SubscriptionRootCoinSupplyByPkArgs = {\n  coin_type_hash: Scalars[\"String\"][\"input\"];\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\nexport type SubscriptionRootCoinSupplyStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<CoinSupplyStreamCursorInput>>;\n  where?: InputMaybe<CoinSupplyBoolExp>;\n};\n\nexport type SubscriptionRootCollectionDatasArgs = {\n  distinct_on?: InputMaybe<Array<CollectionDatasSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CollectionDatasOrderBy>>;\n  where?: InputMaybe<CollectionDatasBoolExp>;\n};\n\nexport type SubscriptionRootCollectionDatasAggregateArgs = {\n  distinct_on?: InputMaybe<Array<CollectionDatasSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CollectionDatasOrderBy>>;\n  where?: InputMaybe<CollectionDatasBoolExp>;\n};\n\nexport type SubscriptionRootCollectionDatasByPkArgs = {\n  collection_data_id_hash: Scalars[\"String\"][\"input\"];\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\nexport type SubscriptionRootCollectionDatasStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<CollectionDatasStreamCursorInput>>;\n  where?: InputMaybe<CollectionDatasBoolExp>;\n};\n\nexport type SubscriptionRootCollectionsV2Args = {\n  distinct_on?: InputMaybe<Array<CollectionsV2SelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CollectionsV2OrderBy>>;\n  where?: InputMaybe<CollectionsV2BoolExp>;\n};\n\nexport type SubscriptionRootCollectionsV2AggregateArgs = {\n  distinct_on?: InputMaybe<Array<CollectionsV2SelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CollectionsV2OrderBy>>;\n  where?: InputMaybe<CollectionsV2BoolExp>;\n};\n\nexport type SubscriptionRootCollectionsV2ByPkArgs = {\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n  write_set_change_index: Scalars[\"bigint\"][\"input\"];\n};\n\nexport type SubscriptionRootCollectionsV2StreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<CollectionsV2StreamCursorInput>>;\n  where?: InputMaybe<CollectionsV2BoolExp>;\n};\n\nexport type SubscriptionRootCurrentAnsLookupArgs = {\n  distinct_on?: InputMaybe<Array<CurrentAnsLookupSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentAnsLookupOrderBy>>;\n  where?: InputMaybe<CurrentAnsLookupBoolExp>;\n};\n\nexport type SubscriptionRootCurrentAnsLookupAggregateArgs = {\n  distinct_on?: InputMaybe<Array<CurrentAnsLookupSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentAnsLookupOrderBy>>;\n  where?: InputMaybe<CurrentAnsLookupBoolExp>;\n};\n\nexport type SubscriptionRootCurrentAnsLookupByPkArgs = {\n  domain: Scalars[\"String\"][\"input\"];\n  subdomain: Scalars[\"String\"][\"input\"];\n};\n\nexport type SubscriptionRootCurrentAnsLookupStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<CurrentAnsLookupStreamCursorInput>>;\n  where?: InputMaybe<CurrentAnsLookupBoolExp>;\n};\n\nexport type SubscriptionRootCurrentAnsLookupV2Args = {\n  distinct_on?: InputMaybe<Array<CurrentAnsLookupV2SelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentAnsLookupV2OrderBy>>;\n  where?: InputMaybe<CurrentAnsLookupV2BoolExp>;\n};\n\nexport type SubscriptionRootCurrentAnsLookupV2AggregateArgs = {\n  distinct_on?: InputMaybe<Array<CurrentAnsLookupV2SelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentAnsLookupV2OrderBy>>;\n  where?: InputMaybe<CurrentAnsLookupV2BoolExp>;\n};\n\nexport type SubscriptionRootCurrentAnsLookupV2ByPkArgs = {\n  domain: Scalars[\"String\"][\"input\"];\n  subdomain: Scalars[\"String\"][\"input\"];\n  token_standard: Scalars[\"String\"][\"input\"];\n};\n\nexport type SubscriptionRootCurrentAnsLookupV2StreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<CurrentAnsLookupV2StreamCursorInput>>;\n  where?: InputMaybe<CurrentAnsLookupV2BoolExp>;\n};\n\nexport type SubscriptionRootCurrentAnsPrimaryNameArgs = {\n  distinct_on?: InputMaybe<Array<CurrentAnsPrimaryNameSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentAnsPrimaryNameOrderBy>>;\n  where?: InputMaybe<CurrentAnsPrimaryNameBoolExp>;\n};\n\nexport type SubscriptionRootCurrentAnsPrimaryNameAggregateArgs = {\n  distinct_on?: InputMaybe<Array<CurrentAnsPrimaryNameSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentAnsPrimaryNameOrderBy>>;\n  where?: InputMaybe<CurrentAnsPrimaryNameBoolExp>;\n};\n\nexport type SubscriptionRootCurrentAnsPrimaryNameByPkArgs = {\n  registered_address: Scalars[\"String\"][\"input\"];\n};\n\nexport type SubscriptionRootCurrentAnsPrimaryNameStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<CurrentAnsPrimaryNameStreamCursorInput>>;\n  where?: InputMaybe<CurrentAnsPrimaryNameBoolExp>;\n};\n\nexport type SubscriptionRootCurrentAnsPrimaryNameV2Args = {\n  distinct_on?: InputMaybe<Array<CurrentAnsPrimaryNameV2SelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentAnsPrimaryNameV2OrderBy>>;\n  where?: InputMaybe<CurrentAnsPrimaryNameV2BoolExp>;\n};\n\nexport type SubscriptionRootCurrentAnsPrimaryNameV2AggregateArgs = {\n  distinct_on?: InputMaybe<Array<CurrentAnsPrimaryNameV2SelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentAnsPrimaryNameV2OrderBy>>;\n  where?: InputMaybe<CurrentAnsPrimaryNameV2BoolExp>;\n};\n\nexport type SubscriptionRootCurrentAnsPrimaryNameV2ByPkArgs = {\n  registered_address: Scalars[\"String\"][\"input\"];\n  token_standard: Scalars[\"String\"][\"input\"];\n};\n\nexport type SubscriptionRootCurrentAnsPrimaryNameV2StreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<CurrentAnsPrimaryNameV2StreamCursorInput>>;\n  where?: InputMaybe<CurrentAnsPrimaryNameV2BoolExp>;\n};\n\nexport type SubscriptionRootCurrentCedraNamesArgs = {\n  distinct_on?: InputMaybe<Array<CurrentCedraNamesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentCedraNamesOrderBy>>;\n  where?: InputMaybe<CurrentCedraNamesBoolExp>;\n};\n\nexport type SubscriptionRootCurrentCedraNamesAggregateArgs = {\n  distinct_on?: InputMaybe<Array<CurrentCedraNamesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentCedraNamesOrderBy>>;\n  where?: InputMaybe<CurrentCedraNamesBoolExp>;\n};\n\nexport type SubscriptionRootCurrentCedraNamesStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<CurrentCedraNamesStreamCursorInput>>;\n  where?: InputMaybe<CurrentCedraNamesBoolExp>;\n};\n\nexport type SubscriptionRootCurrentCoinBalancesArgs = {\n  distinct_on?: InputMaybe<Array<CurrentCoinBalancesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentCoinBalancesOrderBy>>;\n  where?: InputMaybe<CurrentCoinBalancesBoolExp>;\n};\n\nexport type SubscriptionRootCurrentCoinBalancesAggregateArgs = {\n  distinct_on?: InputMaybe<Array<CurrentCoinBalancesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentCoinBalancesOrderBy>>;\n  where?: InputMaybe<CurrentCoinBalancesBoolExp>;\n};\n\nexport type SubscriptionRootCurrentCoinBalancesByPkArgs = {\n  coin_type_hash: Scalars[\"String\"][\"input\"];\n  owner_address: Scalars[\"String\"][\"input\"];\n};\n\nexport type SubscriptionRootCurrentCoinBalancesStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<CurrentCoinBalancesStreamCursorInput>>;\n  where?: InputMaybe<CurrentCoinBalancesBoolExp>;\n};\n\nexport type SubscriptionRootCurrentCollectionDatasArgs = {\n  distinct_on?: InputMaybe<Array<CurrentCollectionDatasSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentCollectionDatasOrderBy>>;\n  where?: InputMaybe<CurrentCollectionDatasBoolExp>;\n};\n\nexport type SubscriptionRootCurrentCollectionDatasAggregateArgs = {\n  distinct_on?: InputMaybe<Array<CurrentCollectionDatasSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentCollectionDatasOrderBy>>;\n  where?: InputMaybe<CurrentCollectionDatasBoolExp>;\n};\n\nexport type SubscriptionRootCurrentCollectionDatasByPkArgs = {\n  collection_data_id_hash: Scalars[\"String\"][\"input\"];\n};\n\nexport type SubscriptionRootCurrentCollectionDatasStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<CurrentCollectionDatasStreamCursorInput>>;\n  where?: InputMaybe<CurrentCollectionDatasBoolExp>;\n};\n\nexport type SubscriptionRootCurrentCollectionOwnershipV2ViewArgs = {\n  distinct_on?: InputMaybe<Array<CurrentCollectionOwnershipV2ViewSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentCollectionOwnershipV2ViewOrderBy>>;\n  where?: InputMaybe<CurrentCollectionOwnershipV2ViewBoolExp>;\n};\n\nexport type SubscriptionRootCurrentCollectionOwnershipV2ViewAggregateArgs = {\n  distinct_on?: InputMaybe<Array<CurrentCollectionOwnershipV2ViewSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentCollectionOwnershipV2ViewOrderBy>>;\n  where?: InputMaybe<CurrentCollectionOwnershipV2ViewBoolExp>;\n};\n\nexport type SubscriptionRootCurrentCollectionOwnershipV2ViewStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<CurrentCollectionOwnershipV2ViewStreamCursorInput>>;\n  where?: InputMaybe<CurrentCollectionOwnershipV2ViewBoolExp>;\n};\n\nexport type SubscriptionRootCurrentCollectionOwnershipViewArgs = {\n  distinct_on?: InputMaybe<Array<CurrentCollectionOwnershipViewSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentCollectionOwnershipViewOrderBy>>;\n  where?: InputMaybe<CurrentCollectionOwnershipViewBoolExp>;\n};\n\nexport type SubscriptionRootCurrentCollectionOwnershipViewAggregateArgs = {\n  distinct_on?: InputMaybe<Array<CurrentCollectionOwnershipViewSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentCollectionOwnershipViewOrderBy>>;\n  where?: InputMaybe<CurrentCollectionOwnershipViewBoolExp>;\n};\n\nexport type SubscriptionRootCurrentCollectionOwnershipViewStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<CurrentCollectionOwnershipViewStreamCursorInput>>;\n  where?: InputMaybe<CurrentCollectionOwnershipViewBoolExp>;\n};\n\nexport type SubscriptionRootCurrentCollectionsV2Args = {\n  distinct_on?: InputMaybe<Array<CurrentCollectionsV2SelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentCollectionsV2OrderBy>>;\n  where?: InputMaybe<CurrentCollectionsV2BoolExp>;\n};\n\nexport type SubscriptionRootCurrentCollectionsV2AggregateArgs = {\n  distinct_on?: InputMaybe<Array<CurrentCollectionsV2SelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentCollectionsV2OrderBy>>;\n  where?: InputMaybe<CurrentCollectionsV2BoolExp>;\n};\n\nexport type SubscriptionRootCurrentCollectionsV2ByPkArgs = {\n  collection_id: Scalars[\"String\"][\"input\"];\n};\n\nexport type SubscriptionRootCurrentCollectionsV2StreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<CurrentCollectionsV2StreamCursorInput>>;\n  where?: InputMaybe<CurrentCollectionsV2BoolExp>;\n};\n\nexport type SubscriptionRootCurrentDelegatedStakingPoolBalancesArgs = {\n  distinct_on?: InputMaybe<Array<CurrentDelegatedStakingPoolBalancesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentDelegatedStakingPoolBalancesOrderBy>>;\n  where?: InputMaybe<CurrentDelegatedStakingPoolBalancesBoolExp>;\n};\n\nexport type SubscriptionRootCurrentDelegatedStakingPoolBalancesAggregateArgs = {\n  distinct_on?: InputMaybe<Array<CurrentDelegatedStakingPoolBalancesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentDelegatedStakingPoolBalancesOrderBy>>;\n  where?: InputMaybe<CurrentDelegatedStakingPoolBalancesBoolExp>;\n};\n\nexport type SubscriptionRootCurrentDelegatedStakingPoolBalancesByPkArgs = {\n  staking_pool_address: Scalars[\"String\"][\"input\"];\n};\n\nexport type SubscriptionRootCurrentDelegatedStakingPoolBalancesStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<CurrentDelegatedStakingPoolBalancesStreamCursorInput>>;\n  where?: InputMaybe<CurrentDelegatedStakingPoolBalancesBoolExp>;\n};\n\nexport type SubscriptionRootCurrentDelegatedVoterArgs = {\n  distinct_on?: InputMaybe<Array<CurrentDelegatedVoterSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentDelegatedVoterOrderBy>>;\n  where?: InputMaybe<CurrentDelegatedVoterBoolExp>;\n};\n\nexport type SubscriptionRootCurrentDelegatedVoterAggregateArgs = {\n  distinct_on?: InputMaybe<Array<CurrentDelegatedVoterSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentDelegatedVoterOrderBy>>;\n  where?: InputMaybe<CurrentDelegatedVoterBoolExp>;\n};\n\nexport type SubscriptionRootCurrentDelegatedVoterByPkArgs = {\n  delegation_pool_address: Scalars[\"String\"][\"input\"];\n  delegator_address: Scalars[\"String\"][\"input\"];\n};\n\nexport type SubscriptionRootCurrentDelegatedVoterStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<CurrentDelegatedVoterStreamCursorInput>>;\n  where?: InputMaybe<CurrentDelegatedVoterBoolExp>;\n};\n\nexport type SubscriptionRootCurrentDelegatorBalancesArgs = {\n  distinct_on?: InputMaybe<Array<CurrentDelegatorBalancesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentDelegatorBalancesOrderBy>>;\n  where?: InputMaybe<CurrentDelegatorBalancesBoolExp>;\n};\n\nexport type SubscriptionRootCurrentDelegatorBalancesAggregateArgs = {\n  distinct_on?: InputMaybe<Array<CurrentDelegatorBalancesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentDelegatorBalancesOrderBy>>;\n  where?: InputMaybe<CurrentDelegatorBalancesBoolExp>;\n};\n\nexport type SubscriptionRootCurrentDelegatorBalancesByPkArgs = {\n  delegator_address: Scalars[\"String\"][\"input\"];\n  pool_address: Scalars[\"String\"][\"input\"];\n  pool_type: Scalars[\"String\"][\"input\"];\n  table_handle: Scalars[\"String\"][\"input\"];\n};\n\nexport type SubscriptionRootCurrentDelegatorBalancesStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<CurrentDelegatorBalancesStreamCursorInput>>;\n  where?: InputMaybe<CurrentDelegatorBalancesBoolExp>;\n};\n\nexport type SubscriptionRootCurrentFungibleAssetBalancesArgs = {\n  distinct_on?: InputMaybe<Array<CurrentFungibleAssetBalancesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentFungibleAssetBalancesOrderBy>>;\n  where?: InputMaybe<CurrentFungibleAssetBalancesBoolExp>;\n};\n\nexport type SubscriptionRootCurrentFungibleAssetBalancesAggregateArgs = {\n  distinct_on?: InputMaybe<Array<CurrentFungibleAssetBalancesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentFungibleAssetBalancesOrderBy>>;\n  where?: InputMaybe<CurrentFungibleAssetBalancesBoolExp>;\n};\n\nexport type SubscriptionRootCurrentFungibleAssetBalancesByPkArgs = {\n  storage_id: Scalars[\"String\"][\"input\"];\n};\n\nexport type SubscriptionRootCurrentFungibleAssetBalancesNewArgs = {\n  distinct_on?: InputMaybe<Array<CurrentFungibleAssetBalancesNewSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentFungibleAssetBalancesNewOrderBy>>;\n  where?: InputMaybe<CurrentFungibleAssetBalancesNewBoolExp>;\n};\n\nexport type SubscriptionRootCurrentFungibleAssetBalancesNewAggregateArgs = {\n  distinct_on?: InputMaybe<Array<CurrentFungibleAssetBalancesNewSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentFungibleAssetBalancesNewOrderBy>>;\n  where?: InputMaybe<CurrentFungibleAssetBalancesNewBoolExp>;\n};\n\nexport type SubscriptionRootCurrentFungibleAssetBalancesNewByPkArgs = {\n  storage_id: Scalars[\"String\"][\"input\"];\n};\n\nexport type SubscriptionRootCurrentFungibleAssetBalancesNewStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<CurrentFungibleAssetBalancesNewStreamCursorInput>>;\n  where?: InputMaybe<CurrentFungibleAssetBalancesNewBoolExp>;\n};\n\nexport type SubscriptionRootCurrentFungibleAssetBalancesStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<CurrentFungibleAssetBalancesStreamCursorInput>>;\n  where?: InputMaybe<CurrentFungibleAssetBalancesBoolExp>;\n};\n\nexport type SubscriptionRootCurrentObjectsArgs = {\n  distinct_on?: InputMaybe<Array<CurrentObjectsSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentObjectsOrderBy>>;\n  where?: InputMaybe<CurrentObjectsBoolExp>;\n};\n\nexport type SubscriptionRootCurrentObjectsAggregateArgs = {\n  distinct_on?: InputMaybe<Array<CurrentObjectsSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentObjectsOrderBy>>;\n  where?: InputMaybe<CurrentObjectsBoolExp>;\n};\n\nexport type SubscriptionRootCurrentObjectsByPkArgs = {\n  object_address: Scalars[\"String\"][\"input\"];\n};\n\nexport type SubscriptionRootCurrentObjectsStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<CurrentObjectsStreamCursorInput>>;\n  where?: InputMaybe<CurrentObjectsBoolExp>;\n};\n\nexport type SubscriptionRootCurrentStakingPoolVoterArgs = {\n  distinct_on?: InputMaybe<Array<CurrentStakingPoolVoterSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentStakingPoolVoterOrderBy>>;\n  where?: InputMaybe<CurrentStakingPoolVoterBoolExp>;\n};\n\nexport type SubscriptionRootCurrentStakingPoolVoterAggregateArgs = {\n  distinct_on?: InputMaybe<Array<CurrentStakingPoolVoterSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentStakingPoolVoterOrderBy>>;\n  where?: InputMaybe<CurrentStakingPoolVoterBoolExp>;\n};\n\nexport type SubscriptionRootCurrentStakingPoolVoterByPkArgs = {\n  staking_pool_address: Scalars[\"String\"][\"input\"];\n};\n\nexport type SubscriptionRootCurrentStakingPoolVoterStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<CurrentStakingPoolVoterStreamCursorInput>>;\n  where?: InputMaybe<CurrentStakingPoolVoterBoolExp>;\n};\n\nexport type SubscriptionRootCurrentTableItemsArgs = {\n  distinct_on?: InputMaybe<Array<CurrentTableItemsSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentTableItemsOrderBy>>;\n  where?: InputMaybe<CurrentTableItemsBoolExp>;\n};\n\nexport type SubscriptionRootCurrentTableItemsAggregateArgs = {\n  distinct_on?: InputMaybe<Array<CurrentTableItemsSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentTableItemsOrderBy>>;\n  where?: InputMaybe<CurrentTableItemsBoolExp>;\n};\n\nexport type SubscriptionRootCurrentTableItemsByPkArgs = {\n  key_hash: Scalars[\"String\"][\"input\"];\n  table_handle: Scalars[\"String\"][\"input\"];\n};\n\nexport type SubscriptionRootCurrentTableItemsStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<CurrentTableItemsStreamCursorInput>>;\n  where?: InputMaybe<CurrentTableItemsBoolExp>;\n};\n\nexport type SubscriptionRootCurrentTableItemsViewArgs = {\n  distinct_on?: InputMaybe<Array<CurrentTableItemsViewSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentTableItemsViewOrderBy>>;\n  where?: InputMaybe<CurrentTableItemsViewBoolExp>;\n};\n\nexport type SubscriptionRootCurrentTableItemsViewAggregateArgs = {\n  distinct_on?: InputMaybe<Array<CurrentTableItemsViewSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentTableItemsViewOrderBy>>;\n  where?: InputMaybe<CurrentTableItemsViewBoolExp>;\n};\n\nexport type SubscriptionRootCurrentTableItemsViewStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<CurrentTableItemsViewStreamCursorInput>>;\n  where?: InputMaybe<CurrentTableItemsViewBoolExp>;\n};\n\nexport type SubscriptionRootCurrentTokenDatasArgs = {\n  distinct_on?: InputMaybe<Array<CurrentTokenDatasSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentTokenDatasOrderBy>>;\n  where?: InputMaybe<CurrentTokenDatasBoolExp>;\n};\n\nexport type SubscriptionRootCurrentTokenDatasAggregateArgs = {\n  distinct_on?: InputMaybe<Array<CurrentTokenDatasSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentTokenDatasOrderBy>>;\n  where?: InputMaybe<CurrentTokenDatasBoolExp>;\n};\n\nexport type SubscriptionRootCurrentTokenDatasByPkArgs = {\n  token_data_id_hash: Scalars[\"String\"][\"input\"];\n};\n\nexport type SubscriptionRootCurrentTokenDatasStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<CurrentTokenDatasStreamCursorInput>>;\n  where?: InputMaybe<CurrentTokenDatasBoolExp>;\n};\n\nexport type SubscriptionRootCurrentTokenDatasV2Args = {\n  distinct_on?: InputMaybe<Array<CurrentTokenDatasV2SelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentTokenDatasV2OrderBy>>;\n  where?: InputMaybe<CurrentTokenDatasV2BoolExp>;\n};\n\nexport type SubscriptionRootCurrentTokenDatasV2AggregateArgs = {\n  distinct_on?: InputMaybe<Array<CurrentTokenDatasV2SelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentTokenDatasV2OrderBy>>;\n  where?: InputMaybe<CurrentTokenDatasV2BoolExp>;\n};\n\nexport type SubscriptionRootCurrentTokenDatasV2ByPkArgs = {\n  token_data_id: Scalars[\"String\"][\"input\"];\n};\n\nexport type SubscriptionRootCurrentTokenDatasV2StreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<CurrentTokenDatasV2StreamCursorInput>>;\n  where?: InputMaybe<CurrentTokenDatasV2BoolExp>;\n};\n\nexport type SubscriptionRootCurrentTokenOwnershipsArgs = {\n  distinct_on?: InputMaybe<Array<CurrentTokenOwnershipsSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentTokenOwnershipsOrderBy>>;\n  where?: InputMaybe<CurrentTokenOwnershipsBoolExp>;\n};\n\nexport type SubscriptionRootCurrentTokenOwnershipsAggregateArgs = {\n  distinct_on?: InputMaybe<Array<CurrentTokenOwnershipsSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentTokenOwnershipsOrderBy>>;\n  where?: InputMaybe<CurrentTokenOwnershipsBoolExp>;\n};\n\nexport type SubscriptionRootCurrentTokenOwnershipsByPkArgs = {\n  owner_address: Scalars[\"String\"][\"input\"];\n  property_version: Scalars[\"numeric\"][\"input\"];\n  token_data_id_hash: Scalars[\"String\"][\"input\"];\n};\n\nexport type SubscriptionRootCurrentTokenOwnershipsStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<CurrentTokenOwnershipsStreamCursorInput>>;\n  where?: InputMaybe<CurrentTokenOwnershipsBoolExp>;\n};\n\nexport type SubscriptionRootCurrentTokenOwnershipsV2Args = {\n  distinct_on?: InputMaybe<Array<CurrentTokenOwnershipsV2SelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentTokenOwnershipsV2OrderBy>>;\n  where?: InputMaybe<CurrentTokenOwnershipsV2BoolExp>;\n};\n\nexport type SubscriptionRootCurrentTokenOwnershipsV2AggregateArgs = {\n  distinct_on?: InputMaybe<Array<CurrentTokenOwnershipsV2SelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentTokenOwnershipsV2OrderBy>>;\n  where?: InputMaybe<CurrentTokenOwnershipsV2BoolExp>;\n};\n\nexport type SubscriptionRootCurrentTokenOwnershipsV2ByPkArgs = {\n  owner_address: Scalars[\"String\"][\"input\"];\n  property_version_v1: Scalars[\"numeric\"][\"input\"];\n  storage_id: Scalars[\"String\"][\"input\"];\n  token_data_id: Scalars[\"String\"][\"input\"];\n};\n\nexport type SubscriptionRootCurrentTokenOwnershipsV2StreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<CurrentTokenOwnershipsV2StreamCursorInput>>;\n  where?: InputMaybe<CurrentTokenOwnershipsV2BoolExp>;\n};\n\nexport type SubscriptionRootCurrentTokenPendingClaimsArgs = {\n  distinct_on?: InputMaybe<Array<CurrentTokenPendingClaimsSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentTokenPendingClaimsOrderBy>>;\n  where?: InputMaybe<CurrentTokenPendingClaimsBoolExp>;\n};\n\nexport type SubscriptionRootCurrentTokenPendingClaimsAggregateArgs = {\n  distinct_on?: InputMaybe<Array<CurrentTokenPendingClaimsSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentTokenPendingClaimsOrderBy>>;\n  where?: InputMaybe<CurrentTokenPendingClaimsBoolExp>;\n};\n\nexport type SubscriptionRootCurrentTokenPendingClaimsByPkArgs = {\n  from_address: Scalars[\"String\"][\"input\"];\n  property_version: Scalars[\"numeric\"][\"input\"];\n  to_address: Scalars[\"String\"][\"input\"];\n  token_data_id_hash: Scalars[\"String\"][\"input\"];\n};\n\nexport type SubscriptionRootCurrentTokenPendingClaimsStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<CurrentTokenPendingClaimsStreamCursorInput>>;\n  where?: InputMaybe<CurrentTokenPendingClaimsBoolExp>;\n};\n\nexport type SubscriptionRootCurrentTokenRoyaltyV1Args = {\n  distinct_on?: InputMaybe<Array<CurrentTokenRoyaltyV1SelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentTokenRoyaltyV1OrderBy>>;\n  where?: InputMaybe<CurrentTokenRoyaltyV1BoolExp>;\n};\n\nexport type SubscriptionRootCurrentTokenRoyaltyV1AggregateArgs = {\n  distinct_on?: InputMaybe<Array<CurrentTokenRoyaltyV1SelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentTokenRoyaltyV1OrderBy>>;\n  where?: InputMaybe<CurrentTokenRoyaltyV1BoolExp>;\n};\n\nexport type SubscriptionRootCurrentTokenRoyaltyV1ByPkArgs = {\n  token_data_id: Scalars[\"String\"][\"input\"];\n};\n\nexport type SubscriptionRootCurrentTokenRoyaltyV1StreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<CurrentTokenRoyaltyV1StreamCursorInput>>;\n  where?: InputMaybe<CurrentTokenRoyaltyV1BoolExp>;\n};\n\nexport type SubscriptionRootCurrentTokenV2MetadataArgs = {\n  distinct_on?: InputMaybe<Array<CurrentTokenV2MetadataSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentTokenV2MetadataOrderBy>>;\n  where?: InputMaybe<CurrentTokenV2MetadataBoolExp>;\n};\n\nexport type SubscriptionRootCurrentTokenV2MetadataAggregateArgs = {\n  distinct_on?: InputMaybe<Array<CurrentTokenV2MetadataSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentTokenV2MetadataOrderBy>>;\n  where?: InputMaybe<CurrentTokenV2MetadataBoolExp>;\n};\n\nexport type SubscriptionRootCurrentTokenV2MetadataByPkArgs = {\n  object_address: Scalars[\"String\"][\"input\"];\n  resource_type: Scalars[\"String\"][\"input\"];\n};\n\nexport type SubscriptionRootCurrentTokenV2MetadataStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<CurrentTokenV2MetadataStreamCursorInput>>;\n  where?: InputMaybe<CurrentTokenV2MetadataBoolExp>;\n};\n\nexport type SubscriptionRootDelegatedStakingActivitiesArgs = {\n  distinct_on?: InputMaybe<Array<DelegatedStakingActivitiesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<DelegatedStakingActivitiesOrderBy>>;\n  where?: InputMaybe<DelegatedStakingActivitiesBoolExp>;\n};\n\nexport type SubscriptionRootDelegatedStakingActivitiesAggregateArgs = {\n  distinct_on?: InputMaybe<Array<DelegatedStakingActivitiesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<DelegatedStakingActivitiesOrderBy>>;\n  where?: InputMaybe<DelegatedStakingActivitiesBoolExp>;\n};\n\nexport type SubscriptionRootDelegatedStakingActivitiesByPkArgs = {\n  event_index: Scalars[\"bigint\"][\"input\"];\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\nexport type SubscriptionRootDelegatedStakingActivitiesStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<DelegatedStakingActivitiesStreamCursorInput>>;\n  where?: InputMaybe<DelegatedStakingActivitiesBoolExp>;\n};\n\nexport type SubscriptionRootDelegatedStakingPoolBalancesArgs = {\n  distinct_on?: InputMaybe<Array<DelegatedStakingPoolBalancesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<DelegatedStakingPoolBalancesOrderBy>>;\n  where?: InputMaybe<DelegatedStakingPoolBalancesBoolExp>;\n};\n\nexport type SubscriptionRootDelegatedStakingPoolBalancesAggregateArgs = {\n  distinct_on?: InputMaybe<Array<DelegatedStakingPoolBalancesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<DelegatedStakingPoolBalancesOrderBy>>;\n  where?: InputMaybe<DelegatedStakingPoolBalancesBoolExp>;\n};\n\nexport type SubscriptionRootDelegatedStakingPoolBalancesByPkArgs = {\n  staking_pool_address: Scalars[\"String\"][\"input\"];\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\nexport type SubscriptionRootDelegatedStakingPoolBalancesStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<DelegatedStakingPoolBalancesStreamCursorInput>>;\n  where?: InputMaybe<DelegatedStakingPoolBalancesBoolExp>;\n};\n\nexport type SubscriptionRootDelegatedStakingPoolsArgs = {\n  distinct_on?: InputMaybe<Array<DelegatedStakingPoolsSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<DelegatedStakingPoolsOrderBy>>;\n  where?: InputMaybe<DelegatedStakingPoolsBoolExp>;\n};\n\nexport type SubscriptionRootDelegatedStakingPoolsAggregateArgs = {\n  distinct_on?: InputMaybe<Array<DelegatedStakingPoolsSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<DelegatedStakingPoolsOrderBy>>;\n  where?: InputMaybe<DelegatedStakingPoolsBoolExp>;\n};\n\nexport type SubscriptionRootDelegatedStakingPoolsByPkArgs = {\n  staking_pool_address: Scalars[\"String\"][\"input\"];\n};\n\nexport type SubscriptionRootDelegatedStakingPoolsStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<DelegatedStakingPoolsStreamCursorInput>>;\n  where?: InputMaybe<DelegatedStakingPoolsBoolExp>;\n};\n\nexport type SubscriptionRootDelegatorBalancesArgs = {\n  distinct_on?: InputMaybe<Array<DelegatorBalancesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<DelegatorBalancesOrderBy>>;\n  where?: InputMaybe<DelegatorBalancesBoolExp>;\n};\n\nexport type SubscriptionRootDelegatorBalancesAggregateArgs = {\n  distinct_on?: InputMaybe<Array<DelegatorBalancesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<DelegatorBalancesOrderBy>>;\n  where?: InputMaybe<DelegatorBalancesBoolExp>;\n};\n\nexport type SubscriptionRootDelegatorBalancesByPkArgs = {\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n  write_set_change_index: Scalars[\"bigint\"][\"input\"];\n};\n\nexport type SubscriptionRootDelegatorBalancesStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<DelegatorBalancesStreamCursorInput>>;\n  where?: InputMaybe<DelegatorBalancesBoolExp>;\n};\n\nexport type SubscriptionRootDelegatorDistinctPoolArgs = {\n  distinct_on?: InputMaybe<Array<DelegatorDistinctPoolSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<DelegatorDistinctPoolOrderBy>>;\n  where?: InputMaybe<DelegatorDistinctPoolBoolExp>;\n};\n\nexport type SubscriptionRootDelegatorDistinctPoolAggregateArgs = {\n  distinct_on?: InputMaybe<Array<DelegatorDistinctPoolSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<DelegatorDistinctPoolOrderBy>>;\n  where?: InputMaybe<DelegatorDistinctPoolBoolExp>;\n};\n\nexport type SubscriptionRootDelegatorDistinctPoolStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<DelegatorDistinctPoolStreamCursorInput>>;\n  where?: InputMaybe<DelegatorDistinctPoolBoolExp>;\n};\n\nexport type SubscriptionRootEventSizeInfoArgs = {\n  distinct_on?: InputMaybe<Array<EventSizeInfoSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<EventSizeInfoOrderBy>>;\n  where?: InputMaybe<EventSizeInfoBoolExp>;\n};\n\nexport type SubscriptionRootEventSizeInfoAggregateArgs = {\n  distinct_on?: InputMaybe<Array<EventSizeInfoSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<EventSizeInfoOrderBy>>;\n  where?: InputMaybe<EventSizeInfoBoolExp>;\n};\n\nexport type SubscriptionRootEventSizeInfoByPkArgs = {\n  index: Scalars[\"bigint\"][\"input\"];\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\nexport type SubscriptionRootEventSizeInfoStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<EventSizeInfoStreamCursorInput>>;\n  where?: InputMaybe<EventSizeInfoBoolExp>;\n};\n\nexport type SubscriptionRootEventsArgs = {\n  distinct_on?: InputMaybe<Array<EventsSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<EventsOrderBy>>;\n  where?: InputMaybe<EventsBoolExp>;\n};\n\nexport type SubscriptionRootEventsAggregateArgs = {\n  distinct_on?: InputMaybe<Array<EventsSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<EventsOrderBy>>;\n  where?: InputMaybe<EventsBoolExp>;\n};\n\nexport type SubscriptionRootEventsByPkArgs = {\n  event_index: Scalars[\"bigint\"][\"input\"];\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\nexport type SubscriptionRootEventsStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<EventsStreamCursorInput>>;\n  where?: InputMaybe<EventsBoolExp>;\n};\n\nexport type SubscriptionRootEventsViewArgs = {\n  distinct_on?: InputMaybe<Array<EventsViewSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<EventsViewOrderBy>>;\n  where?: InputMaybe<EventsViewBoolExp>;\n};\n\nexport type SubscriptionRootEventsViewAggregateArgs = {\n  distinct_on?: InputMaybe<Array<EventsViewSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<EventsViewOrderBy>>;\n  where?: InputMaybe<EventsViewBoolExp>;\n};\n\nexport type SubscriptionRootEventsViewStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<EventsViewStreamCursorInput>>;\n  where?: InputMaybe<EventsViewBoolExp>;\n};\n\nexport type SubscriptionRootFungibleAssetActivitiesArgs = {\n  distinct_on?: InputMaybe<Array<FungibleAssetActivitiesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<FungibleAssetActivitiesOrderBy>>;\n  where?: InputMaybe<FungibleAssetActivitiesBoolExp>;\n};\n\nexport type SubscriptionRootFungibleAssetActivitiesAggregateArgs = {\n  distinct_on?: InputMaybe<Array<FungibleAssetActivitiesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<FungibleAssetActivitiesOrderBy>>;\n  where?: InputMaybe<FungibleAssetActivitiesBoolExp>;\n};\n\nexport type SubscriptionRootFungibleAssetActivitiesByPkArgs = {\n  event_index: Scalars[\"bigint\"][\"input\"];\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\nexport type SubscriptionRootFungibleAssetActivitiesStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<FungibleAssetActivitiesStreamCursorInput>>;\n  where?: InputMaybe<FungibleAssetActivitiesBoolExp>;\n};\n\nexport type SubscriptionRootFungibleAssetBalancesArgs = {\n  distinct_on?: InputMaybe<Array<FungibleAssetBalancesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<FungibleAssetBalancesOrderBy>>;\n  where?: InputMaybe<FungibleAssetBalancesBoolExp>;\n};\n\nexport type SubscriptionRootFungibleAssetBalancesAggregateArgs = {\n  distinct_on?: InputMaybe<Array<FungibleAssetBalancesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<FungibleAssetBalancesOrderBy>>;\n  where?: InputMaybe<FungibleAssetBalancesBoolExp>;\n};\n\nexport type SubscriptionRootFungibleAssetBalancesByPkArgs = {\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n  write_set_change_index: Scalars[\"bigint\"][\"input\"];\n};\n\nexport type SubscriptionRootFungibleAssetBalancesStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<FungibleAssetBalancesStreamCursorInput>>;\n  where?: InputMaybe<FungibleAssetBalancesBoolExp>;\n};\n\nexport type SubscriptionRootFungibleAssetMetadataArgs = {\n  distinct_on?: InputMaybe<Array<FungibleAssetMetadataSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<FungibleAssetMetadataOrderBy>>;\n  where?: InputMaybe<FungibleAssetMetadataBoolExp>;\n};\n\nexport type SubscriptionRootFungibleAssetMetadataAggregateArgs = {\n  distinct_on?: InputMaybe<Array<FungibleAssetMetadataSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<FungibleAssetMetadataOrderBy>>;\n  where?: InputMaybe<FungibleAssetMetadataBoolExp>;\n};\n\nexport type SubscriptionRootFungibleAssetMetadataByPkArgs = {\n  asset_type: Scalars[\"String\"][\"input\"];\n};\n\nexport type SubscriptionRootFungibleAssetMetadataStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<FungibleAssetMetadataStreamCursorInput>>;\n  where?: InputMaybe<FungibleAssetMetadataBoolExp>;\n};\n\nexport type SubscriptionRootFungibleAssetToCoinMappingsArgs = {\n  distinct_on?: InputMaybe<Array<FungibleAssetToCoinMappingsSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<FungibleAssetToCoinMappingsOrderBy>>;\n  where?: InputMaybe<FungibleAssetToCoinMappingsBoolExp>;\n};\n\nexport type SubscriptionRootFungibleAssetToCoinMappingsAggregateArgs = {\n  distinct_on?: InputMaybe<Array<FungibleAssetToCoinMappingsSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<FungibleAssetToCoinMappingsOrderBy>>;\n  where?: InputMaybe<FungibleAssetToCoinMappingsBoolExp>;\n};\n\nexport type SubscriptionRootFungibleAssetToCoinMappingsByPkArgs = {\n  fungible_asset_metadata_address: Scalars[\"String\"][\"input\"];\n};\n\nexport type SubscriptionRootFungibleAssetToCoinMappingsStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<FungibleAssetToCoinMappingsStreamCursorInput>>;\n  where?: InputMaybe<FungibleAssetToCoinMappingsBoolExp>;\n};\n\nexport type SubscriptionRootGasFeesArgs = {\n  distinct_on?: InputMaybe<Array<GasFeesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<GasFeesOrderBy>>;\n  where?: InputMaybe<GasFeesBoolExp>;\n};\n\nexport type SubscriptionRootGasFeesAggregateArgs = {\n  distinct_on?: InputMaybe<Array<GasFeesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<GasFeesOrderBy>>;\n  where?: InputMaybe<GasFeesBoolExp>;\n};\n\nexport type SubscriptionRootGasFeesByPkArgs = {\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\nexport type SubscriptionRootGasFeesStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<GasFeesStreamCursorInput>>;\n  where?: InputMaybe<GasFeesBoolExp>;\n};\n\nexport type SubscriptionRootIndexerStatusArgs = {\n  distinct_on?: InputMaybe<Array<IndexerStatusSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<IndexerStatusOrderBy>>;\n  where?: InputMaybe<IndexerStatusBoolExp>;\n};\n\nexport type SubscriptionRootIndexerStatusAggregateArgs = {\n  distinct_on?: InputMaybe<Array<IndexerStatusSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<IndexerStatusOrderBy>>;\n  where?: InputMaybe<IndexerStatusBoolExp>;\n};\n\nexport type SubscriptionRootIndexerStatusByPkArgs = {\n  db: Scalars[\"String\"][\"input\"];\n};\n\nexport type SubscriptionRootIndexerStatusStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<IndexerStatusStreamCursorInput>>;\n  where?: InputMaybe<IndexerStatusBoolExp>;\n};\n\nexport type SubscriptionRootMoveModulesArgs = {\n  distinct_on?: InputMaybe<Array<MoveModulesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<MoveModulesOrderBy>>;\n  where?: InputMaybe<MoveModulesBoolExp>;\n};\n\nexport type SubscriptionRootMoveModulesAggregateArgs = {\n  distinct_on?: InputMaybe<Array<MoveModulesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<MoveModulesOrderBy>>;\n  where?: InputMaybe<MoveModulesBoolExp>;\n};\n\nexport type SubscriptionRootMoveModulesByPkArgs = {\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n  write_set_change_index: Scalars[\"bigint\"][\"input\"];\n};\n\nexport type SubscriptionRootMoveModulesStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<MoveModulesStreamCursorInput>>;\n  where?: InputMaybe<MoveModulesBoolExp>;\n};\n\nexport type SubscriptionRootMoveResourcesArgs = {\n  distinct_on?: InputMaybe<Array<MoveResourcesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<MoveResourcesOrderBy>>;\n  where?: InputMaybe<MoveResourcesBoolExp>;\n};\n\nexport type SubscriptionRootMoveResourcesAggregateArgs = {\n  distinct_on?: InputMaybe<Array<MoveResourcesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<MoveResourcesOrderBy>>;\n  where?: InputMaybe<MoveResourcesBoolExp>;\n};\n\nexport type SubscriptionRootMoveResourcesByPkArgs = {\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n  write_set_change_index: Scalars[\"bigint\"][\"input\"];\n};\n\nexport type SubscriptionRootMoveResourcesStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<MoveResourcesStreamCursorInput>>;\n  where?: InputMaybe<MoveResourcesBoolExp>;\n};\n\nexport type SubscriptionRootMoveResourcesViewArgs = {\n  distinct_on?: InputMaybe<Array<MoveResourcesViewSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<MoveResourcesViewOrderBy>>;\n  where?: InputMaybe<MoveResourcesViewBoolExp>;\n};\n\nexport type SubscriptionRootMoveResourcesViewAggregateArgs = {\n  distinct_on?: InputMaybe<Array<MoveResourcesViewSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<MoveResourcesViewOrderBy>>;\n  where?: InputMaybe<MoveResourcesViewBoolExp>;\n};\n\nexport type SubscriptionRootMoveResourcesViewStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<MoveResourcesViewStreamCursorInput>>;\n  where?: InputMaybe<MoveResourcesViewBoolExp>;\n};\n\nexport type SubscriptionRootNftMetadataCrawlerParsedAssetUrisArgs = {\n  distinct_on?: InputMaybe<Array<NftMetadataCrawlerParsedAssetUrisSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<NftMetadataCrawlerParsedAssetUrisOrderBy>>;\n  where?: InputMaybe<NftMetadataCrawlerParsedAssetUrisBoolExp>;\n};\n\nexport type SubscriptionRootNftMetadataCrawlerParsedAssetUrisAggregateArgs = {\n  distinct_on?: InputMaybe<Array<NftMetadataCrawlerParsedAssetUrisSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<NftMetadataCrawlerParsedAssetUrisOrderBy>>;\n  where?: InputMaybe<NftMetadataCrawlerParsedAssetUrisBoolExp>;\n};\n\nexport type SubscriptionRootNftMetadataCrawlerParsedAssetUrisByPkArgs = {\n  asset_uri: Scalars[\"String\"][\"input\"];\n};\n\nexport type SubscriptionRootNftMetadataCrawlerParsedAssetUrisStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<NftMetadataCrawlerParsedAssetUrisStreamCursorInput>>;\n  where?: InputMaybe<NftMetadataCrawlerParsedAssetUrisBoolExp>;\n};\n\nexport type SubscriptionRootNftPointsArgs = {\n  distinct_on?: InputMaybe<Array<NftPointsSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<NftPointsOrderBy>>;\n  where?: InputMaybe<NftPointsBoolExp>;\n};\n\nexport type SubscriptionRootNftPointsAggregateArgs = {\n  distinct_on?: InputMaybe<Array<NftPointsSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<NftPointsOrderBy>>;\n  where?: InputMaybe<NftPointsBoolExp>;\n};\n\nexport type SubscriptionRootNftPointsByPkArgs = {\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\nexport type SubscriptionRootNftPointsStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<NftPointsStreamCursorInput>>;\n  where?: InputMaybe<NftPointsBoolExp>;\n};\n\nexport type SubscriptionRootNumActiveDelegatorPerPoolArgs = {\n  distinct_on?: InputMaybe<Array<NumActiveDelegatorPerPoolSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<NumActiveDelegatorPerPoolOrderBy>>;\n  where?: InputMaybe<NumActiveDelegatorPerPoolBoolExp>;\n};\n\nexport type SubscriptionRootNumActiveDelegatorPerPoolAggregateArgs = {\n  distinct_on?: InputMaybe<Array<NumActiveDelegatorPerPoolSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<NumActiveDelegatorPerPoolOrderBy>>;\n  where?: InputMaybe<NumActiveDelegatorPerPoolBoolExp>;\n};\n\nexport type SubscriptionRootNumActiveDelegatorPerPoolStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<NumActiveDelegatorPerPoolStreamCursorInput>>;\n  where?: InputMaybe<NumActiveDelegatorPerPoolBoolExp>;\n};\n\nexport type SubscriptionRootObjectsArgs = {\n  distinct_on?: InputMaybe<Array<ObjectsSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<ObjectsOrderBy>>;\n  where?: InputMaybe<ObjectsBoolExp>;\n};\n\nexport type SubscriptionRootObjectsAggregateArgs = {\n  distinct_on?: InputMaybe<Array<ObjectsSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<ObjectsOrderBy>>;\n  where?: InputMaybe<ObjectsBoolExp>;\n};\n\nexport type SubscriptionRootObjectsByPkArgs = {\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n  write_set_change_index: Scalars[\"bigint\"][\"input\"];\n};\n\nexport type SubscriptionRootObjectsStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<ObjectsStreamCursorInput>>;\n  where?: InputMaybe<ObjectsBoolExp>;\n};\n\nexport type SubscriptionRootProcessorMetadataProcessorStatusArgs = {\n  distinct_on?: InputMaybe<Array<ProcessorMetadataProcessorStatusSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<ProcessorMetadataProcessorStatusOrderBy>>;\n  where?: InputMaybe<ProcessorMetadataProcessorStatusBoolExp>;\n};\n\nexport type SubscriptionRootProcessorMetadataProcessorStatusAggregateArgs = {\n  distinct_on?: InputMaybe<Array<ProcessorMetadataProcessorStatusSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<ProcessorMetadataProcessorStatusOrderBy>>;\n  where?: InputMaybe<ProcessorMetadataProcessorStatusBoolExp>;\n};\n\nexport type SubscriptionRootProcessorMetadataProcessorStatusByPkArgs = {\n  processor: Scalars[\"String\"][\"input\"];\n};\n\nexport type SubscriptionRootProcessorMetadataProcessorStatusStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<ProcessorMetadataProcessorStatusStreamCursorInput>>;\n  where?: InputMaybe<ProcessorMetadataProcessorStatusBoolExp>;\n};\n\nexport type SubscriptionRootProcessorStatusArgs = {\n  distinct_on?: InputMaybe<Array<ProcessorStatusSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<ProcessorStatusOrderBy>>;\n  where?: InputMaybe<ProcessorStatusBoolExp>;\n};\n\nexport type SubscriptionRootProcessorStatusAggregateArgs = {\n  distinct_on?: InputMaybe<Array<ProcessorStatusSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<ProcessorStatusOrderBy>>;\n  where?: InputMaybe<ProcessorStatusBoolExp>;\n};\n\nexport type SubscriptionRootProcessorStatusByPkArgs = {\n  processor: Scalars[\"String\"][\"input\"];\n};\n\nexport type SubscriptionRootProcessorStatusStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<ProcessorStatusStreamCursorInput>>;\n  where?: InputMaybe<ProcessorStatusBoolExp>;\n};\n\nexport type SubscriptionRootProposalVotesArgs = {\n  distinct_on?: InputMaybe<Array<ProposalVotesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<ProposalVotesOrderBy>>;\n  where?: InputMaybe<ProposalVotesBoolExp>;\n};\n\nexport type SubscriptionRootProposalVotesAggregateArgs = {\n  distinct_on?: InputMaybe<Array<ProposalVotesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<ProposalVotesOrderBy>>;\n  where?: InputMaybe<ProposalVotesBoolExp>;\n};\n\nexport type SubscriptionRootProposalVotesByPkArgs = {\n  proposal_id: Scalars[\"bigint\"][\"input\"];\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n  voter_address: Scalars[\"String\"][\"input\"];\n};\n\nexport type SubscriptionRootProposalVotesStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<ProposalVotesStreamCursorInput>>;\n  where?: InputMaybe<ProposalVotesBoolExp>;\n};\n\nexport type SubscriptionRootPublicKeyAuthKeysArgs = {\n  distinct_on?: InputMaybe<Array<PublicKeyAuthKeysSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<PublicKeyAuthKeysOrderBy>>;\n  where?: InputMaybe<PublicKeyAuthKeysBoolExp>;\n};\n\nexport type SubscriptionRootPublicKeyAuthKeysAggregateArgs = {\n  distinct_on?: InputMaybe<Array<PublicKeyAuthKeysSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<PublicKeyAuthKeysOrderBy>>;\n  where?: InputMaybe<PublicKeyAuthKeysBoolExp>;\n};\n\nexport type SubscriptionRootPublicKeyAuthKeysByPkArgs = {\n  auth_key: Scalars[\"String\"][\"input\"];\n  public_key: Scalars[\"String\"][\"input\"];\n  public_key_type: Scalars[\"String\"][\"input\"];\n};\n\nexport type SubscriptionRootPublicKeyAuthKeysStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<PublicKeyAuthKeysStreamCursorInput>>;\n  where?: InputMaybe<PublicKeyAuthKeysBoolExp>;\n};\n\nexport type SubscriptionRootSignaturesArgs = {\n  distinct_on?: InputMaybe<Array<SignaturesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<SignaturesOrderBy>>;\n  where?: InputMaybe<SignaturesBoolExp>;\n};\n\nexport type SubscriptionRootSignaturesAggregateArgs = {\n  distinct_on?: InputMaybe<Array<SignaturesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<SignaturesOrderBy>>;\n  where?: InputMaybe<SignaturesBoolExp>;\n};\n\nexport type SubscriptionRootSignaturesByPkArgs = {\n  is_sender_primary: Scalars[\"Boolean\"][\"input\"];\n  multi_agent_index: Scalars[\"bigint\"][\"input\"];\n  multi_sig_index: Scalars[\"bigint\"][\"input\"];\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\nexport type SubscriptionRootSignaturesStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<SignaturesStreamCursorInput>>;\n  where?: InputMaybe<SignaturesBoolExp>;\n};\n\nexport type SubscriptionRootSpamAssetsArgs = {\n  distinct_on?: InputMaybe<Array<SpamAssetsSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<SpamAssetsOrderBy>>;\n  where?: InputMaybe<SpamAssetsBoolExp>;\n};\n\nexport type SubscriptionRootSpamAssetsAggregateArgs = {\n  distinct_on?: InputMaybe<Array<SpamAssetsSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<SpamAssetsOrderBy>>;\n  where?: InputMaybe<SpamAssetsBoolExp>;\n};\n\nexport type SubscriptionRootSpamAssetsByPkArgs = {\n  asset: Scalars[\"String\"][\"input\"];\n};\n\nexport type SubscriptionRootSpamAssetsStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<SpamAssetsStreamCursorInput>>;\n  where?: InputMaybe<SpamAssetsBoolExp>;\n};\n\nexport type SubscriptionRootTableItemsArgs = {\n  distinct_on?: InputMaybe<Array<TableItemsSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<TableItemsOrderBy>>;\n  where?: InputMaybe<TableItemsBoolExp>;\n};\n\nexport type SubscriptionRootTableItemsAggregateArgs = {\n  distinct_on?: InputMaybe<Array<TableItemsSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<TableItemsOrderBy>>;\n  where?: InputMaybe<TableItemsBoolExp>;\n};\n\nexport type SubscriptionRootTableItemsByPkArgs = {\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n  write_set_change_index: Scalars[\"bigint\"][\"input\"];\n};\n\nexport type SubscriptionRootTableItemsStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<TableItemsStreamCursorInput>>;\n  where?: InputMaybe<TableItemsBoolExp>;\n};\n\nexport type SubscriptionRootTableItemsViewArgs = {\n  distinct_on?: InputMaybe<Array<TableItemsViewSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<TableItemsViewOrderBy>>;\n  where?: InputMaybe<TableItemsViewBoolExp>;\n};\n\nexport type SubscriptionRootTableItemsViewAggregateArgs = {\n  distinct_on?: InputMaybe<Array<TableItemsViewSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<TableItemsViewOrderBy>>;\n  where?: InputMaybe<TableItemsViewBoolExp>;\n};\n\nexport type SubscriptionRootTableItemsViewStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<TableItemsViewStreamCursorInput>>;\n  where?: InputMaybe<TableItemsViewBoolExp>;\n};\n\nexport type SubscriptionRootTableMetadatasArgs = {\n  distinct_on?: InputMaybe<Array<TableMetadatasSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<TableMetadatasOrderBy>>;\n  where?: InputMaybe<TableMetadatasBoolExp>;\n};\n\nexport type SubscriptionRootTableMetadatasAggregateArgs = {\n  distinct_on?: InputMaybe<Array<TableMetadatasSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<TableMetadatasOrderBy>>;\n  where?: InputMaybe<TableMetadatasBoolExp>;\n};\n\nexport type SubscriptionRootTableMetadatasByPkArgs = {\n  handle: Scalars[\"String\"][\"input\"];\n};\n\nexport type SubscriptionRootTableMetadatasStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<TableMetadatasStreamCursorInput>>;\n  where?: InputMaybe<TableMetadatasBoolExp>;\n};\n\nexport type SubscriptionRootTokenActivitiesArgs = {\n  distinct_on?: InputMaybe<Array<TokenActivitiesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<TokenActivitiesOrderBy>>;\n  where?: InputMaybe<TokenActivitiesBoolExp>;\n};\n\nexport type SubscriptionRootTokenActivitiesAggregateArgs = {\n  distinct_on?: InputMaybe<Array<TokenActivitiesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<TokenActivitiesOrderBy>>;\n  where?: InputMaybe<TokenActivitiesBoolExp>;\n};\n\nexport type SubscriptionRootTokenActivitiesByPkArgs = {\n  event_account_address: Scalars[\"String\"][\"input\"];\n  event_creation_number: Scalars[\"bigint\"][\"input\"];\n  event_sequence_number: Scalars[\"bigint\"][\"input\"];\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\nexport type SubscriptionRootTokenActivitiesStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<TokenActivitiesStreamCursorInput>>;\n  where?: InputMaybe<TokenActivitiesBoolExp>;\n};\n\nexport type SubscriptionRootTokenActivitiesV2Args = {\n  distinct_on?: InputMaybe<Array<TokenActivitiesV2SelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<TokenActivitiesV2OrderBy>>;\n  where?: InputMaybe<TokenActivitiesV2BoolExp>;\n};\n\nexport type SubscriptionRootTokenActivitiesV2AggregateArgs = {\n  distinct_on?: InputMaybe<Array<TokenActivitiesV2SelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<TokenActivitiesV2OrderBy>>;\n  where?: InputMaybe<TokenActivitiesV2BoolExp>;\n};\n\nexport type SubscriptionRootTokenActivitiesV2ByPkArgs = {\n  event_index: Scalars[\"bigint\"][\"input\"];\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\nexport type SubscriptionRootTokenActivitiesV2StreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<TokenActivitiesV2StreamCursorInput>>;\n  where?: InputMaybe<TokenActivitiesV2BoolExp>;\n};\n\nexport type SubscriptionRootTokenDatasArgs = {\n  distinct_on?: InputMaybe<Array<TokenDatasSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<TokenDatasOrderBy>>;\n  where?: InputMaybe<TokenDatasBoolExp>;\n};\n\nexport type SubscriptionRootTokenDatasAggregateArgs = {\n  distinct_on?: InputMaybe<Array<TokenDatasSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<TokenDatasOrderBy>>;\n  where?: InputMaybe<TokenDatasBoolExp>;\n};\n\nexport type SubscriptionRootTokenDatasByPkArgs = {\n  token_data_id_hash: Scalars[\"String\"][\"input\"];\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\nexport type SubscriptionRootTokenDatasStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<TokenDatasStreamCursorInput>>;\n  where?: InputMaybe<TokenDatasBoolExp>;\n};\n\nexport type SubscriptionRootTokenDatasV2Args = {\n  distinct_on?: InputMaybe<Array<TokenDatasV2SelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<TokenDatasV2OrderBy>>;\n  where?: InputMaybe<TokenDatasV2BoolExp>;\n};\n\nexport type SubscriptionRootTokenDatasV2AggregateArgs = {\n  distinct_on?: InputMaybe<Array<TokenDatasV2SelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<TokenDatasV2OrderBy>>;\n  where?: InputMaybe<TokenDatasV2BoolExp>;\n};\n\nexport type SubscriptionRootTokenDatasV2ByPkArgs = {\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n  write_set_change_index: Scalars[\"bigint\"][\"input\"];\n};\n\nexport type SubscriptionRootTokenDatasV2StreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<TokenDatasV2StreamCursorInput>>;\n  where?: InputMaybe<TokenDatasV2BoolExp>;\n};\n\nexport type SubscriptionRootTokenOwnershipsArgs = {\n  distinct_on?: InputMaybe<Array<TokenOwnershipsSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<TokenOwnershipsOrderBy>>;\n  where?: InputMaybe<TokenOwnershipsBoolExp>;\n};\n\nexport type SubscriptionRootTokenOwnershipsAggregateArgs = {\n  distinct_on?: InputMaybe<Array<TokenOwnershipsSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<TokenOwnershipsOrderBy>>;\n  where?: InputMaybe<TokenOwnershipsBoolExp>;\n};\n\nexport type SubscriptionRootTokenOwnershipsByPkArgs = {\n  property_version: Scalars[\"numeric\"][\"input\"];\n  table_handle: Scalars[\"String\"][\"input\"];\n  token_data_id_hash: Scalars[\"String\"][\"input\"];\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\nexport type SubscriptionRootTokenOwnershipsStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<TokenOwnershipsStreamCursorInput>>;\n  where?: InputMaybe<TokenOwnershipsBoolExp>;\n};\n\nexport type SubscriptionRootTokenOwnershipsV2Args = {\n  distinct_on?: InputMaybe<Array<TokenOwnershipsV2SelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<TokenOwnershipsV2OrderBy>>;\n  where?: InputMaybe<TokenOwnershipsV2BoolExp>;\n};\n\nexport type SubscriptionRootTokenOwnershipsV2AggregateArgs = {\n  distinct_on?: InputMaybe<Array<TokenOwnershipsV2SelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<TokenOwnershipsV2OrderBy>>;\n  where?: InputMaybe<TokenOwnershipsV2BoolExp>;\n};\n\nexport type SubscriptionRootTokenOwnershipsV2ByPkArgs = {\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n  write_set_change_index: Scalars[\"bigint\"][\"input\"];\n};\n\nexport type SubscriptionRootTokenOwnershipsV2StreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<TokenOwnershipsV2StreamCursorInput>>;\n  where?: InputMaybe<TokenOwnershipsV2BoolExp>;\n};\n\nexport type SubscriptionRootTokensArgs = {\n  distinct_on?: InputMaybe<Array<TokensSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<TokensOrderBy>>;\n  where?: InputMaybe<TokensBoolExp>;\n};\n\nexport type SubscriptionRootTokensAggregateArgs = {\n  distinct_on?: InputMaybe<Array<TokensSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<TokensOrderBy>>;\n  where?: InputMaybe<TokensBoolExp>;\n};\n\nexport type SubscriptionRootTokensByPkArgs = {\n  property_version: Scalars[\"numeric\"][\"input\"];\n  token_data_id_hash: Scalars[\"String\"][\"input\"];\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\nexport type SubscriptionRootTokensStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<TokensStreamCursorInput>>;\n  where?: InputMaybe<TokensBoolExp>;\n};\n\nexport type SubscriptionRootTransactionSizeInfoArgs = {\n  distinct_on?: InputMaybe<Array<TransactionSizeInfoSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<TransactionSizeInfoOrderBy>>;\n  where?: InputMaybe<TransactionSizeInfoBoolExp>;\n};\n\nexport type SubscriptionRootTransactionSizeInfoAggregateArgs = {\n  distinct_on?: InputMaybe<Array<TransactionSizeInfoSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<TransactionSizeInfoOrderBy>>;\n  where?: InputMaybe<TransactionSizeInfoBoolExp>;\n};\n\nexport type SubscriptionRootTransactionSizeInfoByPkArgs = {\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\nexport type SubscriptionRootTransactionSizeInfoStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<TransactionSizeInfoStreamCursorInput>>;\n  where?: InputMaybe<TransactionSizeInfoBoolExp>;\n};\n\nexport type SubscriptionRootTransactionsViewArgs = {\n  distinct_on?: InputMaybe<Array<TransactionsViewSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<TransactionsViewOrderBy>>;\n  where?: InputMaybe<TransactionsViewBoolExp>;\n};\n\nexport type SubscriptionRootTransactionsViewAggregateArgs = {\n  distinct_on?: InputMaybe<Array<TransactionsViewSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<TransactionsViewOrderBy>>;\n  where?: InputMaybe<TransactionsViewBoolExp>;\n};\n\nexport type SubscriptionRootTransactionsViewStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<TransactionsViewStreamCursorInput>>;\n  where?: InputMaybe<TransactionsViewBoolExp>;\n};\n\nexport type SubscriptionRootUserTransactionsArgs = {\n  distinct_on?: InputMaybe<Array<UserTransactionsSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<UserTransactionsOrderBy>>;\n  where?: InputMaybe<UserTransactionsBoolExp>;\n};\n\nexport type SubscriptionRootUserTransactionsAggregateArgs = {\n  distinct_on?: InputMaybe<Array<UserTransactionsSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<UserTransactionsOrderBy>>;\n  where?: InputMaybe<UserTransactionsBoolExp>;\n};\n\nexport type SubscriptionRootUserTransactionsByPkArgs = {\n  version: Scalars[\"bigint\"][\"input\"];\n};\n\nexport type SubscriptionRootUserTransactionsStreamArgs = {\n  batch_size: Scalars[\"Int\"][\"input\"];\n  cursor: Array<InputMaybe<UserTransactionsStreamCursorInput>>;\n  where?: InputMaybe<UserTransactionsBoolExp>;\n};\n\n/** columns and relationships of \"table_items\" */\nexport type TableItems = {\n  decoded_key: Scalars[\"jsonb\"][\"output\"];\n  decoded_value?: Maybe<Scalars[\"jsonb\"][\"output\"]>;\n  inserted_at: Scalars[\"timestamp\"][\"output\"];\n  is_deleted: Scalars[\"Boolean\"][\"output\"];\n  key: Scalars[\"String\"][\"output\"];\n  table_handle: Scalars[\"String\"][\"output\"];\n  transaction_block_height: Scalars[\"bigint\"][\"output\"];\n  transaction_version: Scalars[\"bigint\"][\"output\"];\n  write_set_change_index: Scalars[\"bigint\"][\"output\"];\n};\n\n/** columns and relationships of \"table_items\" */\nexport type TableItemsDecodedKeyArgs = {\n  path?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** columns and relationships of \"table_items\" */\nexport type TableItemsDecodedValueArgs = {\n  path?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregated selection of \"table_items\" */\nexport type TableItemsAggregate = {\n  aggregate?: Maybe<TableItemsAggregateFields>;\n  nodes: Array<TableItems>;\n};\n\n/** aggregate fields of \"table_items\" */\nexport type TableItemsAggregateFields = {\n  avg?: Maybe<TableItemsAvgFields>;\n  count: Scalars[\"Int\"][\"output\"];\n  max?: Maybe<TableItemsMaxFields>;\n  min?: Maybe<TableItemsMinFields>;\n  stddev?: Maybe<TableItemsStddevFields>;\n  stddev_pop?: Maybe<TableItemsStddevPopFields>;\n  stddev_samp?: Maybe<TableItemsStddevSampFields>;\n  sum?: Maybe<TableItemsSumFields>;\n  var_pop?: Maybe<TableItemsVarPopFields>;\n  var_samp?: Maybe<TableItemsVarSampFields>;\n  variance?: Maybe<TableItemsVarianceFields>;\n};\n\n/** aggregate fields of \"table_items\" */\nexport type TableItemsAggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<TableItemsSelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** append existing jsonb value of filtered columns with new jsonb value */\nexport type TableItemsAppendInput = {\n  decoded_key?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  decoded_value?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n};\n\n/** aggregate avg on columns */\nexport type TableItemsAvgFields = {\n  transaction_block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Boolean expression to filter rows from the table \"table_items\". All fields are combined with a logical 'AND'. */\nexport type TableItemsBoolExp = {\n  _and?: InputMaybe<Array<TableItemsBoolExp>>;\n  _not?: InputMaybe<TableItemsBoolExp>;\n  _or?: InputMaybe<Array<TableItemsBoolExp>>;\n  decoded_key?: InputMaybe<JsonbComparisonExp>;\n  decoded_value?: InputMaybe<JsonbComparisonExp>;\n  inserted_at?: InputMaybe<TimestampComparisonExp>;\n  is_deleted?: InputMaybe<BooleanComparisonExp>;\n  key?: InputMaybe<StringComparisonExp>;\n  table_handle?: InputMaybe<StringComparisonExp>;\n  transaction_block_height?: InputMaybe<BigintComparisonExp>;\n  transaction_version?: InputMaybe<BigintComparisonExp>;\n  write_set_change_index?: InputMaybe<BigintComparisonExp>;\n};\n\n/** unique or primary key constraints on table \"table_items\" */\nexport enum TableItemsConstraint {\n  /** unique or primary key constraint on columns \"write_set_change_index\", \"transaction_version\" */\n  TableItemsPkey = \"table_items_pkey\",\n}\n\n/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */\nexport type TableItemsDeleteAtPathInput = {\n  decoded_key?: InputMaybe<Array<Scalars[\"String\"][\"input\"]>>;\n  decoded_value?: InputMaybe<Array<Scalars[\"String\"][\"input\"]>>;\n};\n\n/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */\nexport type TableItemsDeleteElemInput = {\n  decoded_key?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  decoded_value?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n};\n\n/** delete key/value pair or string element. key/value pairs are matched based on their key value */\nexport type TableItemsDeleteKeyInput = {\n  decoded_key?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  decoded_value?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** input type for incrementing numeric columns in table \"table_items\" */\nexport type TableItemsIncInput = {\n  transaction_block_height?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  write_set_change_index?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** input type for inserting data into table \"table_items\" */\nexport type TableItemsInsertInput = {\n  decoded_key?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  decoded_value?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  is_deleted?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  key?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  table_handle?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  transaction_block_height?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  write_set_change_index?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** aggregate max on columns */\nexport type TableItemsMaxFields = {\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  key?: Maybe<Scalars[\"String\"][\"output\"]>;\n  table_handle?: Maybe<Scalars[\"String\"][\"output\"]>;\n  transaction_block_height?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** aggregate min on columns */\nexport type TableItemsMinFields = {\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  key?: Maybe<Scalars[\"String\"][\"output\"]>;\n  table_handle?: Maybe<Scalars[\"String\"][\"output\"]>;\n  transaction_block_height?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** response of any mutation on the table \"table_items\" */\nexport type TableItemsMutationResponse = {\n  /** number of rows affected by the mutation */\n  affected_rows: Scalars[\"Int\"][\"output\"];\n  /** data from the rows affected by the mutation */\n  returning: Array<TableItems>;\n};\n\n/** on_conflict condition type for table \"table_items\" */\nexport type TableItemsOnConflict = {\n  constraint: TableItemsConstraint;\n  update_columns?: Array<TableItemsUpdateColumn>;\n  where?: InputMaybe<TableItemsBoolExp>;\n};\n\n/** Ordering options when selecting data from \"table_items\". */\nexport type TableItemsOrderBy = {\n  decoded_key?: InputMaybe<OrderBy>;\n  decoded_value?: InputMaybe<OrderBy>;\n  inserted_at?: InputMaybe<OrderBy>;\n  is_deleted?: InputMaybe<OrderBy>;\n  key?: InputMaybe<OrderBy>;\n  table_handle?: InputMaybe<OrderBy>;\n  transaction_block_height?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n  write_set_change_index?: InputMaybe<OrderBy>;\n};\n\n/** primary key columns input for table: table_items */\nexport type TableItemsPkColumnsInput = {\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n  write_set_change_index: Scalars[\"bigint\"][\"input\"];\n};\n\n/** prepend existing jsonb value of filtered columns with new jsonb value */\nexport type TableItemsPrependInput = {\n  decoded_key?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  decoded_value?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n};\n\n/** select columns of table \"table_items\" */\nexport enum TableItemsSelectColumn {\n  /** column name */\n  DecodedKey = \"decoded_key\",\n  /** column name */\n  DecodedValue = \"decoded_value\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  IsDeleted = \"is_deleted\",\n  /** column name */\n  Key = \"key\",\n  /** column name */\n  TableHandle = \"table_handle\",\n  /** column name */\n  TransactionBlockHeight = \"transaction_block_height\",\n  /** column name */\n  TransactionVersion = \"transaction_version\",\n  /** column name */\n  WriteSetChangeIndex = \"write_set_change_index\",\n}\n\n/** input type for updating data in table \"table_items\" */\nexport type TableItemsSetInput = {\n  decoded_key?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  decoded_value?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  is_deleted?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  key?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  table_handle?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  transaction_block_height?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  write_set_change_index?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** aggregate stddev on columns */\nexport type TableItemsStddevFields = {\n  transaction_block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_pop on columns */\nexport type TableItemsStddevPopFields = {\n  transaction_block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_samp on columns */\nexport type TableItemsStddevSampFields = {\n  transaction_block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Streaming cursor of the table \"table_items\" */\nexport type TableItemsStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: TableItemsStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type TableItemsStreamCursorValueInput = {\n  decoded_key?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  decoded_value?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  is_deleted?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  key?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  table_handle?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  transaction_block_height?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  write_set_change_index?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** aggregate sum on columns */\nexport type TableItemsSumFields = {\n  transaction_block_height?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** update columns of table \"table_items\" */\nexport enum TableItemsUpdateColumn {\n  /** column name */\n  DecodedKey = \"decoded_key\",\n  /** column name */\n  DecodedValue = \"decoded_value\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  IsDeleted = \"is_deleted\",\n  /** column name */\n  Key = \"key\",\n  /** column name */\n  TableHandle = \"table_handle\",\n  /** column name */\n  TransactionBlockHeight = \"transaction_block_height\",\n  /** column name */\n  TransactionVersion = \"transaction_version\",\n  /** column name */\n  WriteSetChangeIndex = \"write_set_change_index\",\n}\n\nexport type TableItemsUpdates = {\n  /** append existing jsonb value of filtered columns with new jsonb value */\n  _append?: InputMaybe<TableItemsAppendInput>;\n  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */\n  _delete_at_path?: InputMaybe<TableItemsDeleteAtPathInput>;\n  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */\n  _delete_elem?: InputMaybe<TableItemsDeleteElemInput>;\n  /** delete key/value pair or string element. key/value pairs are matched based on their key value */\n  _delete_key?: InputMaybe<TableItemsDeleteKeyInput>;\n  /** increments the numeric columns with given value of the filtered values */\n  _inc?: InputMaybe<TableItemsIncInput>;\n  /** prepend existing jsonb value of filtered columns with new jsonb value */\n  _prepend?: InputMaybe<TableItemsPrependInput>;\n  /** sets the columns of the filtered rows to the given values */\n  _set?: InputMaybe<TableItemsSetInput>;\n  /** filter the rows which have to be updated */\n  where: TableItemsBoolExp;\n};\n\n/** aggregate var_pop on columns */\nexport type TableItemsVarPopFields = {\n  transaction_block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate var_samp on columns */\nexport type TableItemsVarSampFields = {\n  transaction_block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate variance on columns */\nexport type TableItemsVarianceFields = {\n  transaction_block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** columns and relationships of \"table_items_view\" */\nexport type TableItemsView = {\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  is_deleted?: Maybe<Scalars[\"Boolean\"][\"output\"]>;\n  json_decoded_key?: Maybe<Scalars[\"String\"][\"output\"]>;\n  json_decoded_value?: Maybe<Scalars[\"String\"][\"output\"]>;\n  key?: Maybe<Scalars[\"String\"][\"output\"]>;\n  table_handle?: Maybe<Scalars[\"String\"][\"output\"]>;\n  transaction_block_height?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** aggregated selection of \"table_items_view\" */\nexport type TableItemsViewAggregate = {\n  aggregate?: Maybe<TableItemsViewAggregateFields>;\n  nodes: Array<TableItemsView>;\n};\n\n/** aggregate fields of \"table_items_view\" */\nexport type TableItemsViewAggregateFields = {\n  avg?: Maybe<TableItemsViewAvgFields>;\n  count: Scalars[\"Int\"][\"output\"];\n  max?: Maybe<TableItemsViewMaxFields>;\n  min?: Maybe<TableItemsViewMinFields>;\n  stddev?: Maybe<TableItemsViewStddevFields>;\n  stddev_pop?: Maybe<TableItemsViewStddevPopFields>;\n  stddev_samp?: Maybe<TableItemsViewStddevSampFields>;\n  sum?: Maybe<TableItemsViewSumFields>;\n  var_pop?: Maybe<TableItemsViewVarPopFields>;\n  var_samp?: Maybe<TableItemsViewVarSampFields>;\n  variance?: Maybe<TableItemsViewVarianceFields>;\n};\n\n/** aggregate fields of \"table_items_view\" */\nexport type TableItemsViewAggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<TableItemsViewSelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** aggregate avg on columns */\nexport type TableItemsViewAvgFields = {\n  transaction_block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Boolean expression to filter rows from the table \"table_items_view\". All fields are combined with a logical 'AND'. */\nexport type TableItemsViewBoolExp = {\n  _and?: InputMaybe<Array<TableItemsViewBoolExp>>;\n  _not?: InputMaybe<TableItemsViewBoolExp>;\n  _or?: InputMaybe<Array<TableItemsViewBoolExp>>;\n  inserted_at?: InputMaybe<TimestampComparisonExp>;\n  is_deleted?: InputMaybe<BooleanComparisonExp>;\n  json_decoded_key?: InputMaybe<StringComparisonExp>;\n  json_decoded_value?: InputMaybe<StringComparisonExp>;\n  key?: InputMaybe<StringComparisonExp>;\n  table_handle?: InputMaybe<StringComparisonExp>;\n  transaction_block_height?: InputMaybe<BigintComparisonExp>;\n  transaction_version?: InputMaybe<BigintComparisonExp>;\n  write_set_change_index?: InputMaybe<BigintComparisonExp>;\n};\n\n/** input type for incrementing numeric columns in table \"table_items_view\" */\nexport type TableItemsViewIncInput = {\n  transaction_block_height?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  write_set_change_index?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** input type for inserting data into table \"table_items_view\" */\nexport type TableItemsViewInsertInput = {\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  is_deleted?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  json_decoded_key?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  json_decoded_value?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  key?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  table_handle?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  transaction_block_height?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  write_set_change_index?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** aggregate max on columns */\nexport type TableItemsViewMaxFields = {\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  json_decoded_key?: Maybe<Scalars[\"String\"][\"output\"]>;\n  json_decoded_value?: Maybe<Scalars[\"String\"][\"output\"]>;\n  key?: Maybe<Scalars[\"String\"][\"output\"]>;\n  table_handle?: Maybe<Scalars[\"String\"][\"output\"]>;\n  transaction_block_height?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** aggregate min on columns */\nexport type TableItemsViewMinFields = {\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  json_decoded_key?: Maybe<Scalars[\"String\"][\"output\"]>;\n  json_decoded_value?: Maybe<Scalars[\"String\"][\"output\"]>;\n  key?: Maybe<Scalars[\"String\"][\"output\"]>;\n  table_handle?: Maybe<Scalars[\"String\"][\"output\"]>;\n  transaction_block_height?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** response of any mutation on the table \"table_items_view\" */\nexport type TableItemsViewMutationResponse = {\n  /** number of rows affected by the mutation */\n  affected_rows: Scalars[\"Int\"][\"output\"];\n  /** data from the rows affected by the mutation */\n  returning: Array<TableItemsView>;\n};\n\n/** Ordering options when selecting data from \"table_items_view\". */\nexport type TableItemsViewOrderBy = {\n  inserted_at?: InputMaybe<OrderBy>;\n  is_deleted?: InputMaybe<OrderBy>;\n  json_decoded_key?: InputMaybe<OrderBy>;\n  json_decoded_value?: InputMaybe<OrderBy>;\n  key?: InputMaybe<OrderBy>;\n  table_handle?: InputMaybe<OrderBy>;\n  transaction_block_height?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n  write_set_change_index?: InputMaybe<OrderBy>;\n};\n\n/** select columns of table \"table_items_view\" */\nexport enum TableItemsViewSelectColumn {\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  IsDeleted = \"is_deleted\",\n  /** column name */\n  JsonDecodedKey = \"json_decoded_key\",\n  /** column name */\n  JsonDecodedValue = \"json_decoded_value\",\n  /** column name */\n  Key = \"key\",\n  /** column name */\n  TableHandle = \"table_handle\",\n  /** column name */\n  TransactionBlockHeight = \"transaction_block_height\",\n  /** column name */\n  TransactionVersion = \"transaction_version\",\n  /** column name */\n  WriteSetChangeIndex = \"write_set_change_index\",\n}\n\n/** input type for updating data in table \"table_items_view\" */\nexport type TableItemsViewSetInput = {\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  is_deleted?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  json_decoded_key?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  json_decoded_value?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  key?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  table_handle?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  transaction_block_height?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  write_set_change_index?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** aggregate stddev on columns */\nexport type TableItemsViewStddevFields = {\n  transaction_block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_pop on columns */\nexport type TableItemsViewStddevPopFields = {\n  transaction_block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_samp on columns */\nexport type TableItemsViewStddevSampFields = {\n  transaction_block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Streaming cursor of the table \"table_items_view\" */\nexport type TableItemsViewStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: TableItemsViewStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type TableItemsViewStreamCursorValueInput = {\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  is_deleted?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  json_decoded_key?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  json_decoded_value?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  key?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  table_handle?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  transaction_block_height?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  write_set_change_index?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** aggregate sum on columns */\nexport type TableItemsViewSumFields = {\n  transaction_block_height?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\nexport type TableItemsViewUpdates = {\n  /** increments the numeric columns with given value of the filtered values */\n  _inc?: InputMaybe<TableItemsViewIncInput>;\n  /** sets the columns of the filtered rows to the given values */\n  _set?: InputMaybe<TableItemsViewSetInput>;\n  /** filter the rows which have to be updated */\n  where: TableItemsViewBoolExp;\n};\n\n/** aggregate var_pop on columns */\nexport type TableItemsViewVarPopFields = {\n  transaction_block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate var_samp on columns */\nexport type TableItemsViewVarSampFields = {\n  transaction_block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate variance on columns */\nexport type TableItemsViewVarianceFields = {\n  transaction_block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** columns and relationships of \"table_metadatas\" */\nexport type TableMetadatas = {\n  handle: Scalars[\"String\"][\"output\"];\n  inserted_at: Scalars[\"timestamp\"][\"output\"];\n  key_type: Scalars[\"String\"][\"output\"];\n  value_type: Scalars[\"String\"][\"output\"];\n};\n\n/** aggregated selection of \"table_metadatas\" */\nexport type TableMetadatasAggregate = {\n  aggregate?: Maybe<TableMetadatasAggregateFields>;\n  nodes: Array<TableMetadatas>;\n};\n\n/** aggregate fields of \"table_metadatas\" */\nexport type TableMetadatasAggregateFields = {\n  count: Scalars[\"Int\"][\"output\"];\n  max?: Maybe<TableMetadatasMaxFields>;\n  min?: Maybe<TableMetadatasMinFields>;\n};\n\n/** aggregate fields of \"table_metadatas\" */\nexport type TableMetadatasAggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<TableMetadatasSelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** Boolean expression to filter rows from the table \"table_metadatas\". All fields are combined with a logical 'AND'. */\nexport type TableMetadatasBoolExp = {\n  _and?: InputMaybe<Array<TableMetadatasBoolExp>>;\n  _not?: InputMaybe<TableMetadatasBoolExp>;\n  _or?: InputMaybe<Array<TableMetadatasBoolExp>>;\n  handle?: InputMaybe<StringComparisonExp>;\n  inserted_at?: InputMaybe<TimestampComparisonExp>;\n  key_type?: InputMaybe<StringComparisonExp>;\n  value_type?: InputMaybe<StringComparisonExp>;\n};\n\n/** unique or primary key constraints on table \"table_metadatas\" */\nexport enum TableMetadatasConstraint {\n  /** unique or primary key constraint on columns \"handle\" */\n  TableMetadatasPkey = \"table_metadatas_pkey\",\n}\n\n/** input type for inserting data into table \"table_metadatas\" */\nexport type TableMetadatasInsertInput = {\n  handle?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  key_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  value_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate max on columns */\nexport type TableMetadatasMaxFields = {\n  handle?: Maybe<Scalars[\"String\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  key_type?: Maybe<Scalars[\"String\"][\"output\"]>;\n  value_type?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** aggregate min on columns */\nexport type TableMetadatasMinFields = {\n  handle?: Maybe<Scalars[\"String\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  key_type?: Maybe<Scalars[\"String\"][\"output\"]>;\n  value_type?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** response of any mutation on the table \"table_metadatas\" */\nexport type TableMetadatasMutationResponse = {\n  /** number of rows affected by the mutation */\n  affected_rows: Scalars[\"Int\"][\"output\"];\n  /** data from the rows affected by the mutation */\n  returning: Array<TableMetadatas>;\n};\n\n/** on_conflict condition type for table \"table_metadatas\" */\nexport type TableMetadatasOnConflict = {\n  constraint: TableMetadatasConstraint;\n  update_columns?: Array<TableMetadatasUpdateColumn>;\n  where?: InputMaybe<TableMetadatasBoolExp>;\n};\n\n/** Ordering options when selecting data from \"table_metadatas\". */\nexport type TableMetadatasOrderBy = {\n  handle?: InputMaybe<OrderBy>;\n  inserted_at?: InputMaybe<OrderBy>;\n  key_type?: InputMaybe<OrderBy>;\n  value_type?: InputMaybe<OrderBy>;\n};\n\n/** primary key columns input for table: table_metadatas */\nexport type TableMetadatasPkColumnsInput = {\n  handle: Scalars[\"String\"][\"input\"];\n};\n\n/** select columns of table \"table_metadatas\" */\nexport enum TableMetadatasSelectColumn {\n  /** column name */\n  Handle = \"handle\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  KeyType = \"key_type\",\n  /** column name */\n  ValueType = \"value_type\",\n}\n\n/** input type for updating data in table \"table_metadatas\" */\nexport type TableMetadatasSetInput = {\n  handle?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  key_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  value_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** Streaming cursor of the table \"table_metadatas\" */\nexport type TableMetadatasStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: TableMetadatasStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type TableMetadatasStreamCursorValueInput = {\n  handle?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  key_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  value_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** update columns of table \"table_metadatas\" */\nexport enum TableMetadatasUpdateColumn {\n  /** column name */\n  Handle = \"handle\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  KeyType = \"key_type\",\n  /** column name */\n  ValueType = \"value_type\",\n}\n\nexport type TableMetadatasUpdates = {\n  /** sets the columns of the filtered rows to the given values */\n  _set?: InputMaybe<TableMetadatasSetInput>;\n  /** filter the rows which have to be updated */\n  where: TableMetadatasBoolExp;\n};\n\n/** Boolean expression to compare columns of type \"timestamp\". All fields are combined with logical 'AND'. */\nexport type TimestampComparisonExp = {\n  _eq?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  _gt?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  _gte?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  _in?: InputMaybe<Array<Scalars[\"timestamp\"][\"input\"]>>;\n  _is_null?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  _lt?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  _lte?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  _neq?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  _nin?: InputMaybe<Array<Scalars[\"timestamp\"][\"input\"]>>;\n};\n\n/** columns and relationships of \"token_activities\" */\nexport type TokenActivities = {\n  coin_amount?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  coin_type?: Maybe<Scalars[\"String\"][\"output\"]>;\n  collection_data_id_hash: Scalars[\"String\"][\"output\"];\n  collection_name: Scalars[\"String\"][\"output\"];\n  creator_address: Scalars[\"String\"][\"output\"];\n  event_account_address: Scalars[\"String\"][\"output\"];\n  event_creation_number: Scalars[\"bigint\"][\"output\"];\n  event_index?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  event_sequence_number: Scalars[\"bigint\"][\"output\"];\n  from_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  inserted_at: Scalars[\"timestamp\"][\"output\"];\n  name: Scalars[\"String\"][\"output\"];\n  property_version: Scalars[\"numeric\"][\"output\"];\n  to_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_amount: Scalars[\"numeric\"][\"output\"];\n  token_data_id_hash: Scalars[\"String\"][\"output\"];\n  transaction_timestamp: Scalars[\"timestamp\"][\"output\"];\n  transaction_version: Scalars[\"bigint\"][\"output\"];\n  transfer_type: Scalars[\"String\"][\"output\"];\n};\n\n/** aggregated selection of \"token_activities\" */\nexport type TokenActivitiesAggregate = {\n  aggregate?: Maybe<TokenActivitiesAggregateFields>;\n  nodes: Array<TokenActivities>;\n};\n\n/** aggregate fields of \"token_activities\" */\nexport type TokenActivitiesAggregateFields = {\n  avg?: Maybe<TokenActivitiesAvgFields>;\n  count: Scalars[\"Int\"][\"output\"];\n  max?: Maybe<TokenActivitiesMaxFields>;\n  min?: Maybe<TokenActivitiesMinFields>;\n  stddev?: Maybe<TokenActivitiesStddevFields>;\n  stddev_pop?: Maybe<TokenActivitiesStddevPopFields>;\n  stddev_samp?: Maybe<TokenActivitiesStddevSampFields>;\n  sum?: Maybe<TokenActivitiesSumFields>;\n  var_pop?: Maybe<TokenActivitiesVarPopFields>;\n  var_samp?: Maybe<TokenActivitiesVarSampFields>;\n  variance?: Maybe<TokenActivitiesVarianceFields>;\n};\n\n/** aggregate fields of \"token_activities\" */\nexport type TokenActivitiesAggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<TokenActivitiesSelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** aggregate avg on columns */\nexport type TokenActivitiesAvgFields = {\n  coin_amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  event_creation_number?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  event_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  event_sequence_number?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  property_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  token_amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Boolean expression to filter rows from the table \"token_activities\". All fields are combined with a logical 'AND'. */\nexport type TokenActivitiesBoolExp = {\n  _and?: InputMaybe<Array<TokenActivitiesBoolExp>>;\n  _not?: InputMaybe<TokenActivitiesBoolExp>;\n  _or?: InputMaybe<Array<TokenActivitiesBoolExp>>;\n  coin_amount?: InputMaybe<NumericComparisonExp>;\n  coin_type?: InputMaybe<StringComparisonExp>;\n  collection_data_id_hash?: InputMaybe<StringComparisonExp>;\n  collection_name?: InputMaybe<StringComparisonExp>;\n  creator_address?: InputMaybe<StringComparisonExp>;\n  event_account_address?: InputMaybe<StringComparisonExp>;\n  event_creation_number?: InputMaybe<BigintComparisonExp>;\n  event_index?: InputMaybe<BigintComparisonExp>;\n  event_sequence_number?: InputMaybe<BigintComparisonExp>;\n  from_address?: InputMaybe<StringComparisonExp>;\n  inserted_at?: InputMaybe<TimestampComparisonExp>;\n  name?: InputMaybe<StringComparisonExp>;\n  property_version?: InputMaybe<NumericComparisonExp>;\n  to_address?: InputMaybe<StringComparisonExp>;\n  token_amount?: InputMaybe<NumericComparisonExp>;\n  token_data_id_hash?: InputMaybe<StringComparisonExp>;\n  transaction_timestamp?: InputMaybe<TimestampComparisonExp>;\n  transaction_version?: InputMaybe<BigintComparisonExp>;\n  transfer_type?: InputMaybe<StringComparisonExp>;\n};\n\n/** unique or primary key constraints on table \"token_activities\" */\nexport enum TokenActivitiesConstraint {\n  /** unique or primary key constraint on columns \"event_sequence_number\", \"event_creation_number\", \"transaction_version\", \"event_account_address\" */\n  TokenActivitiesPkey = \"token_activities_pkey\",\n}\n\n/** input type for incrementing numeric columns in table \"token_activities\" */\nexport type TokenActivitiesIncInput = {\n  coin_amount?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  event_creation_number?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  event_index?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  event_sequence_number?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  property_version?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  token_amount?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** input type for inserting data into table \"token_activities\" */\nexport type TokenActivitiesInsertInput = {\n  coin_amount?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  coin_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  collection_data_id_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  collection_name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  creator_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  event_account_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  event_creation_number?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  event_index?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  event_sequence_number?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  from_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  property_version?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  to_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_amount?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  token_data_id_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  transfer_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate max on columns */\nexport type TokenActivitiesMaxFields = {\n  coin_amount?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  coin_type?: Maybe<Scalars[\"String\"][\"output\"]>;\n  collection_data_id_hash?: Maybe<Scalars[\"String\"][\"output\"]>;\n  collection_name?: Maybe<Scalars[\"String\"][\"output\"]>;\n  creator_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  event_account_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  event_creation_number?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  event_index?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  event_sequence_number?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  from_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  name?: Maybe<Scalars[\"String\"][\"output\"]>;\n  property_version?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  to_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_amount?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  token_data_id_hash?: Maybe<Scalars[\"String\"][\"output\"]>;\n  transaction_timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  transfer_type?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** aggregate min on columns */\nexport type TokenActivitiesMinFields = {\n  coin_amount?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  coin_type?: Maybe<Scalars[\"String\"][\"output\"]>;\n  collection_data_id_hash?: Maybe<Scalars[\"String\"][\"output\"]>;\n  collection_name?: Maybe<Scalars[\"String\"][\"output\"]>;\n  creator_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  event_account_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  event_creation_number?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  event_index?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  event_sequence_number?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  from_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  name?: Maybe<Scalars[\"String\"][\"output\"]>;\n  property_version?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  to_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_amount?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  token_data_id_hash?: Maybe<Scalars[\"String\"][\"output\"]>;\n  transaction_timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  transfer_type?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** response of any mutation on the table \"token_activities\" */\nexport type TokenActivitiesMutationResponse = {\n  /** number of rows affected by the mutation */\n  affected_rows: Scalars[\"Int\"][\"output\"];\n  /** data from the rows affected by the mutation */\n  returning: Array<TokenActivities>;\n};\n\n/** on_conflict condition type for table \"token_activities\" */\nexport type TokenActivitiesOnConflict = {\n  constraint: TokenActivitiesConstraint;\n  update_columns?: Array<TokenActivitiesUpdateColumn>;\n  where?: InputMaybe<TokenActivitiesBoolExp>;\n};\n\n/** Ordering options when selecting data from \"token_activities\". */\nexport type TokenActivitiesOrderBy = {\n  coin_amount?: InputMaybe<OrderBy>;\n  coin_type?: InputMaybe<OrderBy>;\n  collection_data_id_hash?: InputMaybe<OrderBy>;\n  collection_name?: InputMaybe<OrderBy>;\n  creator_address?: InputMaybe<OrderBy>;\n  event_account_address?: InputMaybe<OrderBy>;\n  event_creation_number?: InputMaybe<OrderBy>;\n  event_index?: InputMaybe<OrderBy>;\n  event_sequence_number?: InputMaybe<OrderBy>;\n  from_address?: InputMaybe<OrderBy>;\n  inserted_at?: InputMaybe<OrderBy>;\n  name?: InputMaybe<OrderBy>;\n  property_version?: InputMaybe<OrderBy>;\n  to_address?: InputMaybe<OrderBy>;\n  token_amount?: InputMaybe<OrderBy>;\n  token_data_id_hash?: InputMaybe<OrderBy>;\n  transaction_timestamp?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n  transfer_type?: InputMaybe<OrderBy>;\n};\n\n/** primary key columns input for table: token_activities */\nexport type TokenActivitiesPkColumnsInput = {\n  event_account_address: Scalars[\"String\"][\"input\"];\n  event_creation_number: Scalars[\"bigint\"][\"input\"];\n  event_sequence_number: Scalars[\"bigint\"][\"input\"];\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\n/** select columns of table \"token_activities\" */\nexport enum TokenActivitiesSelectColumn {\n  /** column name */\n  CoinAmount = \"coin_amount\",\n  /** column name */\n  CoinType = \"coin_type\",\n  /** column name */\n  CollectionDataIdHash = \"collection_data_id_hash\",\n  /** column name */\n  CollectionName = \"collection_name\",\n  /** column name */\n  CreatorAddress = \"creator_address\",\n  /** column name */\n  EventAccountAddress = \"event_account_address\",\n  /** column name */\n  EventCreationNumber = \"event_creation_number\",\n  /** column name */\n  EventIndex = \"event_index\",\n  /** column name */\n  EventSequenceNumber = \"event_sequence_number\",\n  /** column name */\n  FromAddress = \"from_address\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  Name = \"name\",\n  /** column name */\n  PropertyVersion = \"property_version\",\n  /** column name */\n  ToAddress = \"to_address\",\n  /** column name */\n  TokenAmount = \"token_amount\",\n  /** column name */\n  TokenDataIdHash = \"token_data_id_hash\",\n  /** column name */\n  TransactionTimestamp = \"transaction_timestamp\",\n  /** column name */\n  TransactionVersion = \"transaction_version\",\n  /** column name */\n  TransferType = \"transfer_type\",\n}\n\n/** input type for updating data in table \"token_activities\" */\nexport type TokenActivitiesSetInput = {\n  coin_amount?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  coin_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  collection_data_id_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  collection_name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  creator_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  event_account_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  event_creation_number?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  event_index?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  event_sequence_number?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  from_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  property_version?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  to_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_amount?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  token_data_id_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  transfer_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate stddev on columns */\nexport type TokenActivitiesStddevFields = {\n  coin_amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  event_creation_number?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  event_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  event_sequence_number?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  property_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  token_amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_pop on columns */\nexport type TokenActivitiesStddevPopFields = {\n  coin_amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  event_creation_number?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  event_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  event_sequence_number?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  property_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  token_amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_samp on columns */\nexport type TokenActivitiesStddevSampFields = {\n  coin_amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  event_creation_number?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  event_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  event_sequence_number?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  property_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  token_amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Streaming cursor of the table \"token_activities\" */\nexport type TokenActivitiesStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: TokenActivitiesStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type TokenActivitiesStreamCursorValueInput = {\n  coin_amount?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  coin_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  collection_data_id_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  collection_name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  creator_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  event_account_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  event_creation_number?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  event_index?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  event_sequence_number?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  from_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  property_version?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  to_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_amount?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  token_data_id_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  transfer_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate sum on columns */\nexport type TokenActivitiesSumFields = {\n  coin_amount?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  event_creation_number?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  event_index?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  event_sequence_number?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  property_version?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  token_amount?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** update columns of table \"token_activities\" */\nexport enum TokenActivitiesUpdateColumn {\n  /** column name */\n  CoinAmount = \"coin_amount\",\n  /** column name */\n  CoinType = \"coin_type\",\n  /** column name */\n  CollectionDataIdHash = \"collection_data_id_hash\",\n  /** column name */\n  CollectionName = \"collection_name\",\n  /** column name */\n  CreatorAddress = \"creator_address\",\n  /** column name */\n  EventAccountAddress = \"event_account_address\",\n  /** column name */\n  EventCreationNumber = \"event_creation_number\",\n  /** column name */\n  EventIndex = \"event_index\",\n  /** column name */\n  EventSequenceNumber = \"event_sequence_number\",\n  /** column name */\n  FromAddress = \"from_address\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  Name = \"name\",\n  /** column name */\n  PropertyVersion = \"property_version\",\n  /** column name */\n  ToAddress = \"to_address\",\n  /** column name */\n  TokenAmount = \"token_amount\",\n  /** column name */\n  TokenDataIdHash = \"token_data_id_hash\",\n  /** column name */\n  TransactionTimestamp = \"transaction_timestamp\",\n  /** column name */\n  TransactionVersion = \"transaction_version\",\n  /** column name */\n  TransferType = \"transfer_type\",\n}\n\nexport type TokenActivitiesUpdates = {\n  /** increments the numeric columns with given value of the filtered values */\n  _inc?: InputMaybe<TokenActivitiesIncInput>;\n  /** sets the columns of the filtered rows to the given values */\n  _set?: InputMaybe<TokenActivitiesSetInput>;\n  /** filter the rows which have to be updated */\n  where: TokenActivitiesBoolExp;\n};\n\n/** columns and relationships of \"token_activities_v2\" */\nexport type TokenActivitiesV2 = {\n  after_value?: Maybe<Scalars[\"String\"][\"output\"]>;\n  before_value?: Maybe<Scalars[\"String\"][\"output\"]>;\n  /** An array relationship */\n  cedra_names_from: Array<CurrentCedraNames>;\n  /** An aggregate relationship */\n  cedra_names_from_aggregate: CurrentCedraNamesAggregate;\n  /** An array relationship */\n  cedra_names_to: Array<CurrentCedraNames>;\n  /** An aggregate relationship */\n  cedra_names_to_aggregate: CurrentCedraNamesAggregate;\n  /** An object relationship */\n  current_token_data?: Maybe<CurrentTokenDatasV2>;\n  entry_function_id_str?: Maybe<Scalars[\"String\"][\"output\"]>;\n  event_account_address: Scalars[\"String\"][\"output\"];\n  event_index: Scalars[\"bigint\"][\"output\"];\n  from_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  inserted_at: Scalars[\"timestamp\"][\"output\"];\n  is_fungible_v2?: Maybe<Scalars[\"Boolean\"][\"output\"]>;\n  property_version_v1: Scalars[\"numeric\"][\"output\"];\n  to_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_amount: Scalars[\"numeric\"][\"output\"];\n  token_data_id: Scalars[\"String\"][\"output\"];\n  token_standard: Scalars[\"String\"][\"output\"];\n  transaction_timestamp: Scalars[\"timestamp\"][\"output\"];\n  transaction_version: Scalars[\"bigint\"][\"output\"];\n  type: Scalars[\"String\"][\"output\"];\n};\n\n/** columns and relationships of \"token_activities_v2\" */\nexport type TokenActivitiesV2CedraNamesFromArgs = {\n  distinct_on?: InputMaybe<Array<CurrentCedraNamesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentCedraNamesOrderBy>>;\n  where?: InputMaybe<CurrentCedraNamesBoolExp>;\n};\n\n/** columns and relationships of \"token_activities_v2\" */\nexport type TokenActivitiesV2CedraNamesFromAggregateArgs = {\n  distinct_on?: InputMaybe<Array<CurrentCedraNamesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentCedraNamesOrderBy>>;\n  where?: InputMaybe<CurrentCedraNamesBoolExp>;\n};\n\n/** columns and relationships of \"token_activities_v2\" */\nexport type TokenActivitiesV2CedraNamesToArgs = {\n  distinct_on?: InputMaybe<Array<CurrentCedraNamesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentCedraNamesOrderBy>>;\n  where?: InputMaybe<CurrentCedraNamesBoolExp>;\n};\n\n/** columns and relationships of \"token_activities_v2\" */\nexport type TokenActivitiesV2CedraNamesToAggregateArgs = {\n  distinct_on?: InputMaybe<Array<CurrentCedraNamesSelectColumn>>;\n  limit?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  offset?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n  order_by?: InputMaybe<Array<CurrentCedraNamesOrderBy>>;\n  where?: InputMaybe<CurrentCedraNamesBoolExp>;\n};\n\n/** aggregated selection of \"token_activities_v2\" */\nexport type TokenActivitiesV2Aggregate = {\n  aggregate?: Maybe<TokenActivitiesV2AggregateFields>;\n  nodes: Array<TokenActivitiesV2>;\n};\n\nexport type TokenActivitiesV2AggregateBoolExp = {\n  bool_and?: InputMaybe<TokenActivitiesV2AggregateBoolExpBoolAnd>;\n  bool_or?: InputMaybe<TokenActivitiesV2AggregateBoolExpBoolOr>;\n  count?: InputMaybe<TokenActivitiesV2AggregateBoolExpCount>;\n};\n\nexport type TokenActivitiesV2AggregateBoolExpBoolAnd = {\n  arguments: TokenActivitiesV2SelectColumnTokenActivitiesV2AggregateBoolExpBoolAndArgumentsColumns;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  filter?: InputMaybe<TokenActivitiesV2BoolExp>;\n  predicate: BooleanComparisonExp;\n};\n\nexport type TokenActivitiesV2AggregateBoolExpBoolOr = {\n  arguments: TokenActivitiesV2SelectColumnTokenActivitiesV2AggregateBoolExpBoolOrArgumentsColumns;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  filter?: InputMaybe<TokenActivitiesV2BoolExp>;\n  predicate: BooleanComparisonExp;\n};\n\nexport type TokenActivitiesV2AggregateBoolExpCount = {\n  arguments?: InputMaybe<Array<TokenActivitiesV2SelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  filter?: InputMaybe<TokenActivitiesV2BoolExp>;\n  predicate: IntComparisonExp;\n};\n\n/** aggregate fields of \"token_activities_v2\" */\nexport type TokenActivitiesV2AggregateFields = {\n  avg?: Maybe<TokenActivitiesV2AvgFields>;\n  count: Scalars[\"Int\"][\"output\"];\n  max?: Maybe<TokenActivitiesV2MaxFields>;\n  min?: Maybe<TokenActivitiesV2MinFields>;\n  stddev?: Maybe<TokenActivitiesV2StddevFields>;\n  stddev_pop?: Maybe<TokenActivitiesV2StddevPopFields>;\n  stddev_samp?: Maybe<TokenActivitiesV2StddevSampFields>;\n  sum?: Maybe<TokenActivitiesV2SumFields>;\n  var_pop?: Maybe<TokenActivitiesV2VarPopFields>;\n  var_samp?: Maybe<TokenActivitiesV2VarSampFields>;\n  variance?: Maybe<TokenActivitiesV2VarianceFields>;\n};\n\n/** aggregate fields of \"token_activities_v2\" */\nexport type TokenActivitiesV2AggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<TokenActivitiesV2SelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** order by aggregate values of table \"token_activities_v2\" */\nexport type TokenActivitiesV2AggregateOrderBy = {\n  avg?: InputMaybe<TokenActivitiesV2AvgOrderBy>;\n  count?: InputMaybe<OrderBy>;\n  max?: InputMaybe<TokenActivitiesV2MaxOrderBy>;\n  min?: InputMaybe<TokenActivitiesV2MinOrderBy>;\n  stddev?: InputMaybe<TokenActivitiesV2StddevOrderBy>;\n  stddev_pop?: InputMaybe<TokenActivitiesV2StddevPopOrderBy>;\n  stddev_samp?: InputMaybe<TokenActivitiesV2StddevSampOrderBy>;\n  sum?: InputMaybe<TokenActivitiesV2SumOrderBy>;\n  var_pop?: InputMaybe<TokenActivitiesV2VarPopOrderBy>;\n  var_samp?: InputMaybe<TokenActivitiesV2VarSampOrderBy>;\n  variance?: InputMaybe<TokenActivitiesV2VarianceOrderBy>;\n};\n\n/** input type for inserting array relation for remote table \"token_activities_v2\" */\nexport type TokenActivitiesV2ArrRelInsertInput = {\n  data: Array<TokenActivitiesV2InsertInput>;\n  /** upsert condition */\n  on_conflict?: InputMaybe<TokenActivitiesV2OnConflict>;\n};\n\n/** aggregate avg on columns */\nexport type TokenActivitiesV2AvgFields = {\n  event_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  property_version_v1?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  token_amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** order by avg() on columns of table \"token_activities_v2\" */\nexport type TokenActivitiesV2AvgOrderBy = {\n  event_index?: InputMaybe<OrderBy>;\n  property_version_v1?: InputMaybe<OrderBy>;\n  token_amount?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n};\n\n/** Boolean expression to filter rows from the table \"token_activities_v2\". All fields are combined with a logical 'AND'. */\nexport type TokenActivitiesV2BoolExp = {\n  _and?: InputMaybe<Array<TokenActivitiesV2BoolExp>>;\n  _not?: InputMaybe<TokenActivitiesV2BoolExp>;\n  _or?: InputMaybe<Array<TokenActivitiesV2BoolExp>>;\n  after_value?: InputMaybe<StringComparisonExp>;\n  before_value?: InputMaybe<StringComparisonExp>;\n  cedra_names_from?: InputMaybe<CurrentCedraNamesBoolExp>;\n  cedra_names_from_aggregate?: InputMaybe<CurrentCedraNamesAggregateBoolExp>;\n  cedra_names_to?: InputMaybe<CurrentCedraNamesBoolExp>;\n  cedra_names_to_aggregate?: InputMaybe<CurrentCedraNamesAggregateBoolExp>;\n  current_token_data?: InputMaybe<CurrentTokenDatasV2BoolExp>;\n  entry_function_id_str?: InputMaybe<StringComparisonExp>;\n  event_account_address?: InputMaybe<StringComparisonExp>;\n  event_index?: InputMaybe<BigintComparisonExp>;\n  from_address?: InputMaybe<StringComparisonExp>;\n  inserted_at?: InputMaybe<TimestampComparisonExp>;\n  is_fungible_v2?: InputMaybe<BooleanComparisonExp>;\n  property_version_v1?: InputMaybe<NumericComparisonExp>;\n  to_address?: InputMaybe<StringComparisonExp>;\n  token_amount?: InputMaybe<NumericComparisonExp>;\n  token_data_id?: InputMaybe<StringComparisonExp>;\n  token_standard?: InputMaybe<StringComparisonExp>;\n  transaction_timestamp?: InputMaybe<TimestampComparisonExp>;\n  transaction_version?: InputMaybe<BigintComparisonExp>;\n  type?: InputMaybe<StringComparisonExp>;\n};\n\n/** unique or primary key constraints on table \"token_activities_v2\" */\nexport enum TokenActivitiesV2Constraint {\n  /** unique or primary key constraint on columns \"event_index\", \"transaction_version\" */\n  TokenActivitiesV2Pkey = \"token_activities_v2_pkey\",\n}\n\n/** input type for incrementing numeric columns in table \"token_activities_v2\" */\nexport type TokenActivitiesV2IncInput = {\n  event_index?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  property_version_v1?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  token_amount?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** input type for inserting data into table \"token_activities_v2\" */\nexport type TokenActivitiesV2InsertInput = {\n  after_value?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  before_value?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  cedra_names_from?: InputMaybe<CurrentCedraNamesArrRelInsertInput>;\n  cedra_names_to?: InputMaybe<CurrentCedraNamesArrRelInsertInput>;\n  current_token_data?: InputMaybe<CurrentTokenDatasV2ObjRelInsertInput>;\n  entry_function_id_str?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  event_account_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  event_index?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  from_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  is_fungible_v2?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  property_version_v1?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  to_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_amount?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  token_data_id?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_standard?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate max on columns */\nexport type TokenActivitiesV2MaxFields = {\n  after_value?: Maybe<Scalars[\"String\"][\"output\"]>;\n  before_value?: Maybe<Scalars[\"String\"][\"output\"]>;\n  entry_function_id_str?: Maybe<Scalars[\"String\"][\"output\"]>;\n  event_account_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  event_index?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  from_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  property_version_v1?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  to_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_amount?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  token_data_id?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_standard?: Maybe<Scalars[\"String\"][\"output\"]>;\n  transaction_timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  type?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** order by max() on columns of table \"token_activities_v2\" */\nexport type TokenActivitiesV2MaxOrderBy = {\n  after_value?: InputMaybe<OrderBy>;\n  before_value?: InputMaybe<OrderBy>;\n  entry_function_id_str?: InputMaybe<OrderBy>;\n  event_account_address?: InputMaybe<OrderBy>;\n  event_index?: InputMaybe<OrderBy>;\n  from_address?: InputMaybe<OrderBy>;\n  inserted_at?: InputMaybe<OrderBy>;\n  property_version_v1?: InputMaybe<OrderBy>;\n  to_address?: InputMaybe<OrderBy>;\n  token_amount?: InputMaybe<OrderBy>;\n  token_data_id?: InputMaybe<OrderBy>;\n  token_standard?: InputMaybe<OrderBy>;\n  transaction_timestamp?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n  type?: InputMaybe<OrderBy>;\n};\n\n/** aggregate min on columns */\nexport type TokenActivitiesV2MinFields = {\n  after_value?: Maybe<Scalars[\"String\"][\"output\"]>;\n  before_value?: Maybe<Scalars[\"String\"][\"output\"]>;\n  entry_function_id_str?: Maybe<Scalars[\"String\"][\"output\"]>;\n  event_account_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  event_index?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  from_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  property_version_v1?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  to_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_amount?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  token_data_id?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_standard?: Maybe<Scalars[\"String\"][\"output\"]>;\n  transaction_timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  type?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** order by min() on columns of table \"token_activities_v2\" */\nexport type TokenActivitiesV2MinOrderBy = {\n  after_value?: InputMaybe<OrderBy>;\n  before_value?: InputMaybe<OrderBy>;\n  entry_function_id_str?: InputMaybe<OrderBy>;\n  event_account_address?: InputMaybe<OrderBy>;\n  event_index?: InputMaybe<OrderBy>;\n  from_address?: InputMaybe<OrderBy>;\n  inserted_at?: InputMaybe<OrderBy>;\n  property_version_v1?: InputMaybe<OrderBy>;\n  to_address?: InputMaybe<OrderBy>;\n  token_amount?: InputMaybe<OrderBy>;\n  token_data_id?: InputMaybe<OrderBy>;\n  token_standard?: InputMaybe<OrderBy>;\n  transaction_timestamp?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n  type?: InputMaybe<OrderBy>;\n};\n\n/** response of any mutation on the table \"token_activities_v2\" */\nexport type TokenActivitiesV2MutationResponse = {\n  /** number of rows affected by the mutation */\n  affected_rows: Scalars[\"Int\"][\"output\"];\n  /** data from the rows affected by the mutation */\n  returning: Array<TokenActivitiesV2>;\n};\n\n/** on_conflict condition type for table \"token_activities_v2\" */\nexport type TokenActivitiesV2OnConflict = {\n  constraint: TokenActivitiesV2Constraint;\n  update_columns?: Array<TokenActivitiesV2UpdateColumn>;\n  where?: InputMaybe<TokenActivitiesV2BoolExp>;\n};\n\n/** Ordering options when selecting data from \"token_activities_v2\". */\nexport type TokenActivitiesV2OrderBy = {\n  after_value?: InputMaybe<OrderBy>;\n  before_value?: InputMaybe<OrderBy>;\n  cedra_names_from_aggregate?: InputMaybe<CurrentCedraNamesAggregateOrderBy>;\n  cedra_names_to_aggregate?: InputMaybe<CurrentCedraNamesAggregateOrderBy>;\n  current_token_data?: InputMaybe<CurrentTokenDatasV2OrderBy>;\n  entry_function_id_str?: InputMaybe<OrderBy>;\n  event_account_address?: InputMaybe<OrderBy>;\n  event_index?: InputMaybe<OrderBy>;\n  from_address?: InputMaybe<OrderBy>;\n  inserted_at?: InputMaybe<OrderBy>;\n  is_fungible_v2?: InputMaybe<OrderBy>;\n  property_version_v1?: InputMaybe<OrderBy>;\n  to_address?: InputMaybe<OrderBy>;\n  token_amount?: InputMaybe<OrderBy>;\n  token_data_id?: InputMaybe<OrderBy>;\n  token_standard?: InputMaybe<OrderBy>;\n  transaction_timestamp?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n  type?: InputMaybe<OrderBy>;\n};\n\n/** primary key columns input for table: token_activities_v2 */\nexport type TokenActivitiesV2PkColumnsInput = {\n  event_index: Scalars[\"bigint\"][\"input\"];\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\n/** select columns of table \"token_activities_v2\" */\nexport enum TokenActivitiesV2SelectColumn {\n  /** column name */\n  AfterValue = \"after_value\",\n  /** column name */\n  BeforeValue = \"before_value\",\n  /** column name */\n  EntryFunctionIdStr = \"entry_function_id_str\",\n  /** column name */\n  EventAccountAddress = \"event_account_address\",\n  /** column name */\n  EventIndex = \"event_index\",\n  /** column name */\n  FromAddress = \"from_address\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  IsFungibleV2 = \"is_fungible_v2\",\n  /** column name */\n  PropertyVersionV1 = \"property_version_v1\",\n  /** column name */\n  ToAddress = \"to_address\",\n  /** column name */\n  TokenAmount = \"token_amount\",\n  /** column name */\n  TokenDataId = \"token_data_id\",\n  /** column name */\n  TokenStandard = \"token_standard\",\n  /** column name */\n  TransactionTimestamp = \"transaction_timestamp\",\n  /** column name */\n  TransactionVersion = \"transaction_version\",\n  /** column name */\n  Type = \"type\",\n}\n\n/** select \"token_activities_v2_aggregate_bool_exp_bool_and_arguments_columns\" columns of table \"token_activities_v2\" */\nexport enum TokenActivitiesV2SelectColumnTokenActivitiesV2AggregateBoolExpBoolAndArgumentsColumns {\n  /** column name */\n  IsFungibleV2 = \"is_fungible_v2\",\n}\n\n/** select \"token_activities_v2_aggregate_bool_exp_bool_or_arguments_columns\" columns of table \"token_activities_v2\" */\nexport enum TokenActivitiesV2SelectColumnTokenActivitiesV2AggregateBoolExpBoolOrArgumentsColumns {\n  /** column name */\n  IsFungibleV2 = \"is_fungible_v2\",\n}\n\n/** input type for updating data in table \"token_activities_v2\" */\nexport type TokenActivitiesV2SetInput = {\n  after_value?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  before_value?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  entry_function_id_str?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  event_account_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  event_index?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  from_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  is_fungible_v2?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  property_version_v1?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  to_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_amount?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  token_data_id?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_standard?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate stddev on columns */\nexport type TokenActivitiesV2StddevFields = {\n  event_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  property_version_v1?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  token_amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** order by stddev() on columns of table \"token_activities_v2\" */\nexport type TokenActivitiesV2StddevOrderBy = {\n  event_index?: InputMaybe<OrderBy>;\n  property_version_v1?: InputMaybe<OrderBy>;\n  token_amount?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n};\n\n/** aggregate stddev_pop on columns */\nexport type TokenActivitiesV2StddevPopFields = {\n  event_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  property_version_v1?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  token_amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** order by stddev_pop() on columns of table \"token_activities_v2\" */\nexport type TokenActivitiesV2StddevPopOrderBy = {\n  event_index?: InputMaybe<OrderBy>;\n  property_version_v1?: InputMaybe<OrderBy>;\n  token_amount?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n};\n\n/** aggregate stddev_samp on columns */\nexport type TokenActivitiesV2StddevSampFields = {\n  event_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  property_version_v1?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  token_amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** order by stddev_samp() on columns of table \"token_activities_v2\" */\nexport type TokenActivitiesV2StddevSampOrderBy = {\n  event_index?: InputMaybe<OrderBy>;\n  property_version_v1?: InputMaybe<OrderBy>;\n  token_amount?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n};\n\n/** Streaming cursor of the table \"token_activities_v2\" */\nexport type TokenActivitiesV2StreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: TokenActivitiesV2StreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type TokenActivitiesV2StreamCursorValueInput = {\n  after_value?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  before_value?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  entry_function_id_str?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  event_account_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  event_index?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  from_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  is_fungible_v2?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  property_version_v1?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  to_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_amount?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  token_data_id?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_standard?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate sum on columns */\nexport type TokenActivitiesV2SumFields = {\n  event_index?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  property_version_v1?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  token_amount?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** order by sum() on columns of table \"token_activities_v2\" */\nexport type TokenActivitiesV2SumOrderBy = {\n  event_index?: InputMaybe<OrderBy>;\n  property_version_v1?: InputMaybe<OrderBy>;\n  token_amount?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n};\n\n/** update columns of table \"token_activities_v2\" */\nexport enum TokenActivitiesV2UpdateColumn {\n  /** column name */\n  AfterValue = \"after_value\",\n  /** column name */\n  BeforeValue = \"before_value\",\n  /** column name */\n  EntryFunctionIdStr = \"entry_function_id_str\",\n  /** column name */\n  EventAccountAddress = \"event_account_address\",\n  /** column name */\n  EventIndex = \"event_index\",\n  /** column name */\n  FromAddress = \"from_address\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  IsFungibleV2 = \"is_fungible_v2\",\n  /** column name */\n  PropertyVersionV1 = \"property_version_v1\",\n  /** column name */\n  ToAddress = \"to_address\",\n  /** column name */\n  TokenAmount = \"token_amount\",\n  /** column name */\n  TokenDataId = \"token_data_id\",\n  /** column name */\n  TokenStandard = \"token_standard\",\n  /** column name */\n  TransactionTimestamp = \"transaction_timestamp\",\n  /** column name */\n  TransactionVersion = \"transaction_version\",\n  /** column name */\n  Type = \"type\",\n}\n\nexport type TokenActivitiesV2Updates = {\n  /** increments the numeric columns with given value of the filtered values */\n  _inc?: InputMaybe<TokenActivitiesV2IncInput>;\n  /** sets the columns of the filtered rows to the given values */\n  _set?: InputMaybe<TokenActivitiesV2SetInput>;\n  /** filter the rows which have to be updated */\n  where: TokenActivitiesV2BoolExp;\n};\n\n/** aggregate var_pop on columns */\nexport type TokenActivitiesV2VarPopFields = {\n  event_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  property_version_v1?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  token_amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** order by var_pop() on columns of table \"token_activities_v2\" */\nexport type TokenActivitiesV2VarPopOrderBy = {\n  event_index?: InputMaybe<OrderBy>;\n  property_version_v1?: InputMaybe<OrderBy>;\n  token_amount?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n};\n\n/** aggregate var_samp on columns */\nexport type TokenActivitiesV2VarSampFields = {\n  event_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  property_version_v1?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  token_amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** order by var_samp() on columns of table \"token_activities_v2\" */\nexport type TokenActivitiesV2VarSampOrderBy = {\n  event_index?: InputMaybe<OrderBy>;\n  property_version_v1?: InputMaybe<OrderBy>;\n  token_amount?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n};\n\n/** aggregate variance on columns */\nexport type TokenActivitiesV2VarianceFields = {\n  event_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  property_version_v1?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  token_amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** order by variance() on columns of table \"token_activities_v2\" */\nexport type TokenActivitiesV2VarianceOrderBy = {\n  event_index?: InputMaybe<OrderBy>;\n  property_version_v1?: InputMaybe<OrderBy>;\n  token_amount?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n};\n\n/** aggregate var_pop on columns */\nexport type TokenActivitiesVarPopFields = {\n  coin_amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  event_creation_number?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  event_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  event_sequence_number?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  property_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  token_amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate var_samp on columns */\nexport type TokenActivitiesVarSampFields = {\n  coin_amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  event_creation_number?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  event_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  event_sequence_number?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  property_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  token_amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate variance on columns */\nexport type TokenActivitiesVarianceFields = {\n  coin_amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  event_creation_number?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  event_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  event_sequence_number?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  property_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  token_amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** columns and relationships of \"token_datas\" */\nexport type TokenDatas = {\n  collection_data_id_hash: Scalars[\"String\"][\"output\"];\n  collection_name: Scalars[\"String\"][\"output\"];\n  creator_address: Scalars[\"String\"][\"output\"];\n  default_properties: Scalars[\"jsonb\"][\"output\"];\n  description: Scalars[\"String\"][\"output\"];\n  description_mutable: Scalars[\"Boolean\"][\"output\"];\n  inserted_at: Scalars[\"timestamp\"][\"output\"];\n  largest_property_version: Scalars[\"numeric\"][\"output\"];\n  maximum: Scalars[\"numeric\"][\"output\"];\n  maximum_mutable: Scalars[\"Boolean\"][\"output\"];\n  metadata_uri: Scalars[\"String\"][\"output\"];\n  name: Scalars[\"String\"][\"output\"];\n  payee_address: Scalars[\"String\"][\"output\"];\n  properties_mutable: Scalars[\"Boolean\"][\"output\"];\n  royalty_mutable: Scalars[\"Boolean\"][\"output\"];\n  royalty_points_denominator: Scalars[\"numeric\"][\"output\"];\n  royalty_points_numerator: Scalars[\"numeric\"][\"output\"];\n  supply: Scalars[\"numeric\"][\"output\"];\n  token_data_id_hash: Scalars[\"String\"][\"output\"];\n  transaction_timestamp: Scalars[\"timestamp\"][\"output\"];\n  transaction_version: Scalars[\"bigint\"][\"output\"];\n  uri_mutable: Scalars[\"Boolean\"][\"output\"];\n};\n\n/** columns and relationships of \"token_datas\" */\nexport type TokenDatasDefaultPropertiesArgs = {\n  path?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregated selection of \"token_datas\" */\nexport type TokenDatasAggregate = {\n  aggregate?: Maybe<TokenDatasAggregateFields>;\n  nodes: Array<TokenDatas>;\n};\n\n/** aggregate fields of \"token_datas\" */\nexport type TokenDatasAggregateFields = {\n  avg?: Maybe<TokenDatasAvgFields>;\n  count: Scalars[\"Int\"][\"output\"];\n  max?: Maybe<TokenDatasMaxFields>;\n  min?: Maybe<TokenDatasMinFields>;\n  stddev?: Maybe<TokenDatasStddevFields>;\n  stddev_pop?: Maybe<TokenDatasStddevPopFields>;\n  stddev_samp?: Maybe<TokenDatasStddevSampFields>;\n  sum?: Maybe<TokenDatasSumFields>;\n  var_pop?: Maybe<TokenDatasVarPopFields>;\n  var_samp?: Maybe<TokenDatasVarSampFields>;\n  variance?: Maybe<TokenDatasVarianceFields>;\n};\n\n/** aggregate fields of \"token_datas\" */\nexport type TokenDatasAggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<TokenDatasSelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** append existing jsonb value of filtered columns with new jsonb value */\nexport type TokenDatasAppendInput = {\n  default_properties?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n};\n\n/** aggregate avg on columns */\nexport type TokenDatasAvgFields = {\n  largest_property_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  maximum?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  royalty_points_denominator?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  royalty_points_numerator?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  supply?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Boolean expression to filter rows from the table \"token_datas\". All fields are combined with a logical 'AND'. */\nexport type TokenDatasBoolExp = {\n  _and?: InputMaybe<Array<TokenDatasBoolExp>>;\n  _not?: InputMaybe<TokenDatasBoolExp>;\n  _or?: InputMaybe<Array<TokenDatasBoolExp>>;\n  collection_data_id_hash?: InputMaybe<StringComparisonExp>;\n  collection_name?: InputMaybe<StringComparisonExp>;\n  creator_address?: InputMaybe<StringComparisonExp>;\n  default_properties?: InputMaybe<JsonbComparisonExp>;\n  description?: InputMaybe<StringComparisonExp>;\n  description_mutable?: InputMaybe<BooleanComparisonExp>;\n  inserted_at?: InputMaybe<TimestampComparisonExp>;\n  largest_property_version?: InputMaybe<NumericComparisonExp>;\n  maximum?: InputMaybe<NumericComparisonExp>;\n  maximum_mutable?: InputMaybe<BooleanComparisonExp>;\n  metadata_uri?: InputMaybe<StringComparisonExp>;\n  name?: InputMaybe<StringComparisonExp>;\n  payee_address?: InputMaybe<StringComparisonExp>;\n  properties_mutable?: InputMaybe<BooleanComparisonExp>;\n  royalty_mutable?: InputMaybe<BooleanComparisonExp>;\n  royalty_points_denominator?: InputMaybe<NumericComparisonExp>;\n  royalty_points_numerator?: InputMaybe<NumericComparisonExp>;\n  supply?: InputMaybe<NumericComparisonExp>;\n  token_data_id_hash?: InputMaybe<StringComparisonExp>;\n  transaction_timestamp?: InputMaybe<TimestampComparisonExp>;\n  transaction_version?: InputMaybe<BigintComparisonExp>;\n  uri_mutable?: InputMaybe<BooleanComparisonExp>;\n};\n\n/** unique or primary key constraints on table \"token_datas\" */\nexport enum TokenDatasConstraint {\n  /** unique or primary key constraint on columns \"token_data_id_hash\", \"transaction_version\" */\n  TokenDatasPkey = \"token_datas_pkey\",\n}\n\n/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */\nexport type TokenDatasDeleteAtPathInput = {\n  default_properties?: InputMaybe<Array<Scalars[\"String\"][\"input\"]>>;\n};\n\n/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */\nexport type TokenDatasDeleteElemInput = {\n  default_properties?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n};\n\n/** delete key/value pair or string element. key/value pairs are matched based on their key value */\nexport type TokenDatasDeleteKeyInput = {\n  default_properties?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** input type for incrementing numeric columns in table \"token_datas\" */\nexport type TokenDatasIncInput = {\n  largest_property_version?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  maximum?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  royalty_points_denominator?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  royalty_points_numerator?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  supply?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** input type for inserting data into table \"token_datas\" */\nexport type TokenDatasInsertInput = {\n  collection_data_id_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  collection_name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  creator_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  default_properties?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  description?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  description_mutable?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  largest_property_version?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  maximum?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  maximum_mutable?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  metadata_uri?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  payee_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  properties_mutable?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  royalty_mutable?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  royalty_points_denominator?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  royalty_points_numerator?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  supply?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  token_data_id_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  uri_mutable?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** aggregate max on columns */\nexport type TokenDatasMaxFields = {\n  collection_data_id_hash?: Maybe<Scalars[\"String\"][\"output\"]>;\n  collection_name?: Maybe<Scalars[\"String\"][\"output\"]>;\n  creator_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  description?: Maybe<Scalars[\"String\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  largest_property_version?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  maximum?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  metadata_uri?: Maybe<Scalars[\"String\"][\"output\"]>;\n  name?: Maybe<Scalars[\"String\"][\"output\"]>;\n  payee_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  royalty_points_denominator?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  royalty_points_numerator?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  supply?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  token_data_id_hash?: Maybe<Scalars[\"String\"][\"output\"]>;\n  transaction_timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** aggregate min on columns */\nexport type TokenDatasMinFields = {\n  collection_data_id_hash?: Maybe<Scalars[\"String\"][\"output\"]>;\n  collection_name?: Maybe<Scalars[\"String\"][\"output\"]>;\n  creator_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  description?: Maybe<Scalars[\"String\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  largest_property_version?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  maximum?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  metadata_uri?: Maybe<Scalars[\"String\"][\"output\"]>;\n  name?: Maybe<Scalars[\"String\"][\"output\"]>;\n  payee_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  royalty_points_denominator?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  royalty_points_numerator?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  supply?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  token_data_id_hash?: Maybe<Scalars[\"String\"][\"output\"]>;\n  transaction_timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** response of any mutation on the table \"token_datas\" */\nexport type TokenDatasMutationResponse = {\n  /** number of rows affected by the mutation */\n  affected_rows: Scalars[\"Int\"][\"output\"];\n  /** data from the rows affected by the mutation */\n  returning: Array<TokenDatas>;\n};\n\n/** on_conflict condition type for table \"token_datas\" */\nexport type TokenDatasOnConflict = {\n  constraint: TokenDatasConstraint;\n  update_columns?: Array<TokenDatasUpdateColumn>;\n  where?: InputMaybe<TokenDatasBoolExp>;\n};\n\n/** Ordering options when selecting data from \"token_datas\". */\nexport type TokenDatasOrderBy = {\n  collection_data_id_hash?: InputMaybe<OrderBy>;\n  collection_name?: InputMaybe<OrderBy>;\n  creator_address?: InputMaybe<OrderBy>;\n  default_properties?: InputMaybe<OrderBy>;\n  description?: InputMaybe<OrderBy>;\n  description_mutable?: InputMaybe<OrderBy>;\n  inserted_at?: InputMaybe<OrderBy>;\n  largest_property_version?: InputMaybe<OrderBy>;\n  maximum?: InputMaybe<OrderBy>;\n  maximum_mutable?: InputMaybe<OrderBy>;\n  metadata_uri?: InputMaybe<OrderBy>;\n  name?: InputMaybe<OrderBy>;\n  payee_address?: InputMaybe<OrderBy>;\n  properties_mutable?: InputMaybe<OrderBy>;\n  royalty_mutable?: InputMaybe<OrderBy>;\n  royalty_points_denominator?: InputMaybe<OrderBy>;\n  royalty_points_numerator?: InputMaybe<OrderBy>;\n  supply?: InputMaybe<OrderBy>;\n  token_data_id_hash?: InputMaybe<OrderBy>;\n  transaction_timestamp?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n  uri_mutable?: InputMaybe<OrderBy>;\n};\n\n/** primary key columns input for table: token_datas */\nexport type TokenDatasPkColumnsInput = {\n  token_data_id_hash: Scalars[\"String\"][\"input\"];\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\n/** prepend existing jsonb value of filtered columns with new jsonb value */\nexport type TokenDatasPrependInput = {\n  default_properties?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n};\n\n/** select columns of table \"token_datas\" */\nexport enum TokenDatasSelectColumn {\n  /** column name */\n  CollectionDataIdHash = \"collection_data_id_hash\",\n  /** column name */\n  CollectionName = \"collection_name\",\n  /** column name */\n  CreatorAddress = \"creator_address\",\n  /** column name */\n  DefaultProperties = \"default_properties\",\n  /** column name */\n  Description = \"description\",\n  /** column name */\n  DescriptionMutable = \"description_mutable\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  LargestPropertyVersion = \"largest_property_version\",\n  /** column name */\n  Maximum = \"maximum\",\n  /** column name */\n  MaximumMutable = \"maximum_mutable\",\n  /** column name */\n  MetadataUri = \"metadata_uri\",\n  /** column name */\n  Name = \"name\",\n  /** column name */\n  PayeeAddress = \"payee_address\",\n  /** column name */\n  PropertiesMutable = \"properties_mutable\",\n  /** column name */\n  RoyaltyMutable = \"royalty_mutable\",\n  /** column name */\n  RoyaltyPointsDenominator = \"royalty_points_denominator\",\n  /** column name */\n  RoyaltyPointsNumerator = \"royalty_points_numerator\",\n  /** column name */\n  Supply = \"supply\",\n  /** column name */\n  TokenDataIdHash = \"token_data_id_hash\",\n  /** column name */\n  TransactionTimestamp = \"transaction_timestamp\",\n  /** column name */\n  TransactionVersion = \"transaction_version\",\n  /** column name */\n  UriMutable = \"uri_mutable\",\n}\n\n/** input type for updating data in table \"token_datas\" */\nexport type TokenDatasSetInput = {\n  collection_data_id_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  collection_name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  creator_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  default_properties?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  description?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  description_mutable?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  largest_property_version?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  maximum?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  maximum_mutable?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  metadata_uri?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  payee_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  properties_mutable?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  royalty_mutable?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  royalty_points_denominator?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  royalty_points_numerator?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  supply?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  token_data_id_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  uri_mutable?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** aggregate stddev on columns */\nexport type TokenDatasStddevFields = {\n  largest_property_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  maximum?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  royalty_points_denominator?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  royalty_points_numerator?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  supply?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_pop on columns */\nexport type TokenDatasStddevPopFields = {\n  largest_property_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  maximum?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  royalty_points_denominator?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  royalty_points_numerator?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  supply?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_samp on columns */\nexport type TokenDatasStddevSampFields = {\n  largest_property_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  maximum?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  royalty_points_denominator?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  royalty_points_numerator?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  supply?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Streaming cursor of the table \"token_datas\" */\nexport type TokenDatasStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: TokenDatasStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type TokenDatasStreamCursorValueInput = {\n  collection_data_id_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  collection_name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  creator_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  default_properties?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  description?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  description_mutable?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  largest_property_version?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  maximum?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  maximum_mutable?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  metadata_uri?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  payee_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  properties_mutable?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  royalty_mutable?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  royalty_points_denominator?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  royalty_points_numerator?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  supply?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  token_data_id_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  uri_mutable?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** aggregate sum on columns */\nexport type TokenDatasSumFields = {\n  largest_property_version?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  maximum?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  royalty_points_denominator?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  royalty_points_numerator?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  supply?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** update columns of table \"token_datas\" */\nexport enum TokenDatasUpdateColumn {\n  /** column name */\n  CollectionDataIdHash = \"collection_data_id_hash\",\n  /** column name */\n  CollectionName = \"collection_name\",\n  /** column name */\n  CreatorAddress = \"creator_address\",\n  /** column name */\n  DefaultProperties = \"default_properties\",\n  /** column name */\n  Description = \"description\",\n  /** column name */\n  DescriptionMutable = \"description_mutable\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  LargestPropertyVersion = \"largest_property_version\",\n  /** column name */\n  Maximum = \"maximum\",\n  /** column name */\n  MaximumMutable = \"maximum_mutable\",\n  /** column name */\n  MetadataUri = \"metadata_uri\",\n  /** column name */\n  Name = \"name\",\n  /** column name */\n  PayeeAddress = \"payee_address\",\n  /** column name */\n  PropertiesMutable = \"properties_mutable\",\n  /** column name */\n  RoyaltyMutable = \"royalty_mutable\",\n  /** column name */\n  RoyaltyPointsDenominator = \"royalty_points_denominator\",\n  /** column name */\n  RoyaltyPointsNumerator = \"royalty_points_numerator\",\n  /** column name */\n  Supply = \"supply\",\n  /** column name */\n  TokenDataIdHash = \"token_data_id_hash\",\n  /** column name */\n  TransactionTimestamp = \"transaction_timestamp\",\n  /** column name */\n  TransactionVersion = \"transaction_version\",\n  /** column name */\n  UriMutable = \"uri_mutable\",\n}\n\nexport type TokenDatasUpdates = {\n  /** append existing jsonb value of filtered columns with new jsonb value */\n  _append?: InputMaybe<TokenDatasAppendInput>;\n  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */\n  _delete_at_path?: InputMaybe<TokenDatasDeleteAtPathInput>;\n  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */\n  _delete_elem?: InputMaybe<TokenDatasDeleteElemInput>;\n  /** delete key/value pair or string element. key/value pairs are matched based on their key value */\n  _delete_key?: InputMaybe<TokenDatasDeleteKeyInput>;\n  /** increments the numeric columns with given value of the filtered values */\n  _inc?: InputMaybe<TokenDatasIncInput>;\n  /** prepend existing jsonb value of filtered columns with new jsonb value */\n  _prepend?: InputMaybe<TokenDatasPrependInput>;\n  /** sets the columns of the filtered rows to the given values */\n  _set?: InputMaybe<TokenDatasSetInput>;\n  /** filter the rows which have to be updated */\n  where: TokenDatasBoolExp;\n};\n\n/** columns and relationships of \"token_datas_v2\" */\nexport type TokenDatasV2 = {\n  collection_id: Scalars[\"String\"][\"output\"];\n  decimals?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  description: Scalars[\"String\"][\"output\"];\n  inserted_at: Scalars[\"timestamp\"][\"output\"];\n  is_deleted_v2?: Maybe<Scalars[\"Boolean\"][\"output\"]>;\n  is_fungible_v2?: Maybe<Scalars[\"Boolean\"][\"output\"]>;\n  largest_property_version_v1?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  maximum?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  supply?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  token_data_id: Scalars[\"String\"][\"output\"];\n  token_name: Scalars[\"String\"][\"output\"];\n  token_properties: Scalars[\"jsonb\"][\"output\"];\n  token_standard: Scalars[\"String\"][\"output\"];\n  token_uri: Scalars[\"String\"][\"output\"];\n  transaction_timestamp: Scalars[\"timestamp\"][\"output\"];\n  transaction_version: Scalars[\"bigint\"][\"output\"];\n  write_set_change_index: Scalars[\"bigint\"][\"output\"];\n};\n\n/** columns and relationships of \"token_datas_v2\" */\nexport type TokenDatasV2TokenPropertiesArgs = {\n  path?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregated selection of \"token_datas_v2\" */\nexport type TokenDatasV2Aggregate = {\n  aggregate?: Maybe<TokenDatasV2AggregateFields>;\n  nodes: Array<TokenDatasV2>;\n};\n\n/** aggregate fields of \"token_datas_v2\" */\nexport type TokenDatasV2AggregateFields = {\n  avg?: Maybe<TokenDatasV2AvgFields>;\n  count: Scalars[\"Int\"][\"output\"];\n  max?: Maybe<TokenDatasV2MaxFields>;\n  min?: Maybe<TokenDatasV2MinFields>;\n  stddev?: Maybe<TokenDatasV2StddevFields>;\n  stddev_pop?: Maybe<TokenDatasV2StddevPopFields>;\n  stddev_samp?: Maybe<TokenDatasV2StddevSampFields>;\n  sum?: Maybe<TokenDatasV2SumFields>;\n  var_pop?: Maybe<TokenDatasV2VarPopFields>;\n  var_samp?: Maybe<TokenDatasV2VarSampFields>;\n  variance?: Maybe<TokenDatasV2VarianceFields>;\n};\n\n/** aggregate fields of \"token_datas_v2\" */\nexport type TokenDatasV2AggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<TokenDatasV2SelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** append existing jsonb value of filtered columns with new jsonb value */\nexport type TokenDatasV2AppendInput = {\n  token_properties?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n};\n\n/** aggregate avg on columns */\nexport type TokenDatasV2AvgFields = {\n  decimals?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  largest_property_version_v1?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  maximum?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  supply?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Boolean expression to filter rows from the table \"token_datas_v2\". All fields are combined with a logical 'AND'. */\nexport type TokenDatasV2BoolExp = {\n  _and?: InputMaybe<Array<TokenDatasV2BoolExp>>;\n  _not?: InputMaybe<TokenDatasV2BoolExp>;\n  _or?: InputMaybe<Array<TokenDatasV2BoolExp>>;\n  collection_id?: InputMaybe<StringComparisonExp>;\n  decimals?: InputMaybe<BigintComparisonExp>;\n  description?: InputMaybe<StringComparisonExp>;\n  inserted_at?: InputMaybe<TimestampComparisonExp>;\n  is_deleted_v2?: InputMaybe<BooleanComparisonExp>;\n  is_fungible_v2?: InputMaybe<BooleanComparisonExp>;\n  largest_property_version_v1?: InputMaybe<NumericComparisonExp>;\n  maximum?: InputMaybe<NumericComparisonExp>;\n  supply?: InputMaybe<NumericComparisonExp>;\n  token_data_id?: InputMaybe<StringComparisonExp>;\n  token_name?: InputMaybe<StringComparisonExp>;\n  token_properties?: InputMaybe<JsonbComparisonExp>;\n  token_standard?: InputMaybe<StringComparisonExp>;\n  token_uri?: InputMaybe<StringComparisonExp>;\n  transaction_timestamp?: InputMaybe<TimestampComparisonExp>;\n  transaction_version?: InputMaybe<BigintComparisonExp>;\n  write_set_change_index?: InputMaybe<BigintComparisonExp>;\n};\n\n/** unique or primary key constraints on table \"token_datas_v2\" */\nexport enum TokenDatasV2Constraint {\n  /** unique or primary key constraint on columns \"write_set_change_index\", \"transaction_version\" */\n  TokenDatasV2Pkey = \"token_datas_v2_pkey\",\n}\n\n/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */\nexport type TokenDatasV2DeleteAtPathInput = {\n  token_properties?: InputMaybe<Array<Scalars[\"String\"][\"input\"]>>;\n};\n\n/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */\nexport type TokenDatasV2DeleteElemInput = {\n  token_properties?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n};\n\n/** delete key/value pair or string element. key/value pairs are matched based on their key value */\nexport type TokenDatasV2DeleteKeyInput = {\n  token_properties?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** input type for incrementing numeric columns in table \"token_datas_v2\" */\nexport type TokenDatasV2IncInput = {\n  decimals?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  largest_property_version_v1?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  maximum?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  supply?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  write_set_change_index?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** input type for inserting data into table \"token_datas_v2\" */\nexport type TokenDatasV2InsertInput = {\n  collection_id?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  decimals?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  description?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  is_deleted_v2?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  is_fungible_v2?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  largest_property_version_v1?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  maximum?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  supply?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  token_data_id?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_properties?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  token_standard?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_uri?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  write_set_change_index?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** aggregate max on columns */\nexport type TokenDatasV2MaxFields = {\n  collection_id?: Maybe<Scalars[\"String\"][\"output\"]>;\n  decimals?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  description?: Maybe<Scalars[\"String\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  largest_property_version_v1?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  maximum?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  supply?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  token_data_id?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_name?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_standard?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_uri?: Maybe<Scalars[\"String\"][\"output\"]>;\n  transaction_timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** aggregate min on columns */\nexport type TokenDatasV2MinFields = {\n  collection_id?: Maybe<Scalars[\"String\"][\"output\"]>;\n  decimals?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  description?: Maybe<Scalars[\"String\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  largest_property_version_v1?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  maximum?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  supply?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  token_data_id?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_name?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_standard?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_uri?: Maybe<Scalars[\"String\"][\"output\"]>;\n  transaction_timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** response of any mutation on the table \"token_datas_v2\" */\nexport type TokenDatasV2MutationResponse = {\n  /** number of rows affected by the mutation */\n  affected_rows: Scalars[\"Int\"][\"output\"];\n  /** data from the rows affected by the mutation */\n  returning: Array<TokenDatasV2>;\n};\n\n/** on_conflict condition type for table \"token_datas_v2\" */\nexport type TokenDatasV2OnConflict = {\n  constraint: TokenDatasV2Constraint;\n  update_columns?: Array<TokenDatasV2UpdateColumn>;\n  where?: InputMaybe<TokenDatasV2BoolExp>;\n};\n\n/** Ordering options when selecting data from \"token_datas_v2\". */\nexport type TokenDatasV2OrderBy = {\n  collection_id?: InputMaybe<OrderBy>;\n  decimals?: InputMaybe<OrderBy>;\n  description?: InputMaybe<OrderBy>;\n  inserted_at?: InputMaybe<OrderBy>;\n  is_deleted_v2?: InputMaybe<OrderBy>;\n  is_fungible_v2?: InputMaybe<OrderBy>;\n  largest_property_version_v1?: InputMaybe<OrderBy>;\n  maximum?: InputMaybe<OrderBy>;\n  supply?: InputMaybe<OrderBy>;\n  token_data_id?: InputMaybe<OrderBy>;\n  token_name?: InputMaybe<OrderBy>;\n  token_properties?: InputMaybe<OrderBy>;\n  token_standard?: InputMaybe<OrderBy>;\n  token_uri?: InputMaybe<OrderBy>;\n  transaction_timestamp?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n  write_set_change_index?: InputMaybe<OrderBy>;\n};\n\n/** primary key columns input for table: token_datas_v2 */\nexport type TokenDatasV2PkColumnsInput = {\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n  write_set_change_index: Scalars[\"bigint\"][\"input\"];\n};\n\n/** prepend existing jsonb value of filtered columns with new jsonb value */\nexport type TokenDatasV2PrependInput = {\n  token_properties?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n};\n\n/** select columns of table \"token_datas_v2\" */\nexport enum TokenDatasV2SelectColumn {\n  /** column name */\n  CollectionId = \"collection_id\",\n  /** column name */\n  Decimals = \"decimals\",\n  /** column name */\n  Description = \"description\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  IsDeletedV2 = \"is_deleted_v2\",\n  /** column name */\n  IsFungibleV2 = \"is_fungible_v2\",\n  /** column name */\n  LargestPropertyVersionV1 = \"largest_property_version_v1\",\n  /** column name */\n  Maximum = \"maximum\",\n  /** column name */\n  Supply = \"supply\",\n  /** column name */\n  TokenDataId = \"token_data_id\",\n  /** column name */\n  TokenName = \"token_name\",\n  /** column name */\n  TokenProperties = \"token_properties\",\n  /** column name */\n  TokenStandard = \"token_standard\",\n  /** column name */\n  TokenUri = \"token_uri\",\n  /** column name */\n  TransactionTimestamp = \"transaction_timestamp\",\n  /** column name */\n  TransactionVersion = \"transaction_version\",\n  /** column name */\n  WriteSetChangeIndex = \"write_set_change_index\",\n}\n\n/** input type for updating data in table \"token_datas_v2\" */\nexport type TokenDatasV2SetInput = {\n  collection_id?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  decimals?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  description?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  is_deleted_v2?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  is_fungible_v2?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  largest_property_version_v1?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  maximum?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  supply?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  token_data_id?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_properties?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  token_standard?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_uri?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  write_set_change_index?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** aggregate stddev on columns */\nexport type TokenDatasV2StddevFields = {\n  decimals?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  largest_property_version_v1?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  maximum?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  supply?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_pop on columns */\nexport type TokenDatasV2StddevPopFields = {\n  decimals?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  largest_property_version_v1?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  maximum?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  supply?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_samp on columns */\nexport type TokenDatasV2StddevSampFields = {\n  decimals?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  largest_property_version_v1?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  maximum?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  supply?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Streaming cursor of the table \"token_datas_v2\" */\nexport type TokenDatasV2StreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: TokenDatasV2StreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type TokenDatasV2StreamCursorValueInput = {\n  collection_id?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  decimals?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  description?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  is_deleted_v2?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  is_fungible_v2?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  largest_property_version_v1?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  maximum?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  supply?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  token_data_id?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_properties?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  token_standard?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_uri?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  write_set_change_index?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** aggregate sum on columns */\nexport type TokenDatasV2SumFields = {\n  decimals?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  largest_property_version_v1?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  maximum?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  supply?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** update columns of table \"token_datas_v2\" */\nexport enum TokenDatasV2UpdateColumn {\n  /** column name */\n  CollectionId = \"collection_id\",\n  /** column name */\n  Decimals = \"decimals\",\n  /** column name */\n  Description = \"description\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  IsDeletedV2 = \"is_deleted_v2\",\n  /** column name */\n  IsFungibleV2 = \"is_fungible_v2\",\n  /** column name */\n  LargestPropertyVersionV1 = \"largest_property_version_v1\",\n  /** column name */\n  Maximum = \"maximum\",\n  /** column name */\n  Supply = \"supply\",\n  /** column name */\n  TokenDataId = \"token_data_id\",\n  /** column name */\n  TokenName = \"token_name\",\n  /** column name */\n  TokenProperties = \"token_properties\",\n  /** column name */\n  TokenStandard = \"token_standard\",\n  /** column name */\n  TokenUri = \"token_uri\",\n  /** column name */\n  TransactionTimestamp = \"transaction_timestamp\",\n  /** column name */\n  TransactionVersion = \"transaction_version\",\n  /** column name */\n  WriteSetChangeIndex = \"write_set_change_index\",\n}\n\nexport type TokenDatasV2Updates = {\n  /** append existing jsonb value of filtered columns with new jsonb value */\n  _append?: InputMaybe<TokenDatasV2AppendInput>;\n  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */\n  _delete_at_path?: InputMaybe<TokenDatasV2DeleteAtPathInput>;\n  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */\n  _delete_elem?: InputMaybe<TokenDatasV2DeleteElemInput>;\n  /** delete key/value pair or string element. key/value pairs are matched based on their key value */\n  _delete_key?: InputMaybe<TokenDatasV2DeleteKeyInput>;\n  /** increments the numeric columns with given value of the filtered values */\n  _inc?: InputMaybe<TokenDatasV2IncInput>;\n  /** prepend existing jsonb value of filtered columns with new jsonb value */\n  _prepend?: InputMaybe<TokenDatasV2PrependInput>;\n  /** sets the columns of the filtered rows to the given values */\n  _set?: InputMaybe<TokenDatasV2SetInput>;\n  /** filter the rows which have to be updated */\n  where: TokenDatasV2BoolExp;\n};\n\n/** aggregate var_pop on columns */\nexport type TokenDatasV2VarPopFields = {\n  decimals?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  largest_property_version_v1?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  maximum?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  supply?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate var_samp on columns */\nexport type TokenDatasV2VarSampFields = {\n  decimals?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  largest_property_version_v1?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  maximum?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  supply?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate variance on columns */\nexport type TokenDatasV2VarianceFields = {\n  decimals?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  largest_property_version_v1?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  maximum?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  supply?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate var_pop on columns */\nexport type TokenDatasVarPopFields = {\n  largest_property_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  maximum?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  royalty_points_denominator?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  royalty_points_numerator?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  supply?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate var_samp on columns */\nexport type TokenDatasVarSampFields = {\n  largest_property_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  maximum?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  royalty_points_denominator?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  royalty_points_numerator?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  supply?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate variance on columns */\nexport type TokenDatasVarianceFields = {\n  largest_property_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  maximum?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  royalty_points_denominator?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  royalty_points_numerator?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  supply?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** columns and relationships of \"token_ownerships\" */\nexport type TokenOwnerships = {\n  amount: Scalars[\"numeric\"][\"output\"];\n  collection_data_id_hash: Scalars[\"String\"][\"output\"];\n  collection_name: Scalars[\"String\"][\"output\"];\n  creator_address: Scalars[\"String\"][\"output\"];\n  inserted_at: Scalars[\"timestamp\"][\"output\"];\n  name: Scalars[\"String\"][\"output\"];\n  owner_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  property_version: Scalars[\"numeric\"][\"output\"];\n  table_handle: Scalars[\"String\"][\"output\"];\n  table_type?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_data_id_hash: Scalars[\"String\"][\"output\"];\n  transaction_timestamp: Scalars[\"timestamp\"][\"output\"];\n  transaction_version: Scalars[\"bigint\"][\"output\"];\n};\n\n/** aggregated selection of \"token_ownerships\" */\nexport type TokenOwnershipsAggregate = {\n  aggregate?: Maybe<TokenOwnershipsAggregateFields>;\n  nodes: Array<TokenOwnerships>;\n};\n\n/** aggregate fields of \"token_ownerships\" */\nexport type TokenOwnershipsAggregateFields = {\n  avg?: Maybe<TokenOwnershipsAvgFields>;\n  count: Scalars[\"Int\"][\"output\"];\n  max?: Maybe<TokenOwnershipsMaxFields>;\n  min?: Maybe<TokenOwnershipsMinFields>;\n  stddev?: Maybe<TokenOwnershipsStddevFields>;\n  stddev_pop?: Maybe<TokenOwnershipsStddevPopFields>;\n  stddev_samp?: Maybe<TokenOwnershipsStddevSampFields>;\n  sum?: Maybe<TokenOwnershipsSumFields>;\n  var_pop?: Maybe<TokenOwnershipsVarPopFields>;\n  var_samp?: Maybe<TokenOwnershipsVarSampFields>;\n  variance?: Maybe<TokenOwnershipsVarianceFields>;\n};\n\n/** aggregate fields of \"token_ownerships\" */\nexport type TokenOwnershipsAggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<TokenOwnershipsSelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** aggregate avg on columns */\nexport type TokenOwnershipsAvgFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  property_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Boolean expression to filter rows from the table \"token_ownerships\". All fields are combined with a logical 'AND'. */\nexport type TokenOwnershipsBoolExp = {\n  _and?: InputMaybe<Array<TokenOwnershipsBoolExp>>;\n  _not?: InputMaybe<TokenOwnershipsBoolExp>;\n  _or?: InputMaybe<Array<TokenOwnershipsBoolExp>>;\n  amount?: InputMaybe<NumericComparisonExp>;\n  collection_data_id_hash?: InputMaybe<StringComparisonExp>;\n  collection_name?: InputMaybe<StringComparisonExp>;\n  creator_address?: InputMaybe<StringComparisonExp>;\n  inserted_at?: InputMaybe<TimestampComparisonExp>;\n  name?: InputMaybe<StringComparisonExp>;\n  owner_address?: InputMaybe<StringComparisonExp>;\n  property_version?: InputMaybe<NumericComparisonExp>;\n  table_handle?: InputMaybe<StringComparisonExp>;\n  table_type?: InputMaybe<StringComparisonExp>;\n  token_data_id_hash?: InputMaybe<StringComparisonExp>;\n  transaction_timestamp?: InputMaybe<TimestampComparisonExp>;\n  transaction_version?: InputMaybe<BigintComparisonExp>;\n};\n\n/** unique or primary key constraints on table \"token_ownerships\" */\nexport enum TokenOwnershipsConstraint {\n  /** unique or primary key constraint on columns \"property_version\", \"table_handle\", \"token_data_id_hash\", \"transaction_version\" */\n  TokenOwnershipsPkey = \"token_ownerships_pkey\",\n}\n\n/** input type for incrementing numeric columns in table \"token_ownerships\" */\nexport type TokenOwnershipsIncInput = {\n  amount?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  property_version?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** input type for inserting data into table \"token_ownerships\" */\nexport type TokenOwnershipsInsertInput = {\n  amount?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  collection_data_id_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  collection_name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  creator_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  owner_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  property_version?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  table_handle?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  table_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_data_id_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** aggregate max on columns */\nexport type TokenOwnershipsMaxFields = {\n  amount?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  collection_data_id_hash?: Maybe<Scalars[\"String\"][\"output\"]>;\n  collection_name?: Maybe<Scalars[\"String\"][\"output\"]>;\n  creator_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  name?: Maybe<Scalars[\"String\"][\"output\"]>;\n  owner_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  property_version?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  table_handle?: Maybe<Scalars[\"String\"][\"output\"]>;\n  table_type?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_data_id_hash?: Maybe<Scalars[\"String\"][\"output\"]>;\n  transaction_timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** aggregate min on columns */\nexport type TokenOwnershipsMinFields = {\n  amount?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  collection_data_id_hash?: Maybe<Scalars[\"String\"][\"output\"]>;\n  collection_name?: Maybe<Scalars[\"String\"][\"output\"]>;\n  creator_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  name?: Maybe<Scalars[\"String\"][\"output\"]>;\n  owner_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  property_version?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  table_handle?: Maybe<Scalars[\"String\"][\"output\"]>;\n  table_type?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_data_id_hash?: Maybe<Scalars[\"String\"][\"output\"]>;\n  transaction_timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** response of any mutation on the table \"token_ownerships\" */\nexport type TokenOwnershipsMutationResponse = {\n  /** number of rows affected by the mutation */\n  affected_rows: Scalars[\"Int\"][\"output\"];\n  /** data from the rows affected by the mutation */\n  returning: Array<TokenOwnerships>;\n};\n\n/** on_conflict condition type for table \"token_ownerships\" */\nexport type TokenOwnershipsOnConflict = {\n  constraint: TokenOwnershipsConstraint;\n  update_columns?: Array<TokenOwnershipsUpdateColumn>;\n  where?: InputMaybe<TokenOwnershipsBoolExp>;\n};\n\n/** Ordering options when selecting data from \"token_ownerships\". */\nexport type TokenOwnershipsOrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  collection_data_id_hash?: InputMaybe<OrderBy>;\n  collection_name?: InputMaybe<OrderBy>;\n  creator_address?: InputMaybe<OrderBy>;\n  inserted_at?: InputMaybe<OrderBy>;\n  name?: InputMaybe<OrderBy>;\n  owner_address?: InputMaybe<OrderBy>;\n  property_version?: InputMaybe<OrderBy>;\n  table_handle?: InputMaybe<OrderBy>;\n  table_type?: InputMaybe<OrderBy>;\n  token_data_id_hash?: InputMaybe<OrderBy>;\n  transaction_timestamp?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n};\n\n/** primary key columns input for table: token_ownerships */\nexport type TokenOwnershipsPkColumnsInput = {\n  property_version: Scalars[\"numeric\"][\"input\"];\n  table_handle: Scalars[\"String\"][\"input\"];\n  token_data_id_hash: Scalars[\"String\"][\"input\"];\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\n/** select columns of table \"token_ownerships\" */\nexport enum TokenOwnershipsSelectColumn {\n  /** column name */\n  Amount = \"amount\",\n  /** column name */\n  CollectionDataIdHash = \"collection_data_id_hash\",\n  /** column name */\n  CollectionName = \"collection_name\",\n  /** column name */\n  CreatorAddress = \"creator_address\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  Name = \"name\",\n  /** column name */\n  OwnerAddress = \"owner_address\",\n  /** column name */\n  PropertyVersion = \"property_version\",\n  /** column name */\n  TableHandle = \"table_handle\",\n  /** column name */\n  TableType = \"table_type\",\n  /** column name */\n  TokenDataIdHash = \"token_data_id_hash\",\n  /** column name */\n  TransactionTimestamp = \"transaction_timestamp\",\n  /** column name */\n  TransactionVersion = \"transaction_version\",\n}\n\n/** input type for updating data in table \"token_ownerships\" */\nexport type TokenOwnershipsSetInput = {\n  amount?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  collection_data_id_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  collection_name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  creator_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  owner_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  property_version?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  table_handle?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  table_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_data_id_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** aggregate stddev on columns */\nexport type TokenOwnershipsStddevFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  property_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_pop on columns */\nexport type TokenOwnershipsStddevPopFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  property_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_samp on columns */\nexport type TokenOwnershipsStddevSampFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  property_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Streaming cursor of the table \"token_ownerships\" */\nexport type TokenOwnershipsStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: TokenOwnershipsStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type TokenOwnershipsStreamCursorValueInput = {\n  amount?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  collection_data_id_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  collection_name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  creator_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  owner_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  property_version?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  table_handle?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  table_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_data_id_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** aggregate sum on columns */\nexport type TokenOwnershipsSumFields = {\n  amount?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  property_version?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** update columns of table \"token_ownerships\" */\nexport enum TokenOwnershipsUpdateColumn {\n  /** column name */\n  Amount = \"amount\",\n  /** column name */\n  CollectionDataIdHash = \"collection_data_id_hash\",\n  /** column name */\n  CollectionName = \"collection_name\",\n  /** column name */\n  CreatorAddress = \"creator_address\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  Name = \"name\",\n  /** column name */\n  OwnerAddress = \"owner_address\",\n  /** column name */\n  PropertyVersion = \"property_version\",\n  /** column name */\n  TableHandle = \"table_handle\",\n  /** column name */\n  TableType = \"table_type\",\n  /** column name */\n  TokenDataIdHash = \"token_data_id_hash\",\n  /** column name */\n  TransactionTimestamp = \"transaction_timestamp\",\n  /** column name */\n  TransactionVersion = \"transaction_version\",\n}\n\nexport type TokenOwnershipsUpdates = {\n  /** increments the numeric columns with given value of the filtered values */\n  _inc?: InputMaybe<TokenOwnershipsIncInput>;\n  /** sets the columns of the filtered rows to the given values */\n  _set?: InputMaybe<TokenOwnershipsSetInput>;\n  /** filter the rows which have to be updated */\n  where: TokenOwnershipsBoolExp;\n};\n\n/** columns and relationships of \"token_ownerships_v2\" */\nexport type TokenOwnershipsV2 = {\n  amount: Scalars[\"numeric\"][\"output\"];\n  inserted_at: Scalars[\"timestamp\"][\"output\"];\n  is_fungible_v2?: Maybe<Scalars[\"Boolean\"][\"output\"]>;\n  is_soulbound_v2?: Maybe<Scalars[\"Boolean\"][\"output\"]>;\n  non_transferrable_by_owner?: Maybe<Scalars[\"Boolean\"][\"output\"]>;\n  owner_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  property_version_v1: Scalars[\"numeric\"][\"output\"];\n  storage_id: Scalars[\"String\"][\"output\"];\n  table_type_v1?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_data_id: Scalars[\"String\"][\"output\"];\n  token_properties_mutated_v1?: Maybe<Scalars[\"jsonb\"][\"output\"]>;\n  token_standard: Scalars[\"String\"][\"output\"];\n  transaction_timestamp: Scalars[\"timestamp\"][\"output\"];\n  transaction_version: Scalars[\"bigint\"][\"output\"];\n  write_set_change_index: Scalars[\"bigint\"][\"output\"];\n};\n\n/** columns and relationships of \"token_ownerships_v2\" */\nexport type TokenOwnershipsV2TokenPropertiesMutatedV1Args = {\n  path?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregated selection of \"token_ownerships_v2\" */\nexport type TokenOwnershipsV2Aggregate = {\n  aggregate?: Maybe<TokenOwnershipsV2AggregateFields>;\n  nodes: Array<TokenOwnershipsV2>;\n};\n\n/** aggregate fields of \"token_ownerships_v2\" */\nexport type TokenOwnershipsV2AggregateFields = {\n  avg?: Maybe<TokenOwnershipsV2AvgFields>;\n  count: Scalars[\"Int\"][\"output\"];\n  max?: Maybe<TokenOwnershipsV2MaxFields>;\n  min?: Maybe<TokenOwnershipsV2MinFields>;\n  stddev?: Maybe<TokenOwnershipsV2StddevFields>;\n  stddev_pop?: Maybe<TokenOwnershipsV2StddevPopFields>;\n  stddev_samp?: Maybe<TokenOwnershipsV2StddevSampFields>;\n  sum?: Maybe<TokenOwnershipsV2SumFields>;\n  var_pop?: Maybe<TokenOwnershipsV2VarPopFields>;\n  var_samp?: Maybe<TokenOwnershipsV2VarSampFields>;\n  variance?: Maybe<TokenOwnershipsV2VarianceFields>;\n};\n\n/** aggregate fields of \"token_ownerships_v2\" */\nexport type TokenOwnershipsV2AggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<TokenOwnershipsV2SelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** append existing jsonb value of filtered columns with new jsonb value */\nexport type TokenOwnershipsV2AppendInput = {\n  token_properties_mutated_v1?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n};\n\n/** aggregate avg on columns */\nexport type TokenOwnershipsV2AvgFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  property_version_v1?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Boolean expression to filter rows from the table \"token_ownerships_v2\". All fields are combined with a logical 'AND'. */\nexport type TokenOwnershipsV2BoolExp = {\n  _and?: InputMaybe<Array<TokenOwnershipsV2BoolExp>>;\n  _not?: InputMaybe<TokenOwnershipsV2BoolExp>;\n  _or?: InputMaybe<Array<TokenOwnershipsV2BoolExp>>;\n  amount?: InputMaybe<NumericComparisonExp>;\n  inserted_at?: InputMaybe<TimestampComparisonExp>;\n  is_fungible_v2?: InputMaybe<BooleanComparisonExp>;\n  is_soulbound_v2?: InputMaybe<BooleanComparisonExp>;\n  non_transferrable_by_owner?: InputMaybe<BooleanComparisonExp>;\n  owner_address?: InputMaybe<StringComparisonExp>;\n  property_version_v1?: InputMaybe<NumericComparisonExp>;\n  storage_id?: InputMaybe<StringComparisonExp>;\n  table_type_v1?: InputMaybe<StringComparisonExp>;\n  token_data_id?: InputMaybe<StringComparisonExp>;\n  token_properties_mutated_v1?: InputMaybe<JsonbComparisonExp>;\n  token_standard?: InputMaybe<StringComparisonExp>;\n  transaction_timestamp?: InputMaybe<TimestampComparisonExp>;\n  transaction_version?: InputMaybe<BigintComparisonExp>;\n  write_set_change_index?: InputMaybe<BigintComparisonExp>;\n};\n\n/** unique or primary key constraints on table \"token_ownerships_v2\" */\nexport enum TokenOwnershipsV2Constraint {\n  /** unique or primary key constraint on columns \"write_set_change_index\", \"transaction_version\" */\n  TokenOwnershipsV2Pkey = \"token_ownerships_v2_pkey\",\n}\n\n/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */\nexport type TokenOwnershipsV2DeleteAtPathInput = {\n  token_properties_mutated_v1?: InputMaybe<Array<Scalars[\"String\"][\"input\"]>>;\n};\n\n/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */\nexport type TokenOwnershipsV2DeleteElemInput = {\n  token_properties_mutated_v1?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n};\n\n/** delete key/value pair or string element. key/value pairs are matched based on their key value */\nexport type TokenOwnershipsV2DeleteKeyInput = {\n  token_properties_mutated_v1?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** input type for incrementing numeric columns in table \"token_ownerships_v2\" */\nexport type TokenOwnershipsV2IncInput = {\n  amount?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  property_version_v1?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  write_set_change_index?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** input type for inserting data into table \"token_ownerships_v2\" */\nexport type TokenOwnershipsV2InsertInput = {\n  amount?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  is_fungible_v2?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  is_soulbound_v2?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  non_transferrable_by_owner?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  owner_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  property_version_v1?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  storage_id?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  table_type_v1?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_data_id?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_properties_mutated_v1?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  token_standard?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  write_set_change_index?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** aggregate max on columns */\nexport type TokenOwnershipsV2MaxFields = {\n  amount?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  owner_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  property_version_v1?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  storage_id?: Maybe<Scalars[\"String\"][\"output\"]>;\n  table_type_v1?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_data_id?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_standard?: Maybe<Scalars[\"String\"][\"output\"]>;\n  transaction_timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** aggregate min on columns */\nexport type TokenOwnershipsV2MinFields = {\n  amount?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  owner_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  property_version_v1?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  storage_id?: Maybe<Scalars[\"String\"][\"output\"]>;\n  table_type_v1?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_data_id?: Maybe<Scalars[\"String\"][\"output\"]>;\n  token_standard?: Maybe<Scalars[\"String\"][\"output\"]>;\n  transaction_timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** response of any mutation on the table \"token_ownerships_v2\" */\nexport type TokenOwnershipsV2MutationResponse = {\n  /** number of rows affected by the mutation */\n  affected_rows: Scalars[\"Int\"][\"output\"];\n  /** data from the rows affected by the mutation */\n  returning: Array<TokenOwnershipsV2>;\n};\n\n/** on_conflict condition type for table \"token_ownerships_v2\" */\nexport type TokenOwnershipsV2OnConflict = {\n  constraint: TokenOwnershipsV2Constraint;\n  update_columns?: Array<TokenOwnershipsV2UpdateColumn>;\n  where?: InputMaybe<TokenOwnershipsV2BoolExp>;\n};\n\n/** Ordering options when selecting data from \"token_ownerships_v2\". */\nexport type TokenOwnershipsV2OrderBy = {\n  amount?: InputMaybe<OrderBy>;\n  inserted_at?: InputMaybe<OrderBy>;\n  is_fungible_v2?: InputMaybe<OrderBy>;\n  is_soulbound_v2?: InputMaybe<OrderBy>;\n  non_transferrable_by_owner?: InputMaybe<OrderBy>;\n  owner_address?: InputMaybe<OrderBy>;\n  property_version_v1?: InputMaybe<OrderBy>;\n  storage_id?: InputMaybe<OrderBy>;\n  table_type_v1?: InputMaybe<OrderBy>;\n  token_data_id?: InputMaybe<OrderBy>;\n  token_properties_mutated_v1?: InputMaybe<OrderBy>;\n  token_standard?: InputMaybe<OrderBy>;\n  transaction_timestamp?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n  write_set_change_index?: InputMaybe<OrderBy>;\n};\n\n/** primary key columns input for table: token_ownerships_v2 */\nexport type TokenOwnershipsV2PkColumnsInput = {\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n  write_set_change_index: Scalars[\"bigint\"][\"input\"];\n};\n\n/** prepend existing jsonb value of filtered columns with new jsonb value */\nexport type TokenOwnershipsV2PrependInput = {\n  token_properties_mutated_v1?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n};\n\n/** select columns of table \"token_ownerships_v2\" */\nexport enum TokenOwnershipsV2SelectColumn {\n  /** column name */\n  Amount = \"amount\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  IsFungibleV2 = \"is_fungible_v2\",\n  /** column name */\n  IsSoulboundV2 = \"is_soulbound_v2\",\n  /** column name */\n  NonTransferrableByOwner = \"non_transferrable_by_owner\",\n  /** column name */\n  OwnerAddress = \"owner_address\",\n  /** column name */\n  PropertyVersionV1 = \"property_version_v1\",\n  /** column name */\n  StorageId = \"storage_id\",\n  /** column name */\n  TableTypeV1 = \"table_type_v1\",\n  /** column name */\n  TokenDataId = \"token_data_id\",\n  /** column name */\n  TokenPropertiesMutatedV1 = \"token_properties_mutated_v1\",\n  /** column name */\n  TokenStandard = \"token_standard\",\n  /** column name */\n  TransactionTimestamp = \"transaction_timestamp\",\n  /** column name */\n  TransactionVersion = \"transaction_version\",\n  /** column name */\n  WriteSetChangeIndex = \"write_set_change_index\",\n}\n\n/** input type for updating data in table \"token_ownerships_v2\" */\nexport type TokenOwnershipsV2SetInput = {\n  amount?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  is_fungible_v2?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  is_soulbound_v2?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  non_transferrable_by_owner?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  owner_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  property_version_v1?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  storage_id?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  table_type_v1?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_data_id?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_properties_mutated_v1?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  token_standard?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  write_set_change_index?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** aggregate stddev on columns */\nexport type TokenOwnershipsV2StddevFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  property_version_v1?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_pop on columns */\nexport type TokenOwnershipsV2StddevPopFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  property_version_v1?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_samp on columns */\nexport type TokenOwnershipsV2StddevSampFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  property_version_v1?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Streaming cursor of the table \"token_ownerships_v2\" */\nexport type TokenOwnershipsV2StreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: TokenOwnershipsV2StreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type TokenOwnershipsV2StreamCursorValueInput = {\n  amount?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  is_fungible_v2?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  is_soulbound_v2?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  non_transferrable_by_owner?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  owner_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  property_version_v1?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  storage_id?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  table_type_v1?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_data_id?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_properties_mutated_v1?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  token_standard?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  write_set_change_index?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** aggregate sum on columns */\nexport type TokenOwnershipsV2SumFields = {\n  amount?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  property_version_v1?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** update columns of table \"token_ownerships_v2\" */\nexport enum TokenOwnershipsV2UpdateColumn {\n  /** column name */\n  Amount = \"amount\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  IsFungibleV2 = \"is_fungible_v2\",\n  /** column name */\n  IsSoulboundV2 = \"is_soulbound_v2\",\n  /** column name */\n  NonTransferrableByOwner = \"non_transferrable_by_owner\",\n  /** column name */\n  OwnerAddress = \"owner_address\",\n  /** column name */\n  PropertyVersionV1 = \"property_version_v1\",\n  /** column name */\n  StorageId = \"storage_id\",\n  /** column name */\n  TableTypeV1 = \"table_type_v1\",\n  /** column name */\n  TokenDataId = \"token_data_id\",\n  /** column name */\n  TokenPropertiesMutatedV1 = \"token_properties_mutated_v1\",\n  /** column name */\n  TokenStandard = \"token_standard\",\n  /** column name */\n  TransactionTimestamp = \"transaction_timestamp\",\n  /** column name */\n  TransactionVersion = \"transaction_version\",\n  /** column name */\n  WriteSetChangeIndex = \"write_set_change_index\",\n}\n\nexport type TokenOwnershipsV2Updates = {\n  /** append existing jsonb value of filtered columns with new jsonb value */\n  _append?: InputMaybe<TokenOwnershipsV2AppendInput>;\n  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */\n  _delete_at_path?: InputMaybe<TokenOwnershipsV2DeleteAtPathInput>;\n  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */\n  _delete_elem?: InputMaybe<TokenOwnershipsV2DeleteElemInput>;\n  /** delete key/value pair or string element. key/value pairs are matched based on their key value */\n  _delete_key?: InputMaybe<TokenOwnershipsV2DeleteKeyInput>;\n  /** increments the numeric columns with given value of the filtered values */\n  _inc?: InputMaybe<TokenOwnershipsV2IncInput>;\n  /** prepend existing jsonb value of filtered columns with new jsonb value */\n  _prepend?: InputMaybe<TokenOwnershipsV2PrependInput>;\n  /** sets the columns of the filtered rows to the given values */\n  _set?: InputMaybe<TokenOwnershipsV2SetInput>;\n  /** filter the rows which have to be updated */\n  where: TokenOwnershipsV2BoolExp;\n};\n\n/** aggregate var_pop on columns */\nexport type TokenOwnershipsV2VarPopFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  property_version_v1?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate var_samp on columns */\nexport type TokenOwnershipsV2VarSampFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  property_version_v1?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate variance on columns */\nexport type TokenOwnershipsV2VarianceFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  property_version_v1?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  write_set_change_index?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate var_pop on columns */\nexport type TokenOwnershipsVarPopFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  property_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate var_samp on columns */\nexport type TokenOwnershipsVarSampFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  property_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate variance on columns */\nexport type TokenOwnershipsVarianceFields = {\n  amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  property_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** columns and relationships of \"tokens\" */\nexport type Tokens = {\n  collection_data_id_hash: Scalars[\"String\"][\"output\"];\n  collection_name: Scalars[\"String\"][\"output\"];\n  creator_address: Scalars[\"String\"][\"output\"];\n  inserted_at: Scalars[\"timestamp\"][\"output\"];\n  name: Scalars[\"String\"][\"output\"];\n  property_version: Scalars[\"numeric\"][\"output\"];\n  token_data_id_hash: Scalars[\"String\"][\"output\"];\n  token_properties: Scalars[\"jsonb\"][\"output\"];\n  transaction_timestamp: Scalars[\"timestamp\"][\"output\"];\n  transaction_version: Scalars[\"bigint\"][\"output\"];\n};\n\n/** columns and relationships of \"tokens\" */\nexport type TokensTokenPropertiesArgs = {\n  path?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregated selection of \"tokens\" */\nexport type TokensAggregate = {\n  aggregate?: Maybe<TokensAggregateFields>;\n  nodes: Array<Tokens>;\n};\n\n/** aggregate fields of \"tokens\" */\nexport type TokensAggregateFields = {\n  avg?: Maybe<TokensAvgFields>;\n  count: Scalars[\"Int\"][\"output\"];\n  max?: Maybe<TokensMaxFields>;\n  min?: Maybe<TokensMinFields>;\n  stddev?: Maybe<TokensStddevFields>;\n  stddev_pop?: Maybe<TokensStddevPopFields>;\n  stddev_samp?: Maybe<TokensStddevSampFields>;\n  sum?: Maybe<TokensSumFields>;\n  var_pop?: Maybe<TokensVarPopFields>;\n  var_samp?: Maybe<TokensVarSampFields>;\n  variance?: Maybe<TokensVarianceFields>;\n};\n\n/** aggregate fields of \"tokens\" */\nexport type TokensAggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<TokensSelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** append existing jsonb value of filtered columns with new jsonb value */\nexport type TokensAppendInput = {\n  token_properties?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n};\n\n/** aggregate avg on columns */\nexport type TokensAvgFields = {\n  property_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Boolean expression to filter rows from the table \"tokens\". All fields are combined with a logical 'AND'. */\nexport type TokensBoolExp = {\n  _and?: InputMaybe<Array<TokensBoolExp>>;\n  _not?: InputMaybe<TokensBoolExp>;\n  _or?: InputMaybe<Array<TokensBoolExp>>;\n  collection_data_id_hash?: InputMaybe<StringComparisonExp>;\n  collection_name?: InputMaybe<StringComparisonExp>;\n  creator_address?: InputMaybe<StringComparisonExp>;\n  inserted_at?: InputMaybe<TimestampComparisonExp>;\n  name?: InputMaybe<StringComparisonExp>;\n  property_version?: InputMaybe<NumericComparisonExp>;\n  token_data_id_hash?: InputMaybe<StringComparisonExp>;\n  token_properties?: InputMaybe<JsonbComparisonExp>;\n  transaction_timestamp?: InputMaybe<TimestampComparisonExp>;\n  transaction_version?: InputMaybe<BigintComparisonExp>;\n};\n\n/** unique or primary key constraints on table \"tokens\" */\nexport enum TokensConstraint {\n  /** unique or primary key constraint on columns \"property_version\", \"token_data_id_hash\", \"transaction_version\" */\n  TokensPkey = \"tokens_pkey\",\n}\n\n/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */\nexport type TokensDeleteAtPathInput = {\n  token_properties?: InputMaybe<Array<Scalars[\"String\"][\"input\"]>>;\n};\n\n/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */\nexport type TokensDeleteElemInput = {\n  token_properties?: InputMaybe<Scalars[\"Int\"][\"input\"]>;\n};\n\n/** delete key/value pair or string element. key/value pairs are matched based on their key value */\nexport type TokensDeleteKeyInput = {\n  token_properties?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** input type for incrementing numeric columns in table \"tokens\" */\nexport type TokensIncInput = {\n  property_version?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** input type for inserting data into table \"tokens\" */\nexport type TokensInsertInput = {\n  collection_data_id_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  collection_name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  creator_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  property_version?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  token_data_id_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_properties?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** aggregate max on columns */\nexport type TokensMaxFields = {\n  collection_data_id_hash?: Maybe<Scalars[\"String\"][\"output\"]>;\n  collection_name?: Maybe<Scalars[\"String\"][\"output\"]>;\n  creator_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  name?: Maybe<Scalars[\"String\"][\"output\"]>;\n  property_version?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  token_data_id_hash?: Maybe<Scalars[\"String\"][\"output\"]>;\n  transaction_timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** aggregate min on columns */\nexport type TokensMinFields = {\n  collection_data_id_hash?: Maybe<Scalars[\"String\"][\"output\"]>;\n  collection_name?: Maybe<Scalars[\"String\"][\"output\"]>;\n  creator_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  name?: Maybe<Scalars[\"String\"][\"output\"]>;\n  property_version?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  token_data_id_hash?: Maybe<Scalars[\"String\"][\"output\"]>;\n  transaction_timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** response of any mutation on the table \"tokens\" */\nexport type TokensMutationResponse = {\n  /** number of rows affected by the mutation */\n  affected_rows: Scalars[\"Int\"][\"output\"];\n  /** data from the rows affected by the mutation */\n  returning: Array<Tokens>;\n};\n\n/** on_conflict condition type for table \"tokens\" */\nexport type TokensOnConflict = {\n  constraint: TokensConstraint;\n  update_columns?: Array<TokensUpdateColumn>;\n  where?: InputMaybe<TokensBoolExp>;\n};\n\n/** Ordering options when selecting data from \"tokens\". */\nexport type TokensOrderBy = {\n  collection_data_id_hash?: InputMaybe<OrderBy>;\n  collection_name?: InputMaybe<OrderBy>;\n  creator_address?: InputMaybe<OrderBy>;\n  inserted_at?: InputMaybe<OrderBy>;\n  name?: InputMaybe<OrderBy>;\n  property_version?: InputMaybe<OrderBy>;\n  token_data_id_hash?: InputMaybe<OrderBy>;\n  token_properties?: InputMaybe<OrderBy>;\n  transaction_timestamp?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n};\n\n/** primary key columns input for table: tokens */\nexport type TokensPkColumnsInput = {\n  property_version: Scalars[\"numeric\"][\"input\"];\n  token_data_id_hash: Scalars[\"String\"][\"input\"];\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\n/** prepend existing jsonb value of filtered columns with new jsonb value */\nexport type TokensPrependInput = {\n  token_properties?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n};\n\n/** select columns of table \"tokens\" */\nexport enum TokensSelectColumn {\n  /** column name */\n  CollectionDataIdHash = \"collection_data_id_hash\",\n  /** column name */\n  CollectionName = \"collection_name\",\n  /** column name */\n  CreatorAddress = \"creator_address\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  Name = \"name\",\n  /** column name */\n  PropertyVersion = \"property_version\",\n  /** column name */\n  TokenDataIdHash = \"token_data_id_hash\",\n  /** column name */\n  TokenProperties = \"token_properties\",\n  /** column name */\n  TransactionTimestamp = \"transaction_timestamp\",\n  /** column name */\n  TransactionVersion = \"transaction_version\",\n}\n\n/** input type for updating data in table \"tokens\" */\nexport type TokensSetInput = {\n  collection_data_id_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  collection_name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  creator_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  property_version?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  token_data_id_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_properties?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** aggregate stddev on columns */\nexport type TokensStddevFields = {\n  property_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_pop on columns */\nexport type TokensStddevPopFields = {\n  property_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_samp on columns */\nexport type TokensStddevSampFields = {\n  property_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Streaming cursor of the table \"tokens\" */\nexport type TokensStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: TokensStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type TokensStreamCursorValueInput = {\n  collection_data_id_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  collection_name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  creator_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  property_version?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  token_data_id_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  token_properties?: InputMaybe<Scalars[\"jsonb\"][\"input\"]>;\n  transaction_timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** aggregate sum on columns */\nexport type TokensSumFields = {\n  property_version?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** update columns of table \"tokens\" */\nexport enum TokensUpdateColumn {\n  /** column name */\n  CollectionDataIdHash = \"collection_data_id_hash\",\n  /** column name */\n  CollectionName = \"collection_name\",\n  /** column name */\n  CreatorAddress = \"creator_address\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  Name = \"name\",\n  /** column name */\n  PropertyVersion = \"property_version\",\n  /** column name */\n  TokenDataIdHash = \"token_data_id_hash\",\n  /** column name */\n  TokenProperties = \"token_properties\",\n  /** column name */\n  TransactionTimestamp = \"transaction_timestamp\",\n  /** column name */\n  TransactionVersion = \"transaction_version\",\n}\n\nexport type TokensUpdates = {\n  /** append existing jsonb value of filtered columns with new jsonb value */\n  _append?: InputMaybe<TokensAppendInput>;\n  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */\n  _delete_at_path?: InputMaybe<TokensDeleteAtPathInput>;\n  /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */\n  _delete_elem?: InputMaybe<TokensDeleteElemInput>;\n  /** delete key/value pair or string element. key/value pairs are matched based on their key value */\n  _delete_key?: InputMaybe<TokensDeleteKeyInput>;\n  /** increments the numeric columns with given value of the filtered values */\n  _inc?: InputMaybe<TokensIncInput>;\n  /** prepend existing jsonb value of filtered columns with new jsonb value */\n  _prepend?: InputMaybe<TokensPrependInput>;\n  /** sets the columns of the filtered rows to the given values */\n  _set?: InputMaybe<TokensSetInput>;\n  /** filter the rows which have to be updated */\n  where: TokensBoolExp;\n};\n\n/** aggregate var_pop on columns */\nexport type TokensVarPopFields = {\n  property_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate var_samp on columns */\nexport type TokensVarSampFields = {\n  property_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate variance on columns */\nexport type TokensVarianceFields = {\n  property_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** columns and relationships of \"transaction_size_info\" */\nexport type TransactionSizeInfo = {\n  inserted_at: Scalars[\"timestamp\"][\"output\"];\n  size_bytes: Scalars[\"bigint\"][\"output\"];\n  transaction_version: Scalars[\"bigint\"][\"output\"];\n};\n\n/** aggregated selection of \"transaction_size_info\" */\nexport type TransactionSizeInfoAggregate = {\n  aggregate?: Maybe<TransactionSizeInfoAggregateFields>;\n  nodes: Array<TransactionSizeInfo>;\n};\n\n/** aggregate fields of \"transaction_size_info\" */\nexport type TransactionSizeInfoAggregateFields = {\n  avg?: Maybe<TransactionSizeInfoAvgFields>;\n  count: Scalars[\"Int\"][\"output\"];\n  max?: Maybe<TransactionSizeInfoMaxFields>;\n  min?: Maybe<TransactionSizeInfoMinFields>;\n  stddev?: Maybe<TransactionSizeInfoStddevFields>;\n  stddev_pop?: Maybe<TransactionSizeInfoStddevPopFields>;\n  stddev_samp?: Maybe<TransactionSizeInfoStddevSampFields>;\n  sum?: Maybe<TransactionSizeInfoSumFields>;\n  var_pop?: Maybe<TransactionSizeInfoVarPopFields>;\n  var_samp?: Maybe<TransactionSizeInfoVarSampFields>;\n  variance?: Maybe<TransactionSizeInfoVarianceFields>;\n};\n\n/** aggregate fields of \"transaction_size_info\" */\nexport type TransactionSizeInfoAggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<TransactionSizeInfoSelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** aggregate avg on columns */\nexport type TransactionSizeInfoAvgFields = {\n  size_bytes?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Boolean expression to filter rows from the table \"transaction_size_info\". All fields are combined with a logical 'AND'. */\nexport type TransactionSizeInfoBoolExp = {\n  _and?: InputMaybe<Array<TransactionSizeInfoBoolExp>>;\n  _not?: InputMaybe<TransactionSizeInfoBoolExp>;\n  _or?: InputMaybe<Array<TransactionSizeInfoBoolExp>>;\n  inserted_at?: InputMaybe<TimestampComparisonExp>;\n  size_bytes?: InputMaybe<BigintComparisonExp>;\n  transaction_version?: InputMaybe<BigintComparisonExp>;\n};\n\n/** unique or primary key constraints on table \"transaction_size_info\" */\nexport enum TransactionSizeInfoConstraint {\n  /** unique or primary key constraint on columns \"transaction_version\" */\n  TransactionSizeInfoPkey = \"transaction_size_info_pkey\",\n}\n\n/** input type for incrementing numeric columns in table \"transaction_size_info\" */\nexport type TransactionSizeInfoIncInput = {\n  size_bytes?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** input type for inserting data into table \"transaction_size_info\" */\nexport type TransactionSizeInfoInsertInput = {\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  size_bytes?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** aggregate max on columns */\nexport type TransactionSizeInfoMaxFields = {\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  size_bytes?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** aggregate min on columns */\nexport type TransactionSizeInfoMinFields = {\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  size_bytes?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** response of any mutation on the table \"transaction_size_info\" */\nexport type TransactionSizeInfoMutationResponse = {\n  /** number of rows affected by the mutation */\n  affected_rows: Scalars[\"Int\"][\"output\"];\n  /** data from the rows affected by the mutation */\n  returning: Array<TransactionSizeInfo>;\n};\n\n/** on_conflict condition type for table \"transaction_size_info\" */\nexport type TransactionSizeInfoOnConflict = {\n  constraint: TransactionSizeInfoConstraint;\n  update_columns?: Array<TransactionSizeInfoUpdateColumn>;\n  where?: InputMaybe<TransactionSizeInfoBoolExp>;\n};\n\n/** Ordering options when selecting data from \"transaction_size_info\". */\nexport type TransactionSizeInfoOrderBy = {\n  inserted_at?: InputMaybe<OrderBy>;\n  size_bytes?: InputMaybe<OrderBy>;\n  transaction_version?: InputMaybe<OrderBy>;\n};\n\n/** primary key columns input for table: transaction_size_info */\nexport type TransactionSizeInfoPkColumnsInput = {\n  transaction_version: Scalars[\"bigint\"][\"input\"];\n};\n\n/** select columns of table \"transaction_size_info\" */\nexport enum TransactionSizeInfoSelectColumn {\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  SizeBytes = \"size_bytes\",\n  /** column name */\n  TransactionVersion = \"transaction_version\",\n}\n\n/** input type for updating data in table \"transaction_size_info\" */\nexport type TransactionSizeInfoSetInput = {\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  size_bytes?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** aggregate stddev on columns */\nexport type TransactionSizeInfoStddevFields = {\n  size_bytes?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_pop on columns */\nexport type TransactionSizeInfoStddevPopFields = {\n  size_bytes?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_samp on columns */\nexport type TransactionSizeInfoStddevSampFields = {\n  size_bytes?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Streaming cursor of the table \"transaction_size_info\" */\nexport type TransactionSizeInfoStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: TransactionSizeInfoStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type TransactionSizeInfoStreamCursorValueInput = {\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  size_bytes?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  transaction_version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** aggregate sum on columns */\nexport type TransactionSizeInfoSumFields = {\n  size_bytes?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** update columns of table \"transaction_size_info\" */\nexport enum TransactionSizeInfoUpdateColumn {\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  SizeBytes = \"size_bytes\",\n  /** column name */\n  TransactionVersion = \"transaction_version\",\n}\n\nexport type TransactionSizeInfoUpdates = {\n  /** increments the numeric columns with given value of the filtered values */\n  _inc?: InputMaybe<TransactionSizeInfoIncInput>;\n  /** sets the columns of the filtered rows to the given values */\n  _set?: InputMaybe<TransactionSizeInfoSetInput>;\n  /** filter the rows which have to be updated */\n  where: TransactionSizeInfoBoolExp;\n};\n\n/** aggregate var_pop on columns */\nexport type TransactionSizeInfoVarPopFields = {\n  size_bytes?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate var_samp on columns */\nexport type TransactionSizeInfoVarSampFields = {\n  size_bytes?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate variance on columns */\nexport type TransactionSizeInfoVarianceFields = {\n  size_bytes?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  transaction_version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** columns and relationships of \"transactions_view\" */\nexport type TransactionsView = {\n  accumulator_root_hash?: Maybe<Scalars[\"String\"][\"output\"]>;\n  block_height?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  event_root_hash?: Maybe<Scalars[\"String\"][\"output\"]>;\n  gas_used?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  hash?: Maybe<Scalars[\"String\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  json_payload?: Maybe<Scalars[\"String\"][\"output\"]>;\n  num_events?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  num_write_set_changes?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  state_change_hash?: Maybe<Scalars[\"String\"][\"output\"]>;\n  state_checkpoint_hash?: Maybe<Scalars[\"String\"][\"output\"]>;\n  success?: Maybe<Scalars[\"Boolean\"][\"output\"]>;\n  type?: Maybe<Scalars[\"String\"][\"output\"]>;\n  version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  vm_status?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** aggregated selection of \"transactions_view\" */\nexport type TransactionsViewAggregate = {\n  aggregate?: Maybe<TransactionsViewAggregateFields>;\n  nodes: Array<TransactionsView>;\n};\n\n/** aggregate fields of \"transactions_view\" */\nexport type TransactionsViewAggregateFields = {\n  avg?: Maybe<TransactionsViewAvgFields>;\n  count: Scalars[\"Int\"][\"output\"];\n  max?: Maybe<TransactionsViewMaxFields>;\n  min?: Maybe<TransactionsViewMinFields>;\n  stddev?: Maybe<TransactionsViewStddevFields>;\n  stddev_pop?: Maybe<TransactionsViewStddevPopFields>;\n  stddev_samp?: Maybe<TransactionsViewStddevSampFields>;\n  sum?: Maybe<TransactionsViewSumFields>;\n  var_pop?: Maybe<TransactionsViewVarPopFields>;\n  var_samp?: Maybe<TransactionsViewVarSampFields>;\n  variance?: Maybe<TransactionsViewVarianceFields>;\n};\n\n/** aggregate fields of \"transactions_view\" */\nexport type TransactionsViewAggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<TransactionsViewSelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** aggregate avg on columns */\nexport type TransactionsViewAvgFields = {\n  block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  gas_used?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  num_events?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  num_write_set_changes?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Boolean expression to filter rows from the table \"transactions_view\". All fields are combined with a logical 'AND'. */\nexport type TransactionsViewBoolExp = {\n  _and?: InputMaybe<Array<TransactionsViewBoolExp>>;\n  _not?: InputMaybe<TransactionsViewBoolExp>;\n  _or?: InputMaybe<Array<TransactionsViewBoolExp>>;\n  accumulator_root_hash?: InputMaybe<StringComparisonExp>;\n  block_height?: InputMaybe<BigintComparisonExp>;\n  event_root_hash?: InputMaybe<StringComparisonExp>;\n  gas_used?: InputMaybe<NumericComparisonExp>;\n  hash?: InputMaybe<StringComparisonExp>;\n  inserted_at?: InputMaybe<TimestampComparisonExp>;\n  json_payload?: InputMaybe<StringComparisonExp>;\n  num_events?: InputMaybe<BigintComparisonExp>;\n  num_write_set_changes?: InputMaybe<BigintComparisonExp>;\n  state_change_hash?: InputMaybe<StringComparisonExp>;\n  state_checkpoint_hash?: InputMaybe<StringComparisonExp>;\n  success?: InputMaybe<BooleanComparisonExp>;\n  type?: InputMaybe<StringComparisonExp>;\n  version?: InputMaybe<BigintComparisonExp>;\n  vm_status?: InputMaybe<StringComparisonExp>;\n};\n\n/** input type for incrementing numeric columns in table \"transactions_view\" */\nexport type TransactionsViewIncInput = {\n  block_height?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  gas_used?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  num_events?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  num_write_set_changes?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** input type for inserting data into table \"transactions_view\" */\nexport type TransactionsViewInsertInput = {\n  accumulator_root_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  block_height?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  event_root_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  gas_used?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  json_payload?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  num_events?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  num_write_set_changes?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  state_change_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  state_checkpoint_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  success?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  vm_status?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate max on columns */\nexport type TransactionsViewMaxFields = {\n  accumulator_root_hash?: Maybe<Scalars[\"String\"][\"output\"]>;\n  block_height?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  event_root_hash?: Maybe<Scalars[\"String\"][\"output\"]>;\n  gas_used?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  hash?: Maybe<Scalars[\"String\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  json_payload?: Maybe<Scalars[\"String\"][\"output\"]>;\n  num_events?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  num_write_set_changes?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  state_change_hash?: Maybe<Scalars[\"String\"][\"output\"]>;\n  state_checkpoint_hash?: Maybe<Scalars[\"String\"][\"output\"]>;\n  type?: Maybe<Scalars[\"String\"][\"output\"]>;\n  version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  vm_status?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** aggregate min on columns */\nexport type TransactionsViewMinFields = {\n  accumulator_root_hash?: Maybe<Scalars[\"String\"][\"output\"]>;\n  block_height?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  event_root_hash?: Maybe<Scalars[\"String\"][\"output\"]>;\n  gas_used?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  hash?: Maybe<Scalars[\"String\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  json_payload?: Maybe<Scalars[\"String\"][\"output\"]>;\n  num_events?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  num_write_set_changes?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  state_change_hash?: Maybe<Scalars[\"String\"][\"output\"]>;\n  state_checkpoint_hash?: Maybe<Scalars[\"String\"][\"output\"]>;\n  type?: Maybe<Scalars[\"String\"][\"output\"]>;\n  version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  vm_status?: Maybe<Scalars[\"String\"][\"output\"]>;\n};\n\n/** response of any mutation on the table \"transactions_view\" */\nexport type TransactionsViewMutationResponse = {\n  /** number of rows affected by the mutation */\n  affected_rows: Scalars[\"Int\"][\"output\"];\n  /** data from the rows affected by the mutation */\n  returning: Array<TransactionsView>;\n};\n\n/** Ordering options when selecting data from \"transactions_view\". */\nexport type TransactionsViewOrderBy = {\n  accumulator_root_hash?: InputMaybe<OrderBy>;\n  block_height?: InputMaybe<OrderBy>;\n  event_root_hash?: InputMaybe<OrderBy>;\n  gas_used?: InputMaybe<OrderBy>;\n  hash?: InputMaybe<OrderBy>;\n  inserted_at?: InputMaybe<OrderBy>;\n  json_payload?: InputMaybe<OrderBy>;\n  num_events?: InputMaybe<OrderBy>;\n  num_write_set_changes?: InputMaybe<OrderBy>;\n  state_change_hash?: InputMaybe<OrderBy>;\n  state_checkpoint_hash?: InputMaybe<OrderBy>;\n  success?: InputMaybe<OrderBy>;\n  type?: InputMaybe<OrderBy>;\n  version?: InputMaybe<OrderBy>;\n  vm_status?: InputMaybe<OrderBy>;\n};\n\n/** select columns of table \"transactions_view\" */\nexport enum TransactionsViewSelectColumn {\n  /** column name */\n  AccumulatorRootHash = \"accumulator_root_hash\",\n  /** column name */\n  BlockHeight = \"block_height\",\n  /** column name */\n  EventRootHash = \"event_root_hash\",\n  /** column name */\n  GasUsed = \"gas_used\",\n  /** column name */\n  Hash = \"hash\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  JsonPayload = \"json_payload\",\n  /** column name */\n  NumEvents = \"num_events\",\n  /** column name */\n  NumWriteSetChanges = \"num_write_set_changes\",\n  /** column name */\n  StateChangeHash = \"state_change_hash\",\n  /** column name */\n  StateCheckpointHash = \"state_checkpoint_hash\",\n  /** column name */\n  Success = \"success\",\n  /** column name */\n  Type = \"type\",\n  /** column name */\n  Version = \"version\",\n  /** column name */\n  VmStatus = \"vm_status\",\n}\n\n/** input type for updating data in table \"transactions_view\" */\nexport type TransactionsViewSetInput = {\n  accumulator_root_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  block_height?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  event_root_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  gas_used?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  json_payload?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  num_events?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  num_write_set_changes?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  state_change_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  state_checkpoint_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  success?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  vm_status?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate stddev on columns */\nexport type TransactionsViewStddevFields = {\n  block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  gas_used?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  num_events?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  num_write_set_changes?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_pop on columns */\nexport type TransactionsViewStddevPopFields = {\n  block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  gas_used?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  num_events?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  num_write_set_changes?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_samp on columns */\nexport type TransactionsViewStddevSampFields = {\n  block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  gas_used?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  num_events?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  num_write_set_changes?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Streaming cursor of the table \"transactions_view\" */\nexport type TransactionsViewStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: TransactionsViewStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type TransactionsViewStreamCursorValueInput = {\n  accumulator_root_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  block_height?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  event_root_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  gas_used?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  json_payload?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  num_events?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  num_write_set_changes?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  state_change_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  state_checkpoint_hash?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  success?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n  type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  vm_status?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n};\n\n/** aggregate sum on columns */\nexport type TransactionsViewSumFields = {\n  block_height?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  gas_used?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  num_events?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  num_write_set_changes?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\nexport type TransactionsViewUpdates = {\n  /** increments the numeric columns with given value of the filtered values */\n  _inc?: InputMaybe<TransactionsViewIncInput>;\n  /** sets the columns of the filtered rows to the given values */\n  _set?: InputMaybe<TransactionsViewSetInput>;\n  /** filter the rows which have to be updated */\n  where: TransactionsViewBoolExp;\n};\n\n/** aggregate var_pop on columns */\nexport type TransactionsViewVarPopFields = {\n  block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  gas_used?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  num_events?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  num_write_set_changes?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate var_samp on columns */\nexport type TransactionsViewVarSampFields = {\n  block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  gas_used?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  num_events?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  num_write_set_changes?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate variance on columns */\nexport type TransactionsViewVarianceFields = {\n  block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  gas_used?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  num_events?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  num_write_set_changes?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** columns and relationships of \"user_transactions\" */\nexport type UserTransactions = {\n  block_height: Scalars[\"bigint\"][\"output\"];\n  entry_function_contract_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  entry_function_function_name?: Maybe<Scalars[\"String\"][\"output\"]>;\n  entry_function_id_str: Scalars[\"String\"][\"output\"];\n  entry_function_module_name?: Maybe<Scalars[\"String\"][\"output\"]>;\n  epoch: Scalars[\"bigint\"][\"output\"];\n  expiration_timestamp_secs: Scalars[\"timestamp\"][\"output\"];\n  gas_unit_price: Scalars[\"numeric\"][\"output\"];\n  inserted_at: Scalars[\"timestamp\"][\"output\"];\n  max_gas_amount: Scalars[\"numeric\"][\"output\"];\n  parent_signature_type: Scalars[\"String\"][\"output\"];\n  sender: Scalars[\"String\"][\"output\"];\n  sequence_number: Scalars[\"bigint\"][\"output\"];\n  timestamp: Scalars[\"timestamp\"][\"output\"];\n  version: Scalars[\"bigint\"][\"output\"];\n};\n\n/** aggregated selection of \"user_transactions\" */\nexport type UserTransactionsAggregate = {\n  aggregate?: Maybe<UserTransactionsAggregateFields>;\n  nodes: Array<UserTransactions>;\n};\n\n/** aggregate fields of \"user_transactions\" */\nexport type UserTransactionsAggregateFields = {\n  avg?: Maybe<UserTransactionsAvgFields>;\n  count: Scalars[\"Int\"][\"output\"];\n  max?: Maybe<UserTransactionsMaxFields>;\n  min?: Maybe<UserTransactionsMinFields>;\n  stddev?: Maybe<UserTransactionsStddevFields>;\n  stddev_pop?: Maybe<UserTransactionsStddevPopFields>;\n  stddev_samp?: Maybe<UserTransactionsStddevSampFields>;\n  sum?: Maybe<UserTransactionsSumFields>;\n  var_pop?: Maybe<UserTransactionsVarPopFields>;\n  var_samp?: Maybe<UserTransactionsVarSampFields>;\n  variance?: Maybe<UserTransactionsVarianceFields>;\n};\n\n/** aggregate fields of \"user_transactions\" */\nexport type UserTransactionsAggregateFieldsCountArgs = {\n  columns?: InputMaybe<Array<UserTransactionsSelectColumn>>;\n  distinct?: InputMaybe<Scalars[\"Boolean\"][\"input\"]>;\n};\n\n/** aggregate avg on columns */\nexport type UserTransactionsAvgFields = {\n  block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  epoch?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  gas_unit_price?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  max_gas_amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  sequence_number?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Boolean expression to filter rows from the table \"user_transactions\". All fields are combined with a logical 'AND'. */\nexport type UserTransactionsBoolExp = {\n  _and?: InputMaybe<Array<UserTransactionsBoolExp>>;\n  _not?: InputMaybe<UserTransactionsBoolExp>;\n  _or?: InputMaybe<Array<UserTransactionsBoolExp>>;\n  block_height?: InputMaybe<BigintComparisonExp>;\n  entry_function_contract_address?: InputMaybe<StringComparisonExp>;\n  entry_function_function_name?: InputMaybe<StringComparisonExp>;\n  entry_function_id_str?: InputMaybe<StringComparisonExp>;\n  entry_function_module_name?: InputMaybe<StringComparisonExp>;\n  epoch?: InputMaybe<BigintComparisonExp>;\n  expiration_timestamp_secs?: InputMaybe<TimestampComparisonExp>;\n  gas_unit_price?: InputMaybe<NumericComparisonExp>;\n  inserted_at?: InputMaybe<TimestampComparisonExp>;\n  max_gas_amount?: InputMaybe<NumericComparisonExp>;\n  parent_signature_type?: InputMaybe<StringComparisonExp>;\n  sender?: InputMaybe<StringComparisonExp>;\n  sequence_number?: InputMaybe<BigintComparisonExp>;\n  timestamp?: InputMaybe<TimestampComparisonExp>;\n  version?: InputMaybe<BigintComparisonExp>;\n};\n\n/** unique or primary key constraints on table \"user_transactions\" */\nexport enum UserTransactionsConstraint {\n  /** unique or primary key constraint on columns \"version\" */\n  UserTransactionsPkey = \"user_transactions_pkey\",\n  /** unique or primary key constraint on columns \"sender\", \"sequence_number\" */\n  UserTransactionsSenderSequenceNumberKey = \"user_transactions_sender_sequence_number_key\",\n}\n\n/** input type for incrementing numeric columns in table \"user_transactions\" */\nexport type UserTransactionsIncInput = {\n  block_height?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  epoch?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  gas_unit_price?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  max_gas_amount?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  sequence_number?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** input type for inserting data into table \"user_transactions\" */\nexport type UserTransactionsInsertInput = {\n  block_height?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  entry_function_contract_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  entry_function_function_name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  entry_function_id_str?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  entry_function_module_name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  epoch?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  expiration_timestamp_secs?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  gas_unit_price?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  max_gas_amount?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  parent_signature_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  sender?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  sequence_number?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** aggregate max on columns */\nexport type UserTransactionsMaxFields = {\n  block_height?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  entry_function_contract_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  entry_function_function_name?: Maybe<Scalars[\"String\"][\"output\"]>;\n  entry_function_id_str?: Maybe<Scalars[\"String\"][\"output\"]>;\n  entry_function_module_name?: Maybe<Scalars[\"String\"][\"output\"]>;\n  epoch?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  expiration_timestamp_secs?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  gas_unit_price?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  max_gas_amount?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  parent_signature_type?: Maybe<Scalars[\"String\"][\"output\"]>;\n  sender?: Maybe<Scalars[\"String\"][\"output\"]>;\n  sequence_number?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** aggregate min on columns */\nexport type UserTransactionsMinFields = {\n  block_height?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  entry_function_contract_address?: Maybe<Scalars[\"String\"][\"output\"]>;\n  entry_function_function_name?: Maybe<Scalars[\"String\"][\"output\"]>;\n  entry_function_id_str?: Maybe<Scalars[\"String\"][\"output\"]>;\n  entry_function_module_name?: Maybe<Scalars[\"String\"][\"output\"]>;\n  epoch?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  expiration_timestamp_secs?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  gas_unit_price?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  inserted_at?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  max_gas_amount?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  parent_signature_type?: Maybe<Scalars[\"String\"][\"output\"]>;\n  sender?: Maybe<Scalars[\"String\"][\"output\"]>;\n  sequence_number?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  timestamp?: Maybe<Scalars[\"timestamp\"][\"output\"]>;\n  version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** response of any mutation on the table \"user_transactions\" */\nexport type UserTransactionsMutationResponse = {\n  /** number of rows affected by the mutation */\n  affected_rows: Scalars[\"Int\"][\"output\"];\n  /** data from the rows affected by the mutation */\n  returning: Array<UserTransactions>;\n};\n\n/** input type for inserting object relation for remote table \"user_transactions\" */\nexport type UserTransactionsObjRelInsertInput = {\n  data: UserTransactionsInsertInput;\n  /** upsert condition */\n  on_conflict?: InputMaybe<UserTransactionsOnConflict>;\n};\n\n/** on_conflict condition type for table \"user_transactions\" */\nexport type UserTransactionsOnConflict = {\n  constraint: UserTransactionsConstraint;\n  update_columns?: Array<UserTransactionsUpdateColumn>;\n  where?: InputMaybe<UserTransactionsBoolExp>;\n};\n\n/** Ordering options when selecting data from \"user_transactions\". */\nexport type UserTransactionsOrderBy = {\n  block_height?: InputMaybe<OrderBy>;\n  entry_function_contract_address?: InputMaybe<OrderBy>;\n  entry_function_function_name?: InputMaybe<OrderBy>;\n  entry_function_id_str?: InputMaybe<OrderBy>;\n  entry_function_module_name?: InputMaybe<OrderBy>;\n  epoch?: InputMaybe<OrderBy>;\n  expiration_timestamp_secs?: InputMaybe<OrderBy>;\n  gas_unit_price?: InputMaybe<OrderBy>;\n  inserted_at?: InputMaybe<OrderBy>;\n  max_gas_amount?: InputMaybe<OrderBy>;\n  parent_signature_type?: InputMaybe<OrderBy>;\n  sender?: InputMaybe<OrderBy>;\n  sequence_number?: InputMaybe<OrderBy>;\n  timestamp?: InputMaybe<OrderBy>;\n  version?: InputMaybe<OrderBy>;\n};\n\n/** primary key columns input for table: user_transactions */\nexport type UserTransactionsPkColumnsInput = {\n  version: Scalars[\"bigint\"][\"input\"];\n};\n\n/** select columns of table \"user_transactions\" */\nexport enum UserTransactionsSelectColumn {\n  /** column name */\n  BlockHeight = \"block_height\",\n  /** column name */\n  EntryFunctionContractAddress = \"entry_function_contract_address\",\n  /** column name */\n  EntryFunctionFunctionName = \"entry_function_function_name\",\n  /** column name */\n  EntryFunctionIdStr = \"entry_function_id_str\",\n  /** column name */\n  EntryFunctionModuleName = \"entry_function_module_name\",\n  /** column name */\n  Epoch = \"epoch\",\n  /** column name */\n  ExpirationTimestampSecs = \"expiration_timestamp_secs\",\n  /** column name */\n  GasUnitPrice = \"gas_unit_price\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  MaxGasAmount = \"max_gas_amount\",\n  /** column name */\n  ParentSignatureType = \"parent_signature_type\",\n  /** column name */\n  Sender = \"sender\",\n  /** column name */\n  SequenceNumber = \"sequence_number\",\n  /** column name */\n  Timestamp = \"timestamp\",\n  /** column name */\n  Version = \"version\",\n}\n\n/** input type for updating data in table \"user_transactions\" */\nexport type UserTransactionsSetInput = {\n  block_height?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  entry_function_contract_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  entry_function_function_name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  entry_function_id_str?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  entry_function_module_name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  epoch?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  expiration_timestamp_secs?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  gas_unit_price?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  max_gas_amount?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  parent_signature_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  sender?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  sequence_number?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** aggregate stddev on columns */\nexport type UserTransactionsStddevFields = {\n  block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  epoch?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  gas_unit_price?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  max_gas_amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  sequence_number?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_pop on columns */\nexport type UserTransactionsStddevPopFields = {\n  block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  epoch?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  gas_unit_price?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  max_gas_amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  sequence_number?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate stddev_samp on columns */\nexport type UserTransactionsStddevSampFields = {\n  block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  epoch?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  gas_unit_price?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  max_gas_amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  sequence_number?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** Streaming cursor of the table \"user_transactions\" */\nexport type UserTransactionsStreamCursorInput = {\n  /** Stream column input with initial value */\n  initial_value: UserTransactionsStreamCursorValueInput;\n  /** cursor ordering */\n  ordering?: InputMaybe<CursorOrdering>;\n};\n\n/** Initial value of the column from where the streaming should start */\nexport type UserTransactionsStreamCursorValueInput = {\n  block_height?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  entry_function_contract_address?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  entry_function_function_name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  entry_function_id_str?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  entry_function_module_name?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  epoch?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  expiration_timestamp_secs?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  gas_unit_price?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  inserted_at?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  max_gas_amount?: InputMaybe<Scalars[\"numeric\"][\"input\"]>;\n  parent_signature_type?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  sender?: InputMaybe<Scalars[\"String\"][\"input\"]>;\n  sequence_number?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n  timestamp?: InputMaybe<Scalars[\"timestamp\"][\"input\"]>;\n  version?: InputMaybe<Scalars[\"bigint\"][\"input\"]>;\n};\n\n/** aggregate sum on columns */\nexport type UserTransactionsSumFields = {\n  block_height?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  epoch?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  gas_unit_price?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  max_gas_amount?: Maybe<Scalars[\"numeric\"][\"output\"]>;\n  sequence_number?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n  version?: Maybe<Scalars[\"bigint\"][\"output\"]>;\n};\n\n/** update columns of table \"user_transactions\" */\nexport enum UserTransactionsUpdateColumn {\n  /** column name */\n  BlockHeight = \"block_height\",\n  /** column name */\n  EntryFunctionContractAddress = \"entry_function_contract_address\",\n  /** column name */\n  EntryFunctionFunctionName = \"entry_function_function_name\",\n  /** column name */\n  EntryFunctionIdStr = \"entry_function_id_str\",\n  /** column name */\n  EntryFunctionModuleName = \"entry_function_module_name\",\n  /** column name */\n  Epoch = \"epoch\",\n  /** column name */\n  ExpirationTimestampSecs = \"expiration_timestamp_secs\",\n  /** column name */\n  GasUnitPrice = \"gas_unit_price\",\n  /** column name */\n  InsertedAt = \"inserted_at\",\n  /** column name */\n  MaxGasAmount = \"max_gas_amount\",\n  /** column name */\n  ParentSignatureType = \"parent_signature_type\",\n  /** column name */\n  Sender = \"sender\",\n  /** column name */\n  SequenceNumber = \"sequence_number\",\n  /** column name */\n  Timestamp = \"timestamp\",\n  /** column name */\n  Version = \"version\",\n}\n\nexport type UserTransactionsUpdates = {\n  /** increments the numeric columns with given value of the filtered values */\n  _inc?: InputMaybe<UserTransactionsIncInput>;\n  /** sets the columns of the filtered rows to the given values */\n  _set?: InputMaybe<UserTransactionsSetInput>;\n  /** filter the rows which have to be updated */\n  where: UserTransactionsBoolExp;\n};\n\n/** aggregate var_pop on columns */\nexport type UserTransactionsVarPopFields = {\n  block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  epoch?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  gas_unit_price?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  max_gas_amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  sequence_number?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate var_samp on columns */\nexport type UserTransactionsVarSampFields = {\n  block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  epoch?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  gas_unit_price?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  max_gas_amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  sequence_number?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n\n/** aggregate variance on columns */\nexport type UserTransactionsVarianceFields = {\n  block_height?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  epoch?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  gas_unit_price?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  max_gas_amount?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  sequence_number?: Maybe<Scalars[\"Float\"][\"output\"]>;\n  version?: Maybe<Scalars[\"Float\"][\"output\"]>;\n};\n"],"mappings":"iCA6MO,IAAKA,OAEVA,EAAA,wBAA0B,4BAFhBA,OAAA,IAoEAC,OAEVA,EAAA,eAAiB,kBAEjBA,EAAA,WAAa,cAEbA,EAAA,mBAAqB,sBANXA,OAAA,IAoDAC,OAEVA,EAAA,eAAiB,kBAEjBA,EAAA,WAAa,cAEbA,EAAA,mBAAqB,sBANXA,OAAA,IA6GAC,OAEVA,EAAA,eAAiB,kBAEjBA,EAAA,eAAiB,mBAEjBA,EAAA,oBAAsB,wBANZA,OAAA,IAsLAC,OAEVA,EAAA,eAAiB,kBAEjBA,EAAA,mBAAqB,sBAJXA,OAAA,IA0HAC,OAEVA,EAAA,QAAU,UAEVA,EAAA,mBAAqB,sBAJXA,OAAA,IAuHAC,OAEVA,EAAA,cAAgB,kBAFNA,OAAA,IAmFAC,OAEVA,EAAA,OAAS,SAETA,EAAA,oBAAsB,uBAEtBA,EAAA,WAAa,cAEbA,EAAA,UAAY,aAEZA,EAAA,kBAAoB,qBAEpBA,EAAA,UAAY,YAEZA,EAAA,UAAY,aAEZA,EAAA,mBAAqB,sBAErBA,EAAA,oBAAsB,yBAlBZA,OAAA,IAgFAC,OAEVA,EAAA,OAAS,SAETA,EAAA,oBAAsB,uBAEtBA,EAAA,WAAa,cAEbA,EAAA,UAAY,aAEZA,EAAA,kBAAoB,qBAEpBA,EAAA,UAAY,YAEZA,EAAA,UAAY,aAEZA,EAAA,mBAAqB,sBAErBA,EAAA,oBAAsB,yBAlBZA,OAAA,IAkGAC,OAEVA,EAAA,gBAAkB,qBAFRA,OAAA,IA4FAC,OAEVA,EAAA,OAAS,SAETA,EAAA,oBAAsB,uBAEtBA,EAAA,WAAa,cAEbA,EAAA,UAAY,aAEZA,EAAA,kBAAoB,qBAEpBA,EAAA,UAAY,YAEZA,EAAA,0BAA4B,8BAE5BA,EAAA,UAAY,aAEZA,EAAA,cAAgB,iBAEhBA,EAAA,mBAAqB,sBAErBA,EAAA,oBAAsB,yBAtBZA,OAAA,IA4FAC,OAEVA,EAAA,OAAS,SAETA,EAAA,oBAAsB,uBAEtBA,EAAA,WAAa,cAEbA,EAAA,UAAY,aAEZA,EAAA,kBAAoB,qBAEpBA,EAAA,UAAY,YAEZA,EAAA,0BAA4B,8BAE5BA,EAAA,UAAY,aAEZA,EAAA,cAAgB,iBAEhBA,EAAA,mBAAqB,sBAErBA,EAAA,oBAAsB,yBAtBZA,OAAA,IAsIAC,OAEVA,EAAA,mBAAqB,wBAFXA,OAAA,IA+EAC,OAEVA,EAAA,OAAS,SAETA,EAAA,WAAa,cAEbA,EAAA,UAAY,aAEZA,EAAA,kBAAoB,qBAEpBA,EAAA,UAAY,YAEZA,EAAA,UAAY,aAEZA,EAAA,mBAAqB,sBAErBA,EAAA,oBAAsB,yBAhBZA,OAAA,IA4EAC,OAEVA,EAAA,OAAS,SAETA,EAAA,WAAa,cAEbA,EAAA,UAAY,aAEZA,EAAA,kBAAoB,qBAEpBA,EAAA,UAAY,YAEZA,EAAA,UAAY,aAEZA,EAAA,mBAAqB,sBAErBA,EAAA,oBAAsB,yBAhBZA,OAAA,IA2FAC,OAEVA,EAAA,qBAAuB,2BAFbA,OAAA,IAmFAC,OAEVA,EAAA,OAAS,SAETA,EAAA,WAAa,cAEbA,EAAA,UAAY,aAEZA,EAAA,kBAAoB,qBAEpBA,EAAA,UAAY,YAEZA,EAAA,UAAY,aAEZA,EAAA,cAAgB,iBAEhBA,EAAA,mBAAqB,sBAErBA,EAAA,oBAAsB,yBAlBZA,OAAA,IAgFAC,OAEVA,EAAA,OAAS,SAETA,EAAA,WAAa,cAEbA,EAAA,UAAY,aAEZA,EAAA,kBAAoB,qBAEpBA,EAAA,UAAY,YAEZA,EAAA,UAAY,aAEZA,EAAA,cAAgB,iBAEhBA,EAAA,mBAAqB,sBAErBA,EAAA,oBAAsB,yBAlBZA,OAAA,IAsHAC,OAEVA,EAAA,4BAA8B,kCAFpBA,OAAA,IA6DAC,OAEVA,EAAA,eAAiB,kBAEjBA,EAAA,QAAU,WAEVA,EAAA,cAAgB,mBAEhBA,EAAA,uBAAyB,2BARfA,OAAA,IAwDAC,OAEVA,EAAA,eAAiB,kBAEjBA,EAAA,QAAU,WAEVA,EAAA,cAAgB,mBAEhBA,EAAA,uBAAyB,2BARfA,OAAA,IAmIAC,OAEVA,EAAA,wCAA0C,+CAE1CA,EAAA,8BAAgC,mCAJtBA,OAAA,IAgHAC,OAEVA,EAAA,YAAc,eAEdA,EAAA,MAAQ,QAERA,EAAA,sBAAwB,0BAExBA,EAAA,GAAK,KAELA,EAAA,WAAa,cAEbA,EAAA,yBAA2B,8BAE3BA,EAAA,SAAW,WAEXA,EAAA,MAAQ,QAERA,EAAA,UAAY,YAEZA,EAAA,QAAU,UApBAA,OAAA,IA4FAC,OAEVA,EAAA,YAAc,eAEdA,EAAA,MAAQ,QAERA,EAAA,sBAAwB,0BAExBA,EAAA,GAAK,KAELA,EAAA,WAAa,cAEbA,EAAA,yBAA2B,8BAE3BA,EAAA,SAAW,WAEXA,EAAA,MAAQ,QAERA,EAAA,UAAY,YAEZA,EAAA,QAAU,UApBAA,OAAA,IAmKAC,OAEVA,EAAA,mBAAqB,uBAFXA,OAAA,IAwHAC,OAEVA,EAAA,aAAe,gBAEfA,EAAA,OAAS,SAETA,EAAA,YAAc,eAEdA,EAAA,SAAW,YAEXA,EAAA,mBAAqB,wBAErBA,EAAA,oBAAsB,wBAEtBA,EAAA,oBAAsB,wBAEtBA,EAAA,WAAa,cAEbA,EAAA,oBAAsB,wBAEtBA,EAAA,mBAAqB,wBAErBA,EAAA,WAAa,cAEbA,EAAA,SAAW,aAEXA,EAAA,qBAAuB,yBAEvBA,EAAA,aAAe,gBAEfA,EAAA,oBAAsB,wBAEtBA,EAAA,qBAAuB,wBAEvBA,EAAA,mBAAqB,sBAlCXA,OAAA,IAoIAC,OAEVA,EAAA,aAAe,gBAEfA,EAAA,OAAS,SAETA,EAAA,YAAc,eAEdA,EAAA,SAAW,YAEXA,EAAA,mBAAqB,wBAErBA,EAAA,oBAAsB,wBAEtBA,EAAA,oBAAsB,wBAEtBA,EAAA,WAAa,cAEbA,EAAA,oBAAsB,wBAEtBA,EAAA,mBAAqB,wBAErBA,EAAA,WAAa,cAEbA,EAAA,SAAW,aAEXA,EAAA,qBAAuB,yBAEvBA,EAAA,aAAe,gBAEfA,EAAA,oBAAsB,wBAEtBA,EAAA,qBAAuB,wBAEvBA,EAAA,mBAAqB,sBAlCXA,OAAA,IA0IAC,OAEVA,EAAA,iBAAmB,qBAFTA,OAAA,IA8EAC,OAEVA,EAAA,OAAS,SAETA,EAAA,SAAW,YAEXA,EAAA,aAAe,iBAEfA,EAAA,WAAa,cAEbA,EAAA,aAAe,gBAEfA,EAAA,qBAAuB,wBAEvBA,EAAA,mBAAqB,sBAdXA,OAAA,IAwEAC,OAEVA,EAAA,OAAS,SAETA,EAAA,SAAW,YAEXA,EAAA,aAAe,iBAEfA,EAAA,WAAa,cAEbA,EAAA,aAAe,gBAEfA,EAAA,qBAAuB,wBAEvBA,EAAA,mBAAqB,sBAdXA,OAAA,IA+GAC,OAEVA,EAAA,cAAgB,kBAFNA,OAAA,IA4FAC,OAEVA,EAAA,SAAW,YAEXA,EAAA,aAAe,iBAEfA,EAAA,eAAiB,kBAEjBA,EAAA,SAAW,WAEXA,EAAA,WAAa,cAEbA,EAAA,KAAO,OAEPA,EAAA,4BAA8B,iCAE9BA,EAAA,yBAA2B,8BAE3BA,EAAA,OAAS,SAETA,EAAA,4BAA8B,gCAE9BA,EAAA,0BAA4B,8BAtBlBA,OAAA,IAwFAC,OAEVA,EAAA,SAAW,YAEXA,EAAA,aAAe,iBAEfA,EAAA,eAAiB,kBAEjBA,EAAA,SAAW,WAEXA,EAAA,WAAa,cAEbA,EAAA,KAAO,OAEPA,EAAA,4BAA8B,iCAE9BA,EAAA,yBAA2B,8BAE3BA,EAAA,OAAS,SAETA,EAAA,4BAA8B,gCAE9BA,EAAA,0BAA4B,8BAtBlBA,OAAA,IAgHAC,OAEVA,EAAA,eAAiB,mBAFPA,OAAA,IA8EAC,QAEVA,EAAA,SAAW,YAEXA,EAAA,aAAe,iBAEfA,EAAA,WAAa,cAEbA,EAAA,OAAS,SAETA,EAAA,iBAAmB,oBAEnBA,EAAA,qBAAuB,wBAEvBA,EAAA,mBAAqB,sBAdXA,QAAA,IA4EAC,QAEVA,EAAA,SAAW,YAEXA,EAAA,aAAe,iBAEfA,EAAA,WAAa,cAEbA,EAAA,OAAS,SAETA,EAAA,iBAAmB,oBAEnBA,EAAA,qBAAuB,wBAEvBA,EAAA,mBAAqB,sBAdXA,QAAA,IAyHAC,QAEVA,EAAA,oBAAsB,wBAFZA,QAAA,IAoGAC,QAEVA,EAAA,qBAAuB,0BAEvBA,EAAA,eAAiB,kBAEjBA,EAAA,eAAiB,kBAEjBA,EAAA,YAAc,cAEdA,EAAA,mBAAqB,sBAErBA,EAAA,WAAa,cAEbA,EAAA,QAAU,UAEVA,EAAA,eAAiB,kBAEjBA,EAAA,YAAc,eAEdA,EAAA,OAAS,SAETA,EAAA,YAAc,eAEdA,EAAA,qBAAuB,wBAEvBA,EAAA,mBAAqB,sBAErBA,EAAA,WAAa,cA5BHA,QAAA,IAwGAC,QAEVA,EAAA,qBAAuB,0BAEvBA,EAAA,eAAiB,kBAEjBA,EAAA,eAAiB,kBAEjBA,EAAA,YAAc,cAEdA,EAAA,mBAAqB,sBAErBA,EAAA,WAAa,cAEbA,EAAA,QAAU,UAEVA,EAAA,eAAiB,kBAEjBA,EAAA,YAAc,eAEdA,EAAA,OAAS,SAETA,EAAA,YAAc,eAEdA,EAAA,qBAAuB,wBAEvBA,EAAA,mBAAqB,sBAErBA,EAAA,WAAa,cA5BHA,QAAA,IAyJAC,QAEVA,EAAA,kBAAoB,sBAFVA,QAAA,IAsIAC,QAEVA,EAAA,aAAe,gBAEfA,EAAA,eAAiB,kBAEjBA,EAAA,qBAAuB,wBAEvBA,EAAA,eAAiB,kBAEjBA,EAAA,cAAgB,iBAEhBA,EAAA,YAAc,cAEdA,EAAA,WAAa,cAEbA,EAAA,UAAY,aAEZA,EAAA,mBAAqB,sBAErBA,EAAA,WAAa,cAEbA,EAAA,cAAgB,kBAEhBA,EAAA,cAAgB,iBAEhBA,EAAA,cAAgB,kBAEhBA,EAAA,qBAAuB,wBAEvBA,EAAA,mBAAqB,sBAErBA,EAAA,IAAM,MAENA,EAAA,oBAAsB,yBAlCZA,QAAA,IA4HAC,QAEVA,EAAA,aAAe,gBAEfA,EAAA,eAAiB,kBAEjBA,EAAA,qBAAuB,wBAEvBA,EAAA,eAAiB,kBAEjBA,EAAA,cAAgB,iBAEhBA,EAAA,YAAc,cAEdA,EAAA,WAAa,cAEbA,EAAA,UAAY,aAEZA,EAAA,mBAAqB,sBAErBA,EAAA,WAAa,cAEbA,EAAA,cAAgB,kBAEhBA,EAAA,cAAgB,iBAEhBA,EAAA,cAAgB,kBAEhBA,EAAA,qBAAuB,wBAEvBA,EAAA,mBAAqB,sBAErBA,EAAA,IAAM,MAENA,EAAA,oBAAsB,yBAlCZA,QAAA,IA+IAC,QAEVA,EAAA,qBAAuB,0BAFbA,QAAA,IA8EAC,QAEVA,EAAA,OAAS,SAETA,EAAA,oBAAsB,uBAEtBA,EAAA,WAAa,cAEbA,EAAA,UAAY,aAEZA,EAAA,uBAAyB,2BAEzBA,EAAA,kBAAoB,qBAEpBA,EAAA,UAAY,YAEZA,EAAA,UAAY,aAhBFA,QAAA,IAwEAC,QAEVA,EAAA,OAAS,SAETA,EAAA,oBAAsB,uBAEtBA,EAAA,WAAa,cAEbA,EAAA,UAAY,aAEZA,EAAA,uBAAyB,2BAEzBA,EAAA,kBAAoB,qBAEpBA,EAAA,UAAY,YAEZA,EAAA,UAAY,aAhBFA,QAAA,IA6FAC,QAEVA,EAAA,uBAAyB,6BAFfA,QAAA,IAwFAC,QAEVA,EAAA,OAAS,SAETA,EAAA,oBAAsB,uBAEtBA,EAAA,WAAa,cAEbA,EAAA,UAAY,aAEZA,EAAA,uBAAyB,2BAEzBA,EAAA,kBAAoB,qBAEpBA,EAAA,UAAY,YAEZA,EAAA,0BAA4B,8BAE5BA,EAAA,UAAY,aAEZA,EAAA,cAAgB,iBApBNA,QAAA,IAoFAC,QAEVA,EAAA,OAAS,SAETA,EAAA,oBAAsB,uBAEtBA,EAAA,WAAa,cAEbA,EAAA,UAAY,aAEZA,EAAA,uBAAyB,2BAEzBA,EAAA,kBAAoB,qBAEpBA,EAAA,UAAY,YAEZA,EAAA,0BAA4B,8BAE5BA,EAAA,UAAY,aAEZA,EAAA,cAAgB,iBApBNA,QAAA,IA2HAC,QAEVA,EAAA,0BAA4B,gCAFlBA,QAAA,IAyEAC,QAEVA,EAAA,OAAS,SAETA,EAAA,WAAa,cAEbA,EAAA,UAAY,aAEZA,EAAA,uBAAyB,2BAEzBA,EAAA,kBAAoB,qBAEpBA,EAAA,UAAY,YAEZA,EAAA,UAAY,aAdFA,QAAA,IAoEAC,QAEVA,EAAA,OAAS,SAETA,EAAA,WAAa,cAEbA,EAAA,UAAY,aAEZA,EAAA,uBAAyB,2BAEzBA,EAAA,kBAAoB,qBAEpBA,EAAA,UAAY,YAEZA,EAAA,UAAY,aAdFA,QAAA,IAsFAC,QAEVA,EAAA,4BAA8B,mCAFpBA,QAAA,IA8EAC,QAEVA,EAAA,OAAS,SAETA,EAAA,WAAa,cAEbA,EAAA,UAAY,aAEZA,EAAA,uBAAyB,2BAEzBA,EAAA,kBAAoB,qBAEpBA,EAAA,UAAY,YAEZA,EAAA,UAAY,aAEZA,EAAA,cAAgB,iBAhBNA,QAAA,IAwEAC,QAEVA,EAAA,OAAS,SAETA,EAAA,WAAa,cAEbA,EAAA,UAAY,aAEZA,EAAA,uBAAyB,2BAEzBA,EAAA,kBAAoB,qBAEpBA,EAAA,UAAY,YAEZA,EAAA,UAAY,aAEZA,EAAA,cAAgB,iBAhBNA,QAAA,IAsSAC,QAEVA,EAAA,OAAS,SAETA,EAAA,0BAA4B,8BAE5BA,EAAA,iBAAmB,qBAEnBA,EAAA,oBAAsB,uBAEtBA,EAAA,SAAW,YAEXA,EAAA,UAAY,aAEZA,EAAA,uBAAyB,2BAEzBA,EAAA,aAAe,gBAEfA,EAAA,kBAAoB,qBAEpBA,EAAA,UAAY,YAEZA,EAAA,0BAA4B,8BAE5BA,EAAA,YAAc,gBAEdA,EAAA,UAAY,aAEZA,EAAA,cAAgB,iBA5BNA,QAAA,IAgCAC,QAEVA,EAAA,SAAW,YAEXA,EAAA,UAAY,aAJFA,QAAA,IAQAC,QAEVA,EAAA,SAAW,YAEXA,EAAA,UAAY,aAJFA,QAAA,IAgLAC,QAEVA,EAAA,wBAA0B,6BAFhBA,QAAA,IA6EAC,QAEVA,EAAA,OAAS,SAETA,EAAA,SAAW,YAEXA,EAAA,aAAe,iBAEfA,EAAA,WAAa,cAEbA,EAAA,yBAA2B,6BAE3BA,EAAA,uBAAyB,2BAEzBA,EAAA,aAAe,gBAdLA,QAAA,IAwEAC,QAEVA,EAAA,OAAS,SAETA,EAAA,SAAW,YAEXA,EAAA,aAAe,iBAEfA,EAAA,WAAa,cAEbA,EAAA,yBAA2B,6BAE3BA,EAAA,uBAAyB,2BAEzBA,EAAA,aAAe,gBAdLA,QAAA,IAsHAC,QAEVA,EAAA,2BAA6B,gCAFnBA,QAAA,IAmGAC,QAEVA,EAAA,qBAAuB,0BAEvBA,EAAA,eAAiB,kBAEjBA,EAAA,eAAiB,kBAEjBA,EAAA,YAAc,cAEdA,EAAA,mBAAqB,sBAErBA,EAAA,WAAa,cAEbA,EAAA,yBAA2B,6BAE3BA,EAAA,uBAAyB,2BAEzBA,EAAA,QAAU,UAEVA,EAAA,eAAiB,kBAEjBA,EAAA,YAAc,eAEdA,EAAA,OAAS,SAETA,EAAA,YAAc,eAEdA,EAAA,WAAa,cA5BHA,QAAA,IAwGAC,QAEVA,EAAA,qBAAuB,0BAEvBA,EAAA,eAAiB,kBAEjBA,EAAA,eAAiB,kBAEjBA,EAAA,YAAc,cAEdA,EAAA,mBAAqB,sBAErBA,EAAA,WAAa,cAEbA,EAAA,yBAA2B,6BAE3BA,EAAA,uBAAyB,2BAEzBA,EAAA,QAAU,UAEVA,EAAA,eAAiB,kBAEjBA,EAAA,YAAc,eAEdA,EAAA,OAAS,SAETA,EAAA,YAAc,eAEdA,EAAA,WAAa,cA5BHA,QAAA,IAkKAC,QAEVA,EAAA,aAAe,gBAEfA,EAAA,eAAiB,kBAEjBA,EAAA,cAAgB,iBAEhBA,EAAA,eAAiB,kBAEjBA,EAAA,eAAiB,kBAEjBA,EAAA,uBAAyB,2BAEzBA,EAAA,aAAe,gBAEfA,EAAA,eAAiB,mBAhBPA,QAAA,IAwKAC,QAEVA,EAAA,qBAAuB,0BAEvBA,EAAA,eAAiB,kBAEjBA,EAAA,eAAiB,kBAEjBA,EAAA,eAAiB,kBAEjBA,EAAA,uBAAyB,2BAEzBA,EAAA,aAAe,gBAZLA,QAAA,IAuKAC,QAEVA,EAAA,yBAA2B,8BAFjBA,QAAA,IAyIAC,QAEVA,EAAA,aAAe,gBAEfA,EAAA,eAAiB,kBAEjBA,EAAA,qBAAuB,wBAEvBA,EAAA,eAAiB,kBAEjBA,EAAA,cAAgB,iBAEhBA,EAAA,YAAc,cAEdA,EAAA,WAAa,cAEbA,EAAA,yBAA2B,6BAE3BA,EAAA,uBAAyB,2BAEzBA,EAAA,UAAY,aAEZA,EAAA,mBAAqB,sBAErBA,EAAA,WAAa,cAEbA,EAAA,cAAgB,kBAEhBA,EAAA,cAAgB,iBAEhBA,EAAA,cAAgB,kBAEhBA,EAAA,IAAM,MAhCIA,QAAA,IAoHAC,QAEVA,EAAA,aAAe,gBAEfA,EAAA,eAAiB,kBAEjBA,EAAA,qBAAuB,wBAEvBA,EAAA,eAAiB,kBAEjBA,EAAA,cAAgB,iBAEhBA,EAAA,YAAc,cAEdA,EAAA,WAAa,cAEbA,EAAA,yBAA2B,6BAE3BA,EAAA,uBAAyB,2BAEzBA,EAAA,UAAY,aAEZA,EAAA,mBAAqB,sBAErBA,EAAA,WAAa,cAEbA,EAAA,cAAgB,kBAEhBA,EAAA,cAAgB,iBAEhBA,EAAA,cAAgB,kBAEhBA,EAAA,IAAM,MAhCIA,QAAA,IA6IAC,QAEVA,EAAA,wCAA0C,+CAFhCA,QAAA,IAyFAC,QAEVA,EAAA,kBAAoB,sBAEpBA,EAAA,oBAAsB,wBAEtBA,EAAA,WAAa,cAEbA,EAAA,uBAAyB,2BAEzBA,EAAA,6BAA+B,iCAE/BA,EAAA,mBAAqB,uBAErBA,EAAA,WAAa,cAEbA,EAAA,YAAc,eAhBJA,QAAA,IAoFAC,QAEVA,EAAA,kBAAoB,sBAEpBA,EAAA,oBAAsB,wBAEtBA,EAAA,WAAa,cAEbA,EAAA,uBAAyB,2BAEzBA,EAAA,6BAA+B,iCAE/BA,EAAA,mBAAqB,uBAErBA,EAAA,WAAa,cAEbA,EAAA,YAAc,eAhBJA,QAAA,IAgHAC,QAEVA,EAAA,0BAA4B,+BAFlBA,QAAA,IAgFAC,QAEVA,EAAA,sBAAwB,0BAExBA,EAAA,iBAAmB,oBAEnBA,EAAA,WAAa,cAEbA,EAAA,yBAA2B,6BAE3BA,EAAA,uBAAyB,2BAEzBA,EAAA,aAAe,gBAEfA,EAAA,YAAc,eAEdA,EAAA,MAAQ,QAhBEA,QAAA,IAwEAC,QAEVA,EAAA,sBAAwB,0BAExBA,EAAA,iBAAmB,oBAEnBA,EAAA,WAAa,cAEbA,EAAA,yBAA2B,6BAE3BA,EAAA,uBAAyB,2BAEzBA,EAAA,aAAe,gBAEfA,EAAA,YAAc,eAEdA,EAAA,MAAQ,QAhBEA,QAAA,IA8GAC,QAEVA,EAAA,6BAA+B,kCAFrBA,QAAA,IAuFAC,QAEVA,EAAA,iBAAmB,oBAEnBA,EAAA,WAAa,cAEbA,EAAA,uBAAyB,2BAEzBA,EAAA,kBAAoB,sBAEpBA,EAAA,YAAc,eAEdA,EAAA,SAAW,YAEXA,EAAA,OAAS,SAETA,EAAA,YAAc,eAhBJA,QAAA,IA4EAC,QAEVA,EAAA,iBAAmB,oBAEnBA,EAAA,WAAa,cAEbA,EAAA,uBAAyB,2BAEzBA,EAAA,kBAAoB,sBAEpBA,EAAA,YAAc,eAEdA,EAAA,SAAW,YAEXA,EAAA,OAAS,SAETA,EAAA,YAAc,eAhBJA,QAAA,IAkHAC,QAEVA,EAAA,iCAAmC,uCAFzBA,QAAA,IAkJAC,QAEVA,EAAA,wCAA0C,+CAFhCA,QAAA,IAmHAC,QAEVA,EAAA,OAAS,SAETA,EAAA,SAAW,YAEXA,EAAA,SAAW,YAEXA,EAAA,UAAY,aAEZA,EAAA,YAAc,gBAEdA,EAAA,YAAc,gBAEdA,EAAA,WAAa,cAEbA,EAAA,SAAW,YAEXA,EAAA,UAAY,aAEZA,EAAA,yBAA2B,6BAE3BA,EAAA,2BAA6B,gCAE7BA,EAAA,2BAA6B,gCAE7BA,EAAA,uBAAyB,2BAEzBA,EAAA,yBAA2B,8BAE3BA,EAAA,yBAA2B,8BAE3BA,EAAA,aAAe,gBAEfA,EAAA,UAAY,aAEZA,EAAA,cAAgB,iBApCNA,QAAA,IA+HAC,QAEVA,EAAA,SAAW,YAEXA,EAAA,SAAW,YAEXA,EAAA,YAAc,gBAEdA,EAAA,YAAc,gBAEdA,EAAA,WAAa,cAEbA,EAAA,SAAW,YAEXA,EAAA,UAAY,aAEZA,EAAA,2BAA6B,gCAE7BA,EAAA,2BAA6B,gCAE7BA,EAAA,yBAA2B,8BAE3BA,EAAA,yBAA2B,8BAE3BA,EAAA,aAAe,gBAEfA,EAAA,UAAY,aA1BFA,QAAA,IAgGAC,QAEVA,EAAA,OAAS,SAETA,EAAA,UAAY,aAEZA,EAAA,WAAa,cAEbA,EAAA,SAAW,YAEXA,EAAA,UAAY,aAEZA,EAAA,yBAA2B,6BAE3BA,EAAA,uBAAyB,2BAEzBA,EAAA,aAAe,gBAEfA,EAAA,UAAY,aAEZA,EAAA,cAAgB,iBApBNA,QAAA,IAoFAC,QAEVA,EAAA,OAAS,SAETA,EAAA,UAAY,aAEZA,EAAA,WAAa,cAEbA,EAAA,SAAW,YAEXA,EAAA,UAAY,aAEZA,EAAA,yBAA2B,6BAE3BA,EAAA,uBAAyB,2BAEzBA,EAAA,aAAe,gBAEfA,EAAA,UAAY,aAEZA,EAAA,cAAgB,iBApBNA,QAAA,IAiHAC,QAEVA,EAAA,mBAAqB,uBAFXA,QAAA,IA8EAC,QAEVA,EAAA,qBAAuB,yBAEvBA,EAAA,WAAa,cAEbA,EAAA,UAAY,aAEZA,EAAA,oBAAsB,yBAEtBA,EAAA,uBAAyB,2BAEzBA,EAAA,cAAgB,iBAEhBA,EAAA,aAAe,gBAEfA,EAAA,aAAe,iBAEfA,EAAA,gBAAkB,kBAlBRA,QAAA,IAgFAC,QAEVA,EAAA,qBAAuB,yBAEvBA,EAAA,WAAa,cAEbA,EAAA,UAAY,aAEZA,EAAA,oBAAsB,yBAEtBA,EAAA,uBAAyB,2BAEzBA,EAAA,cAAgB,iBAEhBA,EAAA,aAAe,gBAEfA,EAAA,aAAe,iBAEfA,EAAA,gBAAkB,kBAlBRA,QAAA,IA8HAC,QAEVA,EAAA,4BAA8B,kCAFpBA,QAAA,IA4EAC,QAEVA,EAAA,WAAa,cAEbA,EAAA,uBAAyB,2BAEzBA,EAAA,gBAAkB,mBAElBA,EAAA,mBAAqB,uBAErBA,EAAA,aAAe,gBAVLA,QAAA,IA4DAC,QAEVA,EAAA,WAAa,cAEbA,EAAA,uBAAyB,2BAEzBA,EAAA,gBAAkB,mBAElBA,EAAA,mBAAqB,uBAErBA,EAAA,aAAe,gBAVLA,QAAA,IAiHAC,QAEVA,EAAA,sBAAwB,2BAFdA,QAAA,IAkGAC,QAEVA,EAAA,WAAa,cAEbA,EAAA,aAAe,gBAEfA,EAAA,WAAa,cAEbA,EAAA,UAAY,aAEZA,EAAA,IAAM,MAENA,EAAA,QAAU,WAEVA,EAAA,uBAAyB,2BAEzBA,EAAA,YAAc,eAhBJA,QAAA,IAwEAC,QAEVA,EAAA,WAAa,cAEbA,EAAA,aAAe,gBAEfA,EAAA,WAAa,cAEbA,EAAA,UAAY,aAEZA,EAAA,IAAM,MAENA,EAAA,QAAU,WAEVA,EAAA,uBAAyB,2BAEzBA,EAAA,YAAc,eAhBJA,QAAA,IA4KAC,QAEVA,EAAA,WAAa,cAEbA,EAAA,UAAY,aAEZA,EAAA,eAAiB,mBAEjBA,EAAA,iBAAmB,qBAEnBA,EAAA,IAAM,MAENA,EAAA,QAAU,WAEVA,EAAA,uBAAyB,2BAEzBA,EAAA,YAAc,eAhBJA,QAAA,IAsMAC,QAEVA,EAAA,sBAAwB,2BAFdA,QAAA,IAoJAC,QAEVA,EAAA,qBAAuB,0BAEvBA,EAAA,eAAiB,kBAEjBA,EAAA,eAAiB,kBAEjBA,EAAA,kBAAoB,qBAEpBA,EAAA,YAAc,cAEdA,EAAA,mBAAqB,sBAErBA,EAAA,WAAa,cAEbA,EAAA,uBAAyB,2BAEzBA,EAAA,yBAA2B,6BAE3BA,EAAA,uBAAyB,2BAEzBA,EAAA,QAAU,UAEVA,EAAA,eAAiB,kBAEjBA,EAAA,YAAc,eAEdA,EAAA,KAAO,OAEPA,EAAA,aAAe,gBAEfA,EAAA,kBAAoB,qBAEpBA,EAAA,eAAiB,kBAEjBA,EAAA,yBAA2B,6BAE3BA,EAAA,uBAAyB,2BAEzBA,EAAA,OAAS,SAETA,EAAA,gBAAkB,qBAElBA,EAAA,WAAa,cA5CHA,QAAA,IAoJAC,QAEVA,EAAA,qBAAuB,0BAEvBA,EAAA,eAAiB,kBAEjBA,EAAA,eAAiB,kBAEjBA,EAAA,kBAAoB,qBAEpBA,EAAA,YAAc,cAEdA,EAAA,mBAAqB,sBAErBA,EAAA,WAAa,cAEbA,EAAA,uBAAyB,2BAEzBA,EAAA,yBAA2B,6BAE3BA,EAAA,uBAAyB,2BAEzBA,EAAA,QAAU,UAEVA,EAAA,eAAiB,kBAEjBA,EAAA,YAAc,eAEdA,EAAA,KAAO,OAEPA,EAAA,aAAe,gBAEfA,EAAA,kBAAoB,qBAEpBA,EAAA,eAAiB,kBAEjBA,EAAA,yBAA2B,6BAE3BA,EAAA,uBAAyB,2BAEzBA,EAAA,OAAS,SAETA,EAAA,gBAAkB,qBAElBA,EAAA,WAAa,cA5CHA,QAAA,IAgMAC,QAEVA,EAAA,wBAA0B,8BAFhBA,QAAA,IAkJAC,QAEVA,EAAA,aAAe,gBAEfA,EAAA,SAAW,WAEXA,EAAA,YAAc,cAEdA,EAAA,WAAa,cAEbA,EAAA,YAAc,gBAEdA,EAAA,aAAe,iBAEfA,EAAA,yBAA2B,8BAE3BA,EAAA,yBAA2B,6BAE3BA,EAAA,uBAAyB,2BAEzBA,EAAA,QAAU,UAEVA,EAAA,OAAS,SAETA,EAAA,YAAc,gBAEdA,EAAA,UAAY,aAEZA,EAAA,gBAAkB,mBAElBA,EAAA,cAAgB,iBAEhBA,EAAA,SAAW,YAhCDA,QAAA,IAwHAC,QAEVA,EAAA,aAAe,gBAEfA,EAAA,SAAW,WAEXA,EAAA,YAAc,cAEdA,EAAA,WAAa,cAEbA,EAAA,YAAc,gBAEdA,EAAA,aAAe,iBAEfA,EAAA,yBAA2B,8BAE3BA,EAAA,yBAA2B,6BAE3BA,EAAA,uBAAyB,2BAEzBA,EAAA,QAAU,UAEVA,EAAA,OAAS,SAETA,EAAA,YAAc,gBAEdA,EAAA,UAAY,aAEZA,EAAA,gBAAkB,mBAElBA,EAAA,cAAgB,iBAEhBA,EAAA,SAAW,YAhCDA,QAAA,IAiMAC,QAEVA,EAAA,2BAA6B,gCAFnBA,QAAA,IAyHAC,QAEVA,EAAA,OAAS,SAETA,EAAA,qBAAuB,0BAEvBA,EAAA,eAAiB,kBAEjBA,EAAA,eAAiB,kBAEjBA,EAAA,WAAa,cAEbA,EAAA,yBAA2B,6BAE3BA,EAAA,uBAAyB,2BAEzBA,EAAA,KAAO,OAEPA,EAAA,aAAe,gBAEfA,EAAA,gBAAkB,mBAElBA,EAAA,UAAY,aAEZA,EAAA,gBAAkB,qBAElBA,EAAA,gBAAkB,mBA1BRA,QAAA,IAoGAC,QAEVA,EAAA,OAAS,SAETA,EAAA,qBAAuB,0BAEvBA,EAAA,eAAiB,kBAEjBA,EAAA,eAAiB,kBAEjBA,EAAA,WAAa,cAEbA,EAAA,yBAA2B,6BAE3BA,EAAA,uBAAyB,2BAEzBA,EAAA,KAAO,OAEPA,EAAA,aAAe,gBAEfA,EAAA,gBAAkB,mBAElBA,EAAA,UAAY,aAEZA,EAAA,gBAAkB,qBAElBA,EAAA,gBAAkB,mBA1BRA,QAAA,IAuNAC,QAEVA,EAAA,6BAA+B,mCAFrBA,QAAA,IAwJAC,QAEVA,EAAA,OAAS,SAETA,EAAA,WAAa,cAEbA,EAAA,aAAe,iBAEfA,EAAA,cAAgB,kBAEhBA,EAAA,yBAA2B,6BAE3BA,EAAA,uBAAyB,2BAEzBA,EAAA,wBAA0B,6BAE1BA,EAAA,aAAe,gBAEfA,EAAA,kBAAoB,sBAEpBA,EAAA,UAAY,aAEZA,EAAA,YAAc,gBAEdA,EAAA,YAAc,gBAEdA,EAAA,yBAA2B,8BAE3BA,EAAA,cAAgB,iBA5BNA,QAAA,IAgCAC,QAEVA,EAAA,aAAe,iBAEfA,EAAA,cAAgB,kBAEhBA,EAAA,wBAA0B,6BANhBA,QAAA,IAUAC,QAEVA,EAAA,aAAe,iBAEfA,EAAA,cAAgB,kBAEhBA,EAAA,wBAA0B,6BANhBA,QAAA,IA8GAC,QAEVA,EAAA,OAAS,SAETA,EAAA,WAAa,cAEbA,EAAA,aAAe,iBAEfA,EAAA,cAAgB,kBAEhBA,EAAA,yBAA2B,6BAE3BA,EAAA,uBAAyB,2BAEzBA,EAAA,wBAA0B,6BAE1BA,EAAA,aAAe,gBAEfA,EAAA,kBAAoB,sBAEpBA,EAAA,UAAY,aAEZA,EAAA,YAAc,gBAEdA,EAAA,YAAc,gBAEdA,EAAA,yBAA2B,8BAE3BA,EAAA,cAAgB,iBA5BNA,QAAA,IAmMAC,QAEVA,EAAA,8BAAgC,oCAFtBA,QAAA,IAoHAC,QAEVA,EAAA,OAAS,SAETA,EAAA,qBAAuB,0BAEvBA,EAAA,aAAe,gBAEfA,EAAA,eAAiB,kBAEjBA,EAAA,eAAiB,kBAEjBA,EAAA,YAAc,eAEdA,EAAA,WAAa,cAEbA,EAAA,yBAA2B,6BAE3BA,EAAA,uBAAyB,2BAEzBA,EAAA,KAAO,OAEPA,EAAA,gBAAkB,mBAElBA,EAAA,YAAc,eAEdA,EAAA,UAAY,aAEZA,EAAA,YAAc,gBAEdA,EAAA,gBAAkB,qBA9BRA,QAAA,IA4GAC,QAEVA,EAAA,OAAS,SAETA,EAAA,qBAAuB,0BAEvBA,EAAA,aAAe,gBAEfA,EAAA,eAAiB,kBAEjBA,EAAA,eAAiB,kBAEjBA,EAAA,YAAc,eAEdA,EAAA,WAAa,cAEbA,EAAA,yBAA2B,6BAE3BA,EAAA,uBAAyB,2BAEzBA,EAAA,KAAO,OAEPA,EAAA,gBAAkB,mBAElBA,EAAA,YAAc,eAEdA,EAAA,UAAY,aAEZA,EAAA,YAAc,gBAEdA,EAAA,gBAAkB,qBA9BRA,QAAA,IA2HAC,QAEVA,EAAA,0BAA4B,gCAFlBA,QAAA,IAoFAC,QAEVA,EAAA,WAAa,cAEbA,EAAA,yBAA2B,6BAE3BA,EAAA,uBAAyB,2BAEzBA,EAAA,aAAe,gBAEfA,EAAA,yBAA2B,6BAE3BA,EAAA,uBAAyB,2BAEzBA,EAAA,YAAc,gBAdJA,QAAA,IA4EAC,QAEVA,EAAA,WAAa,cAEbA,EAAA,yBAA2B,6BAE3BA,EAAA,uBAAyB,2BAEzBA,EAAA,aAAe,gBAEfA,EAAA,yBAA2B,6BAE3BA,EAAA,uBAAyB,2BAEzBA,EAAA,YAAc,gBAdJA,QAAA,IAiHAC,QAEVA,EAAA,2BAA6B,iCAFnBA,QAAA,IA0FAC,QAEVA,EAAA,KAAO,OAEPA,EAAA,WAAa,cAEbA,EAAA,uBAAyB,2BAEzBA,EAAA,cAAgB,iBAEhBA,EAAA,aAAe,gBAEfA,EAAA,aAAe,iBAZLA,QAAA,IAgEAC,QAEVA,EAAA,KAAO,OAEPA,EAAA,WAAa,cAEbA,EAAA,uBAAyB,2BAEzBA,EAAA,cAAgB,iBAEhBA,EAAA,aAAe,gBAEfA,EAAA,aAAe,iBAZLA,QAAA,IAkDAC,QAEVA,EAAA,IAAM,MAENA,EAAA,KAAO,OAJGA,QAAA,IA2GAC,QAEVA,EAAA,+BAAiC,oCAFvBA,QAAA,IAoGAC,QAEVA,EAAA,OAAS,SAETA,EAAA,iBAAmB,oBAEnBA,EAAA,WAAa,cAEbA,EAAA,UAAY,aAEZA,EAAA,WAAa,cAEbA,EAAA,YAAc,eAEdA,EAAA,mBAAqB,sBAdXA,QAAA,IAwGAC,QAEVA,EAAA,OAAS,SAETA,EAAA,iBAAmB,oBAEnBA,EAAA,WAAa,cAEbA,EAAA,UAAY,aAEZA,EAAA,WAAa,cAEbA,EAAA,YAAc,eAEdA,EAAA,mBAAqB,sBAdXA,QAAA,IAmIAC,QAEVA,EAAA,iCAAmC,uCAFzBA,QAAA,IAmFAC,QAEVA,EAAA,kBAAoB,sBAEpBA,EAAA,oBAAsB,wBAEtBA,EAAA,WAAa,cAEbA,EAAA,6BAA+B,iCAE/BA,EAAA,mBAAqB,uBAErBA,EAAA,WAAa,cAEbA,EAAA,YAAc,eAEdA,EAAA,mBAAqB,sBAhBXA,QAAA,IAoFAC,QAEVA,EAAA,kBAAoB,sBAEpBA,EAAA,oBAAsB,wBAEtBA,EAAA,WAAa,cAEbA,EAAA,6BAA+B,iCAE/BA,EAAA,mBAAqB,uBAErBA,EAAA,WAAa,cAEbA,EAAA,YAAc,eAEdA,EAAA,mBAAqB,sBAhBXA,QAAA,IAyGAC,QAEVA,EAAA,0BAA4B,+BAFlBA,QAAA,IA6DAC,QAEVA,EAAA,wBAA0B,4BAE1BA,EAAA,WAAa,cAEbA,EAAA,mBAAqB,uBANXA,QAAA,IAoDAC,QAEVA,EAAA,wBAA0B,4BAE1BA,EAAA,WAAa,cAEbA,EAAA,mBAAqB,uBANXA,QAAA,IAiGAC,QAEVA,EAAA,sBAAwB,0BAFdA,QAAA,IAsFAC,QAEVA,EAAA,iBAAmB,oBAEnBA,EAAA,WAAa,cAEbA,EAAA,kBAAoB,sBAEpBA,EAAA,YAAc,eAEdA,EAAA,SAAW,YAEXA,EAAA,OAAS,SAETA,EAAA,YAAc,eAEdA,EAAA,mBAAqB,sBAErBA,EAAA,oBAAsB,yBAlBZA,QAAA,IAoFAC,QAEVA,EAAA,iBAAmB,oBAEnBA,EAAA,WAAa,cAEbA,EAAA,kBAAoB,sBAEpBA,EAAA,YAAc,eAEdA,EAAA,SAAW,YAEXA,EAAA,OAAS,SAETA,EAAA,YAAc,eAEdA,EAAA,mBAAqB,sBAErBA,EAAA,oBAAsB,yBAlBZA,QAAA,IAgHAC,QAEVA,EAAA,iBAAmB,oBAEnBA,EAAA,YAAc,eAJJA,QAAA,IA8EAC,QAEVA,EAAA,kBAAoB,uBAFVA,QAAA,IAuEAC,QAEVA,EAAA,MAAQ,QAERA,EAAA,WAAa,cAEbA,EAAA,WAAa,cAEbA,EAAA,mBAAqB,sBAErBA,EAAA,aAAe,iBAVLA,QAAA,IAwEAC,QAEVA,EAAA,MAAQ,QAERA,EAAA,WAAa,cAEbA,EAAA,WAAa,cAEbA,EAAA,mBAAqB,sBAErBA,EAAA,aAAe,iBAVLA,QAAA,IA4HAC,QAEVA,EAAA,WAAa,cAFHA,QAAA,IA8GAC,QAEVA,EAAA,eAAiB,kBAEjBA,EAAA,eAAiB,kBAEjBA,EAAA,KAAO,OAEPA,EAAA,WAAa,cAEbA,EAAA,YAAc,eAEdA,EAAA,WAAa,cAEbA,EAAA,eAAiB,kBAEjBA,EAAA,uBAAyB,2BAEzBA,EAAA,mBAAqB,sBAErBA,EAAA,KAAO,OApBGA,QAAA,IAgGAC,QAEVA,EAAA,eAAiB,kBAEjBA,EAAA,eAAiB,kBAEjBA,EAAA,KAAO,OAEPA,EAAA,WAAa,cAEbA,EAAA,YAAc,eAEdA,EAAA,WAAa,cAEbA,EAAA,eAAiB,kBAEjBA,EAAA,uBAAyB,2BAEzBA,EAAA,mBAAqB,sBAErBA,EAAA,KAAO,OApBGA,QAAA,IAoMAC,QAEVA,EAAA,eAAiB,kBAEjBA,EAAA,eAAiB,kBAEjBA,EAAA,WAAa,cAEbA,EAAA,SAAW,YAEXA,EAAA,eAAiB,kBAEjBA,EAAA,uBAAyB,2BAEzBA,EAAA,mBAAqB,sBAErBA,EAAA,KAAO,OAhBGA,QAAA,IA2RAC,QAEVA,EAAA,4BAA8B,iCAFpBA,QAAA,IA0JAC,QAEVA,EAAA,OAAS,SAETA,EAAA,UAAY,aAEZA,EAAA,YAAc,eAEdA,EAAA,mBAAqB,wBAErBA,EAAA,WAAa,cAEbA,EAAA,mBAAqB,wBAErBA,EAAA,WAAa,cAEbA,EAAA,SAAW,YAEXA,EAAA,SAAW,aAEXA,EAAA,qBAAuB,yBAEvBA,EAAA,aAAe,gBAEfA,EAAA,UAAY,aAEZA,EAAA,oBAAsB,wBAEtBA,EAAA,cAAgB,iBAEhBA,EAAA,qBAAuB,wBAEvBA,EAAA,mBAAqB,sBAErBA,EAAA,KAAO,OAlCGA,QAAA,IAsCAC,QAEVA,EAAA,SAAW,YAEXA,EAAA,SAAW,aAEXA,EAAA,qBAAuB,yBANbA,QAAA,IAUAC,QAEVA,EAAA,SAAW,YAEXA,EAAA,SAAW,aAEXA,EAAA,qBAAuB,yBANbA,QAAA,IAoIAC,QAEVA,EAAA,OAAS,SAETA,EAAA,UAAY,aAEZA,EAAA,YAAc,eAEdA,EAAA,mBAAqB,wBAErBA,EAAA,WAAa,cAEbA,EAAA,mBAAqB,wBAErBA,EAAA,WAAa,cAEbA,EAAA,SAAW,YAEXA,EAAA,SAAW,aAEXA,EAAA,qBAAuB,yBAEvBA,EAAA,aAAe,gBAEfA,EAAA,UAAY,aAEZA,EAAA,oBAAsB,wBAEtBA,EAAA,cAAgB,iBAEhBA,EAAA,qBAAuB,wBAEvBA,EAAA,mBAAqB,sBAErBA,EAAA,KAAO,OAlCGA,QAAA,IAwKAC,QAEVA,EAAA,0BAA4B,+BAFlBA,QAAA,IA0FAC,QAEVA,EAAA,OAAS,SAETA,EAAA,UAAY,aAEZA,EAAA,WAAa,cAEbA,EAAA,SAAW,YAEXA,EAAA,UAAY,aAEZA,EAAA,aAAe,gBAEfA,EAAA,UAAY,aAEZA,EAAA,cAAgB,iBAEhBA,EAAA,qBAAuB,wBAEvBA,EAAA,mBAAqB,sBAErBA,EAAA,oBAAsB,yBAtBZA,QAAA,IA4FAC,QAEVA,EAAA,OAAS,SAETA,EAAA,UAAY,aAEZA,EAAA,WAAa,cAEbA,EAAA,SAAW,YAEXA,EAAA,UAAY,aAEZA,EAAA,aAAe,gBAEfA,EAAA,UAAY,aAEZA,EAAA,cAAgB,iBAEhBA,EAAA,qBAAuB,wBAEvBA,EAAA,mBAAqB,sBAErBA,EAAA,oBAAsB,yBAtBZA,QAAA,IAsIAC,QAEVA,EAAA,0BAA4B,+BAFlBA,QAAA,IAuHAC,QAEVA,EAAA,UAAY,aAEZA,EAAA,eAAiB,kBAEjBA,EAAA,SAAW,WAEXA,EAAA,QAAU,WAEVA,EAAA,WAAa,cAEbA,EAAA,UAAY,cAEZA,EAAA,yBAA2B,6BAE3BA,EAAA,uBAAyB,2BAEzBA,EAAA,UAAY,aAEZA,EAAA,KAAO,OAEPA,EAAA,WAAa,cAEbA,EAAA,8BAAgC,oCAEhCA,EAAA,2BAA6B,iCAE7BA,EAAA,SAAW,YAEXA,EAAA,OAAS,SAETA,EAAA,cAAgB,iBAhCNA,QAAA,IAoHAC,QAEVA,EAAA,UAAY,aAEZA,EAAA,eAAiB,kBAEjBA,EAAA,SAAW,WAEXA,EAAA,QAAU,WAEVA,EAAA,WAAa,cAEbA,EAAA,UAAY,cAEZA,EAAA,yBAA2B,6BAE3BA,EAAA,uBAAyB,2BAEzBA,EAAA,UAAY,aAEZA,EAAA,KAAO,OAEPA,EAAA,WAAa,cAEbA,EAAA,8BAAgC,oCAEhCA,EAAA,2BAA6B,iCAE7BA,EAAA,SAAW,YAEXA,EAAA,OAAS,SAETA,EAAA,cAAgB,iBAhCNA,QAAA,IAsHAC,QAEVA,EAAA,gCAAkC,uCAFxBA,QAAA,IA2DAC,QAEVA,EAAA,SAAW,YAEXA,EAAA,6BAA+B,kCAE/BA,EAAA,uBAAyB,2BANfA,QAAA,IAoDAC,QAEVA,EAAA,SAAW,YAEXA,EAAA,6BAA+B,kCAE/BA,EAAA,uBAAyB,2BANfA,QAAA,IAkGAC,QAEVA,EAAA,YAAc,gBAFJA,QAAA,IAoFAC,QAEVA,EAAA,OAAS,SAETA,EAAA,YAAc,eAEdA,EAAA,mBAAqB,wBAErBA,EAAA,mBAAqB,wBAErBA,EAAA,qBAAuB,yBAEvBA,EAAA,aAAe,gBAEfA,EAAA,oBAAsB,wBAEtBA,EAAA,qBAAuB,wBAEvBA,EAAA,mBAAqB,sBAlBXA,QAAA,IAwFAC,QAEVA,EAAA,OAAS,SAETA,EAAA,YAAc,eAEdA,EAAA,mBAAqB,wBAErBA,EAAA,mBAAqB,wBAErBA,EAAA,qBAAuB,yBAEvBA,EAAA,aAAe,gBAEfA,EAAA,oBAAsB,wBAEtBA,EAAA,qBAAuB,wBAEvBA,EAAA,mBAAqB,sBAlBXA,QAAA,IA2FAC,QAEVA,EAAA,kBAAoB,sBAFVA,QAAA,IAoDAC,QAEVA,EAAA,GAAK,KAELA,EAAA,WAAa,cAEbA,EAAA,YAAc,gBANJA,QAAA,IAgCAC,QAEVA,EAAA,GAAK,KAELA,EAAA,WAAa,cAEbA,EAAA,YAAc,gBANJA,QAAA,IAsIAC,QAEVA,EAAA,gBAAkB,oBAFRA,QAAA,IAgHAC,QAEVA,EAAA,QAAU,UAEVA,EAAA,SAAW,WAEXA,EAAA,iBAAmB,oBAEnBA,EAAA,QAAU,UAEVA,EAAA,WAAa,cAEbA,EAAA,UAAY,aAEZA,EAAA,KAAO,OAEPA,EAAA,QAAU,UAEVA,EAAA,uBAAyB,2BAEzBA,EAAA,mBAAqB,sBAErBA,EAAA,oBAAsB,yBAtBZA,QAAA,IA4FAC,QAEVA,EAAA,QAAU,UAEVA,EAAA,SAAW,WAEXA,EAAA,iBAAmB,oBAEnBA,EAAA,QAAU,UAEVA,EAAA,WAAa,cAEbA,EAAA,UAAY,aAEZA,EAAA,KAAO,OAEPA,EAAA,QAAU,UAEVA,EAAA,uBAAyB,2BAEzBA,EAAA,mBAAqB,sBAErBA,EAAA,oBAAsB,yBAtBZA,QAAA,IAuJAC,QAEVA,EAAA,kBAAoB,sBAFVA,QAAA,IAoHAC,QAEVA,EAAA,QAAU,UAEVA,EAAA,KAAO,OAEPA,EAAA,kBAAoB,sBAEpBA,EAAA,WAAa,cAEbA,EAAA,UAAY,aAEZA,EAAA,OAAS,SAETA,EAAA,KAAO,OAEPA,EAAA,aAAe,iBAEfA,EAAA,uBAAyB,2BAEzBA,EAAA,mBAAqB,sBAErBA,EAAA,KAAO,OAEPA,EAAA,oBAAsB,yBAxBZA,QAAA,IAgGAC,QAEVA,EAAA,QAAU,UAEVA,EAAA,KAAO,OAEPA,EAAA,kBAAoB,sBAEpBA,EAAA,WAAa,cAEbA,EAAA,UAAY,aAEZA,EAAA,OAAS,SAETA,EAAA,KAAO,OAEPA,EAAA,aAAe,iBAEfA,EAAA,uBAAyB,2BAEzBA,EAAA,mBAAqB,sBAErBA,EAAA,KAAO,OAEPA,EAAA,oBAAsB,yBAxBZA,QAAA,IA4OAC,QAEVA,EAAA,QAAU,UAEVA,EAAA,kBAAoB,sBAEpBA,EAAA,WAAa,cAEbA,EAAA,UAAY,aAEZA,EAAA,SAAW,YAEXA,EAAA,OAAS,SAETA,EAAA,KAAO,OAEPA,EAAA,uBAAyB,2BAEzBA,EAAA,mBAAqB,sBAErBA,EAAA,KAAO,OAEPA,EAAA,oBAAsB,yBAtBZA,QAAA,IA80IAC,QAEVA,EAAA,oBAAsB,yBAFZA,QAAA,IAgGAC,QAEVA,EAAA,6BAA+B,kCAE/BA,EAAA,SAAW,YAEXA,EAAA,gBAAkB,oBAElBA,EAAA,YAAc,gBAEdA,EAAA,WAAa,eAEbA,EAAA,yBAA2B,8BAE3BA,EAAA,WAAa,cAEbA,EAAA,qBAAuB,0BAEvBA,EAAA,gBAAkB,oBAElBA,EAAA,YAAc,gBApBJA,QAAA,IAwFAC,QAEVA,EAAA,6BAA+B,kCAE/BA,EAAA,SAAW,YAEXA,EAAA,gBAAkB,oBAElBA,EAAA,YAAc,gBAEdA,EAAA,WAAa,eAEbA,EAAA,yBAA2B,8BAE3BA,EAAA,WAAa,cAEbA,EAAA,qBAAuB,0BAEvBA,EAAA,gBAAkB,oBAElBA,EAAA,YAAc,gBApBJA,QAAA,IAgHAC,QAEVA,EAAA,cAAgB,kBAFNA,QAAA,IA4EAC,QAEVA,EAAA,OAAS,SAETA,EAAA,WAAa,cAEbA,EAAA,aAAe,gBAEfA,EAAA,UAAY,aAEZA,EAAA,UAAY,aAEZA,EAAA,qBAAuB,wBAEvBA,EAAA,mBAAqB,sBAdXA,QAAA,IAwEAC,QAEVA,EAAA,OAAS,SAETA,EAAA,WAAa,cAEbA,EAAA,aAAe,gBAEfA,EAAA,UAAY,aAEZA,EAAA,UAAY,aAEZA,EAAA,qBAAuB,wBAEvBA,EAAA,mBAAqB,sBAdXA,QAAA,IA8GAC,QAEVA,EAAA,mBAAqB,uBAErBA,EAAA,YAAc,eAJJA,QAAA,IAuIAC,QAEVA,EAAA,YAAc,eAFJA,QAAA,IAoFAC,QAEVA,EAAA,qBAAuB,yBAEvBA,EAAA,gBAAkB,oBAElBA,EAAA,WAAa,cAEbA,EAAA,UAAY,aAEZA,EAAA,cAAgB,iBAEhBA,EAAA,aAAe,gBAEfA,EAAA,aAAe,iBAEfA,EAAA,mBAAqB,sBAErBA,EAAA,gBAAkB,kBAElBA,EAAA,oBAAsB,yBApBZA,QAAA,IAwFAC,QAEVA,EAAA,qBAAuB,yBAEvBA,EAAA,gBAAkB,oBAElBA,EAAA,WAAa,cAEbA,EAAA,UAAY,aAEZA,EAAA,cAAgB,iBAEhBA,EAAA,aAAe,gBAEfA,EAAA,aAAe,iBAEfA,EAAA,mBAAqB,sBAErBA,EAAA,gBAAkB,kBAElBA,EAAA,oBAAsB,yBApBZA,QAAA,IAsDAC,QAEVA,EAAA,IAAM,MAENA,EAAA,cAAgB,kBAEhBA,EAAA,aAAe,iBAEfA,EAAA,KAAO,OAEPA,EAAA,eAAiB,mBAEjBA,EAAA,cAAgB,kBAZNA,QAAA,IAmEAC,QAEVA,EAAA,oBAAsB,wBAFZA,QAAA,IA+DAC,QAEVA,EAAA,mBAAqB,uBAErBA,EAAA,yBAA2B,6BAE3BA,EAAA,YAAc,eAEdA,EAAA,UAAY,YARFA,QAAA,IAwDAC,QAEVA,EAAA,mBAAqB,uBAErBA,EAAA,yBAA2B,6BAE3BA,EAAA,YAAc,eAEdA,EAAA,UAAY,YARFA,QAAA,IAuFAC,QAEVA,EAAA,oBAAsB,wBAEtBA,EAAA,qBAAuB,yBAJbA,QAAA,IAiEAC,QAEVA,EAAA,mBAAqB,uBAErBA,EAAA,yBAA2B,6BAE3BA,EAAA,YAAc,eAEdA,EAAA,UAAY,YARFA,QAAA,IAwDAC,QAEVA,EAAA,mBAAqB,uBAErBA,EAAA,yBAA2B,6BAE3BA,EAAA,YAAc,eAEdA,EAAA,UAAY,YARFA,QAAA,IAiGAC,QAEVA,EAAA,kBAAoB,sBAFVA,QAAA,IAiFAC,QAEVA,EAAA,WAAa,cAEbA,EAAA,SAAW,YAEXA,EAAA,WAAa,cAEbA,EAAA,WAAa,cAEbA,EAAA,mBAAqB,uBAErBA,EAAA,qBAAuB,wBAEvBA,EAAA,mBAAqB,sBAErBA,EAAA,aAAe,gBAhBLA,QAAA,IAgFAC,QAEVA,EAAA,WAAa,cAEbA,EAAA,SAAW,YAEXA,EAAA,WAAa,cAEbA,EAAA,WAAa,cAEbA,EAAA,mBAAqB,uBAErBA,EAAA,qBAAuB,wBAEvBA,EAAA,mBAAqB,sBAErBA,EAAA,aAAe,gBAhBLA,QAAA,IA2GAC,QAEVA,EAAA,sBAAwB,4BAFdA,QAAA,IA2EAC,QAEVA,EAAA,iBAAmB,qBAEnBA,EAAA,QAAU,WAEVA,EAAA,gBAAkB,qBAElBA,EAAA,uBAAyB,2BAEzBA,EAAA,UAAY,aAEZA,EAAA,cAAgB,kBAEhBA,EAAA,cAAgB,iBAdNA,QAAA,IAoEAC,QAEVA,EAAA,iBAAmB,qBAEnBA,EAAA,QAAU,WAEVA,EAAA,gBAAkB,qBAElBA,EAAA,uBAAyB,2BAEzBA,EAAA,UAAY,aAEZA,EAAA,cAAgB,kBAEhBA,EAAA,cAAgB,iBAdNA,QAAA,IAssEAC,QAEVA,EAAA,eAAiB,kBAFPA,QAAA,IA8HAC,QAEVA,EAAA,iBAAmB,qBAEnBA,EAAA,WAAa,cAEbA,EAAA,gBAAkB,oBAElBA,EAAA,gBAAkB,oBAElBA,EAAA,cAAgB,kBAEhBA,EAAA,UAAY,aAEZA,EAAA,iBAAmB,qBAEnBA,EAAA,cAAgB,kBAEhBA,EAAA,UAAY,YAEZA,EAAA,OAAS,SAETA,EAAA,UAAY,YAEZA,EAAA,uBAAyB,2BAEzBA,EAAA,mBAAqB,sBAErBA,EAAA,KAAO,OA5BGA,QAAA,IAgHAC,QAEVA,EAAA,iBAAmB,qBAEnBA,EAAA,WAAa,cAEbA,EAAA,gBAAkB,oBAElBA,EAAA,gBAAkB,oBAElBA,EAAA,cAAgB,kBAEhBA,EAAA,UAAY,aAEZA,EAAA,iBAAmB,qBAEnBA,EAAA,cAAgB,kBAEhBA,EAAA,UAAY,YAEZA,EAAA,OAAS,SAETA,EAAA,UAAY,YAEZA,EAAA,uBAAyB,2BAEzBA,EAAA,mBAAqB,sBAErBA,EAAA,KAAO,OA5BGA,QAAA,IAkHAC,QAEVA,EAAA,eAAiB,mBAFPA,QAAA,IAoDAC,QAEVA,EAAA,MAAQ,QAERA,EAAA,OAAS,UAETA,EAAA,YAAc,eANJA,QAAA,IAgCAC,QAEVA,EAAA,MAAQ,QAERA,EAAA,OAAS,UAETA,EAAA,YAAc,eANJA,QAAA,IAuzFAC,QAEVA,EAAA,eAAiB,mBAFPA,QAAA,IAwGAC,QAEVA,EAAA,WAAa,cAEbA,EAAA,aAAe,gBAEfA,EAAA,WAAa,cAEbA,EAAA,UAAY,aAEZA,EAAA,IAAM,MAENA,EAAA,YAAc,eAEdA,EAAA,uBAAyB,2BAEzBA,EAAA,mBAAqB,sBAErBA,EAAA,oBAAsB,yBAlBZA,QAAA,IAoFAC,QAEVA,EAAA,WAAa,cAEbA,EAAA,aAAe,gBAEfA,EAAA,WAAa,cAEbA,EAAA,UAAY,aAEZA,EAAA,IAAM,MAENA,EAAA,YAAc,eAEdA,EAAA,uBAAyB,2BAEzBA,EAAA,mBAAqB,sBAErBA,EAAA,oBAAsB,yBAlBZA,QAAA,IA8LAC,QAEVA,EAAA,WAAa,cAEbA,EAAA,UAAY,aAEZA,EAAA,eAAiB,mBAEjBA,EAAA,iBAAmB,qBAEnBA,EAAA,IAAM,MAENA,EAAA,YAAc,eAEdA,EAAA,uBAAyB,2BAEzBA,EAAA,mBAAqB,sBAErBA,EAAA,oBAAsB,yBAlBZA,QAAA,IAwJAC,QAEVA,EAAA,mBAAqB,uBAFXA,QAAA,IA0DAC,QAEVA,EAAA,OAAS,SAETA,EAAA,WAAa,cAEbA,EAAA,QAAU,WAEVA,EAAA,UAAY,aARFA,QAAA,IAoCAC,QAEVA,EAAA,OAAS,SAETA,EAAA,WAAa,cAEbA,EAAA,QAAU,WAEVA,EAAA,UAAY,aARFA,QAAA,IAuHAC,QAEVA,EAAA,oBAAsB,wBAFZA,QAAA,IAoIAC,QAEVA,EAAA,WAAa,cAEbA,EAAA,SAAW,YAEXA,EAAA,qBAAuB,0BAEvBA,EAAA,eAAiB,kBAEjBA,EAAA,eAAiB,kBAEjBA,EAAA,oBAAsB,wBAEtBA,EAAA,oBAAsB,wBAEtBA,EAAA,WAAa,cAEbA,EAAA,oBAAsB,wBAEtBA,EAAA,YAAc,eAEdA,EAAA,WAAa,cAEbA,EAAA,KAAO,OAEPA,EAAA,gBAAkB,mBAElBA,EAAA,UAAY,aAEZA,EAAA,YAAc,eAEdA,EAAA,gBAAkB,qBAElBA,EAAA,qBAAuB,wBAEvBA,EAAA,mBAAqB,sBAErBA,EAAA,aAAe,gBAtCLA,QAAA,IA4IAC,QAEVA,EAAA,WAAa,cAEbA,EAAA,SAAW,YAEXA,EAAA,qBAAuB,0BAEvBA,EAAA,eAAiB,kBAEjBA,EAAA,eAAiB,kBAEjBA,EAAA,oBAAsB,wBAEtBA,EAAA,oBAAsB,wBAEtBA,EAAA,WAAa,cAEbA,EAAA,oBAAsB,wBAEtBA,EAAA,YAAc,eAEdA,EAAA,WAAa,cAEbA,EAAA,KAAO,OAEPA,EAAA,gBAAkB,mBAElBA,EAAA,UAAY,aAEZA,EAAA,YAAc,eAEdA,EAAA,gBAAkB,qBAElBA,EAAA,qBAAuB,wBAEvBA,EAAA,mBAAqB,sBAErBA,EAAA,aAAe,gBAtCLA,QAAA,IA6OAC,QAEVA,EAAA,sBAAwB,2BAFdA,QAAA,IA6JAC,QAEVA,EAAA,WAAa,cAEbA,EAAA,YAAc,eAEdA,EAAA,mBAAqB,wBAErBA,EAAA,oBAAsB,wBAEtBA,EAAA,WAAa,cAEbA,EAAA,YAAc,eAEdA,EAAA,WAAa,cAEbA,EAAA,aAAe,iBAEfA,EAAA,kBAAoB,sBAEpBA,EAAA,UAAY,aAEZA,EAAA,YAAc,eAEdA,EAAA,YAAc,gBAEdA,EAAA,cAAgB,iBAEhBA,EAAA,qBAAuB,wBAEvBA,EAAA,mBAAqB,sBAErBA,EAAA,KAAO,OAhCGA,QAAA,IAoCAC,QAEVA,EAAA,aAAe,iBAFLA,QAAA,IAMAC,QAEVA,EAAA,aAAe,iBAFLA,QAAA,IAsHAC,QAEVA,EAAA,WAAa,cAEbA,EAAA,YAAc,eAEdA,EAAA,mBAAqB,wBAErBA,EAAA,oBAAsB,wBAEtBA,EAAA,WAAa,cAEbA,EAAA,YAAc,eAEdA,EAAA,WAAa,cAEbA,EAAA,aAAe,iBAEfA,EAAA,kBAAoB,sBAEpBA,EAAA,UAAY,aAEZA,EAAA,YAAc,eAEdA,EAAA,YAAc,gBAEdA,EAAA,cAAgB,iBAEhBA,EAAA,qBAAuB,wBAEvBA,EAAA,mBAAqB,sBAErBA,EAAA,KAAO,OAhCGA,QAAA,IAoOAC,QAEVA,EAAA,eAAiB,mBAFPA,QAAA,IAqJAC,QAEVA,EAAA,qBAAuB,0BAEvBA,EAAA,eAAiB,kBAEjBA,EAAA,eAAiB,kBAEjBA,EAAA,kBAAoB,qBAEpBA,EAAA,YAAc,cAEdA,EAAA,mBAAqB,sBAErBA,EAAA,WAAa,cAEbA,EAAA,uBAAyB,2BAEzBA,EAAA,QAAU,UAEVA,EAAA,eAAiB,kBAEjBA,EAAA,YAAc,eAEdA,EAAA,KAAO,OAEPA,EAAA,aAAe,gBAEfA,EAAA,kBAAoB,qBAEpBA,EAAA,eAAiB,kBAEjBA,EAAA,yBAA2B,6BAE3BA,EAAA,uBAAyB,2BAEzBA,EAAA,OAAS,SAETA,EAAA,gBAAkB,qBAElBA,EAAA,qBAAuB,wBAEvBA,EAAA,mBAAqB,sBAErBA,EAAA,WAAa,cA5CHA,QAAA,IAoJAC,QAEVA,EAAA,qBAAuB,0BAEvBA,EAAA,eAAiB,kBAEjBA,EAAA,eAAiB,kBAEjBA,EAAA,kBAAoB,qBAEpBA,EAAA,YAAc,cAEdA,EAAA,mBAAqB,sBAErBA,EAAA,WAAa,cAEbA,EAAA,uBAAyB,2BAEzBA,EAAA,QAAU,UAEVA,EAAA,eAAiB,kBAEjBA,EAAA,YAAc,eAEdA,EAAA,KAAO,OAEPA,EAAA,aAAe,gBAEfA,EAAA,kBAAoB,qBAEpBA,EAAA,eAAiB,kBAEjBA,EAAA,yBAA2B,6BAE3BA,EAAA,uBAAyB,2BAEzBA,EAAA,OAAS,SAETA,EAAA,gBAAkB,qBAElBA,EAAA,qBAAuB,wBAEvBA,EAAA,mBAAqB,sBAErBA,EAAA,WAAa,cA5CHA,QAAA,IA+JAC,QAEVA,EAAA,iBAAmB,sBAFTA,QAAA,IAuIAC,QAEVA,EAAA,aAAe,gBAEfA,EAAA,SAAW,WAEXA,EAAA,YAAc,cAEdA,EAAA,WAAa,cAEbA,EAAA,YAAc,gBAEdA,EAAA,aAAe,iBAEfA,EAAA,yBAA2B,8BAE3BA,EAAA,QAAU,UAEVA,EAAA,OAAS,SAETA,EAAA,YAAc,gBAEdA,EAAA,UAAY,aAEZA,EAAA,gBAAkB,mBAElBA,EAAA,cAAgB,iBAEhBA,EAAA,SAAW,YAEXA,EAAA,qBAAuB,wBAEvBA,EAAA,mBAAqB,sBAErBA,EAAA,oBAAsB,yBAlCZA,QAAA,IAgIAC,QAEVA,EAAA,aAAe,gBAEfA,EAAA,SAAW,WAEXA,EAAA,YAAc,cAEdA,EAAA,WAAa,cAEbA,EAAA,YAAc,gBAEdA,EAAA,aAAe,iBAEfA,EAAA,yBAA2B,8BAE3BA,EAAA,QAAU,UAEVA,EAAA,OAAS,SAETA,EAAA,YAAc,gBAEdA,EAAA,UAAY,aAEZA,EAAA,gBAAkB,mBAElBA,EAAA,cAAgB,iBAEhBA,EAAA,SAAW,YAEXA,EAAA,qBAAuB,wBAEvBA,EAAA,mBAAqB,sBAErBA,EAAA,oBAAsB,yBAlCZA,QAAA,IA4LAC,QAEVA,EAAA,oBAAsB,wBAFZA,QAAA,IAwGAC,QAEVA,EAAA,OAAS,SAETA,EAAA,qBAAuB,0BAEvBA,EAAA,eAAiB,kBAEjBA,EAAA,eAAiB,kBAEjBA,EAAA,WAAa,cAEbA,EAAA,KAAO,OAEPA,EAAA,aAAe,gBAEfA,EAAA,gBAAkB,mBAElBA,EAAA,YAAc,eAEdA,EAAA,UAAY,aAEZA,EAAA,gBAAkB,qBAElBA,EAAA,qBAAuB,wBAEvBA,EAAA,mBAAqB,sBA1BXA,QAAA,IAoGAC,QAEVA,EAAA,OAAS,SAETA,EAAA,qBAAuB,0BAEvBA,EAAA,eAAiB,kBAEjBA,EAAA,eAAiB,kBAEjBA,EAAA,WAAa,cAEbA,EAAA,KAAO,OAEPA,EAAA,aAAe,gBAEfA,EAAA,gBAAkB,mBAElBA,EAAA,YAAc,eAEdA,EAAA,UAAY,aAEZA,EAAA,gBAAkB,qBAElBA,EAAA,qBAAuB,wBAEvBA,EAAA,mBAAqB,sBA1BXA,QAAA,IA6HAC,QAEVA,EAAA,sBAAwB,2BAFdA,QAAA,IA2HAC,QAEVA,EAAA,OAAS,SAETA,EAAA,WAAa,cAEbA,EAAA,aAAe,iBAEfA,EAAA,cAAgB,kBAEhBA,EAAA,wBAA0B,6BAE1BA,EAAA,aAAe,gBAEfA,EAAA,kBAAoB,sBAEpBA,EAAA,UAAY,aAEZA,EAAA,YAAc,gBAEdA,EAAA,YAAc,gBAEdA,EAAA,yBAA2B,8BAE3BA,EAAA,cAAgB,iBAEhBA,EAAA,qBAAuB,wBAEvBA,EAAA,mBAAqB,sBAErBA,EAAA,oBAAsB,yBA9BZA,QAAA,IAgHAC,QAEVA,EAAA,OAAS,SAETA,EAAA,WAAa,cAEbA,EAAA,aAAe,iBAEfA,EAAA,cAAgB,kBAEhBA,EAAA,wBAA0B,6BAE1BA,EAAA,aAAe,gBAEfA,EAAA,kBAAoB,sBAEpBA,EAAA,UAAY,aAEZA,EAAA,YAAc,gBAEdA,EAAA,YAAc,gBAEdA,EAAA,yBAA2B,8BAE3BA,EAAA,cAAgB,iBAEhBA,EAAA,qBAAuB,wBAEvBA,EAAA,mBAAqB,sBAErBA,EAAA,oBAAsB,yBA9BZA,QAAA,IA4KAC,QAEVA,EAAA,WAAa,cAFHA,QAAA,IA4GAC,QAEVA,EAAA,qBAAuB,0BAEvBA,EAAA,eAAiB,kBAEjBA,EAAA,eAAiB,kBAEjBA,EAAA,WAAa,cAEbA,EAAA,KAAO,OAEPA,EAAA,gBAAkB,mBAElBA,EAAA,gBAAkB,qBAElBA,EAAA,gBAAkB,mBAElBA,EAAA,qBAAuB,wBAEvBA,EAAA,mBAAqB,sBApBXA,QAAA,IAoFAC,QAEVA,EAAA,qBAAuB,0BAEvBA,EAAA,eAAiB,kBAEjBA,EAAA,eAAiB,kBAEjBA,EAAA,WAAa,cAEbA,EAAA,KAAO,OAEPA,EAAA,gBAAkB,mBAElBA,EAAA,gBAAkB,qBAElBA,EAAA,gBAAkB,mBAElBA,EAAA,qBAAuB,wBAEvBA,EAAA,mBAAqB,sBApBXA,QAAA,IA+GAC,QAEVA,EAAA,wBAA0B,6BAFhBA,QAAA,IA4DAC,QAEVA,EAAA,WAAa,cAEbA,EAAA,UAAY,aAEZA,EAAA,mBAAqB,sBANXA,QAAA,IAwDAC,QAEVA,EAAA,WAAa,cAEbA,EAAA,UAAY,aAEZA,EAAA,mBAAqB,sBANXA,QAAA,IA6MAC,QAEVA,EAAA,oBAAsB,wBAEtBA,EAAA,YAAc,eAEdA,EAAA,cAAgB,kBAEhBA,EAAA,QAAU,WAEVA,EAAA,KAAO,OAEPA,EAAA,WAAa,cAEbA,EAAA,YAAc,eAEdA,EAAA,UAAY,aAEZA,EAAA,mBAAqB,wBAErBA,EAAA,gBAAkB,oBAElBA,EAAA,oBAAsB,wBAEtBA,EAAA,QAAU,UAEVA,EAAA,KAAO,OAEPA,EAAA,QAAU,UAEVA,EAAA,SAAW,YA9BDA,QAAA,IAsOAC,QAEVA,EAAA,qBAAuB,yBAEvBA,EAAA,wCAA0C,+CAJhCA,QAAA,IAyHAC,QAEVA,EAAA,YAAc,eAEdA,EAAA,6BAA+B,kCAE/BA,EAAA,0BAA4B,+BAE5BA,EAAA,mBAAqB,wBAErBA,EAAA,wBAA0B,6BAE1BA,EAAA,MAAQ,QAERA,EAAA,wBAA0B,4BAE1BA,EAAA,aAAe,iBAEfA,EAAA,WAAa,cAEbA,EAAA,aAAe,iBAEfA,EAAA,oBAAsB,wBAEtBA,EAAA,OAAS,SAETA,EAAA,eAAiB,kBAEjBA,EAAA,UAAY,YAEZA,EAAA,QAAU,UA9BAA,QAAA,IAwHAC,QAEVA,EAAA,YAAc,eAEdA,EAAA,6BAA+B,kCAE/BA,EAAA,0BAA4B,+BAE5BA,EAAA,mBAAqB,wBAErBA,EAAA,wBAA0B,6BAE1BA,EAAA,MAAQ,QAERA,EAAA,wBAA0B,4BAE1BA,EAAA,aAAe,iBAEfA,EAAA,WAAa,cAEbA,EAAA,aAAe,iBAEfA,EAAA,oBAAsB,wBAEtBA,EAAA,OAAS,SAETA,EAAA,eAAiB,kBAEjBA,EAAA,UAAY,YAEZA,EAAA,QAAU,UA9BAA,QAAA","names":["AccountTransactionsConstraint","AccountTransactionsSelectColumn","AccountTransactionsUpdateColumn","AddressEventsSummarySelectColumn","AddressVersionFromEventsSelectColumn","AddressVersionFromMoveResourcesSelectColumn","AnsLookupConstraint","AnsLookupSelectColumn","AnsLookupUpdateColumn","AnsLookupV2Constraint","AnsLookupV2SelectColumn","AnsLookupV2UpdateColumn","AnsPrimaryNameConstraint","AnsPrimaryNameSelectColumn","AnsPrimaryNameUpdateColumn","AnsPrimaryNameV2Constraint","AnsPrimaryNameV2SelectColumn","AnsPrimaryNameV2UpdateColumn","AuthKeyAccountAddressesConstraint","AuthKeyAccountAddressesSelectColumn","AuthKeyAccountAddressesUpdateColumn","BlockMetadataTransactionsConstraint","BlockMetadataTransactionsSelectColumn","BlockMetadataTransactionsUpdateColumn","CoinActivitiesConstraint","CoinActivitiesSelectColumn","CoinActivitiesUpdateColumn","CoinBalancesConstraint","CoinBalancesSelectColumn","CoinBalancesUpdateColumn","CoinInfosConstraint","CoinInfosSelectColumn","CoinInfosUpdateColumn","CoinSupplyConstraint","CoinSupplySelectColumn","CoinSupplyUpdateColumn","CollectionDatasConstraint","CollectionDatasSelectColumn","CollectionDatasUpdateColumn","CollectionsV2Constraint","CollectionsV2SelectColumn","CollectionsV2UpdateColumn","CurrentAnsLookupConstraint","CurrentAnsLookupSelectColumn","CurrentAnsLookupUpdateColumn","CurrentAnsLookupV2Constraint","CurrentAnsLookupV2SelectColumn","CurrentAnsLookupV2UpdateColumn","CurrentAnsPrimaryNameConstraint","CurrentAnsPrimaryNameSelectColumn","CurrentAnsPrimaryNameUpdateColumn","CurrentAnsPrimaryNameV2Constraint","CurrentAnsPrimaryNameV2SelectColumn","CurrentAnsPrimaryNameV2UpdateColumn","CurrentCedraNamesSelectColumn","CurrentCedraNamesSelectColumnCurrentCedraNamesAggregateBoolExpBoolAndArgumentsColumns","CurrentCedraNamesSelectColumnCurrentCedraNamesAggregateBoolExpBoolOrArgumentsColumns","CurrentCoinBalancesConstraint","CurrentCoinBalancesSelectColumn","CurrentCoinBalancesUpdateColumn","CurrentCollectionDatasConstraint","CurrentCollectionDatasSelectColumn","CurrentCollectionDatasUpdateColumn","CurrentCollectionOwnershipV2ViewSelectColumn","CurrentCollectionOwnershipViewSelectColumn","CurrentCollectionsV2Constraint","CurrentCollectionsV2SelectColumn","CurrentCollectionsV2UpdateColumn","CurrentDelegatedStakingPoolBalancesConstraint","CurrentDelegatedStakingPoolBalancesSelectColumn","CurrentDelegatedStakingPoolBalancesUpdateColumn","CurrentDelegatedVoterConstraint","CurrentDelegatedVoterSelectColumn","CurrentDelegatedVoterUpdateColumn","CurrentDelegatorBalancesConstraint","CurrentDelegatorBalancesSelectColumn","CurrentDelegatorBalancesUpdateColumn","CurrentFungibleAssetBalancesConstraint","CurrentFungibleAssetBalancesNewConstraint","CurrentFungibleAssetBalancesNewSelectColumn","CurrentFungibleAssetBalancesNewUpdateColumn","CurrentFungibleAssetBalancesSelectColumn","CurrentFungibleAssetBalancesUpdateColumn","CurrentObjectsConstraint","CurrentObjectsSelectColumn","CurrentObjectsUpdateColumn","CurrentStakingPoolVoterConstraint","CurrentStakingPoolVoterSelectColumn","CurrentStakingPoolVoterUpdateColumn","CurrentTableItemsConstraint","CurrentTableItemsSelectColumn","CurrentTableItemsUpdateColumn","CurrentTableItemsViewSelectColumn","CurrentTokenDatasConstraint","CurrentTokenDatasSelectColumn","CurrentTokenDatasUpdateColumn","CurrentTokenDatasV2Constraint","CurrentTokenDatasV2SelectColumn","CurrentTokenDatasV2UpdateColumn","CurrentTokenOwnershipsConstraint","CurrentTokenOwnershipsSelectColumn","CurrentTokenOwnershipsUpdateColumn","CurrentTokenOwnershipsV2Constraint","CurrentTokenOwnershipsV2SelectColumn","CurrentTokenOwnershipsV2SelectColumnCurrentTokenOwnershipsV2AggregateBoolExpBoolAndArgumentsColumns","CurrentTokenOwnershipsV2SelectColumnCurrentTokenOwnershipsV2AggregateBoolExpBoolOrArgumentsColumns","CurrentTokenOwnershipsV2UpdateColumn","CurrentTokenPendingClaimsConstraint","CurrentTokenPendingClaimsSelectColumn","CurrentTokenPendingClaimsUpdateColumn","CurrentTokenRoyaltyV1Constraint","CurrentTokenRoyaltyV1SelectColumn","CurrentTokenRoyaltyV1UpdateColumn","CurrentTokenV2MetadataConstraint","CurrentTokenV2MetadataSelectColumn","CurrentTokenV2MetadataUpdateColumn","CursorOrdering","DelegatedStakingActivitiesConstraint","DelegatedStakingActivitiesSelectColumn","DelegatedStakingActivitiesUpdateColumn","DelegatedStakingPoolBalancesConstraint","DelegatedStakingPoolBalancesSelectColumn","DelegatedStakingPoolBalancesUpdateColumn","DelegatedStakingPoolsConstraint","DelegatedStakingPoolsSelectColumn","DelegatedStakingPoolsUpdateColumn","DelegatorBalancesConstraint","DelegatorBalancesSelectColumn","DelegatorBalancesUpdateColumn","DelegatorDistinctPoolSelectColumn","EventSizeInfoConstraint","EventSizeInfoSelectColumn","EventSizeInfoUpdateColumn","EventsConstraint","EventsSelectColumn","EventsUpdateColumn","EventsViewSelectColumn","FungibleAssetActivitiesConstraint","FungibleAssetActivitiesSelectColumn","FungibleAssetActivitiesSelectColumnFungibleAssetActivitiesAggregateBoolExpBoolAndArgumentsColumns","FungibleAssetActivitiesSelectColumnFungibleAssetActivitiesAggregateBoolExpBoolOrArgumentsColumns","FungibleAssetActivitiesUpdateColumn","FungibleAssetBalancesConstraint","FungibleAssetBalancesSelectColumn","FungibleAssetBalancesUpdateColumn","FungibleAssetMetadataConstraint","FungibleAssetMetadataSelectColumn","FungibleAssetMetadataUpdateColumn","FungibleAssetToCoinMappingsConstraint","FungibleAssetToCoinMappingsSelectColumn","FungibleAssetToCoinMappingsUpdateColumn","GasFeesConstraint","GasFeesSelectColumn","GasFeesUpdateColumn","IndexerStatusConstraint","IndexerStatusSelectColumn","IndexerStatusUpdateColumn","MoveModulesConstraint","MoveModulesSelectColumn","MoveModulesUpdateColumn","MoveResourcesConstraint","MoveResourcesSelectColumn","MoveResourcesUpdateColumn","MoveResourcesViewSelectColumn","NftMetadataCrawlerParsedAssetUrisConstraint","NftMetadataCrawlerParsedAssetUrisSelectColumn","NftMetadataCrawlerParsedAssetUrisUpdateColumn","NftPointsConstraint","NftPointsSelectColumn","NftPointsUpdateColumn","NumActiveDelegatorPerPoolSelectColumn","ObjectsConstraint","ObjectsSelectColumn","ObjectsUpdateColumn","OrderBy","ProcessorMetadataProcessorStatusConstraint","ProcessorMetadataProcessorStatusSelectColumn","ProcessorMetadataProcessorStatusUpdateColumn","ProcessorStatusConstraint","ProcessorStatusSelectColumn","ProcessorStatusUpdateColumn","ProposalVotesConstraint","ProposalVotesSelectColumn","ProposalVotesUpdateColumn","PublicKeyAuthKeysConstraint","PublicKeyAuthKeysSelectColumn","PublicKeyAuthKeysUpdateColumn","SignaturesConstraint","SignaturesSelectColumn","SignaturesUpdateColumn","SpamAssetsConstraint","SpamAssetsSelectColumn","SpamAssetsUpdateColumn","TableItemsConstraint","TableItemsSelectColumn","TableItemsUpdateColumn","TableItemsViewSelectColumn","TableMetadatasConstraint","TableMetadatasSelectColumn","TableMetadatasUpdateColumn","TokenActivitiesConstraint","TokenActivitiesSelectColumn","TokenActivitiesUpdateColumn","TokenActivitiesV2Constraint","TokenActivitiesV2SelectColumn","TokenActivitiesV2SelectColumnTokenActivitiesV2AggregateBoolExpBoolAndArgumentsColumns","TokenActivitiesV2SelectColumnTokenActivitiesV2AggregateBoolExpBoolOrArgumentsColumns","TokenActivitiesV2UpdateColumn","TokenDatasConstraint","TokenDatasSelectColumn","TokenDatasUpdateColumn","TokenDatasV2Constraint","TokenDatasV2SelectColumn","TokenDatasV2UpdateColumn","TokenOwnershipsConstraint","TokenOwnershipsSelectColumn","TokenOwnershipsUpdateColumn","TokenOwnershipsV2Constraint","TokenOwnershipsV2SelectColumn","TokenOwnershipsV2UpdateColumn","TokensConstraint","TokensSelectColumn","TokensUpdateColumn","TransactionSizeInfoConstraint","TransactionSizeInfoSelectColumn","TransactionSizeInfoUpdateColumn","TransactionsViewSelectColumn","UserTransactionsConstraint","UserTransactionsSelectColumn","UserTransactionsUpdateColumn"]}