type Maybe<T> = T | null;
type InputMaybe<T> = Maybe<T>;
type Exact<T extends {
    [key: string]: unknown;
}> = {
    [K in keyof T]: T[K];
};
type MakeOptional<T, K extends keyof T> = Omit<T, K> & {
    [SubKey in K]?: Maybe<T[SubKey]>;
};
type MakeMaybe<T, K extends keyof T> = Omit<T, K> & {
    [SubKey in K]: Maybe<T[SubKey]>;
};
type MakeEmpty<T extends {
    [key: string]: unknown;
}, K extends keyof T> = {
    [_ in K]?: never;
};
type Incremental<T> = T | {
    [P in keyof T]?: P extends " $fragmentName" | "__typename" ? T[P] : never;
};
/** All built-in and custom scalars, mapped to their actual values */
type Scalars = {
    ID: {
        input: string;
        output: string;
    };
    String: {
        input: string;
        output: string;
    };
    Boolean: {
        input: boolean;
        output: boolean;
    };
    Int: {
        input: number;
        output: number;
    };
    Float: {
        input: number;
        output: number;
    };
    bigint: {
        input: any;
        output: any;
    };
    bytea: {
        input: any;
        output: any;
    };
    jsonb: {
        input: any;
        output: any;
    };
    numeric: {
        input: any;
        output: any;
    };
    timestamp: {
        input: any;
        output: any;
    };
};
/** Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'. */
type BooleanComparisonExp = {
    _eq?: InputMaybe<Scalars["Boolean"]["input"]>;
    _gt?: InputMaybe<Scalars["Boolean"]["input"]>;
    _gte?: InputMaybe<Scalars["Boolean"]["input"]>;
    _in?: InputMaybe<Array<Scalars["Boolean"]["input"]>>;
    _is_null?: InputMaybe<Scalars["Boolean"]["input"]>;
    _lt?: InputMaybe<Scalars["Boolean"]["input"]>;
    _lte?: InputMaybe<Scalars["Boolean"]["input"]>;
    _neq?: InputMaybe<Scalars["Boolean"]["input"]>;
    _nin?: InputMaybe<Array<Scalars["Boolean"]["input"]>>;
};
/** Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'. */
type IntComparisonExp = {
    _eq?: InputMaybe<Scalars["Int"]["input"]>;
    _gt?: InputMaybe<Scalars["Int"]["input"]>;
    _gte?: InputMaybe<Scalars["Int"]["input"]>;
    _in?: InputMaybe<Array<Scalars["Int"]["input"]>>;
    _is_null?: InputMaybe<Scalars["Boolean"]["input"]>;
    _lt?: InputMaybe<Scalars["Int"]["input"]>;
    _lte?: InputMaybe<Scalars["Int"]["input"]>;
    _neq?: InputMaybe<Scalars["Int"]["input"]>;
    _nin?: InputMaybe<Array<Scalars["Int"]["input"]>>;
};
/** Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'. */
type StringComparisonExp = {
    _eq?: InputMaybe<Scalars["String"]["input"]>;
    _gt?: InputMaybe<Scalars["String"]["input"]>;
    _gte?: InputMaybe<Scalars["String"]["input"]>;
    /** does the column match the given case-insensitive pattern */
    _ilike?: InputMaybe<Scalars["String"]["input"]>;
    _in?: InputMaybe<Array<Scalars["String"]["input"]>>;
    /** does the column match the given POSIX regular expression, case insensitive */
    _iregex?: InputMaybe<Scalars["String"]["input"]>;
    _is_null?: InputMaybe<Scalars["Boolean"]["input"]>;
    /** does the column match the given pattern */
    _like?: InputMaybe<Scalars["String"]["input"]>;
    _lt?: InputMaybe<Scalars["String"]["input"]>;
    _lte?: InputMaybe<Scalars["String"]["input"]>;
    _neq?: InputMaybe<Scalars["String"]["input"]>;
    /** does the column NOT match the given case-insensitive pattern */
    _nilike?: InputMaybe<Scalars["String"]["input"]>;
    _nin?: InputMaybe<Array<Scalars["String"]["input"]>>;
    /** does the column NOT match the given POSIX regular expression, case insensitive */
    _niregex?: InputMaybe<Scalars["String"]["input"]>;
    /** does the column NOT match the given pattern */
    _nlike?: InputMaybe<Scalars["String"]["input"]>;
    /** does the column NOT match the given POSIX regular expression, case sensitive */
    _nregex?: InputMaybe<Scalars["String"]["input"]>;
    /** does the column NOT match the given SQL regular expression */
    _nsimilar?: InputMaybe<Scalars["String"]["input"]>;
    /** does the column match the given POSIX regular expression, case sensitive */
    _regex?: InputMaybe<Scalars["String"]["input"]>;
    /** does the column match the given SQL regular expression */
    _similar?: InputMaybe<Scalars["String"]["input"]>;
};
/** columns and relationships of "account_transactions" */
type AccountTransactions = {
    account_address: Scalars["String"]["output"];
    /** fetch data from the table: "delegated_staking_activities" */
    delegated_staking_activities: Array<DelegatedStakingActivities>;
    /** fetch aggregated fields from the table: "delegated_staking_activities" */
    delegated_staking_activities_aggregate: DelegatedStakingActivitiesAggregate;
    /** fetch data from the table: "fungible_asset_activities" */
    fungible_asset_activities: Array<FungibleAssetActivities>;
    /** fetch aggregated fields from the table: "fungible_asset_activities" */
    fungible_asset_activities_aggregate: FungibleAssetActivitiesAggregate;
    inserted_at: Scalars["timestamp"]["output"];
    /** fetch data from the table: "token_activities_v2" */
    token_activities_v2: Array<TokenActivitiesV2>;
    /** fetch aggregated fields from the table: "token_activities_v2" */
    token_activities_v2_aggregate: TokenActivitiesV2Aggregate;
    transaction_version: Scalars["bigint"]["output"];
    /** An object relationship */
    user_transaction?: Maybe<UserTransactions>;
};
/** columns and relationships of "account_transactions" */
type AccountTransactionsDelegatedStakingActivitiesArgs = {
    distinct_on?: InputMaybe<Array<DelegatedStakingActivitiesSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<DelegatedStakingActivitiesOrderBy>>;
    where?: InputMaybe<DelegatedStakingActivitiesBoolExp>;
};
/** columns and relationships of "account_transactions" */
type AccountTransactionsDelegatedStakingActivitiesAggregateArgs = {
    distinct_on?: InputMaybe<Array<DelegatedStakingActivitiesSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<DelegatedStakingActivitiesOrderBy>>;
    where?: InputMaybe<DelegatedStakingActivitiesBoolExp>;
};
/** columns and relationships of "account_transactions" */
type AccountTransactionsFungibleAssetActivitiesArgs = {
    distinct_on?: InputMaybe<Array<FungibleAssetActivitiesSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<FungibleAssetActivitiesOrderBy>>;
    where?: InputMaybe<FungibleAssetActivitiesBoolExp>;
};
/** columns and relationships of "account_transactions" */
type AccountTransactionsFungibleAssetActivitiesAggregateArgs = {
    distinct_on?: InputMaybe<Array<FungibleAssetActivitiesSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<FungibleAssetActivitiesOrderBy>>;
    where?: InputMaybe<FungibleAssetActivitiesBoolExp>;
};
/** columns and relationships of "account_transactions" */
type AccountTransactionsTokenActivitiesV2Args = {
    distinct_on?: InputMaybe<Array<TokenActivitiesV2SelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<TokenActivitiesV2OrderBy>>;
    where?: InputMaybe<TokenActivitiesV2BoolExp>;
};
/** columns and relationships of "account_transactions" */
type AccountTransactionsTokenActivitiesV2AggregateArgs = {
    distinct_on?: InputMaybe<Array<TokenActivitiesV2SelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<TokenActivitiesV2OrderBy>>;
    where?: InputMaybe<TokenActivitiesV2BoolExp>;
};
/** aggregated selection of "account_transactions" */
type AccountTransactionsAggregate = {
    aggregate?: Maybe<AccountTransactionsAggregateFields>;
    nodes: Array<AccountTransactions>;
};
/** aggregate fields of "account_transactions" */
type AccountTransactionsAggregateFields = {
    avg?: Maybe<AccountTransactionsAvgFields>;
    count: Scalars["Int"]["output"];
    max?: Maybe<AccountTransactionsMaxFields>;
    min?: Maybe<AccountTransactionsMinFields>;
    stddev?: Maybe<AccountTransactionsStddevFields>;
    stddev_pop?: Maybe<AccountTransactionsStddevPopFields>;
    stddev_samp?: Maybe<AccountTransactionsStddevSampFields>;
    sum?: Maybe<AccountTransactionsSumFields>;
    var_pop?: Maybe<AccountTransactionsVarPopFields>;
    var_samp?: Maybe<AccountTransactionsVarSampFields>;
    variance?: Maybe<AccountTransactionsVarianceFields>;
};
/** aggregate fields of "account_transactions" */
type AccountTransactionsAggregateFieldsCountArgs = {
    columns?: InputMaybe<Array<AccountTransactionsSelectColumn>>;
    distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};
/** aggregate avg on columns */
type AccountTransactionsAvgFields = {
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** Boolean expression to filter rows from the table "account_transactions". All fields are combined with a logical 'AND'. */
type AccountTransactionsBoolExp = {
    _and?: InputMaybe<Array<AccountTransactionsBoolExp>>;
    _not?: InputMaybe<AccountTransactionsBoolExp>;
    _or?: InputMaybe<Array<AccountTransactionsBoolExp>>;
    account_address?: InputMaybe<StringComparisonExp>;
    delegated_staking_activities?: InputMaybe<DelegatedStakingActivitiesBoolExp>;
    delegated_staking_activities_aggregate?: InputMaybe<DelegatedStakingActivitiesAggregateBoolExp>;
    fungible_asset_activities?: InputMaybe<FungibleAssetActivitiesBoolExp>;
    fungible_asset_activities_aggregate?: InputMaybe<FungibleAssetActivitiesAggregateBoolExp>;
    inserted_at?: InputMaybe<TimestampComparisonExp>;
    token_activities_v2?: InputMaybe<TokenActivitiesV2BoolExp>;
    token_activities_v2_aggregate?: InputMaybe<TokenActivitiesV2AggregateBoolExp>;
    transaction_version?: InputMaybe<BigintComparisonExp>;
    user_transaction?: InputMaybe<UserTransactionsBoolExp>;
};
/** unique or primary key constraints on table "account_transactions" */
declare enum AccountTransactionsConstraint {
    /** unique or primary key constraint on columns "account_address", "transaction_version" */
    AccountTransactionsPkey = "account_transactions_pkey"
}
/** input type for incrementing numeric columns in table "account_transactions" */
type AccountTransactionsIncInput = {
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** input type for inserting data into table "account_transactions" */
type AccountTransactionsInsertInput = {
    account_address?: InputMaybe<Scalars["String"]["input"]>;
    delegated_staking_activities?: InputMaybe<DelegatedStakingActivitiesArrRelInsertInput>;
    fungible_asset_activities?: InputMaybe<FungibleAssetActivitiesArrRelInsertInput>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    token_activities_v2?: InputMaybe<TokenActivitiesV2ArrRelInsertInput>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    user_transaction?: InputMaybe<UserTransactionsObjRelInsertInput>;
};
/** aggregate max on columns */
type AccountTransactionsMaxFields = {
    account_address?: Maybe<Scalars["String"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};
/** aggregate min on columns */
type AccountTransactionsMinFields = {
    account_address?: Maybe<Scalars["String"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};
/** response of any mutation on the table "account_transactions" */
type AccountTransactionsMutationResponse = {
    /** number of rows affected by the mutation */
    affected_rows: Scalars["Int"]["output"];
    /** data from the rows affected by the mutation */
    returning: Array<AccountTransactions>;
};
/** on_conflict condition type for table "account_transactions" */
type AccountTransactionsOnConflict = {
    constraint: AccountTransactionsConstraint;
    update_columns?: Array<AccountTransactionsUpdateColumn>;
    where?: InputMaybe<AccountTransactionsBoolExp>;
};
/** Ordering options when selecting data from "account_transactions". */
type AccountTransactionsOrderBy = {
    account_address?: InputMaybe<OrderBy>;
    delegated_staking_activities_aggregate?: InputMaybe<DelegatedStakingActivitiesAggregateOrderBy>;
    fungible_asset_activities_aggregate?: InputMaybe<FungibleAssetActivitiesAggregateOrderBy>;
    inserted_at?: InputMaybe<OrderBy>;
    token_activities_v2_aggregate?: InputMaybe<TokenActivitiesV2AggregateOrderBy>;
    transaction_version?: InputMaybe<OrderBy>;
    user_transaction?: InputMaybe<UserTransactionsOrderBy>;
};
/** primary key columns input for table: account_transactions */
type AccountTransactionsPkColumnsInput = {
    account_address: Scalars["String"]["input"];
    transaction_version: Scalars["bigint"]["input"];
};
/** select columns of table "account_transactions" */
declare enum AccountTransactionsSelectColumn {
    /** column name */
    AccountAddress = "account_address",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    TransactionVersion = "transaction_version"
}
/** input type for updating data in table "account_transactions" */
type AccountTransactionsSetInput = {
    account_address?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** aggregate stddev on columns */
type AccountTransactionsStddevFields = {
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_pop on columns */
type AccountTransactionsStddevPopFields = {
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_samp on columns */
type AccountTransactionsStddevSampFields = {
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** Streaming cursor of the table "account_transactions" */
type AccountTransactionsStreamCursorInput = {
    /** Stream column input with initial value */
    initial_value: AccountTransactionsStreamCursorValueInput;
    /** cursor ordering */
    ordering?: InputMaybe<CursorOrdering>;
};
/** Initial value of the column from where the streaming should start */
type AccountTransactionsStreamCursorValueInput = {
    account_address?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** aggregate sum on columns */
type AccountTransactionsSumFields = {
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};
/** update columns of table "account_transactions" */
declare enum AccountTransactionsUpdateColumn {
    /** column name */
    AccountAddress = "account_address",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    TransactionVersion = "transaction_version"
}
type AccountTransactionsUpdates = {
    /** increments the numeric columns with given value of the filtered values */
    _inc?: InputMaybe<AccountTransactionsIncInput>;
    /** sets the columns of the filtered rows to the given values */
    _set?: InputMaybe<AccountTransactionsSetInput>;
    /** filter the rows which have to be updated */
    where: AccountTransactionsBoolExp;
};
/** aggregate var_pop on columns */
type AccountTransactionsVarPopFields = {
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate var_samp on columns */
type AccountTransactionsVarSampFields = {
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate variance on columns */
type AccountTransactionsVarianceFields = {
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** columns and relationships of "address_events_summary" */
type AddressEventsSummary = {
    account_address?: Maybe<Scalars["String"]["output"]>;
    /** An object relationship */
    block_metadata?: Maybe<BlockMetadataTransactions>;
    min_block_height?: Maybe<Scalars["bigint"]["output"]>;
    num_distinct_versions?: Maybe<Scalars["bigint"]["output"]>;
};
/** aggregated selection of "address_events_summary" */
type AddressEventsSummaryAggregate = {
    aggregate?: Maybe<AddressEventsSummaryAggregateFields>;
    nodes: Array<AddressEventsSummary>;
};
/** aggregate fields of "address_events_summary" */
type AddressEventsSummaryAggregateFields = {
    avg?: Maybe<AddressEventsSummaryAvgFields>;
    count: Scalars["Int"]["output"];
    max?: Maybe<AddressEventsSummaryMaxFields>;
    min?: Maybe<AddressEventsSummaryMinFields>;
    stddev?: Maybe<AddressEventsSummaryStddevFields>;
    stddev_pop?: Maybe<AddressEventsSummaryStddevPopFields>;
    stddev_samp?: Maybe<AddressEventsSummaryStddevSampFields>;
    sum?: Maybe<AddressEventsSummarySumFields>;
    var_pop?: Maybe<AddressEventsSummaryVarPopFields>;
    var_samp?: Maybe<AddressEventsSummaryVarSampFields>;
    variance?: Maybe<AddressEventsSummaryVarianceFields>;
};
/** aggregate fields of "address_events_summary" */
type AddressEventsSummaryAggregateFieldsCountArgs = {
    columns?: InputMaybe<Array<AddressEventsSummarySelectColumn>>;
    distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};
/** aggregate avg on columns */
type AddressEventsSummaryAvgFields = {
    min_block_height?: Maybe<Scalars["Float"]["output"]>;
    num_distinct_versions?: Maybe<Scalars["Float"]["output"]>;
};
/** Boolean expression to filter rows from the table "address_events_summary". All fields are combined with a logical 'AND'. */
type AddressEventsSummaryBoolExp = {
    _and?: InputMaybe<Array<AddressEventsSummaryBoolExp>>;
    _not?: InputMaybe<AddressEventsSummaryBoolExp>;
    _or?: InputMaybe<Array<AddressEventsSummaryBoolExp>>;
    account_address?: InputMaybe<StringComparisonExp>;
    block_metadata?: InputMaybe<BlockMetadataTransactionsBoolExp>;
    min_block_height?: InputMaybe<BigintComparisonExp>;
    num_distinct_versions?: InputMaybe<BigintComparisonExp>;
};
/** aggregate max on columns */
type AddressEventsSummaryMaxFields = {
    account_address?: Maybe<Scalars["String"]["output"]>;
    min_block_height?: Maybe<Scalars["bigint"]["output"]>;
    num_distinct_versions?: Maybe<Scalars["bigint"]["output"]>;
};
/** aggregate min on columns */
type AddressEventsSummaryMinFields = {
    account_address?: Maybe<Scalars["String"]["output"]>;
    min_block_height?: Maybe<Scalars["bigint"]["output"]>;
    num_distinct_versions?: Maybe<Scalars["bigint"]["output"]>;
};
/** Ordering options when selecting data from "address_events_summary". */
type AddressEventsSummaryOrderBy = {
    account_address?: InputMaybe<OrderBy>;
    block_metadata?: InputMaybe<BlockMetadataTransactionsOrderBy>;
    min_block_height?: InputMaybe<OrderBy>;
    num_distinct_versions?: InputMaybe<OrderBy>;
};
/** select columns of table "address_events_summary" */
declare enum AddressEventsSummarySelectColumn {
    /** column name */
    AccountAddress = "account_address",
    /** column name */
    MinBlockHeight = "min_block_height",
    /** column name */
    NumDistinctVersions = "num_distinct_versions"
}
/** aggregate stddev on columns */
type AddressEventsSummaryStddevFields = {
    min_block_height?: Maybe<Scalars["Float"]["output"]>;
    num_distinct_versions?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_pop on columns */
type AddressEventsSummaryStddevPopFields = {
    min_block_height?: Maybe<Scalars["Float"]["output"]>;
    num_distinct_versions?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_samp on columns */
type AddressEventsSummaryStddevSampFields = {
    min_block_height?: Maybe<Scalars["Float"]["output"]>;
    num_distinct_versions?: Maybe<Scalars["Float"]["output"]>;
};
/** Streaming cursor of the table "address_events_summary" */
type AddressEventsSummaryStreamCursorInput = {
    /** Stream column input with initial value */
    initial_value: AddressEventsSummaryStreamCursorValueInput;
    /** cursor ordering */
    ordering?: InputMaybe<CursorOrdering>;
};
/** Initial value of the column from where the streaming should start */
type AddressEventsSummaryStreamCursorValueInput = {
    account_address?: InputMaybe<Scalars["String"]["input"]>;
    min_block_height?: InputMaybe<Scalars["bigint"]["input"]>;
    num_distinct_versions?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** aggregate sum on columns */
type AddressEventsSummarySumFields = {
    min_block_height?: Maybe<Scalars["bigint"]["output"]>;
    num_distinct_versions?: Maybe<Scalars["bigint"]["output"]>;
};
/** aggregate var_pop on columns */
type AddressEventsSummaryVarPopFields = {
    min_block_height?: Maybe<Scalars["Float"]["output"]>;
    num_distinct_versions?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate var_samp on columns */
type AddressEventsSummaryVarSampFields = {
    min_block_height?: Maybe<Scalars["Float"]["output"]>;
    num_distinct_versions?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate variance on columns */
type AddressEventsSummaryVarianceFields = {
    min_block_height?: Maybe<Scalars["Float"]["output"]>;
    num_distinct_versions?: Maybe<Scalars["Float"]["output"]>;
};
/** columns and relationships of "address_version_from_events" */
type AddressVersionFromEvents = {
    account_address?: Maybe<Scalars["String"]["output"]>;
    /** fetch data from the table: "delegated_staking_activities" */
    delegated_staking_activities: Array<DelegatedStakingActivities>;
    /** fetch aggregated fields from the table: "delegated_staking_activities" */
    delegated_staking_activities_aggregate: DelegatedStakingActivitiesAggregate;
    /** fetch data from the table: "token_activities_v2" */
    token_activities_v2: Array<TokenActivitiesV2>;
    /** fetch aggregated fields from the table: "token_activities_v2" */
    token_activities_v2_aggregate: TokenActivitiesV2Aggregate;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};
/** columns and relationships of "address_version_from_events" */
type AddressVersionFromEventsDelegatedStakingActivitiesArgs = {
    distinct_on?: InputMaybe<Array<DelegatedStakingActivitiesSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<DelegatedStakingActivitiesOrderBy>>;
    where?: InputMaybe<DelegatedStakingActivitiesBoolExp>;
};
/** columns and relationships of "address_version_from_events" */
type AddressVersionFromEventsDelegatedStakingActivitiesAggregateArgs = {
    distinct_on?: InputMaybe<Array<DelegatedStakingActivitiesSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<DelegatedStakingActivitiesOrderBy>>;
    where?: InputMaybe<DelegatedStakingActivitiesBoolExp>;
};
/** columns and relationships of "address_version_from_events" */
type AddressVersionFromEventsTokenActivitiesV2Args = {
    distinct_on?: InputMaybe<Array<TokenActivitiesV2SelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<TokenActivitiesV2OrderBy>>;
    where?: InputMaybe<TokenActivitiesV2BoolExp>;
};
/** columns and relationships of "address_version_from_events" */
type AddressVersionFromEventsTokenActivitiesV2AggregateArgs = {
    distinct_on?: InputMaybe<Array<TokenActivitiesV2SelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<TokenActivitiesV2OrderBy>>;
    where?: InputMaybe<TokenActivitiesV2BoolExp>;
};
/** aggregated selection of "address_version_from_events" */
type AddressVersionFromEventsAggregate = {
    aggregate?: Maybe<AddressVersionFromEventsAggregateFields>;
    nodes: Array<AddressVersionFromEvents>;
};
/** aggregate fields of "address_version_from_events" */
type AddressVersionFromEventsAggregateFields = {
    avg?: Maybe<AddressVersionFromEventsAvgFields>;
    count: Scalars["Int"]["output"];
    max?: Maybe<AddressVersionFromEventsMaxFields>;
    min?: Maybe<AddressVersionFromEventsMinFields>;
    stddev?: Maybe<AddressVersionFromEventsStddevFields>;
    stddev_pop?: Maybe<AddressVersionFromEventsStddevPopFields>;
    stddev_samp?: Maybe<AddressVersionFromEventsStddevSampFields>;
    sum?: Maybe<AddressVersionFromEventsSumFields>;
    var_pop?: Maybe<AddressVersionFromEventsVarPopFields>;
    var_samp?: Maybe<AddressVersionFromEventsVarSampFields>;
    variance?: Maybe<AddressVersionFromEventsVarianceFields>;
};
/** aggregate fields of "address_version_from_events" */
type AddressVersionFromEventsAggregateFieldsCountArgs = {
    columns?: InputMaybe<Array<AddressVersionFromEventsSelectColumn>>;
    distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};
/** aggregate avg on columns */
type AddressVersionFromEventsAvgFields = {
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** Boolean expression to filter rows from the table "address_version_from_events". All fields are combined with a logical 'AND'. */
type AddressVersionFromEventsBoolExp = {
    _and?: InputMaybe<Array<AddressVersionFromEventsBoolExp>>;
    _not?: InputMaybe<AddressVersionFromEventsBoolExp>;
    _or?: InputMaybe<Array<AddressVersionFromEventsBoolExp>>;
    account_address?: InputMaybe<StringComparisonExp>;
    delegated_staking_activities?: InputMaybe<DelegatedStakingActivitiesBoolExp>;
    delegated_staking_activities_aggregate?: InputMaybe<DelegatedStakingActivitiesAggregateBoolExp>;
    token_activities_v2?: InputMaybe<TokenActivitiesV2BoolExp>;
    token_activities_v2_aggregate?: InputMaybe<TokenActivitiesV2AggregateBoolExp>;
    transaction_version?: InputMaybe<BigintComparisonExp>;
};
/** aggregate max on columns */
type AddressVersionFromEventsMaxFields = {
    account_address?: Maybe<Scalars["String"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};
/** aggregate min on columns */
type AddressVersionFromEventsMinFields = {
    account_address?: Maybe<Scalars["String"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};
/** Ordering options when selecting data from "address_version_from_events". */
type AddressVersionFromEventsOrderBy = {
    account_address?: InputMaybe<OrderBy>;
    delegated_staking_activities_aggregate?: InputMaybe<DelegatedStakingActivitiesAggregateOrderBy>;
    token_activities_v2_aggregate?: InputMaybe<TokenActivitiesV2AggregateOrderBy>;
    transaction_version?: InputMaybe<OrderBy>;
};
/** select columns of table "address_version_from_events" */
declare enum AddressVersionFromEventsSelectColumn {
    /** column name */
    AccountAddress = "account_address",
    /** column name */
    TransactionVersion = "transaction_version"
}
/** aggregate stddev on columns */
type AddressVersionFromEventsStddevFields = {
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_pop on columns */
type AddressVersionFromEventsStddevPopFields = {
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_samp on columns */
type AddressVersionFromEventsStddevSampFields = {
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** Streaming cursor of the table "address_version_from_events" */
type AddressVersionFromEventsStreamCursorInput = {
    /** Stream column input with initial value */
    initial_value: AddressVersionFromEventsStreamCursorValueInput;
    /** cursor ordering */
    ordering?: InputMaybe<CursorOrdering>;
};
/** Initial value of the column from where the streaming should start */
type AddressVersionFromEventsStreamCursorValueInput = {
    account_address?: InputMaybe<Scalars["String"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** aggregate sum on columns */
type AddressVersionFromEventsSumFields = {
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};
/** aggregate var_pop on columns */
type AddressVersionFromEventsVarPopFields = {
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate var_samp on columns */
type AddressVersionFromEventsVarSampFields = {
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate variance on columns */
type AddressVersionFromEventsVarianceFields = {
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** columns and relationships of "address_version_from_move_resources" */
type AddressVersionFromMoveResources = {
    address?: Maybe<Scalars["String"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};
/** aggregated selection of "address_version_from_move_resources" */
type AddressVersionFromMoveResourcesAggregate = {
    aggregate?: Maybe<AddressVersionFromMoveResourcesAggregateFields>;
    nodes: Array<AddressVersionFromMoveResources>;
};
/** aggregate fields of "address_version_from_move_resources" */
type AddressVersionFromMoveResourcesAggregateFields = {
    avg?: Maybe<AddressVersionFromMoveResourcesAvgFields>;
    count: Scalars["Int"]["output"];
    max?: Maybe<AddressVersionFromMoveResourcesMaxFields>;
    min?: Maybe<AddressVersionFromMoveResourcesMinFields>;
    stddev?: Maybe<AddressVersionFromMoveResourcesStddevFields>;
    stddev_pop?: Maybe<AddressVersionFromMoveResourcesStddevPopFields>;
    stddev_samp?: Maybe<AddressVersionFromMoveResourcesStddevSampFields>;
    sum?: Maybe<AddressVersionFromMoveResourcesSumFields>;
    var_pop?: Maybe<AddressVersionFromMoveResourcesVarPopFields>;
    var_samp?: Maybe<AddressVersionFromMoveResourcesVarSampFields>;
    variance?: Maybe<AddressVersionFromMoveResourcesVarianceFields>;
};
/** aggregate fields of "address_version_from_move_resources" */
type AddressVersionFromMoveResourcesAggregateFieldsCountArgs = {
    columns?: InputMaybe<Array<AddressVersionFromMoveResourcesSelectColumn>>;
    distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};
/** aggregate avg on columns */
type AddressVersionFromMoveResourcesAvgFields = {
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** Boolean expression to filter rows from the table "address_version_from_move_resources". All fields are combined with a logical 'AND'. */
type AddressVersionFromMoveResourcesBoolExp = {
    _and?: InputMaybe<Array<AddressVersionFromMoveResourcesBoolExp>>;
    _not?: InputMaybe<AddressVersionFromMoveResourcesBoolExp>;
    _or?: InputMaybe<Array<AddressVersionFromMoveResourcesBoolExp>>;
    address?: InputMaybe<StringComparisonExp>;
    transaction_version?: InputMaybe<BigintComparisonExp>;
};
/** aggregate max on columns */
type AddressVersionFromMoveResourcesMaxFields = {
    address?: Maybe<Scalars["String"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};
/** aggregate min on columns */
type AddressVersionFromMoveResourcesMinFields = {
    address?: Maybe<Scalars["String"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};
/** Ordering options when selecting data from "address_version_from_move_resources". */
type AddressVersionFromMoveResourcesOrderBy = {
    address?: InputMaybe<OrderBy>;
    transaction_version?: InputMaybe<OrderBy>;
};
/** select columns of table "address_version_from_move_resources" */
declare enum AddressVersionFromMoveResourcesSelectColumn {
    /** column name */
    Address = "address",
    /** column name */
    TransactionVersion = "transaction_version"
}
/** aggregate stddev on columns */
type AddressVersionFromMoveResourcesStddevFields = {
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_pop on columns */
type AddressVersionFromMoveResourcesStddevPopFields = {
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_samp on columns */
type AddressVersionFromMoveResourcesStddevSampFields = {
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** Streaming cursor of the table "address_version_from_move_resources" */
type AddressVersionFromMoveResourcesStreamCursorInput = {
    /** Stream column input with initial value */
    initial_value: AddressVersionFromMoveResourcesStreamCursorValueInput;
    /** cursor ordering */
    ordering?: InputMaybe<CursorOrdering>;
};
/** Initial value of the column from where the streaming should start */
type AddressVersionFromMoveResourcesStreamCursorValueInput = {
    address?: InputMaybe<Scalars["String"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** aggregate sum on columns */
type AddressVersionFromMoveResourcesSumFields = {
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};
/** aggregate var_pop on columns */
type AddressVersionFromMoveResourcesVarPopFields = {
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate var_samp on columns */
type AddressVersionFromMoveResourcesVarSampFields = {
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate variance on columns */
type AddressVersionFromMoveResourcesVarianceFields = {
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** columns and relationships of "ans_lookup" */
type AnsLookup = {
    domain: Scalars["String"]["output"];
    expiration_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
    inserted_at: Scalars["timestamp"]["output"];
    is_deleted: Scalars["Boolean"]["output"];
    registered_address?: Maybe<Scalars["String"]["output"]>;
    subdomain: Scalars["String"]["output"];
    token_name: Scalars["String"]["output"];
    transaction_version: Scalars["bigint"]["output"];
    write_set_change_index: Scalars["bigint"]["output"];
};
/** aggregated selection of "ans_lookup" */
type AnsLookupAggregate = {
    aggregate?: Maybe<AnsLookupAggregateFields>;
    nodes: Array<AnsLookup>;
};
/** aggregate fields of "ans_lookup" */
type AnsLookupAggregateFields = {
    avg?: Maybe<AnsLookupAvgFields>;
    count: Scalars["Int"]["output"];
    max?: Maybe<AnsLookupMaxFields>;
    min?: Maybe<AnsLookupMinFields>;
    stddev?: Maybe<AnsLookupStddevFields>;
    stddev_pop?: Maybe<AnsLookupStddevPopFields>;
    stddev_samp?: Maybe<AnsLookupStddevSampFields>;
    sum?: Maybe<AnsLookupSumFields>;
    var_pop?: Maybe<AnsLookupVarPopFields>;
    var_samp?: Maybe<AnsLookupVarSampFields>;
    variance?: Maybe<AnsLookupVarianceFields>;
};
/** aggregate fields of "ans_lookup" */
type AnsLookupAggregateFieldsCountArgs = {
    columns?: InputMaybe<Array<AnsLookupSelectColumn>>;
    distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};
/** aggregate avg on columns */
type AnsLookupAvgFields = {
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};
/** Boolean expression to filter rows from the table "ans_lookup". All fields are combined with a logical 'AND'. */
type AnsLookupBoolExp = {
    _and?: InputMaybe<Array<AnsLookupBoolExp>>;
    _not?: InputMaybe<AnsLookupBoolExp>;
    _or?: InputMaybe<Array<AnsLookupBoolExp>>;
    domain?: InputMaybe<StringComparisonExp>;
    expiration_timestamp?: InputMaybe<TimestampComparisonExp>;
    inserted_at?: InputMaybe<TimestampComparisonExp>;
    is_deleted?: InputMaybe<BooleanComparisonExp>;
    registered_address?: InputMaybe<StringComparisonExp>;
    subdomain?: InputMaybe<StringComparisonExp>;
    token_name?: InputMaybe<StringComparisonExp>;
    transaction_version?: InputMaybe<BigintComparisonExp>;
    write_set_change_index?: InputMaybe<BigintComparisonExp>;
};
/** unique or primary key constraints on table "ans_lookup" */
declare enum AnsLookupConstraint {
    /** unique or primary key constraint on columns "write_set_change_index", "transaction_version" */
    AnsLookupPkey = "ans_lookup_pkey"
}
/** input type for incrementing numeric columns in table "ans_lookup" */
type AnsLookupIncInput = {
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** input type for inserting data into table "ans_lookup" */
type AnsLookupInsertInput = {
    domain?: InputMaybe<Scalars["String"]["input"]>;
    expiration_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    is_deleted?: InputMaybe<Scalars["Boolean"]["input"]>;
    registered_address?: InputMaybe<Scalars["String"]["input"]>;
    subdomain?: InputMaybe<Scalars["String"]["input"]>;
    token_name?: InputMaybe<Scalars["String"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** aggregate max on columns */
type AnsLookupMaxFields = {
    domain?: Maybe<Scalars["String"]["output"]>;
    expiration_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    registered_address?: Maybe<Scalars["String"]["output"]>;
    subdomain?: Maybe<Scalars["String"]["output"]>;
    token_name?: Maybe<Scalars["String"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    write_set_change_index?: Maybe<Scalars["bigint"]["output"]>;
};
/** aggregate min on columns */
type AnsLookupMinFields = {
    domain?: Maybe<Scalars["String"]["output"]>;
    expiration_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    registered_address?: Maybe<Scalars["String"]["output"]>;
    subdomain?: Maybe<Scalars["String"]["output"]>;
    token_name?: Maybe<Scalars["String"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    write_set_change_index?: Maybe<Scalars["bigint"]["output"]>;
};
/** response of any mutation on the table "ans_lookup" */
type AnsLookupMutationResponse = {
    /** number of rows affected by the mutation */
    affected_rows: Scalars["Int"]["output"];
    /** data from the rows affected by the mutation */
    returning: Array<AnsLookup>;
};
/** on_conflict condition type for table "ans_lookup" */
type AnsLookupOnConflict = {
    constraint: AnsLookupConstraint;
    update_columns?: Array<AnsLookupUpdateColumn>;
    where?: InputMaybe<AnsLookupBoolExp>;
};
/** Ordering options when selecting data from "ans_lookup". */
type AnsLookupOrderBy = {
    domain?: InputMaybe<OrderBy>;
    expiration_timestamp?: InputMaybe<OrderBy>;
    inserted_at?: InputMaybe<OrderBy>;
    is_deleted?: InputMaybe<OrderBy>;
    registered_address?: InputMaybe<OrderBy>;
    subdomain?: InputMaybe<OrderBy>;
    token_name?: InputMaybe<OrderBy>;
    transaction_version?: InputMaybe<OrderBy>;
    write_set_change_index?: InputMaybe<OrderBy>;
};
/** primary key columns input for table: ans_lookup */
type AnsLookupPkColumnsInput = {
    transaction_version: Scalars["bigint"]["input"];
    write_set_change_index: Scalars["bigint"]["input"];
};
/** select columns of table "ans_lookup" */
declare enum AnsLookupSelectColumn {
    /** column name */
    Domain = "domain",
    /** column name */
    ExpirationTimestamp = "expiration_timestamp",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    IsDeleted = "is_deleted",
    /** column name */
    RegisteredAddress = "registered_address",
    /** column name */
    Subdomain = "subdomain",
    /** column name */
    TokenName = "token_name",
    /** column name */
    TransactionVersion = "transaction_version",
    /** column name */
    WriteSetChangeIndex = "write_set_change_index"
}
/** input type for updating data in table "ans_lookup" */
type AnsLookupSetInput = {
    domain?: InputMaybe<Scalars["String"]["input"]>;
    expiration_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    is_deleted?: InputMaybe<Scalars["Boolean"]["input"]>;
    registered_address?: InputMaybe<Scalars["String"]["input"]>;
    subdomain?: InputMaybe<Scalars["String"]["input"]>;
    token_name?: InputMaybe<Scalars["String"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** aggregate stddev on columns */
type AnsLookupStddevFields = {
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_pop on columns */
type AnsLookupStddevPopFields = {
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_samp on columns */
type AnsLookupStddevSampFields = {
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};
/** Streaming cursor of the table "ans_lookup" */
type AnsLookupStreamCursorInput = {
    /** Stream column input with initial value */
    initial_value: AnsLookupStreamCursorValueInput;
    /** cursor ordering */
    ordering?: InputMaybe<CursorOrdering>;
};
/** Initial value of the column from where the streaming should start */
type AnsLookupStreamCursorValueInput = {
    domain?: InputMaybe<Scalars["String"]["input"]>;
    expiration_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    is_deleted?: InputMaybe<Scalars["Boolean"]["input"]>;
    registered_address?: InputMaybe<Scalars["String"]["input"]>;
    subdomain?: InputMaybe<Scalars["String"]["input"]>;
    token_name?: InputMaybe<Scalars["String"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** aggregate sum on columns */
type AnsLookupSumFields = {
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    write_set_change_index?: Maybe<Scalars["bigint"]["output"]>;
};
/** update columns of table "ans_lookup" */
declare enum AnsLookupUpdateColumn {
    /** column name */
    Domain = "domain",
    /** column name */
    ExpirationTimestamp = "expiration_timestamp",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    IsDeleted = "is_deleted",
    /** column name */
    RegisteredAddress = "registered_address",
    /** column name */
    Subdomain = "subdomain",
    /** column name */
    TokenName = "token_name",
    /** column name */
    TransactionVersion = "transaction_version",
    /** column name */
    WriteSetChangeIndex = "write_set_change_index"
}
type AnsLookupUpdates = {
    /** increments the numeric columns with given value of the filtered values */
    _inc?: InputMaybe<AnsLookupIncInput>;
    /** sets the columns of the filtered rows to the given values */
    _set?: InputMaybe<AnsLookupSetInput>;
    /** filter the rows which have to be updated */
    where: AnsLookupBoolExp;
};
/** columns and relationships of "ans_lookup_v2" */
type AnsLookupV2 = {
    domain: Scalars["String"]["output"];
    expiration_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
    inserted_at: Scalars["timestamp"]["output"];
    is_deleted: Scalars["Boolean"]["output"];
    registered_address?: Maybe<Scalars["String"]["output"]>;
    subdomain: Scalars["String"]["output"];
    subdomain_expiration_policy?: Maybe<Scalars["bigint"]["output"]>;
    token_name: Scalars["String"]["output"];
    token_standard: Scalars["String"]["output"];
    transaction_version: Scalars["bigint"]["output"];
    write_set_change_index: Scalars["bigint"]["output"];
};
/** aggregated selection of "ans_lookup_v2" */
type AnsLookupV2Aggregate = {
    aggregate?: Maybe<AnsLookupV2AggregateFields>;
    nodes: Array<AnsLookupV2>;
};
/** aggregate fields of "ans_lookup_v2" */
type AnsLookupV2AggregateFields = {
    avg?: Maybe<AnsLookupV2AvgFields>;
    count: Scalars["Int"]["output"];
    max?: Maybe<AnsLookupV2MaxFields>;
    min?: Maybe<AnsLookupV2MinFields>;
    stddev?: Maybe<AnsLookupV2StddevFields>;
    stddev_pop?: Maybe<AnsLookupV2StddevPopFields>;
    stddev_samp?: Maybe<AnsLookupV2StddevSampFields>;
    sum?: Maybe<AnsLookupV2SumFields>;
    var_pop?: Maybe<AnsLookupV2VarPopFields>;
    var_samp?: Maybe<AnsLookupV2VarSampFields>;
    variance?: Maybe<AnsLookupV2VarianceFields>;
};
/** aggregate fields of "ans_lookup_v2" */
type AnsLookupV2AggregateFieldsCountArgs = {
    columns?: InputMaybe<Array<AnsLookupV2SelectColumn>>;
    distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};
/** aggregate avg on columns */
type AnsLookupV2AvgFields = {
    subdomain_expiration_policy?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};
/** Boolean expression to filter rows from the table "ans_lookup_v2". All fields are combined with a logical 'AND'. */
type AnsLookupV2BoolExp = {
    _and?: InputMaybe<Array<AnsLookupV2BoolExp>>;
    _not?: InputMaybe<AnsLookupV2BoolExp>;
    _or?: InputMaybe<Array<AnsLookupV2BoolExp>>;
    domain?: InputMaybe<StringComparisonExp>;
    expiration_timestamp?: InputMaybe<TimestampComparisonExp>;
    inserted_at?: InputMaybe<TimestampComparisonExp>;
    is_deleted?: InputMaybe<BooleanComparisonExp>;
    registered_address?: InputMaybe<StringComparisonExp>;
    subdomain?: InputMaybe<StringComparisonExp>;
    subdomain_expiration_policy?: InputMaybe<BigintComparisonExp>;
    token_name?: InputMaybe<StringComparisonExp>;
    token_standard?: InputMaybe<StringComparisonExp>;
    transaction_version?: InputMaybe<BigintComparisonExp>;
    write_set_change_index?: InputMaybe<BigintComparisonExp>;
};
/** unique or primary key constraints on table "ans_lookup_v2" */
declare enum AnsLookupV2Constraint {
    /** unique or primary key constraint on columns "write_set_change_index", "transaction_version" */
    AnsLookupV2Pkey = "ans_lookup_v2_pkey"
}
/** input type for incrementing numeric columns in table "ans_lookup_v2" */
type AnsLookupV2IncInput = {
    subdomain_expiration_policy?: InputMaybe<Scalars["bigint"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** input type for inserting data into table "ans_lookup_v2" */
type AnsLookupV2InsertInput = {
    domain?: InputMaybe<Scalars["String"]["input"]>;
    expiration_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    is_deleted?: InputMaybe<Scalars["Boolean"]["input"]>;
    registered_address?: InputMaybe<Scalars["String"]["input"]>;
    subdomain?: InputMaybe<Scalars["String"]["input"]>;
    subdomain_expiration_policy?: InputMaybe<Scalars["bigint"]["input"]>;
    token_name?: InputMaybe<Scalars["String"]["input"]>;
    token_standard?: InputMaybe<Scalars["String"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** aggregate max on columns */
type AnsLookupV2MaxFields = {
    domain?: Maybe<Scalars["String"]["output"]>;
    expiration_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    registered_address?: Maybe<Scalars["String"]["output"]>;
    subdomain?: Maybe<Scalars["String"]["output"]>;
    subdomain_expiration_policy?: Maybe<Scalars["bigint"]["output"]>;
    token_name?: Maybe<Scalars["String"]["output"]>;
    token_standard?: Maybe<Scalars["String"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    write_set_change_index?: Maybe<Scalars["bigint"]["output"]>;
};
/** aggregate min on columns */
type AnsLookupV2MinFields = {
    domain?: Maybe<Scalars["String"]["output"]>;
    expiration_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    registered_address?: Maybe<Scalars["String"]["output"]>;
    subdomain?: Maybe<Scalars["String"]["output"]>;
    subdomain_expiration_policy?: Maybe<Scalars["bigint"]["output"]>;
    token_name?: Maybe<Scalars["String"]["output"]>;
    token_standard?: Maybe<Scalars["String"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    write_set_change_index?: Maybe<Scalars["bigint"]["output"]>;
};
/** response of any mutation on the table "ans_lookup_v2" */
type AnsLookupV2MutationResponse = {
    /** number of rows affected by the mutation */
    affected_rows: Scalars["Int"]["output"];
    /** data from the rows affected by the mutation */
    returning: Array<AnsLookupV2>;
};
/** on_conflict condition type for table "ans_lookup_v2" */
type AnsLookupV2OnConflict = {
    constraint: AnsLookupV2Constraint;
    update_columns?: Array<AnsLookupV2UpdateColumn>;
    where?: InputMaybe<AnsLookupV2BoolExp>;
};
/** Ordering options when selecting data from "ans_lookup_v2". */
type AnsLookupV2OrderBy = {
    domain?: InputMaybe<OrderBy>;
    expiration_timestamp?: InputMaybe<OrderBy>;
    inserted_at?: InputMaybe<OrderBy>;
    is_deleted?: InputMaybe<OrderBy>;
    registered_address?: InputMaybe<OrderBy>;
    subdomain?: InputMaybe<OrderBy>;
    subdomain_expiration_policy?: InputMaybe<OrderBy>;
    token_name?: InputMaybe<OrderBy>;
    token_standard?: InputMaybe<OrderBy>;
    transaction_version?: InputMaybe<OrderBy>;
    write_set_change_index?: InputMaybe<OrderBy>;
};
/** primary key columns input for table: ans_lookup_v2 */
type AnsLookupV2PkColumnsInput = {
    transaction_version: Scalars["bigint"]["input"];
    write_set_change_index: Scalars["bigint"]["input"];
};
/** select columns of table "ans_lookup_v2" */
declare enum AnsLookupV2SelectColumn {
    /** column name */
    Domain = "domain",
    /** column name */
    ExpirationTimestamp = "expiration_timestamp",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    IsDeleted = "is_deleted",
    /** column name */
    RegisteredAddress = "registered_address",
    /** column name */
    Subdomain = "subdomain",
    /** column name */
    SubdomainExpirationPolicy = "subdomain_expiration_policy",
    /** column name */
    TokenName = "token_name",
    /** column name */
    TokenStandard = "token_standard",
    /** column name */
    TransactionVersion = "transaction_version",
    /** column name */
    WriteSetChangeIndex = "write_set_change_index"
}
/** input type for updating data in table "ans_lookup_v2" */
type AnsLookupV2SetInput = {
    domain?: InputMaybe<Scalars["String"]["input"]>;
    expiration_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    is_deleted?: InputMaybe<Scalars["Boolean"]["input"]>;
    registered_address?: InputMaybe<Scalars["String"]["input"]>;
    subdomain?: InputMaybe<Scalars["String"]["input"]>;
    subdomain_expiration_policy?: InputMaybe<Scalars["bigint"]["input"]>;
    token_name?: InputMaybe<Scalars["String"]["input"]>;
    token_standard?: InputMaybe<Scalars["String"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** aggregate stddev on columns */
type AnsLookupV2StddevFields = {
    subdomain_expiration_policy?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_pop on columns */
type AnsLookupV2StddevPopFields = {
    subdomain_expiration_policy?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_samp on columns */
type AnsLookupV2StddevSampFields = {
    subdomain_expiration_policy?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};
/** Streaming cursor of the table "ans_lookup_v2" */
type AnsLookupV2StreamCursorInput = {
    /** Stream column input with initial value */
    initial_value: AnsLookupV2StreamCursorValueInput;
    /** cursor ordering */
    ordering?: InputMaybe<CursorOrdering>;
};
/** Initial value of the column from where the streaming should start */
type AnsLookupV2StreamCursorValueInput = {
    domain?: InputMaybe<Scalars["String"]["input"]>;
    expiration_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    is_deleted?: InputMaybe<Scalars["Boolean"]["input"]>;
    registered_address?: InputMaybe<Scalars["String"]["input"]>;
    subdomain?: InputMaybe<Scalars["String"]["input"]>;
    subdomain_expiration_policy?: InputMaybe<Scalars["bigint"]["input"]>;
    token_name?: InputMaybe<Scalars["String"]["input"]>;
    token_standard?: InputMaybe<Scalars["String"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** aggregate sum on columns */
type AnsLookupV2SumFields = {
    subdomain_expiration_policy?: Maybe<Scalars["bigint"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    write_set_change_index?: Maybe<Scalars["bigint"]["output"]>;
};
/** update columns of table "ans_lookup_v2" */
declare enum AnsLookupV2UpdateColumn {
    /** column name */
    Domain = "domain",
    /** column name */
    ExpirationTimestamp = "expiration_timestamp",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    IsDeleted = "is_deleted",
    /** column name */
    RegisteredAddress = "registered_address",
    /** column name */
    Subdomain = "subdomain",
    /** column name */
    SubdomainExpirationPolicy = "subdomain_expiration_policy",
    /** column name */
    TokenName = "token_name",
    /** column name */
    TokenStandard = "token_standard",
    /** column name */
    TransactionVersion = "transaction_version",
    /** column name */
    WriteSetChangeIndex = "write_set_change_index"
}
type AnsLookupV2Updates = {
    /** increments the numeric columns with given value of the filtered values */
    _inc?: InputMaybe<AnsLookupV2IncInput>;
    /** sets the columns of the filtered rows to the given values */
    _set?: InputMaybe<AnsLookupV2SetInput>;
    /** filter the rows which have to be updated */
    where: AnsLookupV2BoolExp;
};
/** aggregate var_pop on columns */
type AnsLookupV2VarPopFields = {
    subdomain_expiration_policy?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate var_samp on columns */
type AnsLookupV2VarSampFields = {
    subdomain_expiration_policy?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate variance on columns */
type AnsLookupV2VarianceFields = {
    subdomain_expiration_policy?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate var_pop on columns */
type AnsLookupVarPopFields = {
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate var_samp on columns */
type AnsLookupVarSampFields = {
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate variance on columns */
type AnsLookupVarianceFields = {
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};
/** columns and relationships of "ans_primary_name" */
type AnsPrimaryName = {
    domain?: Maybe<Scalars["String"]["output"]>;
    inserted_at: Scalars["timestamp"]["output"];
    is_deleted: Scalars["Boolean"]["output"];
    registered_address: Scalars["String"]["output"];
    subdomain?: Maybe<Scalars["String"]["output"]>;
    token_name?: Maybe<Scalars["String"]["output"]>;
    transaction_version: Scalars["bigint"]["output"];
    write_set_change_index: Scalars["bigint"]["output"];
};
/** aggregated selection of "ans_primary_name" */
type AnsPrimaryNameAggregate = {
    aggregate?: Maybe<AnsPrimaryNameAggregateFields>;
    nodes: Array<AnsPrimaryName>;
};
/** aggregate fields of "ans_primary_name" */
type AnsPrimaryNameAggregateFields = {
    avg?: Maybe<AnsPrimaryNameAvgFields>;
    count: Scalars["Int"]["output"];
    max?: Maybe<AnsPrimaryNameMaxFields>;
    min?: Maybe<AnsPrimaryNameMinFields>;
    stddev?: Maybe<AnsPrimaryNameStddevFields>;
    stddev_pop?: Maybe<AnsPrimaryNameStddevPopFields>;
    stddev_samp?: Maybe<AnsPrimaryNameStddevSampFields>;
    sum?: Maybe<AnsPrimaryNameSumFields>;
    var_pop?: Maybe<AnsPrimaryNameVarPopFields>;
    var_samp?: Maybe<AnsPrimaryNameVarSampFields>;
    variance?: Maybe<AnsPrimaryNameVarianceFields>;
};
/** aggregate fields of "ans_primary_name" */
type AnsPrimaryNameAggregateFieldsCountArgs = {
    columns?: InputMaybe<Array<AnsPrimaryNameSelectColumn>>;
    distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};
/** aggregate avg on columns */
type AnsPrimaryNameAvgFields = {
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};
/** Boolean expression to filter rows from the table "ans_primary_name". All fields are combined with a logical 'AND'. */
type AnsPrimaryNameBoolExp = {
    _and?: InputMaybe<Array<AnsPrimaryNameBoolExp>>;
    _not?: InputMaybe<AnsPrimaryNameBoolExp>;
    _or?: InputMaybe<Array<AnsPrimaryNameBoolExp>>;
    domain?: InputMaybe<StringComparisonExp>;
    inserted_at?: InputMaybe<TimestampComparisonExp>;
    is_deleted?: InputMaybe<BooleanComparisonExp>;
    registered_address?: InputMaybe<StringComparisonExp>;
    subdomain?: InputMaybe<StringComparisonExp>;
    token_name?: InputMaybe<StringComparisonExp>;
    transaction_version?: InputMaybe<BigintComparisonExp>;
    write_set_change_index?: InputMaybe<BigintComparisonExp>;
};
/** unique or primary key constraints on table "ans_primary_name" */
declare enum AnsPrimaryNameConstraint {
    /** unique or primary key constraint on columns "write_set_change_index", "transaction_version" */
    AnsPrimaryNamePkey = "ans_primary_name_pkey"
}
/** input type for incrementing numeric columns in table "ans_primary_name" */
type AnsPrimaryNameIncInput = {
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** input type for inserting data into table "ans_primary_name" */
type AnsPrimaryNameInsertInput = {
    domain?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    is_deleted?: InputMaybe<Scalars["Boolean"]["input"]>;
    registered_address?: InputMaybe<Scalars["String"]["input"]>;
    subdomain?: InputMaybe<Scalars["String"]["input"]>;
    token_name?: InputMaybe<Scalars["String"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** aggregate max on columns */
type AnsPrimaryNameMaxFields = {
    domain?: Maybe<Scalars["String"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    registered_address?: Maybe<Scalars["String"]["output"]>;
    subdomain?: Maybe<Scalars["String"]["output"]>;
    token_name?: Maybe<Scalars["String"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    write_set_change_index?: Maybe<Scalars["bigint"]["output"]>;
};
/** aggregate min on columns */
type AnsPrimaryNameMinFields = {
    domain?: Maybe<Scalars["String"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    registered_address?: Maybe<Scalars["String"]["output"]>;
    subdomain?: Maybe<Scalars["String"]["output"]>;
    token_name?: Maybe<Scalars["String"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    write_set_change_index?: Maybe<Scalars["bigint"]["output"]>;
};
/** response of any mutation on the table "ans_primary_name" */
type AnsPrimaryNameMutationResponse = {
    /** number of rows affected by the mutation */
    affected_rows: Scalars["Int"]["output"];
    /** data from the rows affected by the mutation */
    returning: Array<AnsPrimaryName>;
};
/** on_conflict condition type for table "ans_primary_name" */
type AnsPrimaryNameOnConflict = {
    constraint: AnsPrimaryNameConstraint;
    update_columns?: Array<AnsPrimaryNameUpdateColumn>;
    where?: InputMaybe<AnsPrimaryNameBoolExp>;
};
/** Ordering options when selecting data from "ans_primary_name". */
type AnsPrimaryNameOrderBy = {
    domain?: InputMaybe<OrderBy>;
    inserted_at?: InputMaybe<OrderBy>;
    is_deleted?: InputMaybe<OrderBy>;
    registered_address?: InputMaybe<OrderBy>;
    subdomain?: InputMaybe<OrderBy>;
    token_name?: InputMaybe<OrderBy>;
    transaction_version?: InputMaybe<OrderBy>;
    write_set_change_index?: InputMaybe<OrderBy>;
};
/** primary key columns input for table: ans_primary_name */
type AnsPrimaryNamePkColumnsInput = {
    transaction_version: Scalars["bigint"]["input"];
    write_set_change_index: Scalars["bigint"]["input"];
};
/** select columns of table "ans_primary_name" */
declare enum AnsPrimaryNameSelectColumn {
    /** column name */
    Domain = "domain",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    IsDeleted = "is_deleted",
    /** column name */
    RegisteredAddress = "registered_address",
    /** column name */
    Subdomain = "subdomain",
    /** column name */
    TokenName = "token_name",
    /** column name */
    TransactionVersion = "transaction_version",
    /** column name */
    WriteSetChangeIndex = "write_set_change_index"
}
/** input type for updating data in table "ans_primary_name" */
type AnsPrimaryNameSetInput = {
    domain?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    is_deleted?: InputMaybe<Scalars["Boolean"]["input"]>;
    registered_address?: InputMaybe<Scalars["String"]["input"]>;
    subdomain?: InputMaybe<Scalars["String"]["input"]>;
    token_name?: InputMaybe<Scalars["String"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** aggregate stddev on columns */
type AnsPrimaryNameStddevFields = {
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_pop on columns */
type AnsPrimaryNameStddevPopFields = {
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_samp on columns */
type AnsPrimaryNameStddevSampFields = {
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};
/** Streaming cursor of the table "ans_primary_name" */
type AnsPrimaryNameStreamCursorInput = {
    /** Stream column input with initial value */
    initial_value: AnsPrimaryNameStreamCursorValueInput;
    /** cursor ordering */
    ordering?: InputMaybe<CursorOrdering>;
};
/** Initial value of the column from where the streaming should start */
type AnsPrimaryNameStreamCursorValueInput = {
    domain?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    is_deleted?: InputMaybe<Scalars["Boolean"]["input"]>;
    registered_address?: InputMaybe<Scalars["String"]["input"]>;
    subdomain?: InputMaybe<Scalars["String"]["input"]>;
    token_name?: InputMaybe<Scalars["String"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** aggregate sum on columns */
type AnsPrimaryNameSumFields = {
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    write_set_change_index?: Maybe<Scalars["bigint"]["output"]>;
};
/** update columns of table "ans_primary_name" */
declare enum AnsPrimaryNameUpdateColumn {
    /** column name */
    Domain = "domain",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    IsDeleted = "is_deleted",
    /** column name */
    RegisteredAddress = "registered_address",
    /** column name */
    Subdomain = "subdomain",
    /** column name */
    TokenName = "token_name",
    /** column name */
    TransactionVersion = "transaction_version",
    /** column name */
    WriteSetChangeIndex = "write_set_change_index"
}
type AnsPrimaryNameUpdates = {
    /** increments the numeric columns with given value of the filtered values */
    _inc?: InputMaybe<AnsPrimaryNameIncInput>;
    /** sets the columns of the filtered rows to the given values */
    _set?: InputMaybe<AnsPrimaryNameSetInput>;
    /** filter the rows which have to be updated */
    where: AnsPrimaryNameBoolExp;
};
/** columns and relationships of "ans_primary_name_v2" */
type AnsPrimaryNameV2 = {
    domain?: Maybe<Scalars["String"]["output"]>;
    inserted_at: Scalars["timestamp"]["output"];
    is_deleted: Scalars["Boolean"]["output"];
    registered_address: Scalars["String"]["output"];
    subdomain?: Maybe<Scalars["String"]["output"]>;
    token_name?: Maybe<Scalars["String"]["output"]>;
    token_standard: Scalars["String"]["output"];
    transaction_version: Scalars["bigint"]["output"];
    write_set_change_index: Scalars["bigint"]["output"];
};
/** aggregated selection of "ans_primary_name_v2" */
type AnsPrimaryNameV2Aggregate = {
    aggregate?: Maybe<AnsPrimaryNameV2AggregateFields>;
    nodes: Array<AnsPrimaryNameV2>;
};
/** aggregate fields of "ans_primary_name_v2" */
type AnsPrimaryNameV2AggregateFields = {
    avg?: Maybe<AnsPrimaryNameV2AvgFields>;
    count: Scalars["Int"]["output"];
    max?: Maybe<AnsPrimaryNameV2MaxFields>;
    min?: Maybe<AnsPrimaryNameV2MinFields>;
    stddev?: Maybe<AnsPrimaryNameV2StddevFields>;
    stddev_pop?: Maybe<AnsPrimaryNameV2StddevPopFields>;
    stddev_samp?: Maybe<AnsPrimaryNameV2StddevSampFields>;
    sum?: Maybe<AnsPrimaryNameV2SumFields>;
    var_pop?: Maybe<AnsPrimaryNameV2VarPopFields>;
    var_samp?: Maybe<AnsPrimaryNameV2VarSampFields>;
    variance?: Maybe<AnsPrimaryNameV2VarianceFields>;
};
/** aggregate fields of "ans_primary_name_v2" */
type AnsPrimaryNameV2AggregateFieldsCountArgs = {
    columns?: InputMaybe<Array<AnsPrimaryNameV2SelectColumn>>;
    distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};
/** aggregate avg on columns */
type AnsPrimaryNameV2AvgFields = {
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};
/** Boolean expression to filter rows from the table "ans_primary_name_v2". All fields are combined with a logical 'AND'. */
type AnsPrimaryNameV2BoolExp = {
    _and?: InputMaybe<Array<AnsPrimaryNameV2BoolExp>>;
    _not?: InputMaybe<AnsPrimaryNameV2BoolExp>;
    _or?: InputMaybe<Array<AnsPrimaryNameV2BoolExp>>;
    domain?: InputMaybe<StringComparisonExp>;
    inserted_at?: InputMaybe<TimestampComparisonExp>;
    is_deleted?: InputMaybe<BooleanComparisonExp>;
    registered_address?: InputMaybe<StringComparisonExp>;
    subdomain?: InputMaybe<StringComparisonExp>;
    token_name?: InputMaybe<StringComparisonExp>;
    token_standard?: InputMaybe<StringComparisonExp>;
    transaction_version?: InputMaybe<BigintComparisonExp>;
    write_set_change_index?: InputMaybe<BigintComparisonExp>;
};
/** unique or primary key constraints on table "ans_primary_name_v2" */
declare enum AnsPrimaryNameV2Constraint {
    /** unique or primary key constraint on columns "write_set_change_index", "transaction_version" */
    AnsPrimaryNameV2Pkey = "ans_primary_name_v2_pkey"
}
/** input type for incrementing numeric columns in table "ans_primary_name_v2" */
type AnsPrimaryNameV2IncInput = {
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** input type for inserting data into table "ans_primary_name_v2" */
type AnsPrimaryNameV2InsertInput = {
    domain?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    is_deleted?: InputMaybe<Scalars["Boolean"]["input"]>;
    registered_address?: InputMaybe<Scalars["String"]["input"]>;
    subdomain?: InputMaybe<Scalars["String"]["input"]>;
    token_name?: InputMaybe<Scalars["String"]["input"]>;
    token_standard?: InputMaybe<Scalars["String"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** aggregate max on columns */
type AnsPrimaryNameV2MaxFields = {
    domain?: Maybe<Scalars["String"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    registered_address?: Maybe<Scalars["String"]["output"]>;
    subdomain?: Maybe<Scalars["String"]["output"]>;
    token_name?: Maybe<Scalars["String"]["output"]>;
    token_standard?: Maybe<Scalars["String"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    write_set_change_index?: Maybe<Scalars["bigint"]["output"]>;
};
/** aggregate min on columns */
type AnsPrimaryNameV2MinFields = {
    domain?: Maybe<Scalars["String"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    registered_address?: Maybe<Scalars["String"]["output"]>;
    subdomain?: Maybe<Scalars["String"]["output"]>;
    token_name?: Maybe<Scalars["String"]["output"]>;
    token_standard?: Maybe<Scalars["String"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    write_set_change_index?: Maybe<Scalars["bigint"]["output"]>;
};
/** response of any mutation on the table "ans_primary_name_v2" */
type AnsPrimaryNameV2MutationResponse = {
    /** number of rows affected by the mutation */
    affected_rows: Scalars["Int"]["output"];
    /** data from the rows affected by the mutation */
    returning: Array<AnsPrimaryNameV2>;
};
/** on_conflict condition type for table "ans_primary_name_v2" */
type AnsPrimaryNameV2OnConflict = {
    constraint: AnsPrimaryNameV2Constraint;
    update_columns?: Array<AnsPrimaryNameV2UpdateColumn>;
    where?: InputMaybe<AnsPrimaryNameV2BoolExp>;
};
/** Ordering options when selecting data from "ans_primary_name_v2". */
type AnsPrimaryNameV2OrderBy = {
    domain?: InputMaybe<OrderBy>;
    inserted_at?: InputMaybe<OrderBy>;
    is_deleted?: InputMaybe<OrderBy>;
    registered_address?: InputMaybe<OrderBy>;
    subdomain?: InputMaybe<OrderBy>;
    token_name?: InputMaybe<OrderBy>;
    token_standard?: InputMaybe<OrderBy>;
    transaction_version?: InputMaybe<OrderBy>;
    write_set_change_index?: InputMaybe<OrderBy>;
};
/** primary key columns input for table: ans_primary_name_v2 */
type AnsPrimaryNameV2PkColumnsInput = {
    transaction_version: Scalars["bigint"]["input"];
    write_set_change_index: Scalars["bigint"]["input"];
};
/** select columns of table "ans_primary_name_v2" */
declare enum AnsPrimaryNameV2SelectColumn {
    /** column name */
    Domain = "domain",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    IsDeleted = "is_deleted",
    /** column name */
    RegisteredAddress = "registered_address",
    /** column name */
    Subdomain = "subdomain",
    /** column name */
    TokenName = "token_name",
    /** column name */
    TokenStandard = "token_standard",
    /** column name */
    TransactionVersion = "transaction_version",
    /** column name */
    WriteSetChangeIndex = "write_set_change_index"
}
/** input type for updating data in table "ans_primary_name_v2" */
type AnsPrimaryNameV2SetInput = {
    domain?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    is_deleted?: InputMaybe<Scalars["Boolean"]["input"]>;
    registered_address?: InputMaybe<Scalars["String"]["input"]>;
    subdomain?: InputMaybe<Scalars["String"]["input"]>;
    token_name?: InputMaybe<Scalars["String"]["input"]>;
    token_standard?: InputMaybe<Scalars["String"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** aggregate stddev on columns */
type AnsPrimaryNameV2StddevFields = {
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_pop on columns */
type AnsPrimaryNameV2StddevPopFields = {
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_samp on columns */
type AnsPrimaryNameV2StddevSampFields = {
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};
/** Streaming cursor of the table "ans_primary_name_v2" */
type AnsPrimaryNameV2StreamCursorInput = {
    /** Stream column input with initial value */
    initial_value: AnsPrimaryNameV2StreamCursorValueInput;
    /** cursor ordering */
    ordering?: InputMaybe<CursorOrdering>;
};
/** Initial value of the column from where the streaming should start */
type AnsPrimaryNameV2StreamCursorValueInput = {
    domain?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    is_deleted?: InputMaybe<Scalars["Boolean"]["input"]>;
    registered_address?: InputMaybe<Scalars["String"]["input"]>;
    subdomain?: InputMaybe<Scalars["String"]["input"]>;
    token_name?: InputMaybe<Scalars["String"]["input"]>;
    token_standard?: InputMaybe<Scalars["String"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** aggregate sum on columns */
type AnsPrimaryNameV2SumFields = {
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    write_set_change_index?: Maybe<Scalars["bigint"]["output"]>;
};
/** update columns of table "ans_primary_name_v2" */
declare enum AnsPrimaryNameV2UpdateColumn {
    /** column name */
    Domain = "domain",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    IsDeleted = "is_deleted",
    /** column name */
    RegisteredAddress = "registered_address",
    /** column name */
    Subdomain = "subdomain",
    /** column name */
    TokenName = "token_name",
    /** column name */
    TokenStandard = "token_standard",
    /** column name */
    TransactionVersion = "transaction_version",
    /** column name */
    WriteSetChangeIndex = "write_set_change_index"
}
type AnsPrimaryNameV2Updates = {
    /** increments the numeric columns with given value of the filtered values */
    _inc?: InputMaybe<AnsPrimaryNameV2IncInput>;
    /** sets the columns of the filtered rows to the given values */
    _set?: InputMaybe<AnsPrimaryNameV2SetInput>;
    /** filter the rows which have to be updated */
    where: AnsPrimaryNameV2BoolExp;
};
/** aggregate var_pop on columns */
type AnsPrimaryNameV2VarPopFields = {
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate var_samp on columns */
type AnsPrimaryNameV2VarSampFields = {
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate variance on columns */
type AnsPrimaryNameV2VarianceFields = {
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate var_pop on columns */
type AnsPrimaryNameVarPopFields = {
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate var_samp on columns */
type AnsPrimaryNameVarSampFields = {
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate variance on columns */
type AnsPrimaryNameVarianceFields = {
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};
/** columns and relationships of "auth_key_account_addresses" */
type AuthKeyAccountAddresses = {
    account_address: Scalars["String"]["output"];
    auth_key: Scalars["String"]["output"];
    is_auth_key_used: Scalars["Boolean"]["output"];
    last_transaction_version: Scalars["bigint"]["output"];
};
/** aggregated selection of "auth_key_account_addresses" */
type AuthKeyAccountAddressesAggregate = {
    aggregate?: Maybe<AuthKeyAccountAddressesAggregateFields>;
    nodes: Array<AuthKeyAccountAddresses>;
};
/** aggregate fields of "auth_key_account_addresses" */
type AuthKeyAccountAddressesAggregateFields = {
    avg?: Maybe<AuthKeyAccountAddressesAvgFields>;
    count: Scalars["Int"]["output"];
    max?: Maybe<AuthKeyAccountAddressesMaxFields>;
    min?: Maybe<AuthKeyAccountAddressesMinFields>;
    stddev?: Maybe<AuthKeyAccountAddressesStddevFields>;
    stddev_pop?: Maybe<AuthKeyAccountAddressesStddevPopFields>;
    stddev_samp?: Maybe<AuthKeyAccountAddressesStddevSampFields>;
    sum?: Maybe<AuthKeyAccountAddressesSumFields>;
    var_pop?: Maybe<AuthKeyAccountAddressesVarPopFields>;
    var_samp?: Maybe<AuthKeyAccountAddressesVarSampFields>;
    variance?: Maybe<AuthKeyAccountAddressesVarianceFields>;
};
/** aggregate fields of "auth_key_account_addresses" */
type AuthKeyAccountAddressesAggregateFieldsCountArgs = {
    columns?: InputMaybe<Array<AuthKeyAccountAddressesSelectColumn>>;
    distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};
/** aggregate avg on columns */
type AuthKeyAccountAddressesAvgFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** Boolean expression to filter rows from the table "auth_key_account_addresses". All fields are combined with a logical 'AND'. */
type AuthKeyAccountAddressesBoolExp = {
    _and?: InputMaybe<Array<AuthKeyAccountAddressesBoolExp>>;
    _not?: InputMaybe<AuthKeyAccountAddressesBoolExp>;
    _or?: InputMaybe<Array<AuthKeyAccountAddressesBoolExp>>;
    account_address?: InputMaybe<StringComparisonExp>;
    auth_key?: InputMaybe<StringComparisonExp>;
    is_auth_key_used?: InputMaybe<BooleanComparisonExp>;
    last_transaction_version?: InputMaybe<BigintComparisonExp>;
};
/** unique or primary key constraints on table "auth_key_account_addresses" */
declare enum AuthKeyAccountAddressesConstraint {
    /** unique or primary key constraint on columns "account_address" */
    AuthKeyAccountAddressesPkey = "auth_key_account_addresses_pkey"
}
/** input type for incrementing numeric columns in table "auth_key_account_addresses" */
type AuthKeyAccountAddressesIncInput = {
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** input type for inserting data into table "auth_key_account_addresses" */
type AuthKeyAccountAddressesInsertInput = {
    account_address?: InputMaybe<Scalars["String"]["input"]>;
    auth_key?: InputMaybe<Scalars["String"]["input"]>;
    is_auth_key_used?: InputMaybe<Scalars["Boolean"]["input"]>;
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** aggregate max on columns */
type AuthKeyAccountAddressesMaxFields = {
    account_address?: Maybe<Scalars["String"]["output"]>;
    auth_key?: Maybe<Scalars["String"]["output"]>;
    last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};
/** aggregate min on columns */
type AuthKeyAccountAddressesMinFields = {
    account_address?: Maybe<Scalars["String"]["output"]>;
    auth_key?: Maybe<Scalars["String"]["output"]>;
    last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};
/** response of any mutation on the table "auth_key_account_addresses" */
type AuthKeyAccountAddressesMutationResponse = {
    /** number of rows affected by the mutation */
    affected_rows: Scalars["Int"]["output"];
    /** data from the rows affected by the mutation */
    returning: Array<AuthKeyAccountAddresses>;
};
/** on_conflict condition type for table "auth_key_account_addresses" */
type AuthKeyAccountAddressesOnConflict = {
    constraint: AuthKeyAccountAddressesConstraint;
    update_columns?: Array<AuthKeyAccountAddressesUpdateColumn>;
    where?: InputMaybe<AuthKeyAccountAddressesBoolExp>;
};
/** Ordering options when selecting data from "auth_key_account_addresses". */
type AuthKeyAccountAddressesOrderBy = {
    account_address?: InputMaybe<OrderBy>;
    auth_key?: InputMaybe<OrderBy>;
    is_auth_key_used?: InputMaybe<OrderBy>;
    last_transaction_version?: InputMaybe<OrderBy>;
};
/** primary key columns input for table: auth_key_account_addresses */
type AuthKeyAccountAddressesPkColumnsInput = {
    account_address: Scalars["String"]["input"];
};
/** select columns of table "auth_key_account_addresses" */
declare enum AuthKeyAccountAddressesSelectColumn {
    /** column name */
    AccountAddress = "account_address",
    /** column name */
    AuthKey = "auth_key",
    /** column name */
    IsAuthKeyUsed = "is_auth_key_used",
    /** column name */
    LastTransactionVersion = "last_transaction_version"
}
/** input type for updating data in table "auth_key_account_addresses" */
type AuthKeyAccountAddressesSetInput = {
    account_address?: InputMaybe<Scalars["String"]["input"]>;
    auth_key?: InputMaybe<Scalars["String"]["input"]>;
    is_auth_key_used?: InputMaybe<Scalars["Boolean"]["input"]>;
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** aggregate stddev on columns */
type AuthKeyAccountAddressesStddevFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_pop on columns */
type AuthKeyAccountAddressesStddevPopFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_samp on columns */
type AuthKeyAccountAddressesStddevSampFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** Streaming cursor of the table "auth_key_account_addresses" */
type AuthKeyAccountAddressesStreamCursorInput = {
    /** Stream column input with initial value */
    initial_value: AuthKeyAccountAddressesStreamCursorValueInput;
    /** cursor ordering */
    ordering?: InputMaybe<CursorOrdering>;
};
/** Initial value of the column from where the streaming should start */
type AuthKeyAccountAddressesStreamCursorValueInput = {
    account_address?: InputMaybe<Scalars["String"]["input"]>;
    auth_key?: InputMaybe<Scalars["String"]["input"]>;
    is_auth_key_used?: InputMaybe<Scalars["Boolean"]["input"]>;
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** aggregate sum on columns */
type AuthKeyAccountAddressesSumFields = {
    last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};
/** update columns of table "auth_key_account_addresses" */
declare enum AuthKeyAccountAddressesUpdateColumn {
    /** column name */
    AccountAddress = "account_address",
    /** column name */
    AuthKey = "auth_key",
    /** column name */
    IsAuthKeyUsed = "is_auth_key_used",
    /** column name */
    LastTransactionVersion = "last_transaction_version"
}
type AuthKeyAccountAddressesUpdates = {
    /** increments the numeric columns with given value of the filtered values */
    _inc?: InputMaybe<AuthKeyAccountAddressesIncInput>;
    /** sets the columns of the filtered rows to the given values */
    _set?: InputMaybe<AuthKeyAccountAddressesSetInput>;
    /** filter the rows which have to be updated */
    where: AuthKeyAccountAddressesBoolExp;
};
/** aggregate var_pop on columns */
type AuthKeyAccountAddressesVarPopFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate var_samp on columns */
type AuthKeyAccountAddressesVarSampFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate variance on columns */
type AuthKeyAccountAddressesVarianceFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** Boolean expression to compare columns of type "bigint". All fields are combined with logical 'AND'. */
type BigintComparisonExp = {
    _eq?: InputMaybe<Scalars["bigint"]["input"]>;
    _gt?: InputMaybe<Scalars["bigint"]["input"]>;
    _gte?: InputMaybe<Scalars["bigint"]["input"]>;
    _in?: InputMaybe<Array<Scalars["bigint"]["input"]>>;
    _is_null?: InputMaybe<Scalars["Boolean"]["input"]>;
    _lt?: InputMaybe<Scalars["bigint"]["input"]>;
    _lte?: InputMaybe<Scalars["bigint"]["input"]>;
    _neq?: InputMaybe<Scalars["bigint"]["input"]>;
    _nin?: InputMaybe<Array<Scalars["bigint"]["input"]>>;
};
/** columns and relationships of "block_metadata_transactions" */
type BlockMetadataTransactions = {
    block_height: Scalars["bigint"]["output"];
    epoch: Scalars["bigint"]["output"];
    failed_proposer_indices: Scalars["jsonb"]["output"];
    id: Scalars["String"]["output"];
    inserted_at: Scalars["timestamp"]["output"];
    previous_block_votes_bitvec: Scalars["jsonb"]["output"];
    proposer: Scalars["String"]["output"];
    round: Scalars["bigint"]["output"];
    timestamp: Scalars["timestamp"]["output"];
    version: Scalars["bigint"]["output"];
};
/** columns and relationships of "block_metadata_transactions" */
type BlockMetadataTransactionsFailedProposerIndicesArgs = {
    path?: InputMaybe<Scalars["String"]["input"]>;
};
/** columns and relationships of "block_metadata_transactions" */
type BlockMetadataTransactionsPreviousBlockVotesBitvecArgs = {
    path?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregated selection of "block_metadata_transactions" */
type BlockMetadataTransactionsAggregate = {
    aggregate?: Maybe<BlockMetadataTransactionsAggregateFields>;
    nodes: Array<BlockMetadataTransactions>;
};
/** aggregate fields of "block_metadata_transactions" */
type BlockMetadataTransactionsAggregateFields = {
    avg?: Maybe<BlockMetadataTransactionsAvgFields>;
    count: Scalars["Int"]["output"];
    max?: Maybe<BlockMetadataTransactionsMaxFields>;
    min?: Maybe<BlockMetadataTransactionsMinFields>;
    stddev?: Maybe<BlockMetadataTransactionsStddevFields>;
    stddev_pop?: Maybe<BlockMetadataTransactionsStddevPopFields>;
    stddev_samp?: Maybe<BlockMetadataTransactionsStddevSampFields>;
    sum?: Maybe<BlockMetadataTransactionsSumFields>;
    var_pop?: Maybe<BlockMetadataTransactionsVarPopFields>;
    var_samp?: Maybe<BlockMetadataTransactionsVarSampFields>;
    variance?: Maybe<BlockMetadataTransactionsVarianceFields>;
};
/** aggregate fields of "block_metadata_transactions" */
type BlockMetadataTransactionsAggregateFieldsCountArgs = {
    columns?: InputMaybe<Array<BlockMetadataTransactionsSelectColumn>>;
    distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};
/** append existing jsonb value of filtered columns with new jsonb value */
type BlockMetadataTransactionsAppendInput = {
    failed_proposer_indices?: InputMaybe<Scalars["jsonb"]["input"]>;
    previous_block_votes_bitvec?: InputMaybe<Scalars["jsonb"]["input"]>;
};
/** aggregate avg on columns */
type BlockMetadataTransactionsAvgFields = {
    block_height?: Maybe<Scalars["Float"]["output"]>;
    epoch?: Maybe<Scalars["Float"]["output"]>;
    round?: Maybe<Scalars["Float"]["output"]>;
    version?: Maybe<Scalars["Float"]["output"]>;
};
/** Boolean expression to filter rows from the table "block_metadata_transactions". All fields are combined with a logical 'AND'. */
type BlockMetadataTransactionsBoolExp = {
    _and?: InputMaybe<Array<BlockMetadataTransactionsBoolExp>>;
    _not?: InputMaybe<BlockMetadataTransactionsBoolExp>;
    _or?: InputMaybe<Array<BlockMetadataTransactionsBoolExp>>;
    block_height?: InputMaybe<BigintComparisonExp>;
    epoch?: InputMaybe<BigintComparisonExp>;
    failed_proposer_indices?: InputMaybe<JsonbComparisonExp>;
    id?: InputMaybe<StringComparisonExp>;
    inserted_at?: InputMaybe<TimestampComparisonExp>;
    previous_block_votes_bitvec?: InputMaybe<JsonbComparisonExp>;
    proposer?: InputMaybe<StringComparisonExp>;
    round?: InputMaybe<BigintComparisonExp>;
    timestamp?: InputMaybe<TimestampComparisonExp>;
    version?: InputMaybe<BigintComparisonExp>;
};
/** unique or primary key constraints on table "block_metadata_transactions" */
declare enum BlockMetadataTransactionsConstraint {
    /** unique or primary key constraint on columns "block_height" */
    BlockMetadataTransactionsBlockHeightKey = "block_metadata_transactions_block_height_key",
    /** unique or primary key constraint on columns "version" */
    BlockMetadataTransactionsPkey = "block_metadata_transactions_pkey"
}
/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
type BlockMetadataTransactionsDeleteAtPathInput = {
    failed_proposer_indices?: InputMaybe<Array<Scalars["String"]["input"]>>;
    previous_block_votes_bitvec?: InputMaybe<Array<Scalars["String"]["input"]>>;
};
/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
type BlockMetadataTransactionsDeleteElemInput = {
    failed_proposer_indices?: InputMaybe<Scalars["Int"]["input"]>;
    previous_block_votes_bitvec?: InputMaybe<Scalars["Int"]["input"]>;
};
/** delete key/value pair or string element. key/value pairs are matched based on their key value */
type BlockMetadataTransactionsDeleteKeyInput = {
    failed_proposer_indices?: InputMaybe<Scalars["String"]["input"]>;
    previous_block_votes_bitvec?: InputMaybe<Scalars["String"]["input"]>;
};
/** input type for incrementing numeric columns in table "block_metadata_transactions" */
type BlockMetadataTransactionsIncInput = {
    block_height?: InputMaybe<Scalars["bigint"]["input"]>;
    epoch?: InputMaybe<Scalars["bigint"]["input"]>;
    round?: InputMaybe<Scalars["bigint"]["input"]>;
    version?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** input type for inserting data into table "block_metadata_transactions" */
type BlockMetadataTransactionsInsertInput = {
    block_height?: InputMaybe<Scalars["bigint"]["input"]>;
    epoch?: InputMaybe<Scalars["bigint"]["input"]>;
    failed_proposer_indices?: InputMaybe<Scalars["jsonb"]["input"]>;
    id?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    previous_block_votes_bitvec?: InputMaybe<Scalars["jsonb"]["input"]>;
    proposer?: InputMaybe<Scalars["String"]["input"]>;
    round?: InputMaybe<Scalars["bigint"]["input"]>;
    timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    version?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** aggregate max on columns */
type BlockMetadataTransactionsMaxFields = {
    block_height?: Maybe<Scalars["bigint"]["output"]>;
    epoch?: Maybe<Scalars["bigint"]["output"]>;
    id?: Maybe<Scalars["String"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    proposer?: Maybe<Scalars["String"]["output"]>;
    round?: Maybe<Scalars["bigint"]["output"]>;
    timestamp?: Maybe<Scalars["timestamp"]["output"]>;
    version?: Maybe<Scalars["bigint"]["output"]>;
};
/** aggregate min on columns */
type BlockMetadataTransactionsMinFields = {
    block_height?: Maybe<Scalars["bigint"]["output"]>;
    epoch?: Maybe<Scalars["bigint"]["output"]>;
    id?: Maybe<Scalars["String"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    proposer?: Maybe<Scalars["String"]["output"]>;
    round?: Maybe<Scalars["bigint"]["output"]>;
    timestamp?: Maybe<Scalars["timestamp"]["output"]>;
    version?: Maybe<Scalars["bigint"]["output"]>;
};
/** response of any mutation on the table "block_metadata_transactions" */
type BlockMetadataTransactionsMutationResponse = {
    /** number of rows affected by the mutation */
    affected_rows: Scalars["Int"]["output"];
    /** data from the rows affected by the mutation */
    returning: Array<BlockMetadataTransactions>;
};
/** on_conflict condition type for table "block_metadata_transactions" */
type BlockMetadataTransactionsOnConflict = {
    constraint: BlockMetadataTransactionsConstraint;
    update_columns?: Array<BlockMetadataTransactionsUpdateColumn>;
    where?: InputMaybe<BlockMetadataTransactionsBoolExp>;
};
/** Ordering options when selecting data from "block_metadata_transactions". */
type BlockMetadataTransactionsOrderBy = {
    block_height?: InputMaybe<OrderBy>;
    epoch?: InputMaybe<OrderBy>;
    failed_proposer_indices?: InputMaybe<OrderBy>;
    id?: InputMaybe<OrderBy>;
    inserted_at?: InputMaybe<OrderBy>;
    previous_block_votes_bitvec?: InputMaybe<OrderBy>;
    proposer?: InputMaybe<OrderBy>;
    round?: InputMaybe<OrderBy>;
    timestamp?: InputMaybe<OrderBy>;
    version?: InputMaybe<OrderBy>;
};
/** primary key columns input for table: block_metadata_transactions */
type BlockMetadataTransactionsPkColumnsInput = {
    version: Scalars["bigint"]["input"];
};
/** prepend existing jsonb value of filtered columns with new jsonb value */
type BlockMetadataTransactionsPrependInput = {
    failed_proposer_indices?: InputMaybe<Scalars["jsonb"]["input"]>;
    previous_block_votes_bitvec?: InputMaybe<Scalars["jsonb"]["input"]>;
};
/** select columns of table "block_metadata_transactions" */
declare enum BlockMetadataTransactionsSelectColumn {
    /** column name */
    BlockHeight = "block_height",
    /** column name */
    Epoch = "epoch",
    /** column name */
    FailedProposerIndices = "failed_proposer_indices",
    /** column name */
    Id = "id",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    PreviousBlockVotesBitvec = "previous_block_votes_bitvec",
    /** column name */
    Proposer = "proposer",
    /** column name */
    Round = "round",
    /** column name */
    Timestamp = "timestamp",
    /** column name */
    Version = "version"
}
/** input type for updating data in table "block_metadata_transactions" */
type BlockMetadataTransactionsSetInput = {
    block_height?: InputMaybe<Scalars["bigint"]["input"]>;
    epoch?: InputMaybe<Scalars["bigint"]["input"]>;
    failed_proposer_indices?: InputMaybe<Scalars["jsonb"]["input"]>;
    id?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    previous_block_votes_bitvec?: InputMaybe<Scalars["jsonb"]["input"]>;
    proposer?: InputMaybe<Scalars["String"]["input"]>;
    round?: InputMaybe<Scalars["bigint"]["input"]>;
    timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    version?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** aggregate stddev on columns */
type BlockMetadataTransactionsStddevFields = {
    block_height?: Maybe<Scalars["Float"]["output"]>;
    epoch?: Maybe<Scalars["Float"]["output"]>;
    round?: Maybe<Scalars["Float"]["output"]>;
    version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_pop on columns */
type BlockMetadataTransactionsStddevPopFields = {
    block_height?: Maybe<Scalars["Float"]["output"]>;
    epoch?: Maybe<Scalars["Float"]["output"]>;
    round?: Maybe<Scalars["Float"]["output"]>;
    version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_samp on columns */
type BlockMetadataTransactionsStddevSampFields = {
    block_height?: Maybe<Scalars["Float"]["output"]>;
    epoch?: Maybe<Scalars["Float"]["output"]>;
    round?: Maybe<Scalars["Float"]["output"]>;
    version?: Maybe<Scalars["Float"]["output"]>;
};
/** Streaming cursor of the table "block_metadata_transactions" */
type BlockMetadataTransactionsStreamCursorInput = {
    /** Stream column input with initial value */
    initial_value: BlockMetadataTransactionsStreamCursorValueInput;
    /** cursor ordering */
    ordering?: InputMaybe<CursorOrdering>;
};
/** Initial value of the column from where the streaming should start */
type BlockMetadataTransactionsStreamCursorValueInput = {
    block_height?: InputMaybe<Scalars["bigint"]["input"]>;
    epoch?: InputMaybe<Scalars["bigint"]["input"]>;
    failed_proposer_indices?: InputMaybe<Scalars["jsonb"]["input"]>;
    id?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    previous_block_votes_bitvec?: InputMaybe<Scalars["jsonb"]["input"]>;
    proposer?: InputMaybe<Scalars["String"]["input"]>;
    round?: InputMaybe<Scalars["bigint"]["input"]>;
    timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    version?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** aggregate sum on columns */
type BlockMetadataTransactionsSumFields = {
    block_height?: Maybe<Scalars["bigint"]["output"]>;
    epoch?: Maybe<Scalars["bigint"]["output"]>;
    round?: Maybe<Scalars["bigint"]["output"]>;
    version?: Maybe<Scalars["bigint"]["output"]>;
};
/** update columns of table "block_metadata_transactions" */
declare enum BlockMetadataTransactionsUpdateColumn {
    /** column name */
    BlockHeight = "block_height",
    /** column name */
    Epoch = "epoch",
    /** column name */
    FailedProposerIndices = "failed_proposer_indices",
    /** column name */
    Id = "id",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    PreviousBlockVotesBitvec = "previous_block_votes_bitvec",
    /** column name */
    Proposer = "proposer",
    /** column name */
    Round = "round",
    /** column name */
    Timestamp = "timestamp",
    /** column name */
    Version = "version"
}
type BlockMetadataTransactionsUpdates = {
    /** append existing jsonb value of filtered columns with new jsonb value */
    _append?: InputMaybe<BlockMetadataTransactionsAppendInput>;
    /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
    _delete_at_path?: InputMaybe<BlockMetadataTransactionsDeleteAtPathInput>;
    /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
    _delete_elem?: InputMaybe<BlockMetadataTransactionsDeleteElemInput>;
    /** delete key/value pair or string element. key/value pairs are matched based on their key value */
    _delete_key?: InputMaybe<BlockMetadataTransactionsDeleteKeyInput>;
    /** increments the numeric columns with given value of the filtered values */
    _inc?: InputMaybe<BlockMetadataTransactionsIncInput>;
    /** prepend existing jsonb value of filtered columns with new jsonb value */
    _prepend?: InputMaybe<BlockMetadataTransactionsPrependInput>;
    /** sets the columns of the filtered rows to the given values */
    _set?: InputMaybe<BlockMetadataTransactionsSetInput>;
    /** filter the rows which have to be updated */
    where: BlockMetadataTransactionsBoolExp;
};
/** aggregate var_pop on columns */
type BlockMetadataTransactionsVarPopFields = {
    block_height?: Maybe<Scalars["Float"]["output"]>;
    epoch?: Maybe<Scalars["Float"]["output"]>;
    round?: Maybe<Scalars["Float"]["output"]>;
    version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate var_samp on columns */
type BlockMetadataTransactionsVarSampFields = {
    block_height?: Maybe<Scalars["Float"]["output"]>;
    epoch?: Maybe<Scalars["Float"]["output"]>;
    round?: Maybe<Scalars["Float"]["output"]>;
    version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate variance on columns */
type BlockMetadataTransactionsVarianceFields = {
    block_height?: Maybe<Scalars["Float"]["output"]>;
    epoch?: Maybe<Scalars["Float"]["output"]>;
    round?: Maybe<Scalars["Float"]["output"]>;
    version?: Maybe<Scalars["Float"]["output"]>;
};
/** Boolean expression to compare columns of type "bytea". All fields are combined with logical 'AND'. */
type ByteaComparisonExp = {
    _eq?: InputMaybe<Scalars["bytea"]["input"]>;
    _gt?: InputMaybe<Scalars["bytea"]["input"]>;
    _gte?: InputMaybe<Scalars["bytea"]["input"]>;
    _in?: InputMaybe<Array<Scalars["bytea"]["input"]>>;
    _is_null?: InputMaybe<Scalars["Boolean"]["input"]>;
    _lt?: InputMaybe<Scalars["bytea"]["input"]>;
    _lte?: InputMaybe<Scalars["bytea"]["input"]>;
    _neq?: InputMaybe<Scalars["bytea"]["input"]>;
    _nin?: InputMaybe<Array<Scalars["bytea"]["input"]>>;
};
/** columns and relationships of "coin_activities" */
type CoinActivities = {
    activity_type: Scalars["String"]["output"];
    amount: Scalars["numeric"]["output"];
    block_height: Scalars["bigint"]["output"];
    coin_type: Scalars["String"]["output"];
    entry_function_id_str?: Maybe<Scalars["String"]["output"]>;
    event_account_address: Scalars["String"]["output"];
    event_creation_number: Scalars["bigint"]["output"];
    event_index?: Maybe<Scalars["bigint"]["output"]>;
    event_sequence_number: Scalars["bigint"]["output"];
    gas_fee_payer_address?: Maybe<Scalars["String"]["output"]>;
    inserted_at: Scalars["timestamp"]["output"];
    is_gas_fee: Scalars["Boolean"]["output"];
    is_transaction_success: Scalars["Boolean"]["output"];
    owner_address: Scalars["String"]["output"];
    storage_refund_amount: Scalars["numeric"]["output"];
    transaction_timestamp: Scalars["timestamp"]["output"];
    transaction_version: Scalars["bigint"]["output"];
};
/** aggregated selection of "coin_activities" */
type CoinActivitiesAggregate = {
    aggregate?: Maybe<CoinActivitiesAggregateFields>;
    nodes: Array<CoinActivities>;
};
/** aggregate fields of "coin_activities" */
type CoinActivitiesAggregateFields = {
    avg?: Maybe<CoinActivitiesAvgFields>;
    count: Scalars["Int"]["output"];
    max?: Maybe<CoinActivitiesMaxFields>;
    min?: Maybe<CoinActivitiesMinFields>;
    stddev?: Maybe<CoinActivitiesStddevFields>;
    stddev_pop?: Maybe<CoinActivitiesStddevPopFields>;
    stddev_samp?: Maybe<CoinActivitiesStddevSampFields>;
    sum?: Maybe<CoinActivitiesSumFields>;
    var_pop?: Maybe<CoinActivitiesVarPopFields>;
    var_samp?: Maybe<CoinActivitiesVarSampFields>;
    variance?: Maybe<CoinActivitiesVarianceFields>;
};
/** aggregate fields of "coin_activities" */
type CoinActivitiesAggregateFieldsCountArgs = {
    columns?: InputMaybe<Array<CoinActivitiesSelectColumn>>;
    distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};
/** aggregate avg on columns */
type CoinActivitiesAvgFields = {
    amount?: Maybe<Scalars["Float"]["output"]>;
    block_height?: Maybe<Scalars["Float"]["output"]>;
    event_creation_number?: Maybe<Scalars["Float"]["output"]>;
    event_index?: Maybe<Scalars["Float"]["output"]>;
    event_sequence_number?: Maybe<Scalars["Float"]["output"]>;
    storage_refund_amount?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** Boolean expression to filter rows from the table "coin_activities". All fields are combined with a logical 'AND'. */
type CoinActivitiesBoolExp = {
    _and?: InputMaybe<Array<CoinActivitiesBoolExp>>;
    _not?: InputMaybe<CoinActivitiesBoolExp>;
    _or?: InputMaybe<Array<CoinActivitiesBoolExp>>;
    activity_type?: InputMaybe<StringComparisonExp>;
    amount?: InputMaybe<NumericComparisonExp>;
    block_height?: InputMaybe<BigintComparisonExp>;
    coin_type?: InputMaybe<StringComparisonExp>;
    entry_function_id_str?: InputMaybe<StringComparisonExp>;
    event_account_address?: InputMaybe<StringComparisonExp>;
    event_creation_number?: InputMaybe<BigintComparisonExp>;
    event_index?: InputMaybe<BigintComparisonExp>;
    event_sequence_number?: InputMaybe<BigintComparisonExp>;
    gas_fee_payer_address?: InputMaybe<StringComparisonExp>;
    inserted_at?: InputMaybe<TimestampComparisonExp>;
    is_gas_fee?: InputMaybe<BooleanComparisonExp>;
    is_transaction_success?: InputMaybe<BooleanComparisonExp>;
    owner_address?: InputMaybe<StringComparisonExp>;
    storage_refund_amount?: InputMaybe<NumericComparisonExp>;
    transaction_timestamp?: InputMaybe<TimestampComparisonExp>;
    transaction_version?: InputMaybe<BigintComparisonExp>;
};
/** unique or primary key constraints on table "coin_activities" */
declare enum CoinActivitiesConstraint {
    /** unique or primary key constraint on columns "event_sequence_number", "event_creation_number", "transaction_version", "event_account_address" */
    CoinActivitiesPkey = "coin_activities_pkey"
}
/** input type for incrementing numeric columns in table "coin_activities" */
type CoinActivitiesIncInput = {
    amount?: InputMaybe<Scalars["numeric"]["input"]>;
    block_height?: InputMaybe<Scalars["bigint"]["input"]>;
    event_creation_number?: InputMaybe<Scalars["bigint"]["input"]>;
    event_index?: InputMaybe<Scalars["bigint"]["input"]>;
    event_sequence_number?: InputMaybe<Scalars["bigint"]["input"]>;
    storage_refund_amount?: InputMaybe<Scalars["numeric"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** input type for inserting data into table "coin_activities" */
type CoinActivitiesInsertInput = {
    activity_type?: InputMaybe<Scalars["String"]["input"]>;
    amount?: InputMaybe<Scalars["numeric"]["input"]>;
    block_height?: InputMaybe<Scalars["bigint"]["input"]>;
    coin_type?: InputMaybe<Scalars["String"]["input"]>;
    entry_function_id_str?: InputMaybe<Scalars["String"]["input"]>;
    event_account_address?: InputMaybe<Scalars["String"]["input"]>;
    event_creation_number?: InputMaybe<Scalars["bigint"]["input"]>;
    event_index?: InputMaybe<Scalars["bigint"]["input"]>;
    event_sequence_number?: InputMaybe<Scalars["bigint"]["input"]>;
    gas_fee_payer_address?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    is_gas_fee?: InputMaybe<Scalars["Boolean"]["input"]>;
    is_transaction_success?: InputMaybe<Scalars["Boolean"]["input"]>;
    owner_address?: InputMaybe<Scalars["String"]["input"]>;
    storage_refund_amount?: InputMaybe<Scalars["numeric"]["input"]>;
    transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** aggregate max on columns */
type CoinActivitiesMaxFields = {
    activity_type?: Maybe<Scalars["String"]["output"]>;
    amount?: Maybe<Scalars["numeric"]["output"]>;
    block_height?: Maybe<Scalars["bigint"]["output"]>;
    coin_type?: Maybe<Scalars["String"]["output"]>;
    entry_function_id_str?: Maybe<Scalars["String"]["output"]>;
    event_account_address?: Maybe<Scalars["String"]["output"]>;
    event_creation_number?: Maybe<Scalars["bigint"]["output"]>;
    event_index?: Maybe<Scalars["bigint"]["output"]>;
    event_sequence_number?: Maybe<Scalars["bigint"]["output"]>;
    gas_fee_payer_address?: Maybe<Scalars["String"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    owner_address?: Maybe<Scalars["String"]["output"]>;
    storage_refund_amount?: Maybe<Scalars["numeric"]["output"]>;
    transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};
/** aggregate min on columns */
type CoinActivitiesMinFields = {
    activity_type?: Maybe<Scalars["String"]["output"]>;
    amount?: Maybe<Scalars["numeric"]["output"]>;
    block_height?: Maybe<Scalars["bigint"]["output"]>;
    coin_type?: Maybe<Scalars["String"]["output"]>;
    entry_function_id_str?: Maybe<Scalars["String"]["output"]>;
    event_account_address?: Maybe<Scalars["String"]["output"]>;
    event_creation_number?: Maybe<Scalars["bigint"]["output"]>;
    event_index?: Maybe<Scalars["bigint"]["output"]>;
    event_sequence_number?: Maybe<Scalars["bigint"]["output"]>;
    gas_fee_payer_address?: Maybe<Scalars["String"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    owner_address?: Maybe<Scalars["String"]["output"]>;
    storage_refund_amount?: Maybe<Scalars["numeric"]["output"]>;
    transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};
/** response of any mutation on the table "coin_activities" */
type CoinActivitiesMutationResponse = {
    /** number of rows affected by the mutation */
    affected_rows: Scalars["Int"]["output"];
    /** data from the rows affected by the mutation */
    returning: Array<CoinActivities>;
};
/** on_conflict condition type for table "coin_activities" */
type CoinActivitiesOnConflict = {
    constraint: CoinActivitiesConstraint;
    update_columns?: Array<CoinActivitiesUpdateColumn>;
    where?: InputMaybe<CoinActivitiesBoolExp>;
};
/** Ordering options when selecting data from "coin_activities". */
type CoinActivitiesOrderBy = {
    activity_type?: InputMaybe<OrderBy>;
    amount?: InputMaybe<OrderBy>;
    block_height?: InputMaybe<OrderBy>;
    coin_type?: InputMaybe<OrderBy>;
    entry_function_id_str?: InputMaybe<OrderBy>;
    event_account_address?: InputMaybe<OrderBy>;
    event_creation_number?: InputMaybe<OrderBy>;
    event_index?: InputMaybe<OrderBy>;
    event_sequence_number?: InputMaybe<OrderBy>;
    gas_fee_payer_address?: InputMaybe<OrderBy>;
    inserted_at?: InputMaybe<OrderBy>;
    is_gas_fee?: InputMaybe<OrderBy>;
    is_transaction_success?: InputMaybe<OrderBy>;
    owner_address?: InputMaybe<OrderBy>;
    storage_refund_amount?: InputMaybe<OrderBy>;
    transaction_timestamp?: InputMaybe<OrderBy>;
    transaction_version?: InputMaybe<OrderBy>;
};
/** primary key columns input for table: coin_activities */
type CoinActivitiesPkColumnsInput = {
    event_account_address: Scalars["String"]["input"];
    event_creation_number: Scalars["bigint"]["input"];
    event_sequence_number: Scalars["bigint"]["input"];
    transaction_version: Scalars["bigint"]["input"];
};
/** select columns of table "coin_activities" */
declare enum CoinActivitiesSelectColumn {
    /** column name */
    ActivityType = "activity_type",
    /** column name */
    Amount = "amount",
    /** column name */
    BlockHeight = "block_height",
    /** column name */
    CoinType = "coin_type",
    /** column name */
    EntryFunctionIdStr = "entry_function_id_str",
    /** column name */
    EventAccountAddress = "event_account_address",
    /** column name */
    EventCreationNumber = "event_creation_number",
    /** column name */
    EventIndex = "event_index",
    /** column name */
    EventSequenceNumber = "event_sequence_number",
    /** column name */
    GasFeePayerAddress = "gas_fee_payer_address",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    IsGasFee = "is_gas_fee",
    /** column name */
    IsTransactionSuccess = "is_transaction_success",
    /** column name */
    OwnerAddress = "owner_address",
    /** column name */
    StorageRefundAmount = "storage_refund_amount",
    /** column name */
    TransactionTimestamp = "transaction_timestamp",
    /** column name */
    TransactionVersion = "transaction_version"
}
/** input type for updating data in table "coin_activities" */
type CoinActivitiesSetInput = {
    activity_type?: InputMaybe<Scalars["String"]["input"]>;
    amount?: InputMaybe<Scalars["numeric"]["input"]>;
    block_height?: InputMaybe<Scalars["bigint"]["input"]>;
    coin_type?: InputMaybe<Scalars["String"]["input"]>;
    entry_function_id_str?: InputMaybe<Scalars["String"]["input"]>;
    event_account_address?: InputMaybe<Scalars["String"]["input"]>;
    event_creation_number?: InputMaybe<Scalars["bigint"]["input"]>;
    event_index?: InputMaybe<Scalars["bigint"]["input"]>;
    event_sequence_number?: InputMaybe<Scalars["bigint"]["input"]>;
    gas_fee_payer_address?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    is_gas_fee?: InputMaybe<Scalars["Boolean"]["input"]>;
    is_transaction_success?: InputMaybe<Scalars["Boolean"]["input"]>;
    owner_address?: InputMaybe<Scalars["String"]["input"]>;
    storage_refund_amount?: InputMaybe<Scalars["numeric"]["input"]>;
    transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** aggregate stddev on columns */
type CoinActivitiesStddevFields = {
    amount?: Maybe<Scalars["Float"]["output"]>;
    block_height?: Maybe<Scalars["Float"]["output"]>;
    event_creation_number?: Maybe<Scalars["Float"]["output"]>;
    event_index?: Maybe<Scalars["Float"]["output"]>;
    event_sequence_number?: Maybe<Scalars["Float"]["output"]>;
    storage_refund_amount?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_pop on columns */
type CoinActivitiesStddevPopFields = {
    amount?: Maybe<Scalars["Float"]["output"]>;
    block_height?: Maybe<Scalars["Float"]["output"]>;
    event_creation_number?: Maybe<Scalars["Float"]["output"]>;
    event_index?: Maybe<Scalars["Float"]["output"]>;
    event_sequence_number?: Maybe<Scalars["Float"]["output"]>;
    storage_refund_amount?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_samp on columns */
type CoinActivitiesStddevSampFields = {
    amount?: Maybe<Scalars["Float"]["output"]>;
    block_height?: Maybe<Scalars["Float"]["output"]>;
    event_creation_number?: Maybe<Scalars["Float"]["output"]>;
    event_index?: Maybe<Scalars["Float"]["output"]>;
    event_sequence_number?: Maybe<Scalars["Float"]["output"]>;
    storage_refund_amount?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** Streaming cursor of the table "coin_activities" */
type CoinActivitiesStreamCursorInput = {
    /** Stream column input with initial value */
    initial_value: CoinActivitiesStreamCursorValueInput;
    /** cursor ordering */
    ordering?: InputMaybe<CursorOrdering>;
};
/** Initial value of the column from where the streaming should start */
type CoinActivitiesStreamCursorValueInput = {
    activity_type?: InputMaybe<Scalars["String"]["input"]>;
    amount?: InputMaybe<Scalars["numeric"]["input"]>;
    block_height?: InputMaybe<Scalars["bigint"]["input"]>;
    coin_type?: InputMaybe<Scalars["String"]["input"]>;
    entry_function_id_str?: InputMaybe<Scalars["String"]["input"]>;
    event_account_address?: InputMaybe<Scalars["String"]["input"]>;
    event_creation_number?: InputMaybe<Scalars["bigint"]["input"]>;
    event_index?: InputMaybe<Scalars["bigint"]["input"]>;
    event_sequence_number?: InputMaybe<Scalars["bigint"]["input"]>;
    gas_fee_payer_address?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    is_gas_fee?: InputMaybe<Scalars["Boolean"]["input"]>;
    is_transaction_success?: InputMaybe<Scalars["Boolean"]["input"]>;
    owner_address?: InputMaybe<Scalars["String"]["input"]>;
    storage_refund_amount?: InputMaybe<Scalars["numeric"]["input"]>;
    transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** aggregate sum on columns */
type CoinActivitiesSumFields = {
    amount?: Maybe<Scalars["numeric"]["output"]>;
    block_height?: Maybe<Scalars["bigint"]["output"]>;
    event_creation_number?: Maybe<Scalars["bigint"]["output"]>;
    event_index?: Maybe<Scalars["bigint"]["output"]>;
    event_sequence_number?: Maybe<Scalars["bigint"]["output"]>;
    storage_refund_amount?: Maybe<Scalars["numeric"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};
/** update columns of table "coin_activities" */
declare enum CoinActivitiesUpdateColumn {
    /** column name */
    ActivityType = "activity_type",
    /** column name */
    Amount = "amount",
    /** column name */
    BlockHeight = "block_height",
    /** column name */
    CoinType = "coin_type",
    /** column name */
    EntryFunctionIdStr = "entry_function_id_str",
    /** column name */
    EventAccountAddress = "event_account_address",
    /** column name */
    EventCreationNumber = "event_creation_number",
    /** column name */
    EventIndex = "event_index",
    /** column name */
    EventSequenceNumber = "event_sequence_number",
    /** column name */
    GasFeePayerAddress = "gas_fee_payer_address",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    IsGasFee = "is_gas_fee",
    /** column name */
    IsTransactionSuccess = "is_transaction_success",
    /** column name */
    OwnerAddress = "owner_address",
    /** column name */
    StorageRefundAmount = "storage_refund_amount",
    /** column name */
    TransactionTimestamp = "transaction_timestamp",
    /** column name */
    TransactionVersion = "transaction_version"
}
type CoinActivitiesUpdates = {
    /** increments the numeric columns with given value of the filtered values */
    _inc?: InputMaybe<CoinActivitiesIncInput>;
    /** sets the columns of the filtered rows to the given values */
    _set?: InputMaybe<CoinActivitiesSetInput>;
    /** filter the rows which have to be updated */
    where: CoinActivitiesBoolExp;
};
/** aggregate var_pop on columns */
type CoinActivitiesVarPopFields = {
    amount?: Maybe<Scalars["Float"]["output"]>;
    block_height?: Maybe<Scalars["Float"]["output"]>;
    event_creation_number?: Maybe<Scalars["Float"]["output"]>;
    event_index?: Maybe<Scalars["Float"]["output"]>;
    event_sequence_number?: Maybe<Scalars["Float"]["output"]>;
    storage_refund_amount?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate var_samp on columns */
type CoinActivitiesVarSampFields = {
    amount?: Maybe<Scalars["Float"]["output"]>;
    block_height?: Maybe<Scalars["Float"]["output"]>;
    event_creation_number?: Maybe<Scalars["Float"]["output"]>;
    event_index?: Maybe<Scalars["Float"]["output"]>;
    event_sequence_number?: Maybe<Scalars["Float"]["output"]>;
    storage_refund_amount?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate variance on columns */
type CoinActivitiesVarianceFields = {
    amount?: Maybe<Scalars["Float"]["output"]>;
    block_height?: Maybe<Scalars["Float"]["output"]>;
    event_creation_number?: Maybe<Scalars["Float"]["output"]>;
    event_index?: Maybe<Scalars["Float"]["output"]>;
    event_sequence_number?: Maybe<Scalars["Float"]["output"]>;
    storage_refund_amount?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** columns and relationships of "coin_balances" */
type CoinBalances = {
    amount: Scalars["numeric"]["output"];
    coin_type: Scalars["String"]["output"];
    coin_type_hash: Scalars["String"]["output"];
    inserted_at: Scalars["timestamp"]["output"];
    owner_address: Scalars["String"]["output"];
    transaction_timestamp: Scalars["timestamp"]["output"];
    transaction_version: Scalars["bigint"]["output"];
};
/** aggregated selection of "coin_balances" */
type CoinBalancesAggregate = {
    aggregate?: Maybe<CoinBalancesAggregateFields>;
    nodes: Array<CoinBalances>;
};
/** aggregate fields of "coin_balances" */
type CoinBalancesAggregateFields = {
    avg?: Maybe<CoinBalancesAvgFields>;
    count: Scalars["Int"]["output"];
    max?: Maybe<CoinBalancesMaxFields>;
    min?: Maybe<CoinBalancesMinFields>;
    stddev?: Maybe<CoinBalancesStddevFields>;
    stddev_pop?: Maybe<CoinBalancesStddevPopFields>;
    stddev_samp?: Maybe<CoinBalancesStddevSampFields>;
    sum?: Maybe<CoinBalancesSumFields>;
    var_pop?: Maybe<CoinBalancesVarPopFields>;
    var_samp?: Maybe<CoinBalancesVarSampFields>;
    variance?: Maybe<CoinBalancesVarianceFields>;
};
/** aggregate fields of "coin_balances" */
type CoinBalancesAggregateFieldsCountArgs = {
    columns?: InputMaybe<Array<CoinBalancesSelectColumn>>;
    distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};
/** aggregate avg on columns */
type CoinBalancesAvgFields = {
    amount?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** Boolean expression to filter rows from the table "coin_balances". All fields are combined with a logical 'AND'. */
type CoinBalancesBoolExp = {
    _and?: InputMaybe<Array<CoinBalancesBoolExp>>;
    _not?: InputMaybe<CoinBalancesBoolExp>;
    _or?: InputMaybe<Array<CoinBalancesBoolExp>>;
    amount?: InputMaybe<NumericComparisonExp>;
    coin_type?: InputMaybe<StringComparisonExp>;
    coin_type_hash?: InputMaybe<StringComparisonExp>;
    inserted_at?: InputMaybe<TimestampComparisonExp>;
    owner_address?: InputMaybe<StringComparisonExp>;
    transaction_timestamp?: InputMaybe<TimestampComparisonExp>;
    transaction_version?: InputMaybe<BigintComparisonExp>;
};
/** unique or primary key constraints on table "coin_balances" */
declare enum CoinBalancesConstraint {
    /** unique or primary key constraint on columns "coin_type_hash", "owner_address", "transaction_version" */
    CoinBalancesPkey = "coin_balances_pkey"
}
/** input type for incrementing numeric columns in table "coin_balances" */
type CoinBalancesIncInput = {
    amount?: InputMaybe<Scalars["numeric"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** input type for inserting data into table "coin_balances" */
type CoinBalancesInsertInput = {
    amount?: InputMaybe<Scalars["numeric"]["input"]>;
    coin_type?: InputMaybe<Scalars["String"]["input"]>;
    coin_type_hash?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    owner_address?: InputMaybe<Scalars["String"]["input"]>;
    transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** aggregate max on columns */
type CoinBalancesMaxFields = {
    amount?: Maybe<Scalars["numeric"]["output"]>;
    coin_type?: Maybe<Scalars["String"]["output"]>;
    coin_type_hash?: Maybe<Scalars["String"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    owner_address?: Maybe<Scalars["String"]["output"]>;
    transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};
/** aggregate min on columns */
type CoinBalancesMinFields = {
    amount?: Maybe<Scalars["numeric"]["output"]>;
    coin_type?: Maybe<Scalars["String"]["output"]>;
    coin_type_hash?: Maybe<Scalars["String"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    owner_address?: Maybe<Scalars["String"]["output"]>;
    transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};
/** response of any mutation on the table "coin_balances" */
type CoinBalancesMutationResponse = {
    /** number of rows affected by the mutation */
    affected_rows: Scalars["Int"]["output"];
    /** data from the rows affected by the mutation */
    returning: Array<CoinBalances>;
};
/** on_conflict condition type for table "coin_balances" */
type CoinBalancesOnConflict = {
    constraint: CoinBalancesConstraint;
    update_columns?: Array<CoinBalancesUpdateColumn>;
    where?: InputMaybe<CoinBalancesBoolExp>;
};
/** Ordering options when selecting data from "coin_balances". */
type CoinBalancesOrderBy = {
    amount?: InputMaybe<OrderBy>;
    coin_type?: InputMaybe<OrderBy>;
    coin_type_hash?: InputMaybe<OrderBy>;
    inserted_at?: InputMaybe<OrderBy>;
    owner_address?: InputMaybe<OrderBy>;
    transaction_timestamp?: InputMaybe<OrderBy>;
    transaction_version?: InputMaybe<OrderBy>;
};
/** primary key columns input for table: coin_balances */
type CoinBalancesPkColumnsInput = {
    coin_type_hash: Scalars["String"]["input"];
    owner_address: Scalars["String"]["input"];
    transaction_version: Scalars["bigint"]["input"];
};
/** select columns of table "coin_balances" */
declare enum CoinBalancesSelectColumn {
    /** column name */
    Amount = "amount",
    /** column name */
    CoinType = "coin_type",
    /** column name */
    CoinTypeHash = "coin_type_hash",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    OwnerAddress = "owner_address",
    /** column name */
    TransactionTimestamp = "transaction_timestamp",
    /** column name */
    TransactionVersion = "transaction_version"
}
/** input type for updating data in table "coin_balances" */
type CoinBalancesSetInput = {
    amount?: InputMaybe<Scalars["numeric"]["input"]>;
    coin_type?: InputMaybe<Scalars["String"]["input"]>;
    coin_type_hash?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    owner_address?: InputMaybe<Scalars["String"]["input"]>;
    transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** aggregate stddev on columns */
type CoinBalancesStddevFields = {
    amount?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_pop on columns */
type CoinBalancesStddevPopFields = {
    amount?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_samp on columns */
type CoinBalancesStddevSampFields = {
    amount?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** Streaming cursor of the table "coin_balances" */
type CoinBalancesStreamCursorInput = {
    /** Stream column input with initial value */
    initial_value: CoinBalancesStreamCursorValueInput;
    /** cursor ordering */
    ordering?: InputMaybe<CursorOrdering>;
};
/** Initial value of the column from where the streaming should start */
type CoinBalancesStreamCursorValueInput = {
    amount?: InputMaybe<Scalars["numeric"]["input"]>;
    coin_type?: InputMaybe<Scalars["String"]["input"]>;
    coin_type_hash?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    owner_address?: InputMaybe<Scalars["String"]["input"]>;
    transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** aggregate sum on columns */
type CoinBalancesSumFields = {
    amount?: Maybe<Scalars["numeric"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};
/** update columns of table "coin_balances" */
declare enum CoinBalancesUpdateColumn {
    /** column name */
    Amount = "amount",
    /** column name */
    CoinType = "coin_type",
    /** column name */
    CoinTypeHash = "coin_type_hash",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    OwnerAddress = "owner_address",
    /** column name */
    TransactionTimestamp = "transaction_timestamp",
    /** column name */
    TransactionVersion = "transaction_version"
}
type CoinBalancesUpdates = {
    /** increments the numeric columns with given value of the filtered values */
    _inc?: InputMaybe<CoinBalancesIncInput>;
    /** sets the columns of the filtered rows to the given values */
    _set?: InputMaybe<CoinBalancesSetInput>;
    /** filter the rows which have to be updated */
    where: CoinBalancesBoolExp;
};
/** aggregate var_pop on columns */
type CoinBalancesVarPopFields = {
    amount?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate var_samp on columns */
type CoinBalancesVarSampFields = {
    amount?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate variance on columns */
type CoinBalancesVarianceFields = {
    amount?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** columns and relationships of "coin_infos" */
type CoinInfos = {
    coin_type: Scalars["String"]["output"];
    coin_type_hash: Scalars["String"]["output"];
    creator_address: Scalars["String"]["output"];
    decimals: Scalars["Int"]["output"];
    inserted_at: Scalars["timestamp"]["output"];
    name: Scalars["String"]["output"];
    supply_aggregator_table_handle?: Maybe<Scalars["String"]["output"]>;
    supply_aggregator_table_key?: Maybe<Scalars["String"]["output"]>;
    symbol: Scalars["String"]["output"];
    transaction_created_timestamp: Scalars["timestamp"]["output"];
    transaction_version_created: Scalars["bigint"]["output"];
};
/** aggregated selection of "coin_infos" */
type CoinInfosAggregate = {
    aggregate?: Maybe<CoinInfosAggregateFields>;
    nodes: Array<CoinInfos>;
};
/** aggregate fields of "coin_infos" */
type CoinInfosAggregateFields = {
    avg?: Maybe<CoinInfosAvgFields>;
    count: Scalars["Int"]["output"];
    max?: Maybe<CoinInfosMaxFields>;
    min?: Maybe<CoinInfosMinFields>;
    stddev?: Maybe<CoinInfosStddevFields>;
    stddev_pop?: Maybe<CoinInfosStddevPopFields>;
    stddev_samp?: Maybe<CoinInfosStddevSampFields>;
    sum?: Maybe<CoinInfosSumFields>;
    var_pop?: Maybe<CoinInfosVarPopFields>;
    var_samp?: Maybe<CoinInfosVarSampFields>;
    variance?: Maybe<CoinInfosVarianceFields>;
};
/** aggregate fields of "coin_infos" */
type CoinInfosAggregateFieldsCountArgs = {
    columns?: InputMaybe<Array<CoinInfosSelectColumn>>;
    distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};
/** aggregate avg on columns */
type CoinInfosAvgFields = {
    decimals?: Maybe<Scalars["Float"]["output"]>;
    transaction_version_created?: Maybe<Scalars["Float"]["output"]>;
};
/** Boolean expression to filter rows from the table "coin_infos". All fields are combined with a logical 'AND'. */
type CoinInfosBoolExp = {
    _and?: InputMaybe<Array<CoinInfosBoolExp>>;
    _not?: InputMaybe<CoinInfosBoolExp>;
    _or?: InputMaybe<Array<CoinInfosBoolExp>>;
    coin_type?: InputMaybe<StringComparisonExp>;
    coin_type_hash?: InputMaybe<StringComparisonExp>;
    creator_address?: InputMaybe<StringComparisonExp>;
    decimals?: InputMaybe<IntComparisonExp>;
    inserted_at?: InputMaybe<TimestampComparisonExp>;
    name?: InputMaybe<StringComparisonExp>;
    supply_aggregator_table_handle?: InputMaybe<StringComparisonExp>;
    supply_aggregator_table_key?: InputMaybe<StringComparisonExp>;
    symbol?: InputMaybe<StringComparisonExp>;
    transaction_created_timestamp?: InputMaybe<TimestampComparisonExp>;
    transaction_version_created?: InputMaybe<BigintComparisonExp>;
};
/** unique or primary key constraints on table "coin_infos" */
declare enum CoinInfosConstraint {
    /** unique or primary key constraint on columns "coin_type_hash" */
    CoinInfosPkey = "coin_infos_pkey"
}
/** input type for incrementing numeric columns in table "coin_infos" */
type CoinInfosIncInput = {
    decimals?: InputMaybe<Scalars["Int"]["input"]>;
    transaction_version_created?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** input type for inserting data into table "coin_infos" */
type CoinInfosInsertInput = {
    coin_type?: InputMaybe<Scalars["String"]["input"]>;
    coin_type_hash?: InputMaybe<Scalars["String"]["input"]>;
    creator_address?: InputMaybe<Scalars["String"]["input"]>;
    decimals?: InputMaybe<Scalars["Int"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    name?: InputMaybe<Scalars["String"]["input"]>;
    supply_aggregator_table_handle?: InputMaybe<Scalars["String"]["input"]>;
    supply_aggregator_table_key?: InputMaybe<Scalars["String"]["input"]>;
    symbol?: InputMaybe<Scalars["String"]["input"]>;
    transaction_created_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    transaction_version_created?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** aggregate max on columns */
type CoinInfosMaxFields = {
    coin_type?: Maybe<Scalars["String"]["output"]>;
    coin_type_hash?: Maybe<Scalars["String"]["output"]>;
    creator_address?: Maybe<Scalars["String"]["output"]>;
    decimals?: Maybe<Scalars["Int"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    name?: Maybe<Scalars["String"]["output"]>;
    supply_aggregator_table_handle?: Maybe<Scalars["String"]["output"]>;
    supply_aggregator_table_key?: Maybe<Scalars["String"]["output"]>;
    symbol?: Maybe<Scalars["String"]["output"]>;
    transaction_created_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
    transaction_version_created?: Maybe<Scalars["bigint"]["output"]>;
};
/** aggregate min on columns */
type CoinInfosMinFields = {
    coin_type?: Maybe<Scalars["String"]["output"]>;
    coin_type_hash?: Maybe<Scalars["String"]["output"]>;
    creator_address?: Maybe<Scalars["String"]["output"]>;
    decimals?: Maybe<Scalars["Int"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    name?: Maybe<Scalars["String"]["output"]>;
    supply_aggregator_table_handle?: Maybe<Scalars["String"]["output"]>;
    supply_aggregator_table_key?: Maybe<Scalars["String"]["output"]>;
    symbol?: Maybe<Scalars["String"]["output"]>;
    transaction_created_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
    transaction_version_created?: Maybe<Scalars["bigint"]["output"]>;
};
/** response of any mutation on the table "coin_infos" */
type CoinInfosMutationResponse = {
    /** number of rows affected by the mutation */
    affected_rows: Scalars["Int"]["output"];
    /** data from the rows affected by the mutation */
    returning: Array<CoinInfos>;
};
/** on_conflict condition type for table "coin_infos" */
type CoinInfosOnConflict = {
    constraint: CoinInfosConstraint;
    update_columns?: Array<CoinInfosUpdateColumn>;
    where?: InputMaybe<CoinInfosBoolExp>;
};
/** Ordering options when selecting data from "coin_infos". */
type CoinInfosOrderBy = {
    coin_type?: InputMaybe<OrderBy>;
    coin_type_hash?: InputMaybe<OrderBy>;
    creator_address?: InputMaybe<OrderBy>;
    decimals?: InputMaybe<OrderBy>;
    inserted_at?: InputMaybe<OrderBy>;
    name?: InputMaybe<OrderBy>;
    supply_aggregator_table_handle?: InputMaybe<OrderBy>;
    supply_aggregator_table_key?: InputMaybe<OrderBy>;
    symbol?: InputMaybe<OrderBy>;
    transaction_created_timestamp?: InputMaybe<OrderBy>;
    transaction_version_created?: InputMaybe<OrderBy>;
};
/** primary key columns input for table: coin_infos */
type CoinInfosPkColumnsInput = {
    coin_type_hash: Scalars["String"]["input"];
};
/** select columns of table "coin_infos" */
declare enum CoinInfosSelectColumn {
    /** column name */
    CoinType = "coin_type",
    /** column name */
    CoinTypeHash = "coin_type_hash",
    /** column name */
    CreatorAddress = "creator_address",
    /** column name */
    Decimals = "decimals",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    Name = "name",
    /** column name */
    SupplyAggregatorTableHandle = "supply_aggregator_table_handle",
    /** column name */
    SupplyAggregatorTableKey = "supply_aggregator_table_key",
    /** column name */
    Symbol = "symbol",
    /** column name */
    TransactionCreatedTimestamp = "transaction_created_timestamp",
    /** column name */
    TransactionVersionCreated = "transaction_version_created"
}
/** input type for updating data in table "coin_infos" */
type CoinInfosSetInput = {
    coin_type?: InputMaybe<Scalars["String"]["input"]>;
    coin_type_hash?: InputMaybe<Scalars["String"]["input"]>;
    creator_address?: InputMaybe<Scalars["String"]["input"]>;
    decimals?: InputMaybe<Scalars["Int"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    name?: InputMaybe<Scalars["String"]["input"]>;
    supply_aggregator_table_handle?: InputMaybe<Scalars["String"]["input"]>;
    supply_aggregator_table_key?: InputMaybe<Scalars["String"]["input"]>;
    symbol?: InputMaybe<Scalars["String"]["input"]>;
    transaction_created_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    transaction_version_created?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** aggregate stddev on columns */
type CoinInfosStddevFields = {
    decimals?: Maybe<Scalars["Float"]["output"]>;
    transaction_version_created?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_pop on columns */
type CoinInfosStddevPopFields = {
    decimals?: Maybe<Scalars["Float"]["output"]>;
    transaction_version_created?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_samp on columns */
type CoinInfosStddevSampFields = {
    decimals?: Maybe<Scalars["Float"]["output"]>;
    transaction_version_created?: Maybe<Scalars["Float"]["output"]>;
};
/** Streaming cursor of the table "coin_infos" */
type CoinInfosStreamCursorInput = {
    /** Stream column input with initial value */
    initial_value: CoinInfosStreamCursorValueInput;
    /** cursor ordering */
    ordering?: InputMaybe<CursorOrdering>;
};
/** Initial value of the column from where the streaming should start */
type CoinInfosStreamCursorValueInput = {
    coin_type?: InputMaybe<Scalars["String"]["input"]>;
    coin_type_hash?: InputMaybe<Scalars["String"]["input"]>;
    creator_address?: InputMaybe<Scalars["String"]["input"]>;
    decimals?: InputMaybe<Scalars["Int"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    name?: InputMaybe<Scalars["String"]["input"]>;
    supply_aggregator_table_handle?: InputMaybe<Scalars["String"]["input"]>;
    supply_aggregator_table_key?: InputMaybe<Scalars["String"]["input"]>;
    symbol?: InputMaybe<Scalars["String"]["input"]>;
    transaction_created_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    transaction_version_created?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** aggregate sum on columns */
type CoinInfosSumFields = {
    decimals?: Maybe<Scalars["Int"]["output"]>;
    transaction_version_created?: Maybe<Scalars["bigint"]["output"]>;
};
/** update columns of table "coin_infos" */
declare enum CoinInfosUpdateColumn {
    /** column name */
    CoinType = "coin_type",
    /** column name */
    CoinTypeHash = "coin_type_hash",
    /** column name */
    CreatorAddress = "creator_address",
    /** column name */
    Decimals = "decimals",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    Name = "name",
    /** column name */
    SupplyAggregatorTableHandle = "supply_aggregator_table_handle",
    /** column name */
    SupplyAggregatorTableKey = "supply_aggregator_table_key",
    /** column name */
    Symbol = "symbol",
    /** column name */
    TransactionCreatedTimestamp = "transaction_created_timestamp",
    /** column name */
    TransactionVersionCreated = "transaction_version_created"
}
type CoinInfosUpdates = {
    /** increments the numeric columns with given value of the filtered values */
    _inc?: InputMaybe<CoinInfosIncInput>;
    /** sets the columns of the filtered rows to the given values */
    _set?: InputMaybe<CoinInfosSetInput>;
    /** filter the rows which have to be updated */
    where: CoinInfosBoolExp;
};
/** aggregate var_pop on columns */
type CoinInfosVarPopFields = {
    decimals?: Maybe<Scalars["Float"]["output"]>;
    transaction_version_created?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate var_samp on columns */
type CoinInfosVarSampFields = {
    decimals?: Maybe<Scalars["Float"]["output"]>;
    transaction_version_created?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate variance on columns */
type CoinInfosVarianceFields = {
    decimals?: Maybe<Scalars["Float"]["output"]>;
    transaction_version_created?: Maybe<Scalars["Float"]["output"]>;
};
/** columns and relationships of "coin_supply" */
type CoinSupply = {
    coin_type: Scalars["String"]["output"];
    coin_type_hash: Scalars["String"]["output"];
    inserted_at: Scalars["timestamp"]["output"];
    supply: Scalars["numeric"]["output"];
    transaction_epoch: Scalars["bigint"]["output"];
    transaction_timestamp: Scalars["timestamp"]["output"];
    transaction_version: Scalars["bigint"]["output"];
};
/** aggregated selection of "coin_supply" */
type CoinSupplyAggregate = {
    aggregate?: Maybe<CoinSupplyAggregateFields>;
    nodes: Array<CoinSupply>;
};
/** aggregate fields of "coin_supply" */
type CoinSupplyAggregateFields = {
    avg?: Maybe<CoinSupplyAvgFields>;
    count: Scalars["Int"]["output"];
    max?: Maybe<CoinSupplyMaxFields>;
    min?: Maybe<CoinSupplyMinFields>;
    stddev?: Maybe<CoinSupplyStddevFields>;
    stddev_pop?: Maybe<CoinSupplyStddevPopFields>;
    stddev_samp?: Maybe<CoinSupplyStddevSampFields>;
    sum?: Maybe<CoinSupplySumFields>;
    var_pop?: Maybe<CoinSupplyVarPopFields>;
    var_samp?: Maybe<CoinSupplyVarSampFields>;
    variance?: Maybe<CoinSupplyVarianceFields>;
};
/** aggregate fields of "coin_supply" */
type CoinSupplyAggregateFieldsCountArgs = {
    columns?: InputMaybe<Array<CoinSupplySelectColumn>>;
    distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};
/** aggregate avg on columns */
type CoinSupplyAvgFields = {
    supply?: Maybe<Scalars["Float"]["output"]>;
    transaction_epoch?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** Boolean expression to filter rows from the table "coin_supply". All fields are combined with a logical 'AND'. */
type CoinSupplyBoolExp = {
    _and?: InputMaybe<Array<CoinSupplyBoolExp>>;
    _not?: InputMaybe<CoinSupplyBoolExp>;
    _or?: InputMaybe<Array<CoinSupplyBoolExp>>;
    coin_type?: InputMaybe<StringComparisonExp>;
    coin_type_hash?: InputMaybe<StringComparisonExp>;
    inserted_at?: InputMaybe<TimestampComparisonExp>;
    supply?: InputMaybe<NumericComparisonExp>;
    transaction_epoch?: InputMaybe<BigintComparisonExp>;
    transaction_timestamp?: InputMaybe<TimestampComparisonExp>;
    transaction_version?: InputMaybe<BigintComparisonExp>;
};
/** unique or primary key constraints on table "coin_supply" */
declare enum CoinSupplyConstraint {
    /** unique or primary key constraint on columns "coin_type_hash", "transaction_version" */
    CoinSupplyPkey = "coin_supply_pkey"
}
/** input type for incrementing numeric columns in table "coin_supply" */
type CoinSupplyIncInput = {
    supply?: InputMaybe<Scalars["numeric"]["input"]>;
    transaction_epoch?: InputMaybe<Scalars["bigint"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** input type for inserting data into table "coin_supply" */
type CoinSupplyInsertInput = {
    coin_type?: InputMaybe<Scalars["String"]["input"]>;
    coin_type_hash?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    supply?: InputMaybe<Scalars["numeric"]["input"]>;
    transaction_epoch?: InputMaybe<Scalars["bigint"]["input"]>;
    transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** aggregate max on columns */
type CoinSupplyMaxFields = {
    coin_type?: Maybe<Scalars["String"]["output"]>;
    coin_type_hash?: Maybe<Scalars["String"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    supply?: Maybe<Scalars["numeric"]["output"]>;
    transaction_epoch?: Maybe<Scalars["bigint"]["output"]>;
    transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};
/** aggregate min on columns */
type CoinSupplyMinFields = {
    coin_type?: Maybe<Scalars["String"]["output"]>;
    coin_type_hash?: Maybe<Scalars["String"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    supply?: Maybe<Scalars["numeric"]["output"]>;
    transaction_epoch?: Maybe<Scalars["bigint"]["output"]>;
    transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};
/** response of any mutation on the table "coin_supply" */
type CoinSupplyMutationResponse = {
    /** number of rows affected by the mutation */
    affected_rows: Scalars["Int"]["output"];
    /** data from the rows affected by the mutation */
    returning: Array<CoinSupply>;
};
/** on_conflict condition type for table "coin_supply" */
type CoinSupplyOnConflict = {
    constraint: CoinSupplyConstraint;
    update_columns?: Array<CoinSupplyUpdateColumn>;
    where?: InputMaybe<CoinSupplyBoolExp>;
};
/** Ordering options when selecting data from "coin_supply". */
type CoinSupplyOrderBy = {
    coin_type?: InputMaybe<OrderBy>;
    coin_type_hash?: InputMaybe<OrderBy>;
    inserted_at?: InputMaybe<OrderBy>;
    supply?: InputMaybe<OrderBy>;
    transaction_epoch?: InputMaybe<OrderBy>;
    transaction_timestamp?: InputMaybe<OrderBy>;
    transaction_version?: InputMaybe<OrderBy>;
};
/** primary key columns input for table: coin_supply */
type CoinSupplyPkColumnsInput = {
    coin_type_hash: Scalars["String"]["input"];
    transaction_version: Scalars["bigint"]["input"];
};
/** select columns of table "coin_supply" */
declare enum CoinSupplySelectColumn {
    /** column name */
    CoinType = "coin_type",
    /** column name */
    CoinTypeHash = "coin_type_hash",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    Supply = "supply",
    /** column name */
    TransactionEpoch = "transaction_epoch",
    /** column name */
    TransactionTimestamp = "transaction_timestamp",
    /** column name */
    TransactionVersion = "transaction_version"
}
/** input type for updating data in table "coin_supply" */
type CoinSupplySetInput = {
    coin_type?: InputMaybe<Scalars["String"]["input"]>;
    coin_type_hash?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    supply?: InputMaybe<Scalars["numeric"]["input"]>;
    transaction_epoch?: InputMaybe<Scalars["bigint"]["input"]>;
    transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** aggregate stddev on columns */
type CoinSupplyStddevFields = {
    supply?: Maybe<Scalars["Float"]["output"]>;
    transaction_epoch?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_pop on columns */
type CoinSupplyStddevPopFields = {
    supply?: Maybe<Scalars["Float"]["output"]>;
    transaction_epoch?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_samp on columns */
type CoinSupplyStddevSampFields = {
    supply?: Maybe<Scalars["Float"]["output"]>;
    transaction_epoch?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** Streaming cursor of the table "coin_supply" */
type CoinSupplyStreamCursorInput = {
    /** Stream column input with initial value */
    initial_value: CoinSupplyStreamCursorValueInput;
    /** cursor ordering */
    ordering?: InputMaybe<CursorOrdering>;
};
/** Initial value of the column from where the streaming should start */
type CoinSupplyStreamCursorValueInput = {
    coin_type?: InputMaybe<Scalars["String"]["input"]>;
    coin_type_hash?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    supply?: InputMaybe<Scalars["numeric"]["input"]>;
    transaction_epoch?: InputMaybe<Scalars["bigint"]["input"]>;
    transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** aggregate sum on columns */
type CoinSupplySumFields = {
    supply?: Maybe<Scalars["numeric"]["output"]>;
    transaction_epoch?: Maybe<Scalars["bigint"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};
/** update columns of table "coin_supply" */
declare enum CoinSupplyUpdateColumn {
    /** column name */
    CoinType = "coin_type",
    /** column name */
    CoinTypeHash = "coin_type_hash",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    Supply = "supply",
    /** column name */
    TransactionEpoch = "transaction_epoch",
    /** column name */
    TransactionTimestamp = "transaction_timestamp",
    /** column name */
    TransactionVersion = "transaction_version"
}
type CoinSupplyUpdates = {
    /** increments the numeric columns with given value of the filtered values */
    _inc?: InputMaybe<CoinSupplyIncInput>;
    /** sets the columns of the filtered rows to the given values */
    _set?: InputMaybe<CoinSupplySetInput>;
    /** filter the rows which have to be updated */
    where: CoinSupplyBoolExp;
};
/** aggregate var_pop on columns */
type CoinSupplyVarPopFields = {
    supply?: Maybe<Scalars["Float"]["output"]>;
    transaction_epoch?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate var_samp on columns */
type CoinSupplyVarSampFields = {
    supply?: Maybe<Scalars["Float"]["output"]>;
    transaction_epoch?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate variance on columns */
type CoinSupplyVarianceFields = {
    supply?: Maybe<Scalars["Float"]["output"]>;
    transaction_epoch?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** columns and relationships of "collection_datas" */
type CollectionDatas = {
    collection_data_id_hash: Scalars["String"]["output"];
    collection_name: Scalars["String"]["output"];
    creator_address: Scalars["String"]["output"];
    description: Scalars["String"]["output"];
    description_mutable: Scalars["Boolean"]["output"];
    inserted_at: Scalars["timestamp"]["output"];
    maximum: Scalars["numeric"]["output"];
    maximum_mutable: Scalars["Boolean"]["output"];
    metadata_uri: Scalars["String"]["output"];
    supply: Scalars["numeric"]["output"];
    table_handle: Scalars["String"]["output"];
    transaction_timestamp: Scalars["timestamp"]["output"];
    transaction_version: Scalars["bigint"]["output"];
    uri_mutable: Scalars["Boolean"]["output"];
};
/** aggregated selection of "collection_datas" */
type CollectionDatasAggregate = {
    aggregate?: Maybe<CollectionDatasAggregateFields>;
    nodes: Array<CollectionDatas>;
};
/** aggregate fields of "collection_datas" */
type CollectionDatasAggregateFields = {
    avg?: Maybe<CollectionDatasAvgFields>;
    count: Scalars["Int"]["output"];
    max?: Maybe<CollectionDatasMaxFields>;
    min?: Maybe<CollectionDatasMinFields>;
    stddev?: Maybe<CollectionDatasStddevFields>;
    stddev_pop?: Maybe<CollectionDatasStddevPopFields>;
    stddev_samp?: Maybe<CollectionDatasStddevSampFields>;
    sum?: Maybe<CollectionDatasSumFields>;
    var_pop?: Maybe<CollectionDatasVarPopFields>;
    var_samp?: Maybe<CollectionDatasVarSampFields>;
    variance?: Maybe<CollectionDatasVarianceFields>;
};
/** aggregate fields of "collection_datas" */
type CollectionDatasAggregateFieldsCountArgs = {
    columns?: InputMaybe<Array<CollectionDatasSelectColumn>>;
    distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};
/** aggregate avg on columns */
type CollectionDatasAvgFields = {
    maximum?: Maybe<Scalars["Float"]["output"]>;
    supply?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** Boolean expression to filter rows from the table "collection_datas". All fields are combined with a logical 'AND'. */
type CollectionDatasBoolExp = {
    _and?: InputMaybe<Array<CollectionDatasBoolExp>>;
    _not?: InputMaybe<CollectionDatasBoolExp>;
    _or?: InputMaybe<Array<CollectionDatasBoolExp>>;
    collection_data_id_hash?: InputMaybe<StringComparisonExp>;
    collection_name?: InputMaybe<StringComparisonExp>;
    creator_address?: InputMaybe<StringComparisonExp>;
    description?: InputMaybe<StringComparisonExp>;
    description_mutable?: InputMaybe<BooleanComparisonExp>;
    inserted_at?: InputMaybe<TimestampComparisonExp>;
    maximum?: InputMaybe<NumericComparisonExp>;
    maximum_mutable?: InputMaybe<BooleanComparisonExp>;
    metadata_uri?: InputMaybe<StringComparisonExp>;
    supply?: InputMaybe<NumericComparisonExp>;
    table_handle?: InputMaybe<StringComparisonExp>;
    transaction_timestamp?: InputMaybe<TimestampComparisonExp>;
    transaction_version?: InputMaybe<BigintComparisonExp>;
    uri_mutable?: InputMaybe<BooleanComparisonExp>;
};
/** unique or primary key constraints on table "collection_datas" */
declare enum CollectionDatasConstraint {
    /** unique or primary key constraint on columns "collection_data_id_hash", "transaction_version" */
    CollectionDatasPkey = "collection_datas_pkey"
}
/** input type for incrementing numeric columns in table "collection_datas" */
type CollectionDatasIncInput = {
    maximum?: InputMaybe<Scalars["numeric"]["input"]>;
    supply?: InputMaybe<Scalars["numeric"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** input type for inserting data into table "collection_datas" */
type CollectionDatasInsertInput = {
    collection_data_id_hash?: InputMaybe<Scalars["String"]["input"]>;
    collection_name?: InputMaybe<Scalars["String"]["input"]>;
    creator_address?: InputMaybe<Scalars["String"]["input"]>;
    description?: InputMaybe<Scalars["String"]["input"]>;
    description_mutable?: InputMaybe<Scalars["Boolean"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    maximum?: InputMaybe<Scalars["numeric"]["input"]>;
    maximum_mutable?: InputMaybe<Scalars["Boolean"]["input"]>;
    metadata_uri?: InputMaybe<Scalars["String"]["input"]>;
    supply?: InputMaybe<Scalars["numeric"]["input"]>;
    table_handle?: InputMaybe<Scalars["String"]["input"]>;
    transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    uri_mutable?: InputMaybe<Scalars["Boolean"]["input"]>;
};
/** aggregate max on columns */
type CollectionDatasMaxFields = {
    collection_data_id_hash?: Maybe<Scalars["String"]["output"]>;
    collection_name?: Maybe<Scalars["String"]["output"]>;
    creator_address?: Maybe<Scalars["String"]["output"]>;
    description?: Maybe<Scalars["String"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    maximum?: Maybe<Scalars["numeric"]["output"]>;
    metadata_uri?: Maybe<Scalars["String"]["output"]>;
    supply?: Maybe<Scalars["numeric"]["output"]>;
    table_handle?: Maybe<Scalars["String"]["output"]>;
    transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};
/** aggregate min on columns */
type CollectionDatasMinFields = {
    collection_data_id_hash?: Maybe<Scalars["String"]["output"]>;
    collection_name?: Maybe<Scalars["String"]["output"]>;
    creator_address?: Maybe<Scalars["String"]["output"]>;
    description?: Maybe<Scalars["String"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    maximum?: Maybe<Scalars["numeric"]["output"]>;
    metadata_uri?: Maybe<Scalars["String"]["output"]>;
    supply?: Maybe<Scalars["numeric"]["output"]>;
    table_handle?: Maybe<Scalars["String"]["output"]>;
    transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};
/** response of any mutation on the table "collection_datas" */
type CollectionDatasMutationResponse = {
    /** number of rows affected by the mutation */
    affected_rows: Scalars["Int"]["output"];
    /** data from the rows affected by the mutation */
    returning: Array<CollectionDatas>;
};
/** on_conflict condition type for table "collection_datas" */
type CollectionDatasOnConflict = {
    constraint: CollectionDatasConstraint;
    update_columns?: Array<CollectionDatasUpdateColumn>;
    where?: InputMaybe<CollectionDatasBoolExp>;
};
/** Ordering options when selecting data from "collection_datas". */
type CollectionDatasOrderBy = {
    collection_data_id_hash?: InputMaybe<OrderBy>;
    collection_name?: InputMaybe<OrderBy>;
    creator_address?: InputMaybe<OrderBy>;
    description?: InputMaybe<OrderBy>;
    description_mutable?: InputMaybe<OrderBy>;
    inserted_at?: InputMaybe<OrderBy>;
    maximum?: InputMaybe<OrderBy>;
    maximum_mutable?: InputMaybe<OrderBy>;
    metadata_uri?: InputMaybe<OrderBy>;
    supply?: InputMaybe<OrderBy>;
    table_handle?: InputMaybe<OrderBy>;
    transaction_timestamp?: InputMaybe<OrderBy>;
    transaction_version?: InputMaybe<OrderBy>;
    uri_mutable?: InputMaybe<OrderBy>;
};
/** primary key columns input for table: collection_datas */
type CollectionDatasPkColumnsInput = {
    collection_data_id_hash: Scalars["String"]["input"];
    transaction_version: Scalars["bigint"]["input"];
};
/** select columns of table "collection_datas" */
declare enum CollectionDatasSelectColumn {
    /** column name */
    CollectionDataIdHash = "collection_data_id_hash",
    /** column name */
    CollectionName = "collection_name",
    /** column name */
    CreatorAddress = "creator_address",
    /** column name */
    Description = "description",
    /** column name */
    DescriptionMutable = "description_mutable",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    Maximum = "maximum",
    /** column name */
    MaximumMutable = "maximum_mutable",
    /** column name */
    MetadataUri = "metadata_uri",
    /** column name */
    Supply = "supply",
    /** column name */
    TableHandle = "table_handle",
    /** column name */
    TransactionTimestamp = "transaction_timestamp",
    /** column name */
    TransactionVersion = "transaction_version",
    /** column name */
    UriMutable = "uri_mutable"
}
/** input type for updating data in table "collection_datas" */
type CollectionDatasSetInput = {
    collection_data_id_hash?: InputMaybe<Scalars["String"]["input"]>;
    collection_name?: InputMaybe<Scalars["String"]["input"]>;
    creator_address?: InputMaybe<Scalars["String"]["input"]>;
    description?: InputMaybe<Scalars["String"]["input"]>;
    description_mutable?: InputMaybe<Scalars["Boolean"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    maximum?: InputMaybe<Scalars["numeric"]["input"]>;
    maximum_mutable?: InputMaybe<Scalars["Boolean"]["input"]>;
    metadata_uri?: InputMaybe<Scalars["String"]["input"]>;
    supply?: InputMaybe<Scalars["numeric"]["input"]>;
    table_handle?: InputMaybe<Scalars["String"]["input"]>;
    transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    uri_mutable?: InputMaybe<Scalars["Boolean"]["input"]>;
};
/** aggregate stddev on columns */
type CollectionDatasStddevFields = {
    maximum?: Maybe<Scalars["Float"]["output"]>;
    supply?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_pop on columns */
type CollectionDatasStddevPopFields = {
    maximum?: Maybe<Scalars["Float"]["output"]>;
    supply?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_samp on columns */
type CollectionDatasStddevSampFields = {
    maximum?: Maybe<Scalars["Float"]["output"]>;
    supply?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** Streaming cursor of the table "collection_datas" */
type CollectionDatasStreamCursorInput = {
    /** Stream column input with initial value */
    initial_value: CollectionDatasStreamCursorValueInput;
    /** cursor ordering */
    ordering?: InputMaybe<CursorOrdering>;
};
/** Initial value of the column from where the streaming should start */
type CollectionDatasStreamCursorValueInput = {
    collection_data_id_hash?: InputMaybe<Scalars["String"]["input"]>;
    collection_name?: InputMaybe<Scalars["String"]["input"]>;
    creator_address?: InputMaybe<Scalars["String"]["input"]>;
    description?: InputMaybe<Scalars["String"]["input"]>;
    description_mutable?: InputMaybe<Scalars["Boolean"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    maximum?: InputMaybe<Scalars["numeric"]["input"]>;
    maximum_mutable?: InputMaybe<Scalars["Boolean"]["input"]>;
    metadata_uri?: InputMaybe<Scalars["String"]["input"]>;
    supply?: InputMaybe<Scalars["numeric"]["input"]>;
    table_handle?: InputMaybe<Scalars["String"]["input"]>;
    transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    uri_mutable?: InputMaybe<Scalars["Boolean"]["input"]>;
};
/** aggregate sum on columns */
type CollectionDatasSumFields = {
    maximum?: Maybe<Scalars["numeric"]["output"]>;
    supply?: Maybe<Scalars["numeric"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};
/** update columns of table "collection_datas" */
declare enum CollectionDatasUpdateColumn {
    /** column name */
    CollectionDataIdHash = "collection_data_id_hash",
    /** column name */
    CollectionName = "collection_name",
    /** column name */
    CreatorAddress = "creator_address",
    /** column name */
    Description = "description",
    /** column name */
    DescriptionMutable = "description_mutable",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    Maximum = "maximum",
    /** column name */
    MaximumMutable = "maximum_mutable",
    /** column name */
    MetadataUri = "metadata_uri",
    /** column name */
    Supply = "supply",
    /** column name */
    TableHandle = "table_handle",
    /** column name */
    TransactionTimestamp = "transaction_timestamp",
    /** column name */
    TransactionVersion = "transaction_version",
    /** column name */
    UriMutable = "uri_mutable"
}
type CollectionDatasUpdates = {
    /** increments the numeric columns with given value of the filtered values */
    _inc?: InputMaybe<CollectionDatasIncInput>;
    /** sets the columns of the filtered rows to the given values */
    _set?: InputMaybe<CollectionDatasSetInput>;
    /** filter the rows which have to be updated */
    where: CollectionDatasBoolExp;
};
/** aggregate var_pop on columns */
type CollectionDatasVarPopFields = {
    maximum?: Maybe<Scalars["Float"]["output"]>;
    supply?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate var_samp on columns */
type CollectionDatasVarSampFields = {
    maximum?: Maybe<Scalars["Float"]["output"]>;
    supply?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate variance on columns */
type CollectionDatasVarianceFields = {
    maximum?: Maybe<Scalars["Float"]["output"]>;
    supply?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** columns and relationships of "collections_v2" */
type CollectionsV2 = {
    collection_id: Scalars["String"]["output"];
    collection_name: Scalars["String"]["output"];
    collection_properties?: Maybe<Scalars["jsonb"]["output"]>;
    creator_address: Scalars["String"]["output"];
    current_supply: Scalars["numeric"]["output"];
    description: Scalars["String"]["output"];
    inserted_at: Scalars["timestamp"]["output"];
    max_supply?: Maybe<Scalars["numeric"]["output"]>;
    mutable_description?: Maybe<Scalars["Boolean"]["output"]>;
    mutable_uri?: Maybe<Scalars["Boolean"]["output"]>;
    table_handle_v1?: Maybe<Scalars["String"]["output"]>;
    token_standard: Scalars["String"]["output"];
    total_minted_v2?: Maybe<Scalars["numeric"]["output"]>;
    transaction_timestamp: Scalars["timestamp"]["output"];
    transaction_version: Scalars["bigint"]["output"];
    uri: Scalars["String"]["output"];
    write_set_change_index: Scalars["bigint"]["output"];
};
/** columns and relationships of "collections_v2" */
type CollectionsV2CollectionPropertiesArgs = {
    path?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregated selection of "collections_v2" */
type CollectionsV2Aggregate = {
    aggregate?: Maybe<CollectionsV2AggregateFields>;
    nodes: Array<CollectionsV2>;
};
/** aggregate fields of "collections_v2" */
type CollectionsV2AggregateFields = {
    avg?: Maybe<CollectionsV2AvgFields>;
    count: Scalars["Int"]["output"];
    max?: Maybe<CollectionsV2MaxFields>;
    min?: Maybe<CollectionsV2MinFields>;
    stddev?: Maybe<CollectionsV2StddevFields>;
    stddev_pop?: Maybe<CollectionsV2StddevPopFields>;
    stddev_samp?: Maybe<CollectionsV2StddevSampFields>;
    sum?: Maybe<CollectionsV2SumFields>;
    var_pop?: Maybe<CollectionsV2VarPopFields>;
    var_samp?: Maybe<CollectionsV2VarSampFields>;
    variance?: Maybe<CollectionsV2VarianceFields>;
};
/** aggregate fields of "collections_v2" */
type CollectionsV2AggregateFieldsCountArgs = {
    columns?: InputMaybe<Array<CollectionsV2SelectColumn>>;
    distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};
/** append existing jsonb value of filtered columns with new jsonb value */
type CollectionsV2AppendInput = {
    collection_properties?: InputMaybe<Scalars["jsonb"]["input"]>;
};
/** aggregate avg on columns */
type CollectionsV2AvgFields = {
    current_supply?: Maybe<Scalars["Float"]["output"]>;
    max_supply?: Maybe<Scalars["Float"]["output"]>;
    total_minted_v2?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};
/** Boolean expression to filter rows from the table "collections_v2". All fields are combined with a logical 'AND'. */
type CollectionsV2BoolExp = {
    _and?: InputMaybe<Array<CollectionsV2BoolExp>>;
    _not?: InputMaybe<CollectionsV2BoolExp>;
    _or?: InputMaybe<Array<CollectionsV2BoolExp>>;
    collection_id?: InputMaybe<StringComparisonExp>;
    collection_name?: InputMaybe<StringComparisonExp>;
    collection_properties?: InputMaybe<JsonbComparisonExp>;
    creator_address?: InputMaybe<StringComparisonExp>;
    current_supply?: InputMaybe<NumericComparisonExp>;
    description?: InputMaybe<StringComparisonExp>;
    inserted_at?: InputMaybe<TimestampComparisonExp>;
    max_supply?: InputMaybe<NumericComparisonExp>;
    mutable_description?: InputMaybe<BooleanComparisonExp>;
    mutable_uri?: InputMaybe<BooleanComparisonExp>;
    table_handle_v1?: InputMaybe<StringComparisonExp>;
    token_standard?: InputMaybe<StringComparisonExp>;
    total_minted_v2?: InputMaybe<NumericComparisonExp>;
    transaction_timestamp?: InputMaybe<TimestampComparisonExp>;
    transaction_version?: InputMaybe<BigintComparisonExp>;
    uri?: InputMaybe<StringComparisonExp>;
    write_set_change_index?: InputMaybe<BigintComparisonExp>;
};
/** unique or primary key constraints on table "collections_v2" */
declare enum CollectionsV2Constraint {
    /** unique or primary key constraint on columns "write_set_change_index", "transaction_version" */
    CollectionsV2Pkey = "collections_v2_pkey"
}
/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
type CollectionsV2DeleteAtPathInput = {
    collection_properties?: InputMaybe<Array<Scalars["String"]["input"]>>;
};
/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
type CollectionsV2DeleteElemInput = {
    collection_properties?: InputMaybe<Scalars["Int"]["input"]>;
};
/** delete key/value pair or string element. key/value pairs are matched based on their key value */
type CollectionsV2DeleteKeyInput = {
    collection_properties?: InputMaybe<Scalars["String"]["input"]>;
};
/** input type for incrementing numeric columns in table "collections_v2" */
type CollectionsV2IncInput = {
    current_supply?: InputMaybe<Scalars["numeric"]["input"]>;
    max_supply?: InputMaybe<Scalars["numeric"]["input"]>;
    total_minted_v2?: InputMaybe<Scalars["numeric"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** input type for inserting data into table "collections_v2" */
type CollectionsV2InsertInput = {
    collection_id?: InputMaybe<Scalars["String"]["input"]>;
    collection_name?: InputMaybe<Scalars["String"]["input"]>;
    collection_properties?: InputMaybe<Scalars["jsonb"]["input"]>;
    creator_address?: InputMaybe<Scalars["String"]["input"]>;
    current_supply?: InputMaybe<Scalars["numeric"]["input"]>;
    description?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    max_supply?: InputMaybe<Scalars["numeric"]["input"]>;
    mutable_description?: InputMaybe<Scalars["Boolean"]["input"]>;
    mutable_uri?: InputMaybe<Scalars["Boolean"]["input"]>;
    table_handle_v1?: InputMaybe<Scalars["String"]["input"]>;
    token_standard?: InputMaybe<Scalars["String"]["input"]>;
    total_minted_v2?: InputMaybe<Scalars["numeric"]["input"]>;
    transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    uri?: InputMaybe<Scalars["String"]["input"]>;
    write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** aggregate max on columns */
type CollectionsV2MaxFields = {
    collection_id?: Maybe<Scalars["String"]["output"]>;
    collection_name?: Maybe<Scalars["String"]["output"]>;
    creator_address?: Maybe<Scalars["String"]["output"]>;
    current_supply?: Maybe<Scalars["numeric"]["output"]>;
    description?: Maybe<Scalars["String"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    max_supply?: Maybe<Scalars["numeric"]["output"]>;
    table_handle_v1?: Maybe<Scalars["String"]["output"]>;
    token_standard?: Maybe<Scalars["String"]["output"]>;
    total_minted_v2?: Maybe<Scalars["numeric"]["output"]>;
    transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    uri?: Maybe<Scalars["String"]["output"]>;
    write_set_change_index?: Maybe<Scalars["bigint"]["output"]>;
};
/** aggregate min on columns */
type CollectionsV2MinFields = {
    collection_id?: Maybe<Scalars["String"]["output"]>;
    collection_name?: Maybe<Scalars["String"]["output"]>;
    creator_address?: Maybe<Scalars["String"]["output"]>;
    current_supply?: Maybe<Scalars["numeric"]["output"]>;
    description?: Maybe<Scalars["String"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    max_supply?: Maybe<Scalars["numeric"]["output"]>;
    table_handle_v1?: Maybe<Scalars["String"]["output"]>;
    token_standard?: Maybe<Scalars["String"]["output"]>;
    total_minted_v2?: Maybe<Scalars["numeric"]["output"]>;
    transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    uri?: Maybe<Scalars["String"]["output"]>;
    write_set_change_index?: Maybe<Scalars["bigint"]["output"]>;
};
/** response of any mutation on the table "collections_v2" */
type CollectionsV2MutationResponse = {
    /** number of rows affected by the mutation */
    affected_rows: Scalars["Int"]["output"];
    /** data from the rows affected by the mutation */
    returning: Array<CollectionsV2>;
};
/** on_conflict condition type for table "collections_v2" */
type CollectionsV2OnConflict = {
    constraint: CollectionsV2Constraint;
    update_columns?: Array<CollectionsV2UpdateColumn>;
    where?: InputMaybe<CollectionsV2BoolExp>;
};
/** Ordering options when selecting data from "collections_v2". */
type CollectionsV2OrderBy = {
    collection_id?: InputMaybe<OrderBy>;
    collection_name?: InputMaybe<OrderBy>;
    collection_properties?: InputMaybe<OrderBy>;
    creator_address?: InputMaybe<OrderBy>;
    current_supply?: InputMaybe<OrderBy>;
    description?: InputMaybe<OrderBy>;
    inserted_at?: InputMaybe<OrderBy>;
    max_supply?: InputMaybe<OrderBy>;
    mutable_description?: InputMaybe<OrderBy>;
    mutable_uri?: InputMaybe<OrderBy>;
    table_handle_v1?: InputMaybe<OrderBy>;
    token_standard?: InputMaybe<OrderBy>;
    total_minted_v2?: InputMaybe<OrderBy>;
    transaction_timestamp?: InputMaybe<OrderBy>;
    transaction_version?: InputMaybe<OrderBy>;
    uri?: InputMaybe<OrderBy>;
    write_set_change_index?: InputMaybe<OrderBy>;
};
/** primary key columns input for table: collections_v2 */
type CollectionsV2PkColumnsInput = {
    transaction_version: Scalars["bigint"]["input"];
    write_set_change_index: Scalars["bigint"]["input"];
};
/** prepend existing jsonb value of filtered columns with new jsonb value */
type CollectionsV2PrependInput = {
    collection_properties?: InputMaybe<Scalars["jsonb"]["input"]>;
};
/** select columns of table "collections_v2" */
declare enum CollectionsV2SelectColumn {
    /** column name */
    CollectionId = "collection_id",
    /** column name */
    CollectionName = "collection_name",
    /** column name */
    CollectionProperties = "collection_properties",
    /** column name */
    CreatorAddress = "creator_address",
    /** column name */
    CurrentSupply = "current_supply",
    /** column name */
    Description = "description",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    MaxSupply = "max_supply",
    /** column name */
    MutableDescription = "mutable_description",
    /** column name */
    MutableUri = "mutable_uri",
    /** column name */
    TableHandleV1 = "table_handle_v1",
    /** column name */
    TokenStandard = "token_standard",
    /** column name */
    TotalMintedV2 = "total_minted_v2",
    /** column name */
    TransactionTimestamp = "transaction_timestamp",
    /** column name */
    TransactionVersion = "transaction_version",
    /** column name */
    Uri = "uri",
    /** column name */
    WriteSetChangeIndex = "write_set_change_index"
}
/** input type for updating data in table "collections_v2" */
type CollectionsV2SetInput = {
    collection_id?: InputMaybe<Scalars["String"]["input"]>;
    collection_name?: InputMaybe<Scalars["String"]["input"]>;
    collection_properties?: InputMaybe<Scalars["jsonb"]["input"]>;
    creator_address?: InputMaybe<Scalars["String"]["input"]>;
    current_supply?: InputMaybe<Scalars["numeric"]["input"]>;
    description?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    max_supply?: InputMaybe<Scalars["numeric"]["input"]>;
    mutable_description?: InputMaybe<Scalars["Boolean"]["input"]>;
    mutable_uri?: InputMaybe<Scalars["Boolean"]["input"]>;
    table_handle_v1?: InputMaybe<Scalars["String"]["input"]>;
    token_standard?: InputMaybe<Scalars["String"]["input"]>;
    total_minted_v2?: InputMaybe<Scalars["numeric"]["input"]>;
    transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    uri?: InputMaybe<Scalars["String"]["input"]>;
    write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** aggregate stddev on columns */
type CollectionsV2StddevFields = {
    current_supply?: Maybe<Scalars["Float"]["output"]>;
    max_supply?: Maybe<Scalars["Float"]["output"]>;
    total_minted_v2?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_pop on columns */
type CollectionsV2StddevPopFields = {
    current_supply?: Maybe<Scalars["Float"]["output"]>;
    max_supply?: Maybe<Scalars["Float"]["output"]>;
    total_minted_v2?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_samp on columns */
type CollectionsV2StddevSampFields = {
    current_supply?: Maybe<Scalars["Float"]["output"]>;
    max_supply?: Maybe<Scalars["Float"]["output"]>;
    total_minted_v2?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};
/** Streaming cursor of the table "collections_v2" */
type CollectionsV2StreamCursorInput = {
    /** Stream column input with initial value */
    initial_value: CollectionsV2StreamCursorValueInput;
    /** cursor ordering */
    ordering?: InputMaybe<CursorOrdering>;
};
/** Initial value of the column from where the streaming should start */
type CollectionsV2StreamCursorValueInput = {
    collection_id?: InputMaybe<Scalars["String"]["input"]>;
    collection_name?: InputMaybe<Scalars["String"]["input"]>;
    collection_properties?: InputMaybe<Scalars["jsonb"]["input"]>;
    creator_address?: InputMaybe<Scalars["String"]["input"]>;
    current_supply?: InputMaybe<Scalars["numeric"]["input"]>;
    description?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    max_supply?: InputMaybe<Scalars["numeric"]["input"]>;
    mutable_description?: InputMaybe<Scalars["Boolean"]["input"]>;
    mutable_uri?: InputMaybe<Scalars["Boolean"]["input"]>;
    table_handle_v1?: InputMaybe<Scalars["String"]["input"]>;
    token_standard?: InputMaybe<Scalars["String"]["input"]>;
    total_minted_v2?: InputMaybe<Scalars["numeric"]["input"]>;
    transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    uri?: InputMaybe<Scalars["String"]["input"]>;
    write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** aggregate sum on columns */
type CollectionsV2SumFields = {
    current_supply?: Maybe<Scalars["numeric"]["output"]>;
    max_supply?: Maybe<Scalars["numeric"]["output"]>;
    total_minted_v2?: Maybe<Scalars["numeric"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    write_set_change_index?: Maybe<Scalars["bigint"]["output"]>;
};
/** update columns of table "collections_v2" */
declare enum CollectionsV2UpdateColumn {
    /** column name */
    CollectionId = "collection_id",
    /** column name */
    CollectionName = "collection_name",
    /** column name */
    CollectionProperties = "collection_properties",
    /** column name */
    CreatorAddress = "creator_address",
    /** column name */
    CurrentSupply = "current_supply",
    /** column name */
    Description = "description",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    MaxSupply = "max_supply",
    /** column name */
    MutableDescription = "mutable_description",
    /** column name */
    MutableUri = "mutable_uri",
    /** column name */
    TableHandleV1 = "table_handle_v1",
    /** column name */
    TokenStandard = "token_standard",
    /** column name */
    TotalMintedV2 = "total_minted_v2",
    /** column name */
    TransactionTimestamp = "transaction_timestamp",
    /** column name */
    TransactionVersion = "transaction_version",
    /** column name */
    Uri = "uri",
    /** column name */
    WriteSetChangeIndex = "write_set_change_index"
}
type CollectionsV2Updates = {
    /** append existing jsonb value of filtered columns with new jsonb value */
    _append?: InputMaybe<CollectionsV2AppendInput>;
    /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
    _delete_at_path?: InputMaybe<CollectionsV2DeleteAtPathInput>;
    /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
    _delete_elem?: InputMaybe<CollectionsV2DeleteElemInput>;
    /** delete key/value pair or string element. key/value pairs are matched based on their key value */
    _delete_key?: InputMaybe<CollectionsV2DeleteKeyInput>;
    /** increments the numeric columns with given value of the filtered values */
    _inc?: InputMaybe<CollectionsV2IncInput>;
    /** prepend existing jsonb value of filtered columns with new jsonb value */
    _prepend?: InputMaybe<CollectionsV2PrependInput>;
    /** sets the columns of the filtered rows to the given values */
    _set?: InputMaybe<CollectionsV2SetInput>;
    /** filter the rows which have to be updated */
    where: CollectionsV2BoolExp;
};
/** aggregate var_pop on columns */
type CollectionsV2VarPopFields = {
    current_supply?: Maybe<Scalars["Float"]["output"]>;
    max_supply?: Maybe<Scalars["Float"]["output"]>;
    total_minted_v2?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate var_samp on columns */
type CollectionsV2VarSampFields = {
    current_supply?: Maybe<Scalars["Float"]["output"]>;
    max_supply?: Maybe<Scalars["Float"]["output"]>;
    total_minted_v2?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate variance on columns */
type CollectionsV2VarianceFields = {
    current_supply?: Maybe<Scalars["Float"]["output"]>;
    max_supply?: Maybe<Scalars["Float"]["output"]>;
    total_minted_v2?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};
/** columns and relationships of "current_ans_lookup" */
type CurrentAnsLookup = {
    domain: Scalars["String"]["output"];
    expiration_timestamp: Scalars["timestamp"]["output"];
    inserted_at: Scalars["timestamp"]["output"];
    is_deleted: Scalars["Boolean"]["output"];
    last_transaction_version: Scalars["bigint"]["output"];
    registered_address?: Maybe<Scalars["String"]["output"]>;
    subdomain: Scalars["String"]["output"];
    token_name: Scalars["String"]["output"];
};
/** aggregated selection of "current_ans_lookup" */
type CurrentAnsLookupAggregate = {
    aggregate?: Maybe<CurrentAnsLookupAggregateFields>;
    nodes: Array<CurrentAnsLookup>;
};
/** aggregate fields of "current_ans_lookup" */
type CurrentAnsLookupAggregateFields = {
    avg?: Maybe<CurrentAnsLookupAvgFields>;
    count: Scalars["Int"]["output"];
    max?: Maybe<CurrentAnsLookupMaxFields>;
    min?: Maybe<CurrentAnsLookupMinFields>;
    stddev?: Maybe<CurrentAnsLookupStddevFields>;
    stddev_pop?: Maybe<CurrentAnsLookupStddevPopFields>;
    stddev_samp?: Maybe<CurrentAnsLookupStddevSampFields>;
    sum?: Maybe<CurrentAnsLookupSumFields>;
    var_pop?: Maybe<CurrentAnsLookupVarPopFields>;
    var_samp?: Maybe<CurrentAnsLookupVarSampFields>;
    variance?: Maybe<CurrentAnsLookupVarianceFields>;
};
/** aggregate fields of "current_ans_lookup" */
type CurrentAnsLookupAggregateFieldsCountArgs = {
    columns?: InputMaybe<Array<CurrentAnsLookupSelectColumn>>;
    distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};
/** aggregate avg on columns */
type CurrentAnsLookupAvgFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** Boolean expression to filter rows from the table "current_ans_lookup". All fields are combined with a logical 'AND'. */
type CurrentAnsLookupBoolExp = {
    _and?: InputMaybe<Array<CurrentAnsLookupBoolExp>>;
    _not?: InputMaybe<CurrentAnsLookupBoolExp>;
    _or?: InputMaybe<Array<CurrentAnsLookupBoolExp>>;
    domain?: InputMaybe<StringComparisonExp>;
    expiration_timestamp?: InputMaybe<TimestampComparisonExp>;
    inserted_at?: InputMaybe<TimestampComparisonExp>;
    is_deleted?: InputMaybe<BooleanComparisonExp>;
    last_transaction_version?: InputMaybe<BigintComparisonExp>;
    registered_address?: InputMaybe<StringComparisonExp>;
    subdomain?: InputMaybe<StringComparisonExp>;
    token_name?: InputMaybe<StringComparisonExp>;
};
/** unique or primary key constraints on table "current_ans_lookup" */
declare enum CurrentAnsLookupConstraint {
    /** unique or primary key constraint on columns "domain", "subdomain" */
    CurrentAnsLookupPkey = "current_ans_lookup_pkey"
}
/** input type for incrementing numeric columns in table "current_ans_lookup" */
type CurrentAnsLookupIncInput = {
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** input type for inserting data into table "current_ans_lookup" */
type CurrentAnsLookupInsertInput = {
    domain?: InputMaybe<Scalars["String"]["input"]>;
    expiration_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    is_deleted?: InputMaybe<Scalars["Boolean"]["input"]>;
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    registered_address?: InputMaybe<Scalars["String"]["input"]>;
    subdomain?: InputMaybe<Scalars["String"]["input"]>;
    token_name?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregate max on columns */
type CurrentAnsLookupMaxFields = {
    domain?: Maybe<Scalars["String"]["output"]>;
    expiration_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    registered_address?: Maybe<Scalars["String"]["output"]>;
    subdomain?: Maybe<Scalars["String"]["output"]>;
    token_name?: Maybe<Scalars["String"]["output"]>;
};
/** aggregate min on columns */
type CurrentAnsLookupMinFields = {
    domain?: Maybe<Scalars["String"]["output"]>;
    expiration_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    registered_address?: Maybe<Scalars["String"]["output"]>;
    subdomain?: Maybe<Scalars["String"]["output"]>;
    token_name?: Maybe<Scalars["String"]["output"]>;
};
/** response of any mutation on the table "current_ans_lookup" */
type CurrentAnsLookupMutationResponse = {
    /** number of rows affected by the mutation */
    affected_rows: Scalars["Int"]["output"];
    /** data from the rows affected by the mutation */
    returning: Array<CurrentAnsLookup>;
};
/** on_conflict condition type for table "current_ans_lookup" */
type CurrentAnsLookupOnConflict = {
    constraint: CurrentAnsLookupConstraint;
    update_columns?: Array<CurrentAnsLookupUpdateColumn>;
    where?: InputMaybe<CurrentAnsLookupBoolExp>;
};
/** Ordering options when selecting data from "current_ans_lookup". */
type CurrentAnsLookupOrderBy = {
    domain?: InputMaybe<OrderBy>;
    expiration_timestamp?: InputMaybe<OrderBy>;
    inserted_at?: InputMaybe<OrderBy>;
    is_deleted?: InputMaybe<OrderBy>;
    last_transaction_version?: InputMaybe<OrderBy>;
    registered_address?: InputMaybe<OrderBy>;
    subdomain?: InputMaybe<OrderBy>;
    token_name?: InputMaybe<OrderBy>;
};
/** primary key columns input for table: current_ans_lookup */
type CurrentAnsLookupPkColumnsInput = {
    domain: Scalars["String"]["input"];
    subdomain: Scalars["String"]["input"];
};
/** select columns of table "current_ans_lookup" */
declare enum CurrentAnsLookupSelectColumn {
    /** column name */
    Domain = "domain",
    /** column name */
    ExpirationTimestamp = "expiration_timestamp",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    IsDeleted = "is_deleted",
    /** column name */
    LastTransactionVersion = "last_transaction_version",
    /** column name */
    RegisteredAddress = "registered_address",
    /** column name */
    Subdomain = "subdomain",
    /** column name */
    TokenName = "token_name"
}
/** input type for updating data in table "current_ans_lookup" */
type CurrentAnsLookupSetInput = {
    domain?: InputMaybe<Scalars["String"]["input"]>;
    expiration_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    is_deleted?: InputMaybe<Scalars["Boolean"]["input"]>;
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    registered_address?: InputMaybe<Scalars["String"]["input"]>;
    subdomain?: InputMaybe<Scalars["String"]["input"]>;
    token_name?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregate stddev on columns */
type CurrentAnsLookupStddevFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_pop on columns */
type CurrentAnsLookupStddevPopFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_samp on columns */
type CurrentAnsLookupStddevSampFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** Streaming cursor of the table "current_ans_lookup" */
type CurrentAnsLookupStreamCursorInput = {
    /** Stream column input with initial value */
    initial_value: CurrentAnsLookupStreamCursorValueInput;
    /** cursor ordering */
    ordering?: InputMaybe<CursorOrdering>;
};
/** Initial value of the column from where the streaming should start */
type CurrentAnsLookupStreamCursorValueInput = {
    domain?: InputMaybe<Scalars["String"]["input"]>;
    expiration_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    is_deleted?: InputMaybe<Scalars["Boolean"]["input"]>;
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    registered_address?: InputMaybe<Scalars["String"]["input"]>;
    subdomain?: InputMaybe<Scalars["String"]["input"]>;
    token_name?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregate sum on columns */
type CurrentAnsLookupSumFields = {
    last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};
/** update columns of table "current_ans_lookup" */
declare enum CurrentAnsLookupUpdateColumn {
    /** column name */
    Domain = "domain",
    /** column name */
    ExpirationTimestamp = "expiration_timestamp",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    IsDeleted = "is_deleted",
    /** column name */
    LastTransactionVersion = "last_transaction_version",
    /** column name */
    RegisteredAddress = "registered_address",
    /** column name */
    Subdomain = "subdomain",
    /** column name */
    TokenName = "token_name"
}
type CurrentAnsLookupUpdates = {
    /** increments the numeric columns with given value of the filtered values */
    _inc?: InputMaybe<CurrentAnsLookupIncInput>;
    /** sets the columns of the filtered rows to the given values */
    _set?: InputMaybe<CurrentAnsLookupSetInput>;
    /** filter the rows which have to be updated */
    where: CurrentAnsLookupBoolExp;
};
/** columns and relationships of "current_ans_lookup_v2" */
type CurrentAnsLookupV2 = {
    domain: Scalars["String"]["output"];
    expiration_timestamp: Scalars["timestamp"]["output"];
    inserted_at: Scalars["timestamp"]["output"];
    is_deleted: Scalars["Boolean"]["output"];
    last_transaction_version: Scalars["bigint"]["output"];
    registered_address?: Maybe<Scalars["String"]["output"]>;
    subdomain: Scalars["String"]["output"];
    subdomain_expiration_policy?: Maybe<Scalars["bigint"]["output"]>;
    token_name?: Maybe<Scalars["String"]["output"]>;
    token_standard: Scalars["String"]["output"];
};
/** aggregated selection of "current_ans_lookup_v2" */
type CurrentAnsLookupV2Aggregate = {
    aggregate?: Maybe<CurrentAnsLookupV2AggregateFields>;
    nodes: Array<CurrentAnsLookupV2>;
};
/** aggregate fields of "current_ans_lookup_v2" */
type CurrentAnsLookupV2AggregateFields = {
    avg?: Maybe<CurrentAnsLookupV2AvgFields>;
    count: Scalars["Int"]["output"];
    max?: Maybe<CurrentAnsLookupV2MaxFields>;
    min?: Maybe<CurrentAnsLookupV2MinFields>;
    stddev?: Maybe<CurrentAnsLookupV2StddevFields>;
    stddev_pop?: Maybe<CurrentAnsLookupV2StddevPopFields>;
    stddev_samp?: Maybe<CurrentAnsLookupV2StddevSampFields>;
    sum?: Maybe<CurrentAnsLookupV2SumFields>;
    var_pop?: Maybe<CurrentAnsLookupV2VarPopFields>;
    var_samp?: Maybe<CurrentAnsLookupV2VarSampFields>;
    variance?: Maybe<CurrentAnsLookupV2VarianceFields>;
};
/** aggregate fields of "current_ans_lookup_v2" */
type CurrentAnsLookupV2AggregateFieldsCountArgs = {
    columns?: InputMaybe<Array<CurrentAnsLookupV2SelectColumn>>;
    distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};
/** aggregate avg on columns */
type CurrentAnsLookupV2AvgFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
    subdomain_expiration_policy?: Maybe<Scalars["Float"]["output"]>;
};
/** Boolean expression to filter rows from the table "current_ans_lookup_v2". All fields are combined with a logical 'AND'. */
type CurrentAnsLookupV2BoolExp = {
    _and?: InputMaybe<Array<CurrentAnsLookupV2BoolExp>>;
    _not?: InputMaybe<CurrentAnsLookupV2BoolExp>;
    _or?: InputMaybe<Array<CurrentAnsLookupV2BoolExp>>;
    domain?: InputMaybe<StringComparisonExp>;
    expiration_timestamp?: InputMaybe<TimestampComparisonExp>;
    inserted_at?: InputMaybe<TimestampComparisonExp>;
    is_deleted?: InputMaybe<BooleanComparisonExp>;
    last_transaction_version?: InputMaybe<BigintComparisonExp>;
    registered_address?: InputMaybe<StringComparisonExp>;
    subdomain?: InputMaybe<StringComparisonExp>;
    subdomain_expiration_policy?: InputMaybe<BigintComparisonExp>;
    token_name?: InputMaybe<StringComparisonExp>;
    token_standard?: InputMaybe<StringComparisonExp>;
};
/** unique or primary key constraints on table "current_ans_lookup_v2" */
declare enum CurrentAnsLookupV2Constraint {
    /** unique or primary key constraint on columns "domain", "token_standard", "subdomain" */
    CurrentAnsLookupV2Pkey = "current_ans_lookup_v2_pkey"
}
/** input type for incrementing numeric columns in table "current_ans_lookup_v2" */
type CurrentAnsLookupV2IncInput = {
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    subdomain_expiration_policy?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** input type for inserting data into table "current_ans_lookup_v2" */
type CurrentAnsLookupV2InsertInput = {
    domain?: InputMaybe<Scalars["String"]["input"]>;
    expiration_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    is_deleted?: InputMaybe<Scalars["Boolean"]["input"]>;
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    registered_address?: InputMaybe<Scalars["String"]["input"]>;
    subdomain?: InputMaybe<Scalars["String"]["input"]>;
    subdomain_expiration_policy?: InputMaybe<Scalars["bigint"]["input"]>;
    token_name?: InputMaybe<Scalars["String"]["input"]>;
    token_standard?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregate max on columns */
type CurrentAnsLookupV2MaxFields = {
    domain?: Maybe<Scalars["String"]["output"]>;
    expiration_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    registered_address?: Maybe<Scalars["String"]["output"]>;
    subdomain?: Maybe<Scalars["String"]["output"]>;
    subdomain_expiration_policy?: Maybe<Scalars["bigint"]["output"]>;
    token_name?: Maybe<Scalars["String"]["output"]>;
    token_standard?: Maybe<Scalars["String"]["output"]>;
};
/** aggregate min on columns */
type CurrentAnsLookupV2MinFields = {
    domain?: Maybe<Scalars["String"]["output"]>;
    expiration_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    registered_address?: Maybe<Scalars["String"]["output"]>;
    subdomain?: Maybe<Scalars["String"]["output"]>;
    subdomain_expiration_policy?: Maybe<Scalars["bigint"]["output"]>;
    token_name?: Maybe<Scalars["String"]["output"]>;
    token_standard?: Maybe<Scalars["String"]["output"]>;
};
/** response of any mutation on the table "current_ans_lookup_v2" */
type CurrentAnsLookupV2MutationResponse = {
    /** number of rows affected by the mutation */
    affected_rows: Scalars["Int"]["output"];
    /** data from the rows affected by the mutation */
    returning: Array<CurrentAnsLookupV2>;
};
/** on_conflict condition type for table "current_ans_lookup_v2" */
type CurrentAnsLookupV2OnConflict = {
    constraint: CurrentAnsLookupV2Constraint;
    update_columns?: Array<CurrentAnsLookupV2UpdateColumn>;
    where?: InputMaybe<CurrentAnsLookupV2BoolExp>;
};
/** Ordering options when selecting data from "current_ans_lookup_v2". */
type CurrentAnsLookupV2OrderBy = {
    domain?: InputMaybe<OrderBy>;
    expiration_timestamp?: InputMaybe<OrderBy>;
    inserted_at?: InputMaybe<OrderBy>;
    is_deleted?: InputMaybe<OrderBy>;
    last_transaction_version?: InputMaybe<OrderBy>;
    registered_address?: InputMaybe<OrderBy>;
    subdomain?: InputMaybe<OrderBy>;
    subdomain_expiration_policy?: InputMaybe<OrderBy>;
    token_name?: InputMaybe<OrderBy>;
    token_standard?: InputMaybe<OrderBy>;
};
/** primary key columns input for table: current_ans_lookup_v2 */
type CurrentAnsLookupV2PkColumnsInput = {
    domain: Scalars["String"]["input"];
    subdomain: Scalars["String"]["input"];
    token_standard: Scalars["String"]["input"];
};
/** select columns of table "current_ans_lookup_v2" */
declare enum CurrentAnsLookupV2SelectColumn {
    /** column name */
    Domain = "domain",
    /** column name */
    ExpirationTimestamp = "expiration_timestamp",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    IsDeleted = "is_deleted",
    /** column name */
    LastTransactionVersion = "last_transaction_version",
    /** column name */
    RegisteredAddress = "registered_address",
    /** column name */
    Subdomain = "subdomain",
    /** column name */
    SubdomainExpirationPolicy = "subdomain_expiration_policy",
    /** column name */
    TokenName = "token_name",
    /** column name */
    TokenStandard = "token_standard"
}
/** input type for updating data in table "current_ans_lookup_v2" */
type CurrentAnsLookupV2SetInput = {
    domain?: InputMaybe<Scalars["String"]["input"]>;
    expiration_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    is_deleted?: InputMaybe<Scalars["Boolean"]["input"]>;
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    registered_address?: InputMaybe<Scalars["String"]["input"]>;
    subdomain?: InputMaybe<Scalars["String"]["input"]>;
    subdomain_expiration_policy?: InputMaybe<Scalars["bigint"]["input"]>;
    token_name?: InputMaybe<Scalars["String"]["input"]>;
    token_standard?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregate stddev on columns */
type CurrentAnsLookupV2StddevFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
    subdomain_expiration_policy?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_pop on columns */
type CurrentAnsLookupV2StddevPopFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
    subdomain_expiration_policy?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_samp on columns */
type CurrentAnsLookupV2StddevSampFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
    subdomain_expiration_policy?: Maybe<Scalars["Float"]["output"]>;
};
/** Streaming cursor of the table "current_ans_lookup_v2" */
type CurrentAnsLookupV2StreamCursorInput = {
    /** Stream column input with initial value */
    initial_value: CurrentAnsLookupV2StreamCursorValueInput;
    /** cursor ordering */
    ordering?: InputMaybe<CursorOrdering>;
};
/** Initial value of the column from where the streaming should start */
type CurrentAnsLookupV2StreamCursorValueInput = {
    domain?: InputMaybe<Scalars["String"]["input"]>;
    expiration_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    is_deleted?: InputMaybe<Scalars["Boolean"]["input"]>;
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    registered_address?: InputMaybe<Scalars["String"]["input"]>;
    subdomain?: InputMaybe<Scalars["String"]["input"]>;
    subdomain_expiration_policy?: InputMaybe<Scalars["bigint"]["input"]>;
    token_name?: InputMaybe<Scalars["String"]["input"]>;
    token_standard?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregate sum on columns */
type CurrentAnsLookupV2SumFields = {
    last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    subdomain_expiration_policy?: Maybe<Scalars["bigint"]["output"]>;
};
/** update columns of table "current_ans_lookup_v2" */
declare enum CurrentAnsLookupV2UpdateColumn {
    /** column name */
    Domain = "domain",
    /** column name */
    ExpirationTimestamp = "expiration_timestamp",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    IsDeleted = "is_deleted",
    /** column name */
    LastTransactionVersion = "last_transaction_version",
    /** column name */
    RegisteredAddress = "registered_address",
    /** column name */
    Subdomain = "subdomain",
    /** column name */
    SubdomainExpirationPolicy = "subdomain_expiration_policy",
    /** column name */
    TokenName = "token_name",
    /** column name */
    TokenStandard = "token_standard"
}
type CurrentAnsLookupV2Updates = {
    /** increments the numeric columns with given value of the filtered values */
    _inc?: InputMaybe<CurrentAnsLookupV2IncInput>;
    /** sets the columns of the filtered rows to the given values */
    _set?: InputMaybe<CurrentAnsLookupV2SetInput>;
    /** filter the rows which have to be updated */
    where: CurrentAnsLookupV2BoolExp;
};
/** aggregate var_pop on columns */
type CurrentAnsLookupV2VarPopFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
    subdomain_expiration_policy?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate var_samp on columns */
type CurrentAnsLookupV2VarSampFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
    subdomain_expiration_policy?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate variance on columns */
type CurrentAnsLookupV2VarianceFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
    subdomain_expiration_policy?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate var_pop on columns */
type CurrentAnsLookupVarPopFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate var_samp on columns */
type CurrentAnsLookupVarSampFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate variance on columns */
type CurrentAnsLookupVarianceFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** columns and relationships of "current_ans_primary_name" */
type CurrentAnsPrimaryName = {
    domain?: Maybe<Scalars["String"]["output"]>;
    inserted_at: Scalars["timestamp"]["output"];
    is_deleted: Scalars["Boolean"]["output"];
    last_transaction_version: Scalars["bigint"]["output"];
    registered_address: Scalars["String"]["output"];
    subdomain?: Maybe<Scalars["String"]["output"]>;
    token_name?: Maybe<Scalars["String"]["output"]>;
};
/** aggregated selection of "current_ans_primary_name" */
type CurrentAnsPrimaryNameAggregate = {
    aggregate?: Maybe<CurrentAnsPrimaryNameAggregateFields>;
    nodes: Array<CurrentAnsPrimaryName>;
};
/** aggregate fields of "current_ans_primary_name" */
type CurrentAnsPrimaryNameAggregateFields = {
    avg?: Maybe<CurrentAnsPrimaryNameAvgFields>;
    count: Scalars["Int"]["output"];
    max?: Maybe<CurrentAnsPrimaryNameMaxFields>;
    min?: Maybe<CurrentAnsPrimaryNameMinFields>;
    stddev?: Maybe<CurrentAnsPrimaryNameStddevFields>;
    stddev_pop?: Maybe<CurrentAnsPrimaryNameStddevPopFields>;
    stddev_samp?: Maybe<CurrentAnsPrimaryNameStddevSampFields>;
    sum?: Maybe<CurrentAnsPrimaryNameSumFields>;
    var_pop?: Maybe<CurrentAnsPrimaryNameVarPopFields>;
    var_samp?: Maybe<CurrentAnsPrimaryNameVarSampFields>;
    variance?: Maybe<CurrentAnsPrimaryNameVarianceFields>;
};
/** aggregate fields of "current_ans_primary_name" */
type CurrentAnsPrimaryNameAggregateFieldsCountArgs = {
    columns?: InputMaybe<Array<CurrentAnsPrimaryNameSelectColumn>>;
    distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};
/** aggregate avg on columns */
type CurrentAnsPrimaryNameAvgFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** Boolean expression to filter rows from the table "current_ans_primary_name". All fields are combined with a logical 'AND'. */
type CurrentAnsPrimaryNameBoolExp = {
    _and?: InputMaybe<Array<CurrentAnsPrimaryNameBoolExp>>;
    _not?: InputMaybe<CurrentAnsPrimaryNameBoolExp>;
    _or?: InputMaybe<Array<CurrentAnsPrimaryNameBoolExp>>;
    domain?: InputMaybe<StringComparisonExp>;
    inserted_at?: InputMaybe<TimestampComparisonExp>;
    is_deleted?: InputMaybe<BooleanComparisonExp>;
    last_transaction_version?: InputMaybe<BigintComparisonExp>;
    registered_address?: InputMaybe<StringComparisonExp>;
    subdomain?: InputMaybe<StringComparisonExp>;
    token_name?: InputMaybe<StringComparisonExp>;
};
/** unique or primary key constraints on table "current_ans_primary_name" */
declare enum CurrentAnsPrimaryNameConstraint {
    /** unique or primary key constraint on columns "registered_address" */
    CurrentAnsPrimaryNamePkey = "current_ans_primary_name_pkey"
}
/** input type for incrementing numeric columns in table "current_ans_primary_name" */
type CurrentAnsPrimaryNameIncInput = {
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** input type for inserting data into table "current_ans_primary_name" */
type CurrentAnsPrimaryNameInsertInput = {
    domain?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    is_deleted?: InputMaybe<Scalars["Boolean"]["input"]>;
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    registered_address?: InputMaybe<Scalars["String"]["input"]>;
    subdomain?: InputMaybe<Scalars["String"]["input"]>;
    token_name?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregate max on columns */
type CurrentAnsPrimaryNameMaxFields = {
    domain?: Maybe<Scalars["String"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    registered_address?: Maybe<Scalars["String"]["output"]>;
    subdomain?: Maybe<Scalars["String"]["output"]>;
    token_name?: Maybe<Scalars["String"]["output"]>;
};
/** aggregate min on columns */
type CurrentAnsPrimaryNameMinFields = {
    domain?: Maybe<Scalars["String"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    registered_address?: Maybe<Scalars["String"]["output"]>;
    subdomain?: Maybe<Scalars["String"]["output"]>;
    token_name?: Maybe<Scalars["String"]["output"]>;
};
/** response of any mutation on the table "current_ans_primary_name" */
type CurrentAnsPrimaryNameMutationResponse = {
    /** number of rows affected by the mutation */
    affected_rows: Scalars["Int"]["output"];
    /** data from the rows affected by the mutation */
    returning: Array<CurrentAnsPrimaryName>;
};
/** on_conflict condition type for table "current_ans_primary_name" */
type CurrentAnsPrimaryNameOnConflict = {
    constraint: CurrentAnsPrimaryNameConstraint;
    update_columns?: Array<CurrentAnsPrimaryNameUpdateColumn>;
    where?: InputMaybe<CurrentAnsPrimaryNameBoolExp>;
};
/** Ordering options when selecting data from "current_ans_primary_name". */
type CurrentAnsPrimaryNameOrderBy = {
    domain?: InputMaybe<OrderBy>;
    inserted_at?: InputMaybe<OrderBy>;
    is_deleted?: InputMaybe<OrderBy>;
    last_transaction_version?: InputMaybe<OrderBy>;
    registered_address?: InputMaybe<OrderBy>;
    subdomain?: InputMaybe<OrderBy>;
    token_name?: InputMaybe<OrderBy>;
};
/** primary key columns input for table: current_ans_primary_name */
type CurrentAnsPrimaryNamePkColumnsInput = {
    registered_address: Scalars["String"]["input"];
};
/** select columns of table "current_ans_primary_name" */
declare enum CurrentAnsPrimaryNameSelectColumn {
    /** column name */
    Domain = "domain",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    IsDeleted = "is_deleted",
    /** column name */
    LastTransactionVersion = "last_transaction_version",
    /** column name */
    RegisteredAddress = "registered_address",
    /** column name */
    Subdomain = "subdomain",
    /** column name */
    TokenName = "token_name"
}
/** input type for updating data in table "current_ans_primary_name" */
type CurrentAnsPrimaryNameSetInput = {
    domain?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    is_deleted?: InputMaybe<Scalars["Boolean"]["input"]>;
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    registered_address?: InputMaybe<Scalars["String"]["input"]>;
    subdomain?: InputMaybe<Scalars["String"]["input"]>;
    token_name?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregate stddev on columns */
type CurrentAnsPrimaryNameStddevFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_pop on columns */
type CurrentAnsPrimaryNameStddevPopFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_samp on columns */
type CurrentAnsPrimaryNameStddevSampFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** Streaming cursor of the table "current_ans_primary_name" */
type CurrentAnsPrimaryNameStreamCursorInput = {
    /** Stream column input with initial value */
    initial_value: CurrentAnsPrimaryNameStreamCursorValueInput;
    /** cursor ordering */
    ordering?: InputMaybe<CursorOrdering>;
};
/** Initial value of the column from where the streaming should start */
type CurrentAnsPrimaryNameStreamCursorValueInput = {
    domain?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    is_deleted?: InputMaybe<Scalars["Boolean"]["input"]>;
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    registered_address?: InputMaybe<Scalars["String"]["input"]>;
    subdomain?: InputMaybe<Scalars["String"]["input"]>;
    token_name?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregate sum on columns */
type CurrentAnsPrimaryNameSumFields = {
    last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};
/** update columns of table "current_ans_primary_name" */
declare enum CurrentAnsPrimaryNameUpdateColumn {
    /** column name */
    Domain = "domain",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    IsDeleted = "is_deleted",
    /** column name */
    LastTransactionVersion = "last_transaction_version",
    /** column name */
    RegisteredAddress = "registered_address",
    /** column name */
    Subdomain = "subdomain",
    /** column name */
    TokenName = "token_name"
}
type CurrentAnsPrimaryNameUpdates = {
    /** increments the numeric columns with given value of the filtered values */
    _inc?: InputMaybe<CurrentAnsPrimaryNameIncInput>;
    /** sets the columns of the filtered rows to the given values */
    _set?: InputMaybe<CurrentAnsPrimaryNameSetInput>;
    /** filter the rows which have to be updated */
    where: CurrentAnsPrimaryNameBoolExp;
};
/** columns and relationships of "current_ans_primary_name_v2" */
type CurrentAnsPrimaryNameV2 = {
    domain?: Maybe<Scalars["String"]["output"]>;
    inserted_at: Scalars["timestamp"]["output"];
    is_deleted: Scalars["Boolean"]["output"];
    last_transaction_version: Scalars["bigint"]["output"];
    registered_address: Scalars["String"]["output"];
    subdomain?: Maybe<Scalars["String"]["output"]>;
    token_name?: Maybe<Scalars["String"]["output"]>;
    token_standard: Scalars["String"]["output"];
};
/** aggregated selection of "current_ans_primary_name_v2" */
type CurrentAnsPrimaryNameV2Aggregate = {
    aggregate?: Maybe<CurrentAnsPrimaryNameV2AggregateFields>;
    nodes: Array<CurrentAnsPrimaryNameV2>;
};
/** aggregate fields of "current_ans_primary_name_v2" */
type CurrentAnsPrimaryNameV2AggregateFields = {
    avg?: Maybe<CurrentAnsPrimaryNameV2AvgFields>;
    count: Scalars["Int"]["output"];
    max?: Maybe<CurrentAnsPrimaryNameV2MaxFields>;
    min?: Maybe<CurrentAnsPrimaryNameV2MinFields>;
    stddev?: Maybe<CurrentAnsPrimaryNameV2StddevFields>;
    stddev_pop?: Maybe<CurrentAnsPrimaryNameV2StddevPopFields>;
    stddev_samp?: Maybe<CurrentAnsPrimaryNameV2StddevSampFields>;
    sum?: Maybe<CurrentAnsPrimaryNameV2SumFields>;
    var_pop?: Maybe<CurrentAnsPrimaryNameV2VarPopFields>;
    var_samp?: Maybe<CurrentAnsPrimaryNameV2VarSampFields>;
    variance?: Maybe<CurrentAnsPrimaryNameV2VarianceFields>;
};
/** aggregate fields of "current_ans_primary_name_v2" */
type CurrentAnsPrimaryNameV2AggregateFieldsCountArgs = {
    columns?: InputMaybe<Array<CurrentAnsPrimaryNameV2SelectColumn>>;
    distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};
/** aggregate avg on columns */
type CurrentAnsPrimaryNameV2AvgFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** Boolean expression to filter rows from the table "current_ans_primary_name_v2". All fields are combined with a logical 'AND'. */
type CurrentAnsPrimaryNameV2BoolExp = {
    _and?: InputMaybe<Array<CurrentAnsPrimaryNameV2BoolExp>>;
    _not?: InputMaybe<CurrentAnsPrimaryNameV2BoolExp>;
    _or?: InputMaybe<Array<CurrentAnsPrimaryNameV2BoolExp>>;
    domain?: InputMaybe<StringComparisonExp>;
    inserted_at?: InputMaybe<TimestampComparisonExp>;
    is_deleted?: InputMaybe<BooleanComparisonExp>;
    last_transaction_version?: InputMaybe<BigintComparisonExp>;
    registered_address?: InputMaybe<StringComparisonExp>;
    subdomain?: InputMaybe<StringComparisonExp>;
    token_name?: InputMaybe<StringComparisonExp>;
    token_standard?: InputMaybe<StringComparisonExp>;
};
/** unique or primary key constraints on table "current_ans_primary_name_v2" */
declare enum CurrentAnsPrimaryNameV2Constraint {
    /** unique or primary key constraint on columns "token_standard", "registered_address" */
    CurrentAnsPrimaryNameV2Pkey = "current_ans_primary_name_v2_pkey"
}
/** input type for incrementing numeric columns in table "current_ans_primary_name_v2" */
type CurrentAnsPrimaryNameV2IncInput = {
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** input type for inserting data into table "current_ans_primary_name_v2" */
type CurrentAnsPrimaryNameV2InsertInput = {
    domain?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    is_deleted?: InputMaybe<Scalars["Boolean"]["input"]>;
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    registered_address?: InputMaybe<Scalars["String"]["input"]>;
    subdomain?: InputMaybe<Scalars["String"]["input"]>;
    token_name?: InputMaybe<Scalars["String"]["input"]>;
    token_standard?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregate max on columns */
type CurrentAnsPrimaryNameV2MaxFields = {
    domain?: Maybe<Scalars["String"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    registered_address?: Maybe<Scalars["String"]["output"]>;
    subdomain?: Maybe<Scalars["String"]["output"]>;
    token_name?: Maybe<Scalars["String"]["output"]>;
    token_standard?: Maybe<Scalars["String"]["output"]>;
};
/** aggregate min on columns */
type CurrentAnsPrimaryNameV2MinFields = {
    domain?: Maybe<Scalars["String"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    registered_address?: Maybe<Scalars["String"]["output"]>;
    subdomain?: Maybe<Scalars["String"]["output"]>;
    token_name?: Maybe<Scalars["String"]["output"]>;
    token_standard?: Maybe<Scalars["String"]["output"]>;
};
/** response of any mutation on the table "current_ans_primary_name_v2" */
type CurrentAnsPrimaryNameV2MutationResponse = {
    /** number of rows affected by the mutation */
    affected_rows: Scalars["Int"]["output"];
    /** data from the rows affected by the mutation */
    returning: Array<CurrentAnsPrimaryNameV2>;
};
/** on_conflict condition type for table "current_ans_primary_name_v2" */
type CurrentAnsPrimaryNameV2OnConflict = {
    constraint: CurrentAnsPrimaryNameV2Constraint;
    update_columns?: Array<CurrentAnsPrimaryNameV2UpdateColumn>;
    where?: InputMaybe<CurrentAnsPrimaryNameV2BoolExp>;
};
/** Ordering options when selecting data from "current_ans_primary_name_v2". */
type CurrentAnsPrimaryNameV2OrderBy = {
    domain?: InputMaybe<OrderBy>;
    inserted_at?: InputMaybe<OrderBy>;
    is_deleted?: InputMaybe<OrderBy>;
    last_transaction_version?: InputMaybe<OrderBy>;
    registered_address?: InputMaybe<OrderBy>;
    subdomain?: InputMaybe<OrderBy>;
    token_name?: InputMaybe<OrderBy>;
    token_standard?: InputMaybe<OrderBy>;
};
/** primary key columns input for table: current_ans_primary_name_v2 */
type CurrentAnsPrimaryNameV2PkColumnsInput = {
    registered_address: Scalars["String"]["input"];
    token_standard: Scalars["String"]["input"];
};
/** select columns of table "current_ans_primary_name_v2" */
declare enum CurrentAnsPrimaryNameV2SelectColumn {
    /** column name */
    Domain = "domain",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    IsDeleted = "is_deleted",
    /** column name */
    LastTransactionVersion = "last_transaction_version",
    /** column name */
    RegisteredAddress = "registered_address",
    /** column name */
    Subdomain = "subdomain",
    /** column name */
    TokenName = "token_name",
    /** column name */
    TokenStandard = "token_standard"
}
/** input type for updating data in table "current_ans_primary_name_v2" */
type CurrentAnsPrimaryNameV2SetInput = {
    domain?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    is_deleted?: InputMaybe<Scalars["Boolean"]["input"]>;
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    registered_address?: InputMaybe<Scalars["String"]["input"]>;
    subdomain?: InputMaybe<Scalars["String"]["input"]>;
    token_name?: InputMaybe<Scalars["String"]["input"]>;
    token_standard?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregate stddev on columns */
type CurrentAnsPrimaryNameV2StddevFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_pop on columns */
type CurrentAnsPrimaryNameV2StddevPopFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_samp on columns */
type CurrentAnsPrimaryNameV2StddevSampFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** Streaming cursor of the table "current_ans_primary_name_v2" */
type CurrentAnsPrimaryNameV2StreamCursorInput = {
    /** Stream column input with initial value */
    initial_value: CurrentAnsPrimaryNameV2StreamCursorValueInput;
    /** cursor ordering */
    ordering?: InputMaybe<CursorOrdering>;
};
/** Initial value of the column from where the streaming should start */
type CurrentAnsPrimaryNameV2StreamCursorValueInput = {
    domain?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    is_deleted?: InputMaybe<Scalars["Boolean"]["input"]>;
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    registered_address?: InputMaybe<Scalars["String"]["input"]>;
    subdomain?: InputMaybe<Scalars["String"]["input"]>;
    token_name?: InputMaybe<Scalars["String"]["input"]>;
    token_standard?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregate sum on columns */
type CurrentAnsPrimaryNameV2SumFields = {
    last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};
/** update columns of table "current_ans_primary_name_v2" */
declare enum CurrentAnsPrimaryNameV2UpdateColumn {
    /** column name */
    Domain = "domain",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    IsDeleted = "is_deleted",
    /** column name */
    LastTransactionVersion = "last_transaction_version",
    /** column name */
    RegisteredAddress = "registered_address",
    /** column name */
    Subdomain = "subdomain",
    /** column name */
    TokenName = "token_name",
    /** column name */
    TokenStandard = "token_standard"
}
type CurrentAnsPrimaryNameV2Updates = {
    /** increments the numeric columns with given value of the filtered values */
    _inc?: InputMaybe<CurrentAnsPrimaryNameV2IncInput>;
    /** sets the columns of the filtered rows to the given values */
    _set?: InputMaybe<CurrentAnsPrimaryNameV2SetInput>;
    /** filter the rows which have to be updated */
    where: CurrentAnsPrimaryNameV2BoolExp;
};
/** aggregate var_pop on columns */
type CurrentAnsPrimaryNameV2VarPopFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate var_samp on columns */
type CurrentAnsPrimaryNameV2VarSampFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate variance on columns */
type CurrentAnsPrimaryNameV2VarianceFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate var_pop on columns */
type CurrentAnsPrimaryNameVarPopFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate var_samp on columns */
type CurrentAnsPrimaryNameVarSampFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate variance on columns */
type CurrentAnsPrimaryNameVarianceFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** columns and relationships of "current_cedra_names" */
type CurrentCedraNames = {
    domain?: Maybe<Scalars["String"]["output"]>;
    domain_expiration_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
    domain_with_suffix?: Maybe<Scalars["String"]["output"]>;
    expiration_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
    is_active?: Maybe<Scalars["Boolean"]["output"]>;
    /** An object relationship */
    is_domain_owner?: Maybe<CurrentCedraNames>;
    is_primary?: Maybe<Scalars["Boolean"]["output"]>;
    last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    owner_address?: Maybe<Scalars["String"]["output"]>;
    registered_address?: Maybe<Scalars["String"]["output"]>;
    subdomain?: Maybe<Scalars["String"]["output"]>;
    subdomain_expiration_policy?: Maybe<Scalars["bigint"]["output"]>;
    token_data_id?: Maybe<Scalars["String"]["output"]>;
    token_name?: Maybe<Scalars["String"]["output"]>;
    token_standard?: Maybe<Scalars["String"]["output"]>;
};
/** aggregated selection of "current_cedra_names" */
type CurrentCedraNamesAggregate = {
    aggregate?: Maybe<CurrentCedraNamesAggregateFields>;
    nodes: Array<CurrentCedraNames>;
};
type CurrentCedraNamesAggregateBoolExp = {
    bool_and?: InputMaybe<CurrentCedraNamesAggregateBoolExpBoolAnd>;
    bool_or?: InputMaybe<CurrentCedraNamesAggregateBoolExpBoolOr>;
    count?: InputMaybe<CurrentCedraNamesAggregateBoolExpCount>;
};
type CurrentCedraNamesAggregateBoolExpBoolAnd = {
    arguments: CurrentCedraNamesSelectColumnCurrentCedraNamesAggregateBoolExpBoolAndArgumentsColumns;
    distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
    filter?: InputMaybe<CurrentCedraNamesBoolExp>;
    predicate: BooleanComparisonExp;
};
type CurrentCedraNamesAggregateBoolExpBoolOr = {
    arguments: CurrentCedraNamesSelectColumnCurrentCedraNamesAggregateBoolExpBoolOrArgumentsColumns;
    distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
    filter?: InputMaybe<CurrentCedraNamesBoolExp>;
    predicate: BooleanComparisonExp;
};
type CurrentCedraNamesAggregateBoolExpCount = {
    arguments?: InputMaybe<Array<CurrentCedraNamesSelectColumn>>;
    distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
    filter?: InputMaybe<CurrentCedraNamesBoolExp>;
    predicate: IntComparisonExp;
};
/** aggregate fields of "current_cedra_names" */
type CurrentCedraNamesAggregateFields = {
    avg?: Maybe<CurrentCedraNamesAvgFields>;
    count: Scalars["Int"]["output"];
    max?: Maybe<CurrentCedraNamesMaxFields>;
    min?: Maybe<CurrentCedraNamesMinFields>;
    stddev?: Maybe<CurrentCedraNamesStddevFields>;
    stddev_pop?: Maybe<CurrentCedraNamesStddevPopFields>;
    stddev_samp?: Maybe<CurrentCedraNamesStddevSampFields>;
    sum?: Maybe<CurrentCedraNamesSumFields>;
    var_pop?: Maybe<CurrentCedraNamesVarPopFields>;
    var_samp?: Maybe<CurrentCedraNamesVarSampFields>;
    variance?: Maybe<CurrentCedraNamesVarianceFields>;
};
/** aggregate fields of "current_cedra_names" */
type CurrentCedraNamesAggregateFieldsCountArgs = {
    columns?: InputMaybe<Array<CurrentCedraNamesSelectColumn>>;
    distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};
/** order by aggregate values of table "current_cedra_names" */
type CurrentCedraNamesAggregateOrderBy = {
    avg?: InputMaybe<CurrentCedraNamesAvgOrderBy>;
    count?: InputMaybe<OrderBy>;
    max?: InputMaybe<CurrentCedraNamesMaxOrderBy>;
    min?: InputMaybe<CurrentCedraNamesMinOrderBy>;
    stddev?: InputMaybe<CurrentCedraNamesStddevOrderBy>;
    stddev_pop?: InputMaybe<CurrentCedraNamesStddevPopOrderBy>;
    stddev_samp?: InputMaybe<CurrentCedraNamesStddevSampOrderBy>;
    sum?: InputMaybe<CurrentCedraNamesSumOrderBy>;
    var_pop?: InputMaybe<CurrentCedraNamesVarPopOrderBy>;
    var_samp?: InputMaybe<CurrentCedraNamesVarSampOrderBy>;
    variance?: InputMaybe<CurrentCedraNamesVarianceOrderBy>;
};
/** input type for inserting array relation for remote table "current_cedra_names" */
type CurrentCedraNamesArrRelInsertInput = {
    data: Array<CurrentCedraNamesInsertInput>;
};
/** aggregate avg on columns */
type CurrentCedraNamesAvgFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
    subdomain_expiration_policy?: Maybe<Scalars["Float"]["output"]>;
};
/** order by avg() on columns of table "current_cedra_names" */
type CurrentCedraNamesAvgOrderBy = {
    last_transaction_version?: InputMaybe<OrderBy>;
    subdomain_expiration_policy?: InputMaybe<OrderBy>;
};
/** Boolean expression to filter rows from the table "current_cedra_names". All fields are combined with a logical 'AND'. */
type CurrentCedraNamesBoolExp = {
    _and?: InputMaybe<Array<CurrentCedraNamesBoolExp>>;
    _not?: InputMaybe<CurrentCedraNamesBoolExp>;
    _or?: InputMaybe<Array<CurrentCedraNamesBoolExp>>;
    domain?: InputMaybe<StringComparisonExp>;
    domain_expiration_timestamp?: InputMaybe<TimestampComparisonExp>;
    domain_with_suffix?: InputMaybe<StringComparisonExp>;
    expiration_timestamp?: InputMaybe<TimestampComparisonExp>;
    is_active?: InputMaybe<BooleanComparisonExp>;
    is_domain_owner?: InputMaybe<CurrentCedraNamesBoolExp>;
    is_primary?: InputMaybe<BooleanComparisonExp>;
    last_transaction_version?: InputMaybe<BigintComparisonExp>;
    owner_address?: InputMaybe<StringComparisonExp>;
    registered_address?: InputMaybe<StringComparisonExp>;
    subdomain?: InputMaybe<StringComparisonExp>;
    subdomain_expiration_policy?: InputMaybe<BigintComparisonExp>;
    token_data_id?: InputMaybe<StringComparisonExp>;
    token_name?: InputMaybe<StringComparisonExp>;
    token_standard?: InputMaybe<StringComparisonExp>;
};
/** input type for inserting data into table "current_cedra_names" */
type CurrentCedraNamesInsertInput = {
    domain?: InputMaybe<Scalars["String"]["input"]>;
    domain_expiration_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    domain_with_suffix?: InputMaybe<Scalars["String"]["input"]>;
    expiration_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    is_active?: InputMaybe<Scalars["Boolean"]["input"]>;
    is_domain_owner?: InputMaybe<CurrentCedraNamesObjRelInsertInput>;
    is_primary?: InputMaybe<Scalars["Boolean"]["input"]>;
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    owner_address?: InputMaybe<Scalars["String"]["input"]>;
    registered_address?: InputMaybe<Scalars["String"]["input"]>;
    subdomain?: InputMaybe<Scalars["String"]["input"]>;
    subdomain_expiration_policy?: InputMaybe<Scalars["bigint"]["input"]>;
    token_data_id?: InputMaybe<Scalars["String"]["input"]>;
    token_name?: InputMaybe<Scalars["String"]["input"]>;
    token_standard?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregate max on columns */
type CurrentCedraNamesMaxFields = {
    domain?: Maybe<Scalars["String"]["output"]>;
    domain_expiration_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
    domain_with_suffix?: Maybe<Scalars["String"]["output"]>;
    expiration_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
    last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    owner_address?: Maybe<Scalars["String"]["output"]>;
    registered_address?: Maybe<Scalars["String"]["output"]>;
    subdomain?: Maybe<Scalars["String"]["output"]>;
    subdomain_expiration_policy?: Maybe<Scalars["bigint"]["output"]>;
    token_data_id?: Maybe<Scalars["String"]["output"]>;
    token_name?: Maybe<Scalars["String"]["output"]>;
    token_standard?: Maybe<Scalars["String"]["output"]>;
};
/** order by max() on columns of table "current_cedra_names" */
type CurrentCedraNamesMaxOrderBy = {
    domain?: InputMaybe<OrderBy>;
    domain_expiration_timestamp?: InputMaybe<OrderBy>;
    domain_with_suffix?: InputMaybe<OrderBy>;
    expiration_timestamp?: InputMaybe<OrderBy>;
    last_transaction_version?: InputMaybe<OrderBy>;
    owner_address?: InputMaybe<OrderBy>;
    registered_address?: InputMaybe<OrderBy>;
    subdomain?: InputMaybe<OrderBy>;
    subdomain_expiration_policy?: InputMaybe<OrderBy>;
    token_data_id?: InputMaybe<OrderBy>;
    token_name?: InputMaybe<OrderBy>;
    token_standard?: InputMaybe<OrderBy>;
};
/** aggregate min on columns */
type CurrentCedraNamesMinFields = {
    domain?: Maybe<Scalars["String"]["output"]>;
    domain_expiration_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
    domain_with_suffix?: Maybe<Scalars["String"]["output"]>;
    expiration_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
    last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    owner_address?: Maybe<Scalars["String"]["output"]>;
    registered_address?: Maybe<Scalars["String"]["output"]>;
    subdomain?: Maybe<Scalars["String"]["output"]>;
    subdomain_expiration_policy?: Maybe<Scalars["bigint"]["output"]>;
    token_data_id?: Maybe<Scalars["String"]["output"]>;
    token_name?: Maybe<Scalars["String"]["output"]>;
    token_standard?: Maybe<Scalars["String"]["output"]>;
};
/** order by min() on columns of table "current_cedra_names" */
type CurrentCedraNamesMinOrderBy = {
    domain?: InputMaybe<OrderBy>;
    domain_expiration_timestamp?: InputMaybe<OrderBy>;
    domain_with_suffix?: InputMaybe<OrderBy>;
    expiration_timestamp?: InputMaybe<OrderBy>;
    last_transaction_version?: InputMaybe<OrderBy>;
    owner_address?: InputMaybe<OrderBy>;
    registered_address?: InputMaybe<OrderBy>;
    subdomain?: InputMaybe<OrderBy>;
    subdomain_expiration_policy?: InputMaybe<OrderBy>;
    token_data_id?: InputMaybe<OrderBy>;
    token_name?: InputMaybe<OrderBy>;
    token_standard?: InputMaybe<OrderBy>;
};
/** input type for inserting object relation for remote table "current_cedra_names" */
type CurrentCedraNamesObjRelInsertInput = {
    data: CurrentCedraNamesInsertInput;
};
/** Ordering options when selecting data from "current_cedra_names". */
type CurrentCedraNamesOrderBy = {
    domain?: InputMaybe<OrderBy>;
    domain_expiration_timestamp?: InputMaybe<OrderBy>;
    domain_with_suffix?: InputMaybe<OrderBy>;
    expiration_timestamp?: InputMaybe<OrderBy>;
    is_active?: InputMaybe<OrderBy>;
    is_domain_owner?: InputMaybe<CurrentCedraNamesOrderBy>;
    is_primary?: InputMaybe<OrderBy>;
    last_transaction_version?: InputMaybe<OrderBy>;
    owner_address?: InputMaybe<OrderBy>;
    registered_address?: InputMaybe<OrderBy>;
    subdomain?: InputMaybe<OrderBy>;
    subdomain_expiration_policy?: InputMaybe<OrderBy>;
    token_data_id?: InputMaybe<OrderBy>;
    token_name?: InputMaybe<OrderBy>;
    token_standard?: InputMaybe<OrderBy>;
};
/** select columns of table "current_cedra_names" */
declare enum CurrentCedraNamesSelectColumn {
    /** column name */
    Domain = "domain",
    /** column name */
    DomainExpirationTimestamp = "domain_expiration_timestamp",
    /** column name */
    DomainWithSuffix = "domain_with_suffix",
    /** column name */
    ExpirationTimestamp = "expiration_timestamp",
    /** column name */
    IsActive = "is_active",
    /** column name */
    IsPrimary = "is_primary",
    /** column name */
    LastTransactionVersion = "last_transaction_version",
    /** column name */
    OwnerAddress = "owner_address",
    /** column name */
    RegisteredAddress = "registered_address",
    /** column name */
    Subdomain = "subdomain",
    /** column name */
    SubdomainExpirationPolicy = "subdomain_expiration_policy",
    /** column name */
    TokenDataId = "token_data_id",
    /** column name */
    TokenName = "token_name",
    /** column name */
    TokenStandard = "token_standard"
}
/** select "current_cedra_names_aggregate_bool_exp_bool_and_arguments_columns" columns of table "current_cedra_names" */
declare enum CurrentCedraNamesSelectColumnCurrentCedraNamesAggregateBoolExpBoolAndArgumentsColumns {
    /** column name */
    IsActive = "is_active",
    /** column name */
    IsPrimary = "is_primary"
}
/** select "current_cedra_names_aggregate_bool_exp_bool_or_arguments_columns" columns of table "current_cedra_names" */
declare enum CurrentCedraNamesSelectColumnCurrentCedraNamesAggregateBoolExpBoolOrArgumentsColumns {
    /** column name */
    IsActive = "is_active",
    /** column name */
    IsPrimary = "is_primary"
}
/** aggregate stddev on columns */
type CurrentCedraNamesStddevFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
    subdomain_expiration_policy?: Maybe<Scalars["Float"]["output"]>;
};
/** order by stddev() on columns of table "current_cedra_names" */
type CurrentCedraNamesStddevOrderBy = {
    last_transaction_version?: InputMaybe<OrderBy>;
    subdomain_expiration_policy?: InputMaybe<OrderBy>;
};
/** aggregate stddev_pop on columns */
type CurrentCedraNamesStddevPopFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
    subdomain_expiration_policy?: Maybe<Scalars["Float"]["output"]>;
};
/** order by stddev_pop() on columns of table "current_cedra_names" */
type CurrentCedraNamesStddevPopOrderBy = {
    last_transaction_version?: InputMaybe<OrderBy>;
    subdomain_expiration_policy?: InputMaybe<OrderBy>;
};
/** aggregate stddev_samp on columns */
type CurrentCedraNamesStddevSampFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
    subdomain_expiration_policy?: Maybe<Scalars["Float"]["output"]>;
};
/** order by stddev_samp() on columns of table "current_cedra_names" */
type CurrentCedraNamesStddevSampOrderBy = {
    last_transaction_version?: InputMaybe<OrderBy>;
    subdomain_expiration_policy?: InputMaybe<OrderBy>;
};
/** Streaming cursor of the table "current_cedra_names" */
type CurrentCedraNamesStreamCursorInput = {
    /** Stream column input with initial value */
    initial_value: CurrentCedraNamesStreamCursorValueInput;
    /** cursor ordering */
    ordering?: InputMaybe<CursorOrdering>;
};
/** Initial value of the column from where the streaming should start */
type CurrentCedraNamesStreamCursorValueInput = {
    domain?: InputMaybe<Scalars["String"]["input"]>;
    domain_expiration_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    domain_with_suffix?: InputMaybe<Scalars["String"]["input"]>;
    expiration_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    is_active?: InputMaybe<Scalars["Boolean"]["input"]>;
    is_primary?: InputMaybe<Scalars["Boolean"]["input"]>;
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    owner_address?: InputMaybe<Scalars["String"]["input"]>;
    registered_address?: InputMaybe<Scalars["String"]["input"]>;
    subdomain?: InputMaybe<Scalars["String"]["input"]>;
    subdomain_expiration_policy?: InputMaybe<Scalars["bigint"]["input"]>;
    token_data_id?: InputMaybe<Scalars["String"]["input"]>;
    token_name?: InputMaybe<Scalars["String"]["input"]>;
    token_standard?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregate sum on columns */
type CurrentCedraNamesSumFields = {
    last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    subdomain_expiration_policy?: Maybe<Scalars["bigint"]["output"]>;
};
/** order by sum() on columns of table "current_cedra_names" */
type CurrentCedraNamesSumOrderBy = {
    last_transaction_version?: InputMaybe<OrderBy>;
    subdomain_expiration_policy?: InputMaybe<OrderBy>;
};
/** aggregate var_pop on columns */
type CurrentCedraNamesVarPopFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
    subdomain_expiration_policy?: Maybe<Scalars["Float"]["output"]>;
};
/** order by var_pop() on columns of table "current_cedra_names" */
type CurrentCedraNamesVarPopOrderBy = {
    last_transaction_version?: InputMaybe<OrderBy>;
    subdomain_expiration_policy?: InputMaybe<OrderBy>;
};
/** aggregate var_samp on columns */
type CurrentCedraNamesVarSampFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
    subdomain_expiration_policy?: Maybe<Scalars["Float"]["output"]>;
};
/** order by var_samp() on columns of table "current_cedra_names" */
type CurrentCedraNamesVarSampOrderBy = {
    last_transaction_version?: InputMaybe<OrderBy>;
    subdomain_expiration_policy?: InputMaybe<OrderBy>;
};
/** aggregate variance on columns */
type CurrentCedraNamesVarianceFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
    subdomain_expiration_policy?: Maybe<Scalars["Float"]["output"]>;
};
/** order by variance() on columns of table "current_cedra_names" */
type CurrentCedraNamesVarianceOrderBy = {
    last_transaction_version?: InputMaybe<OrderBy>;
    subdomain_expiration_policy?: InputMaybe<OrderBy>;
};
/** columns and relationships of "current_coin_balances" */
type CurrentCoinBalances = {
    amount: Scalars["numeric"]["output"];
    coin_type: Scalars["String"]["output"];
    coin_type_hash: Scalars["String"]["output"];
    inserted_at: Scalars["timestamp"]["output"];
    last_transaction_timestamp: Scalars["timestamp"]["output"];
    last_transaction_version: Scalars["bigint"]["output"];
    owner_address: Scalars["String"]["output"];
};
/** aggregated selection of "current_coin_balances" */
type CurrentCoinBalancesAggregate = {
    aggregate?: Maybe<CurrentCoinBalancesAggregateFields>;
    nodes: Array<CurrentCoinBalances>;
};
/** aggregate fields of "current_coin_balances" */
type CurrentCoinBalancesAggregateFields = {
    avg?: Maybe<CurrentCoinBalancesAvgFields>;
    count: Scalars["Int"]["output"];
    max?: Maybe<CurrentCoinBalancesMaxFields>;
    min?: Maybe<CurrentCoinBalancesMinFields>;
    stddev?: Maybe<CurrentCoinBalancesStddevFields>;
    stddev_pop?: Maybe<CurrentCoinBalancesStddevPopFields>;
    stddev_samp?: Maybe<CurrentCoinBalancesStddevSampFields>;
    sum?: Maybe<CurrentCoinBalancesSumFields>;
    var_pop?: Maybe<CurrentCoinBalancesVarPopFields>;
    var_samp?: Maybe<CurrentCoinBalancesVarSampFields>;
    variance?: Maybe<CurrentCoinBalancesVarianceFields>;
};
/** aggregate fields of "current_coin_balances" */
type CurrentCoinBalancesAggregateFieldsCountArgs = {
    columns?: InputMaybe<Array<CurrentCoinBalancesSelectColumn>>;
    distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};
/** aggregate avg on columns */
type CurrentCoinBalancesAvgFields = {
    amount?: Maybe<Scalars["Float"]["output"]>;
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** Boolean expression to filter rows from the table "current_coin_balances". All fields are combined with a logical 'AND'. */
type CurrentCoinBalancesBoolExp = {
    _and?: InputMaybe<Array<CurrentCoinBalancesBoolExp>>;
    _not?: InputMaybe<CurrentCoinBalancesBoolExp>;
    _or?: InputMaybe<Array<CurrentCoinBalancesBoolExp>>;
    amount?: InputMaybe<NumericComparisonExp>;
    coin_type?: InputMaybe<StringComparisonExp>;
    coin_type_hash?: InputMaybe<StringComparisonExp>;
    inserted_at?: InputMaybe<TimestampComparisonExp>;
    last_transaction_timestamp?: InputMaybe<TimestampComparisonExp>;
    last_transaction_version?: InputMaybe<BigintComparisonExp>;
    owner_address?: InputMaybe<StringComparisonExp>;
};
/** unique or primary key constraints on table "current_coin_balances" */
declare enum CurrentCoinBalancesConstraint {
    /** unique or primary key constraint on columns "coin_type_hash", "owner_address" */
    CurrentCoinBalancesPkey = "current_coin_balances_pkey"
}
/** input type for incrementing numeric columns in table "current_coin_balances" */
type CurrentCoinBalancesIncInput = {
    amount?: InputMaybe<Scalars["numeric"]["input"]>;
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** input type for inserting data into table "current_coin_balances" */
type CurrentCoinBalancesInsertInput = {
    amount?: InputMaybe<Scalars["numeric"]["input"]>;
    coin_type?: InputMaybe<Scalars["String"]["input"]>;
    coin_type_hash?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    last_transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    owner_address?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregate max on columns */
type CurrentCoinBalancesMaxFields = {
    amount?: Maybe<Scalars["numeric"]["output"]>;
    coin_type?: Maybe<Scalars["String"]["output"]>;
    coin_type_hash?: Maybe<Scalars["String"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    last_transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
    last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    owner_address?: Maybe<Scalars["String"]["output"]>;
};
/** aggregate min on columns */
type CurrentCoinBalancesMinFields = {
    amount?: Maybe<Scalars["numeric"]["output"]>;
    coin_type?: Maybe<Scalars["String"]["output"]>;
    coin_type_hash?: Maybe<Scalars["String"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    last_transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
    last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    owner_address?: Maybe<Scalars["String"]["output"]>;
};
/** response of any mutation on the table "current_coin_balances" */
type CurrentCoinBalancesMutationResponse = {
    /** number of rows affected by the mutation */
    affected_rows: Scalars["Int"]["output"];
    /** data from the rows affected by the mutation */
    returning: Array<CurrentCoinBalances>;
};
/** on_conflict condition type for table "current_coin_balances" */
type CurrentCoinBalancesOnConflict = {
    constraint: CurrentCoinBalancesConstraint;
    update_columns?: Array<CurrentCoinBalancesUpdateColumn>;
    where?: InputMaybe<CurrentCoinBalancesBoolExp>;
};
/** Ordering options when selecting data from "current_coin_balances". */
type CurrentCoinBalancesOrderBy = {
    amount?: InputMaybe<OrderBy>;
    coin_type?: InputMaybe<OrderBy>;
    coin_type_hash?: InputMaybe<OrderBy>;
    inserted_at?: InputMaybe<OrderBy>;
    last_transaction_timestamp?: InputMaybe<OrderBy>;
    last_transaction_version?: InputMaybe<OrderBy>;
    owner_address?: InputMaybe<OrderBy>;
};
/** primary key columns input for table: current_coin_balances */
type CurrentCoinBalancesPkColumnsInput = {
    coin_type_hash: Scalars["String"]["input"];
    owner_address: Scalars["String"]["input"];
};
/** select columns of table "current_coin_balances" */
declare enum CurrentCoinBalancesSelectColumn {
    /** column name */
    Amount = "amount",
    /** column name */
    CoinType = "coin_type",
    /** column name */
    CoinTypeHash = "coin_type_hash",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    LastTransactionTimestamp = "last_transaction_timestamp",
    /** column name */
    LastTransactionVersion = "last_transaction_version",
    /** column name */
    OwnerAddress = "owner_address"
}
/** input type for updating data in table "current_coin_balances" */
type CurrentCoinBalancesSetInput = {
    amount?: InputMaybe<Scalars["numeric"]["input"]>;
    coin_type?: InputMaybe<Scalars["String"]["input"]>;
    coin_type_hash?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    last_transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    owner_address?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregate stddev on columns */
type CurrentCoinBalancesStddevFields = {
    amount?: Maybe<Scalars["Float"]["output"]>;
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_pop on columns */
type CurrentCoinBalancesStddevPopFields = {
    amount?: Maybe<Scalars["Float"]["output"]>;
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_samp on columns */
type CurrentCoinBalancesStddevSampFields = {
    amount?: Maybe<Scalars["Float"]["output"]>;
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** Streaming cursor of the table "current_coin_balances" */
type CurrentCoinBalancesStreamCursorInput = {
    /** Stream column input with initial value */
    initial_value: CurrentCoinBalancesStreamCursorValueInput;
    /** cursor ordering */
    ordering?: InputMaybe<CursorOrdering>;
};
/** Initial value of the column from where the streaming should start */
type CurrentCoinBalancesStreamCursorValueInput = {
    amount?: InputMaybe<Scalars["numeric"]["input"]>;
    coin_type?: InputMaybe<Scalars["String"]["input"]>;
    coin_type_hash?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    last_transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    owner_address?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregate sum on columns */
type CurrentCoinBalancesSumFields = {
    amount?: Maybe<Scalars["numeric"]["output"]>;
    last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};
/** update columns of table "current_coin_balances" */
declare enum CurrentCoinBalancesUpdateColumn {
    /** column name */
    Amount = "amount",
    /** column name */
    CoinType = "coin_type",
    /** column name */
    CoinTypeHash = "coin_type_hash",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    LastTransactionTimestamp = "last_transaction_timestamp",
    /** column name */
    LastTransactionVersion = "last_transaction_version",
    /** column name */
    OwnerAddress = "owner_address"
}
type CurrentCoinBalancesUpdates = {
    /** increments the numeric columns with given value of the filtered values */
    _inc?: InputMaybe<CurrentCoinBalancesIncInput>;
    /** sets the columns of the filtered rows to the given values */
    _set?: InputMaybe<CurrentCoinBalancesSetInput>;
    /** filter the rows which have to be updated */
    where: CurrentCoinBalancesBoolExp;
};
/** aggregate var_pop on columns */
type CurrentCoinBalancesVarPopFields = {
    amount?: Maybe<Scalars["Float"]["output"]>;
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate var_samp on columns */
type CurrentCoinBalancesVarSampFields = {
    amount?: Maybe<Scalars["Float"]["output"]>;
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate variance on columns */
type CurrentCoinBalancesVarianceFields = {
    amount?: Maybe<Scalars["Float"]["output"]>;
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** columns and relationships of "current_collection_datas" */
type CurrentCollectionDatas = {
    collection_data_id_hash: Scalars["String"]["output"];
    collection_name: Scalars["String"]["output"];
    creator_address: Scalars["String"]["output"];
    description: Scalars["String"]["output"];
    description_mutable: Scalars["Boolean"]["output"];
    inserted_at: Scalars["timestamp"]["output"];
    last_transaction_timestamp: Scalars["timestamp"]["output"];
    last_transaction_version: Scalars["bigint"]["output"];
    maximum: Scalars["numeric"]["output"];
    maximum_mutable: Scalars["Boolean"]["output"];
    metadata_uri: Scalars["String"]["output"];
    supply: Scalars["numeric"]["output"];
    table_handle: Scalars["String"]["output"];
    uri_mutable: Scalars["Boolean"]["output"];
};
/** aggregated selection of "current_collection_datas" */
type CurrentCollectionDatasAggregate = {
    aggregate?: Maybe<CurrentCollectionDatasAggregateFields>;
    nodes: Array<CurrentCollectionDatas>;
};
/** aggregate fields of "current_collection_datas" */
type CurrentCollectionDatasAggregateFields = {
    avg?: Maybe<CurrentCollectionDatasAvgFields>;
    count: Scalars["Int"]["output"];
    max?: Maybe<CurrentCollectionDatasMaxFields>;
    min?: Maybe<CurrentCollectionDatasMinFields>;
    stddev?: Maybe<CurrentCollectionDatasStddevFields>;
    stddev_pop?: Maybe<CurrentCollectionDatasStddevPopFields>;
    stddev_samp?: Maybe<CurrentCollectionDatasStddevSampFields>;
    sum?: Maybe<CurrentCollectionDatasSumFields>;
    var_pop?: Maybe<CurrentCollectionDatasVarPopFields>;
    var_samp?: Maybe<CurrentCollectionDatasVarSampFields>;
    variance?: Maybe<CurrentCollectionDatasVarianceFields>;
};
/** aggregate fields of "current_collection_datas" */
type CurrentCollectionDatasAggregateFieldsCountArgs = {
    columns?: InputMaybe<Array<CurrentCollectionDatasSelectColumn>>;
    distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};
/** aggregate avg on columns */
type CurrentCollectionDatasAvgFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
    maximum?: Maybe<Scalars["Float"]["output"]>;
    supply?: Maybe<Scalars["Float"]["output"]>;
};
/** Boolean expression to filter rows from the table "current_collection_datas". All fields are combined with a logical 'AND'. */
type CurrentCollectionDatasBoolExp = {
    _and?: InputMaybe<Array<CurrentCollectionDatasBoolExp>>;
    _not?: InputMaybe<CurrentCollectionDatasBoolExp>;
    _or?: InputMaybe<Array<CurrentCollectionDatasBoolExp>>;
    collection_data_id_hash?: InputMaybe<StringComparisonExp>;
    collection_name?: InputMaybe<StringComparisonExp>;
    creator_address?: InputMaybe<StringComparisonExp>;
    description?: InputMaybe<StringComparisonExp>;
    description_mutable?: InputMaybe<BooleanComparisonExp>;
    inserted_at?: InputMaybe<TimestampComparisonExp>;
    last_transaction_timestamp?: InputMaybe<TimestampComparisonExp>;
    last_transaction_version?: InputMaybe<BigintComparisonExp>;
    maximum?: InputMaybe<NumericComparisonExp>;
    maximum_mutable?: InputMaybe<BooleanComparisonExp>;
    metadata_uri?: InputMaybe<StringComparisonExp>;
    supply?: InputMaybe<NumericComparisonExp>;
    table_handle?: InputMaybe<StringComparisonExp>;
    uri_mutable?: InputMaybe<BooleanComparisonExp>;
};
/** unique or primary key constraints on table "current_collection_datas" */
declare enum CurrentCollectionDatasConstraint {
    /** unique or primary key constraint on columns "collection_data_id_hash" */
    CurrentCollectionDatasPkey = "current_collection_datas_pkey"
}
/** input type for incrementing numeric columns in table "current_collection_datas" */
type CurrentCollectionDatasIncInput = {
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    maximum?: InputMaybe<Scalars["numeric"]["input"]>;
    supply?: InputMaybe<Scalars["numeric"]["input"]>;
};
/** input type for inserting data into table "current_collection_datas" */
type CurrentCollectionDatasInsertInput = {
    collection_data_id_hash?: InputMaybe<Scalars["String"]["input"]>;
    collection_name?: InputMaybe<Scalars["String"]["input"]>;
    creator_address?: InputMaybe<Scalars["String"]["input"]>;
    description?: InputMaybe<Scalars["String"]["input"]>;
    description_mutable?: InputMaybe<Scalars["Boolean"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    last_transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    maximum?: InputMaybe<Scalars["numeric"]["input"]>;
    maximum_mutable?: InputMaybe<Scalars["Boolean"]["input"]>;
    metadata_uri?: InputMaybe<Scalars["String"]["input"]>;
    supply?: InputMaybe<Scalars["numeric"]["input"]>;
    table_handle?: InputMaybe<Scalars["String"]["input"]>;
    uri_mutable?: InputMaybe<Scalars["Boolean"]["input"]>;
};
/** aggregate max on columns */
type CurrentCollectionDatasMaxFields = {
    collection_data_id_hash?: Maybe<Scalars["String"]["output"]>;
    collection_name?: Maybe<Scalars["String"]["output"]>;
    creator_address?: Maybe<Scalars["String"]["output"]>;
    description?: Maybe<Scalars["String"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    last_transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
    last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    maximum?: Maybe<Scalars["numeric"]["output"]>;
    metadata_uri?: Maybe<Scalars["String"]["output"]>;
    supply?: Maybe<Scalars["numeric"]["output"]>;
    table_handle?: Maybe<Scalars["String"]["output"]>;
};
/** aggregate min on columns */
type CurrentCollectionDatasMinFields = {
    collection_data_id_hash?: Maybe<Scalars["String"]["output"]>;
    collection_name?: Maybe<Scalars["String"]["output"]>;
    creator_address?: Maybe<Scalars["String"]["output"]>;
    description?: Maybe<Scalars["String"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    last_transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
    last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    maximum?: Maybe<Scalars["numeric"]["output"]>;
    metadata_uri?: Maybe<Scalars["String"]["output"]>;
    supply?: Maybe<Scalars["numeric"]["output"]>;
    table_handle?: Maybe<Scalars["String"]["output"]>;
};
/** response of any mutation on the table "current_collection_datas" */
type CurrentCollectionDatasMutationResponse = {
    /** number of rows affected by the mutation */
    affected_rows: Scalars["Int"]["output"];
    /** data from the rows affected by the mutation */
    returning: Array<CurrentCollectionDatas>;
};
/** on_conflict condition type for table "current_collection_datas" */
type CurrentCollectionDatasOnConflict = {
    constraint: CurrentCollectionDatasConstraint;
    update_columns?: Array<CurrentCollectionDatasUpdateColumn>;
    where?: InputMaybe<CurrentCollectionDatasBoolExp>;
};
/** Ordering options when selecting data from "current_collection_datas". */
type CurrentCollectionDatasOrderBy = {
    collection_data_id_hash?: InputMaybe<OrderBy>;
    collection_name?: InputMaybe<OrderBy>;
    creator_address?: InputMaybe<OrderBy>;
    description?: InputMaybe<OrderBy>;
    description_mutable?: InputMaybe<OrderBy>;
    inserted_at?: InputMaybe<OrderBy>;
    last_transaction_timestamp?: InputMaybe<OrderBy>;
    last_transaction_version?: InputMaybe<OrderBy>;
    maximum?: InputMaybe<OrderBy>;
    maximum_mutable?: InputMaybe<OrderBy>;
    metadata_uri?: InputMaybe<OrderBy>;
    supply?: InputMaybe<OrderBy>;
    table_handle?: InputMaybe<OrderBy>;
    uri_mutable?: InputMaybe<OrderBy>;
};
/** primary key columns input for table: current_collection_datas */
type CurrentCollectionDatasPkColumnsInput = {
    collection_data_id_hash: Scalars["String"]["input"];
};
/** select columns of table "current_collection_datas" */
declare enum CurrentCollectionDatasSelectColumn {
    /** column name */
    CollectionDataIdHash = "collection_data_id_hash",
    /** column name */
    CollectionName = "collection_name",
    /** column name */
    CreatorAddress = "creator_address",
    /** column name */
    Description = "description",
    /** column name */
    DescriptionMutable = "description_mutable",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    LastTransactionTimestamp = "last_transaction_timestamp",
    /** column name */
    LastTransactionVersion = "last_transaction_version",
    /** column name */
    Maximum = "maximum",
    /** column name */
    MaximumMutable = "maximum_mutable",
    /** column name */
    MetadataUri = "metadata_uri",
    /** column name */
    Supply = "supply",
    /** column name */
    TableHandle = "table_handle",
    /** column name */
    UriMutable = "uri_mutable"
}
/** input type for updating data in table "current_collection_datas" */
type CurrentCollectionDatasSetInput = {
    collection_data_id_hash?: InputMaybe<Scalars["String"]["input"]>;
    collection_name?: InputMaybe<Scalars["String"]["input"]>;
    creator_address?: InputMaybe<Scalars["String"]["input"]>;
    description?: InputMaybe<Scalars["String"]["input"]>;
    description_mutable?: InputMaybe<Scalars["Boolean"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    last_transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    maximum?: InputMaybe<Scalars["numeric"]["input"]>;
    maximum_mutable?: InputMaybe<Scalars["Boolean"]["input"]>;
    metadata_uri?: InputMaybe<Scalars["String"]["input"]>;
    supply?: InputMaybe<Scalars["numeric"]["input"]>;
    table_handle?: InputMaybe<Scalars["String"]["input"]>;
    uri_mutable?: InputMaybe<Scalars["Boolean"]["input"]>;
};
/** aggregate stddev on columns */
type CurrentCollectionDatasStddevFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
    maximum?: Maybe<Scalars["Float"]["output"]>;
    supply?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_pop on columns */
type CurrentCollectionDatasStddevPopFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
    maximum?: Maybe<Scalars["Float"]["output"]>;
    supply?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_samp on columns */
type CurrentCollectionDatasStddevSampFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
    maximum?: Maybe<Scalars["Float"]["output"]>;
    supply?: Maybe<Scalars["Float"]["output"]>;
};
/** Streaming cursor of the table "current_collection_datas" */
type CurrentCollectionDatasStreamCursorInput = {
    /** Stream column input with initial value */
    initial_value: CurrentCollectionDatasStreamCursorValueInput;
    /** cursor ordering */
    ordering?: InputMaybe<CursorOrdering>;
};
/** Initial value of the column from where the streaming should start */
type CurrentCollectionDatasStreamCursorValueInput = {
    collection_data_id_hash?: InputMaybe<Scalars["String"]["input"]>;
    collection_name?: InputMaybe<Scalars["String"]["input"]>;
    creator_address?: InputMaybe<Scalars["String"]["input"]>;
    description?: InputMaybe<Scalars["String"]["input"]>;
    description_mutable?: InputMaybe<Scalars["Boolean"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    last_transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    maximum?: InputMaybe<Scalars["numeric"]["input"]>;
    maximum_mutable?: InputMaybe<Scalars["Boolean"]["input"]>;
    metadata_uri?: InputMaybe<Scalars["String"]["input"]>;
    supply?: InputMaybe<Scalars["numeric"]["input"]>;
    table_handle?: InputMaybe<Scalars["String"]["input"]>;
    uri_mutable?: InputMaybe<Scalars["Boolean"]["input"]>;
};
/** aggregate sum on columns */
type CurrentCollectionDatasSumFields = {
    last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    maximum?: Maybe<Scalars["numeric"]["output"]>;
    supply?: Maybe<Scalars["numeric"]["output"]>;
};
/** update columns of table "current_collection_datas" */
declare enum CurrentCollectionDatasUpdateColumn {
    /** column name */
    CollectionDataIdHash = "collection_data_id_hash",
    /** column name */
    CollectionName = "collection_name",
    /** column name */
    CreatorAddress = "creator_address",
    /** column name */
    Description = "description",
    /** column name */
    DescriptionMutable = "description_mutable",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    LastTransactionTimestamp = "last_transaction_timestamp",
    /** column name */
    LastTransactionVersion = "last_transaction_version",
    /** column name */
    Maximum = "maximum",
    /** column name */
    MaximumMutable = "maximum_mutable",
    /** column name */
    MetadataUri = "metadata_uri",
    /** column name */
    Supply = "supply",
    /** column name */
    TableHandle = "table_handle",
    /** column name */
    UriMutable = "uri_mutable"
}
type CurrentCollectionDatasUpdates = {
    /** increments the numeric columns with given value of the filtered values */
    _inc?: InputMaybe<CurrentCollectionDatasIncInput>;
    /** sets the columns of the filtered rows to the given values */
    _set?: InputMaybe<CurrentCollectionDatasSetInput>;
    /** filter the rows which have to be updated */
    where: CurrentCollectionDatasBoolExp;
};
/** aggregate var_pop on columns */
type CurrentCollectionDatasVarPopFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
    maximum?: Maybe<Scalars["Float"]["output"]>;
    supply?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate var_samp on columns */
type CurrentCollectionDatasVarSampFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
    maximum?: Maybe<Scalars["Float"]["output"]>;
    supply?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate variance on columns */
type CurrentCollectionDatasVarianceFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
    maximum?: Maybe<Scalars["Float"]["output"]>;
    supply?: Maybe<Scalars["Float"]["output"]>;
};
/** columns and relationships of "current_collection_ownership_v2_view" */
type CurrentCollectionOwnershipV2View = {
    collection_id?: Maybe<Scalars["String"]["output"]>;
    collection_name?: Maybe<Scalars["String"]["output"]>;
    collection_uri?: Maybe<Scalars["String"]["output"]>;
    creator_address?: Maybe<Scalars["String"]["output"]>;
    /** An object relationship */
    current_collection?: Maybe<CurrentCollectionsV2>;
    distinct_tokens?: Maybe<Scalars["bigint"]["output"]>;
    last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    owner_address?: Maybe<Scalars["String"]["output"]>;
    single_token_uri?: Maybe<Scalars["String"]["output"]>;
};
/** aggregated selection of "current_collection_ownership_v2_view" */
type CurrentCollectionOwnershipV2ViewAggregate = {
    aggregate?: Maybe<CurrentCollectionOwnershipV2ViewAggregateFields>;
    nodes: Array<CurrentCollectionOwnershipV2View>;
};
/** aggregate fields of "current_collection_ownership_v2_view" */
type CurrentCollectionOwnershipV2ViewAggregateFields = {
    avg?: Maybe<CurrentCollectionOwnershipV2ViewAvgFields>;
    count: Scalars["Int"]["output"];
    max?: Maybe<CurrentCollectionOwnershipV2ViewMaxFields>;
    min?: Maybe<CurrentCollectionOwnershipV2ViewMinFields>;
    stddev?: Maybe<CurrentCollectionOwnershipV2ViewStddevFields>;
    stddev_pop?: Maybe<CurrentCollectionOwnershipV2ViewStddevPopFields>;
    stddev_samp?: Maybe<CurrentCollectionOwnershipV2ViewStddevSampFields>;
    sum?: Maybe<CurrentCollectionOwnershipV2ViewSumFields>;
    var_pop?: Maybe<CurrentCollectionOwnershipV2ViewVarPopFields>;
    var_samp?: Maybe<CurrentCollectionOwnershipV2ViewVarSampFields>;
    variance?: Maybe<CurrentCollectionOwnershipV2ViewVarianceFields>;
};
/** aggregate fields of "current_collection_ownership_v2_view" */
type CurrentCollectionOwnershipV2ViewAggregateFieldsCountArgs = {
    columns?: InputMaybe<Array<CurrentCollectionOwnershipV2ViewSelectColumn>>;
    distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};
/** aggregate avg on columns */
type CurrentCollectionOwnershipV2ViewAvgFields = {
    distinct_tokens?: Maybe<Scalars["Float"]["output"]>;
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** Boolean expression to filter rows from the table "current_collection_ownership_v2_view". All fields are combined with a logical 'AND'. */
type CurrentCollectionOwnershipV2ViewBoolExp = {
    _and?: InputMaybe<Array<CurrentCollectionOwnershipV2ViewBoolExp>>;
    _not?: InputMaybe<CurrentCollectionOwnershipV2ViewBoolExp>;
    _or?: InputMaybe<Array<CurrentCollectionOwnershipV2ViewBoolExp>>;
    collection_id?: InputMaybe<StringComparisonExp>;
    collection_name?: InputMaybe<StringComparisonExp>;
    collection_uri?: InputMaybe<StringComparisonExp>;
    creator_address?: InputMaybe<StringComparisonExp>;
    current_collection?: InputMaybe<CurrentCollectionsV2BoolExp>;
    distinct_tokens?: InputMaybe<BigintComparisonExp>;
    last_transaction_version?: InputMaybe<BigintComparisonExp>;
    owner_address?: InputMaybe<StringComparisonExp>;
    single_token_uri?: InputMaybe<StringComparisonExp>;
};
/** aggregate max on columns */
type CurrentCollectionOwnershipV2ViewMaxFields = {
    collection_id?: Maybe<Scalars["String"]["output"]>;
    collection_name?: Maybe<Scalars["String"]["output"]>;
    collection_uri?: Maybe<Scalars["String"]["output"]>;
    creator_address?: Maybe<Scalars["String"]["output"]>;
    distinct_tokens?: Maybe<Scalars["bigint"]["output"]>;
    last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    owner_address?: Maybe<Scalars["String"]["output"]>;
    single_token_uri?: Maybe<Scalars["String"]["output"]>;
};
/** aggregate min on columns */
type CurrentCollectionOwnershipV2ViewMinFields = {
    collection_id?: Maybe<Scalars["String"]["output"]>;
    collection_name?: Maybe<Scalars["String"]["output"]>;
    collection_uri?: Maybe<Scalars["String"]["output"]>;
    creator_address?: Maybe<Scalars["String"]["output"]>;
    distinct_tokens?: Maybe<Scalars["bigint"]["output"]>;
    last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    owner_address?: Maybe<Scalars["String"]["output"]>;
    single_token_uri?: Maybe<Scalars["String"]["output"]>;
};
/** Ordering options when selecting data from "current_collection_ownership_v2_view". */
type CurrentCollectionOwnershipV2ViewOrderBy = {
    collection_id?: InputMaybe<OrderBy>;
    collection_name?: InputMaybe<OrderBy>;
    collection_uri?: InputMaybe<OrderBy>;
    creator_address?: InputMaybe<OrderBy>;
    current_collection?: InputMaybe<CurrentCollectionsV2OrderBy>;
    distinct_tokens?: InputMaybe<OrderBy>;
    last_transaction_version?: InputMaybe<OrderBy>;
    owner_address?: InputMaybe<OrderBy>;
    single_token_uri?: InputMaybe<OrderBy>;
};
/** select columns of table "current_collection_ownership_v2_view" */
declare enum CurrentCollectionOwnershipV2ViewSelectColumn {
    /** column name */
    CollectionId = "collection_id",
    /** column name */
    CollectionName = "collection_name",
    /** column name */
    CollectionUri = "collection_uri",
    /** column name */
    CreatorAddress = "creator_address",
    /** column name */
    DistinctTokens = "distinct_tokens",
    /** column name */
    LastTransactionVersion = "last_transaction_version",
    /** column name */
    OwnerAddress = "owner_address",
    /** column name */
    SingleTokenUri = "single_token_uri"
}
/** aggregate stddev on columns */
type CurrentCollectionOwnershipV2ViewStddevFields = {
    distinct_tokens?: Maybe<Scalars["Float"]["output"]>;
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_pop on columns */
type CurrentCollectionOwnershipV2ViewStddevPopFields = {
    distinct_tokens?: Maybe<Scalars["Float"]["output"]>;
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_samp on columns */
type CurrentCollectionOwnershipV2ViewStddevSampFields = {
    distinct_tokens?: Maybe<Scalars["Float"]["output"]>;
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** Streaming cursor of the table "current_collection_ownership_v2_view" */
type CurrentCollectionOwnershipV2ViewStreamCursorInput = {
    /** Stream column input with initial value */
    initial_value: CurrentCollectionOwnershipV2ViewStreamCursorValueInput;
    /** cursor ordering */
    ordering?: InputMaybe<CursorOrdering>;
};
/** Initial value of the column from where the streaming should start */
type CurrentCollectionOwnershipV2ViewStreamCursorValueInput = {
    collection_id?: InputMaybe<Scalars["String"]["input"]>;
    collection_name?: InputMaybe<Scalars["String"]["input"]>;
    collection_uri?: InputMaybe<Scalars["String"]["input"]>;
    creator_address?: InputMaybe<Scalars["String"]["input"]>;
    distinct_tokens?: InputMaybe<Scalars["bigint"]["input"]>;
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    owner_address?: InputMaybe<Scalars["String"]["input"]>;
    single_token_uri?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregate sum on columns */
type CurrentCollectionOwnershipV2ViewSumFields = {
    distinct_tokens?: Maybe<Scalars["bigint"]["output"]>;
    last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};
/** aggregate var_pop on columns */
type CurrentCollectionOwnershipV2ViewVarPopFields = {
    distinct_tokens?: Maybe<Scalars["Float"]["output"]>;
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate var_samp on columns */
type CurrentCollectionOwnershipV2ViewVarSampFields = {
    distinct_tokens?: Maybe<Scalars["Float"]["output"]>;
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate variance on columns */
type CurrentCollectionOwnershipV2ViewVarianceFields = {
    distinct_tokens?: Maybe<Scalars["Float"]["output"]>;
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** columns and relationships of "current_collection_ownership_view" */
type CurrentCollectionOwnershipView = {
    collection_data_id_hash?: Maybe<Scalars["String"]["output"]>;
    collection_name?: Maybe<Scalars["String"]["output"]>;
    creator_address?: Maybe<Scalars["String"]["output"]>;
    distinct_tokens?: Maybe<Scalars["bigint"]["output"]>;
    last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    owner_address?: Maybe<Scalars["String"]["output"]>;
};
/** aggregated selection of "current_collection_ownership_view" */
type CurrentCollectionOwnershipViewAggregate = {
    aggregate?: Maybe<CurrentCollectionOwnershipViewAggregateFields>;
    nodes: Array<CurrentCollectionOwnershipView>;
};
/** aggregate fields of "current_collection_ownership_view" */
type CurrentCollectionOwnershipViewAggregateFields = {
    avg?: Maybe<CurrentCollectionOwnershipViewAvgFields>;
    count: Scalars["Int"]["output"];
    max?: Maybe<CurrentCollectionOwnershipViewMaxFields>;
    min?: Maybe<CurrentCollectionOwnershipViewMinFields>;
    stddev?: Maybe<CurrentCollectionOwnershipViewStddevFields>;
    stddev_pop?: Maybe<CurrentCollectionOwnershipViewStddevPopFields>;
    stddev_samp?: Maybe<CurrentCollectionOwnershipViewStddevSampFields>;
    sum?: Maybe<CurrentCollectionOwnershipViewSumFields>;
    var_pop?: Maybe<CurrentCollectionOwnershipViewVarPopFields>;
    var_samp?: Maybe<CurrentCollectionOwnershipViewVarSampFields>;
    variance?: Maybe<CurrentCollectionOwnershipViewVarianceFields>;
};
/** aggregate fields of "current_collection_ownership_view" */
type CurrentCollectionOwnershipViewAggregateFieldsCountArgs = {
    columns?: InputMaybe<Array<CurrentCollectionOwnershipViewSelectColumn>>;
    distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};
/** aggregate avg on columns */
type CurrentCollectionOwnershipViewAvgFields = {
    distinct_tokens?: Maybe<Scalars["Float"]["output"]>;
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** Boolean expression to filter rows from the table "current_collection_ownership_view". All fields are combined with a logical 'AND'. */
type CurrentCollectionOwnershipViewBoolExp = {
    _and?: InputMaybe<Array<CurrentCollectionOwnershipViewBoolExp>>;
    _not?: InputMaybe<CurrentCollectionOwnershipViewBoolExp>;
    _or?: InputMaybe<Array<CurrentCollectionOwnershipViewBoolExp>>;
    collection_data_id_hash?: InputMaybe<StringComparisonExp>;
    collection_name?: InputMaybe<StringComparisonExp>;
    creator_address?: InputMaybe<StringComparisonExp>;
    distinct_tokens?: InputMaybe<BigintComparisonExp>;
    last_transaction_version?: InputMaybe<BigintComparisonExp>;
    owner_address?: InputMaybe<StringComparisonExp>;
};
/** aggregate max on columns */
type CurrentCollectionOwnershipViewMaxFields = {
    collection_data_id_hash?: Maybe<Scalars["String"]["output"]>;
    collection_name?: Maybe<Scalars["String"]["output"]>;
    creator_address?: Maybe<Scalars["String"]["output"]>;
    distinct_tokens?: Maybe<Scalars["bigint"]["output"]>;
    last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    owner_address?: Maybe<Scalars["String"]["output"]>;
};
/** aggregate min on columns */
type CurrentCollectionOwnershipViewMinFields = {
    collection_data_id_hash?: Maybe<Scalars["String"]["output"]>;
    collection_name?: Maybe<Scalars["String"]["output"]>;
    creator_address?: Maybe<Scalars["String"]["output"]>;
    distinct_tokens?: Maybe<Scalars["bigint"]["output"]>;
    last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    owner_address?: Maybe<Scalars["String"]["output"]>;
};
/** Ordering options when selecting data from "current_collection_ownership_view". */
type CurrentCollectionOwnershipViewOrderBy = {
    collection_data_id_hash?: InputMaybe<OrderBy>;
    collection_name?: InputMaybe<OrderBy>;
    creator_address?: InputMaybe<OrderBy>;
    distinct_tokens?: InputMaybe<OrderBy>;
    last_transaction_version?: InputMaybe<OrderBy>;
    owner_address?: InputMaybe<OrderBy>;
};
/** select columns of table "current_collection_ownership_view" */
declare enum CurrentCollectionOwnershipViewSelectColumn {
    /** column name */
    CollectionDataIdHash = "collection_data_id_hash",
    /** column name */
    CollectionName = "collection_name",
    /** column name */
    CreatorAddress = "creator_address",
    /** column name */
    DistinctTokens = "distinct_tokens",
    /** column name */
    LastTransactionVersion = "last_transaction_version",
    /** column name */
    OwnerAddress = "owner_address"
}
/** aggregate stddev on columns */
type CurrentCollectionOwnershipViewStddevFields = {
    distinct_tokens?: Maybe<Scalars["Float"]["output"]>;
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_pop on columns */
type CurrentCollectionOwnershipViewStddevPopFields = {
    distinct_tokens?: Maybe<Scalars["Float"]["output"]>;
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_samp on columns */
type CurrentCollectionOwnershipViewStddevSampFields = {
    distinct_tokens?: Maybe<Scalars["Float"]["output"]>;
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** Streaming cursor of the table "current_collection_ownership_view" */
type CurrentCollectionOwnershipViewStreamCursorInput = {
    /** Stream column input with initial value */
    initial_value: CurrentCollectionOwnershipViewStreamCursorValueInput;
    /** cursor ordering */
    ordering?: InputMaybe<CursorOrdering>;
};
/** Initial value of the column from where the streaming should start */
type CurrentCollectionOwnershipViewStreamCursorValueInput = {
    collection_data_id_hash?: InputMaybe<Scalars["String"]["input"]>;
    collection_name?: InputMaybe<Scalars["String"]["input"]>;
    creator_address?: InputMaybe<Scalars["String"]["input"]>;
    distinct_tokens?: InputMaybe<Scalars["bigint"]["input"]>;
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    owner_address?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregate sum on columns */
type CurrentCollectionOwnershipViewSumFields = {
    distinct_tokens?: Maybe<Scalars["bigint"]["output"]>;
    last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};
/** aggregate var_pop on columns */
type CurrentCollectionOwnershipViewVarPopFields = {
    distinct_tokens?: Maybe<Scalars["Float"]["output"]>;
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate var_samp on columns */
type CurrentCollectionOwnershipViewVarSampFields = {
    distinct_tokens?: Maybe<Scalars["Float"]["output"]>;
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate variance on columns */
type CurrentCollectionOwnershipViewVarianceFields = {
    distinct_tokens?: Maybe<Scalars["Float"]["output"]>;
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** columns and relationships of "current_collections_v2" */
type CurrentCollectionsV2 = {
    /** An object relationship */
    cdn_asset_uris?: Maybe<NftMetadataCrawlerParsedAssetUris>;
    collection_id: Scalars["String"]["output"];
    collection_name: Scalars["String"]["output"];
    collection_properties?: Maybe<Scalars["jsonb"]["output"]>;
    creator_address: Scalars["String"]["output"];
    current_supply: Scalars["numeric"]["output"];
    description: Scalars["String"]["output"];
    inserted_at: Scalars["timestamp"]["output"];
    last_transaction_timestamp: Scalars["timestamp"]["output"];
    last_transaction_version: Scalars["bigint"]["output"];
    max_supply?: Maybe<Scalars["numeric"]["output"]>;
    mutable_description?: Maybe<Scalars["Boolean"]["output"]>;
    mutable_uri?: Maybe<Scalars["Boolean"]["output"]>;
    table_handle_v1?: Maybe<Scalars["String"]["output"]>;
    token_standard: Scalars["String"]["output"];
    total_minted_v2?: Maybe<Scalars["numeric"]["output"]>;
    uri: Scalars["String"]["output"];
};
/** columns and relationships of "current_collections_v2" */
type CurrentCollectionsV2CollectionPropertiesArgs = {
    path?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregated selection of "current_collections_v2" */
type CurrentCollectionsV2Aggregate = {
    aggregate?: Maybe<CurrentCollectionsV2AggregateFields>;
    nodes: Array<CurrentCollectionsV2>;
};
/** aggregate fields of "current_collections_v2" */
type CurrentCollectionsV2AggregateFields = {
    avg?: Maybe<CurrentCollectionsV2AvgFields>;
    count: Scalars["Int"]["output"];
    max?: Maybe<CurrentCollectionsV2MaxFields>;
    min?: Maybe<CurrentCollectionsV2MinFields>;
    stddev?: Maybe<CurrentCollectionsV2StddevFields>;
    stddev_pop?: Maybe<CurrentCollectionsV2StddevPopFields>;
    stddev_samp?: Maybe<CurrentCollectionsV2StddevSampFields>;
    sum?: Maybe<CurrentCollectionsV2SumFields>;
    var_pop?: Maybe<CurrentCollectionsV2VarPopFields>;
    var_samp?: Maybe<CurrentCollectionsV2VarSampFields>;
    variance?: Maybe<CurrentCollectionsV2VarianceFields>;
};
/** aggregate fields of "current_collections_v2" */
type CurrentCollectionsV2AggregateFieldsCountArgs = {
    columns?: InputMaybe<Array<CurrentCollectionsV2SelectColumn>>;
    distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};
/** append existing jsonb value of filtered columns with new jsonb value */
type CurrentCollectionsV2AppendInput = {
    collection_properties?: InputMaybe<Scalars["jsonb"]["input"]>;
};
/** aggregate avg on columns */
type CurrentCollectionsV2AvgFields = {
    current_supply?: Maybe<Scalars["Float"]["output"]>;
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
    max_supply?: Maybe<Scalars["Float"]["output"]>;
    total_minted_v2?: Maybe<Scalars["Float"]["output"]>;
};
/** Boolean expression to filter rows from the table "current_collections_v2". All fields are combined with a logical 'AND'. */
type CurrentCollectionsV2BoolExp = {
    _and?: InputMaybe<Array<CurrentCollectionsV2BoolExp>>;
    _not?: InputMaybe<CurrentCollectionsV2BoolExp>;
    _or?: InputMaybe<Array<CurrentCollectionsV2BoolExp>>;
    cdn_asset_uris?: InputMaybe<NftMetadataCrawlerParsedAssetUrisBoolExp>;
    collection_id?: InputMaybe<StringComparisonExp>;
    collection_name?: InputMaybe<StringComparisonExp>;
    collection_properties?: InputMaybe<JsonbComparisonExp>;
    creator_address?: InputMaybe<StringComparisonExp>;
    current_supply?: InputMaybe<NumericComparisonExp>;
    description?: InputMaybe<StringComparisonExp>;
    inserted_at?: InputMaybe<TimestampComparisonExp>;
    last_transaction_timestamp?: InputMaybe<TimestampComparisonExp>;
    last_transaction_version?: InputMaybe<BigintComparisonExp>;
    max_supply?: InputMaybe<NumericComparisonExp>;
    mutable_description?: InputMaybe<BooleanComparisonExp>;
    mutable_uri?: InputMaybe<BooleanComparisonExp>;
    table_handle_v1?: InputMaybe<StringComparisonExp>;
    token_standard?: InputMaybe<StringComparisonExp>;
    total_minted_v2?: InputMaybe<NumericComparisonExp>;
    uri?: InputMaybe<StringComparisonExp>;
};
/** unique or primary key constraints on table "current_collections_v2" */
declare enum CurrentCollectionsV2Constraint {
    /** unique or primary key constraint on columns "collection_id" */
    CurrentCollectionsV2Pkey = "current_collections_v2_pkey"
}
/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
type CurrentCollectionsV2DeleteAtPathInput = {
    collection_properties?: InputMaybe<Array<Scalars["String"]["input"]>>;
};
/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
type CurrentCollectionsV2DeleteElemInput = {
    collection_properties?: InputMaybe<Scalars["Int"]["input"]>;
};
/** delete key/value pair or string element. key/value pairs are matched based on their key value */
type CurrentCollectionsV2DeleteKeyInput = {
    collection_properties?: InputMaybe<Scalars["String"]["input"]>;
};
/** input type for incrementing numeric columns in table "current_collections_v2" */
type CurrentCollectionsV2IncInput = {
    current_supply?: InputMaybe<Scalars["numeric"]["input"]>;
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    max_supply?: InputMaybe<Scalars["numeric"]["input"]>;
    total_minted_v2?: InputMaybe<Scalars["numeric"]["input"]>;
};
/** input type for inserting data into table "current_collections_v2" */
type CurrentCollectionsV2InsertInput = {
    cdn_asset_uris?: InputMaybe<NftMetadataCrawlerParsedAssetUrisObjRelInsertInput>;
    collection_id?: InputMaybe<Scalars["String"]["input"]>;
    collection_name?: InputMaybe<Scalars["String"]["input"]>;
    collection_properties?: InputMaybe<Scalars["jsonb"]["input"]>;
    creator_address?: InputMaybe<Scalars["String"]["input"]>;
    current_supply?: InputMaybe<Scalars["numeric"]["input"]>;
    description?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    last_transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    max_supply?: InputMaybe<Scalars["numeric"]["input"]>;
    mutable_description?: InputMaybe<Scalars["Boolean"]["input"]>;
    mutable_uri?: InputMaybe<Scalars["Boolean"]["input"]>;
    table_handle_v1?: InputMaybe<Scalars["String"]["input"]>;
    token_standard?: InputMaybe<Scalars["String"]["input"]>;
    total_minted_v2?: InputMaybe<Scalars["numeric"]["input"]>;
    uri?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregate max on columns */
type CurrentCollectionsV2MaxFields = {
    collection_id?: Maybe<Scalars["String"]["output"]>;
    collection_name?: Maybe<Scalars["String"]["output"]>;
    creator_address?: Maybe<Scalars["String"]["output"]>;
    current_supply?: Maybe<Scalars["numeric"]["output"]>;
    description?: Maybe<Scalars["String"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    last_transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
    last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    max_supply?: Maybe<Scalars["numeric"]["output"]>;
    table_handle_v1?: Maybe<Scalars["String"]["output"]>;
    token_standard?: Maybe<Scalars["String"]["output"]>;
    total_minted_v2?: Maybe<Scalars["numeric"]["output"]>;
    uri?: Maybe<Scalars["String"]["output"]>;
};
/** aggregate min on columns */
type CurrentCollectionsV2MinFields = {
    collection_id?: Maybe<Scalars["String"]["output"]>;
    collection_name?: Maybe<Scalars["String"]["output"]>;
    creator_address?: Maybe<Scalars["String"]["output"]>;
    current_supply?: Maybe<Scalars["numeric"]["output"]>;
    description?: Maybe<Scalars["String"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    last_transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
    last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    max_supply?: Maybe<Scalars["numeric"]["output"]>;
    table_handle_v1?: Maybe<Scalars["String"]["output"]>;
    token_standard?: Maybe<Scalars["String"]["output"]>;
    total_minted_v2?: Maybe<Scalars["numeric"]["output"]>;
    uri?: Maybe<Scalars["String"]["output"]>;
};
/** response of any mutation on the table "current_collections_v2" */
type CurrentCollectionsV2MutationResponse = {
    /** number of rows affected by the mutation */
    affected_rows: Scalars["Int"]["output"];
    /** data from the rows affected by the mutation */
    returning: Array<CurrentCollectionsV2>;
};
/** input type for inserting object relation for remote table "current_collections_v2" */
type CurrentCollectionsV2ObjRelInsertInput = {
    data: CurrentCollectionsV2InsertInput;
    /** upsert condition */
    on_conflict?: InputMaybe<CurrentCollectionsV2OnConflict>;
};
/** on_conflict condition type for table "current_collections_v2" */
type CurrentCollectionsV2OnConflict = {
    constraint: CurrentCollectionsV2Constraint;
    update_columns?: Array<CurrentCollectionsV2UpdateColumn>;
    where?: InputMaybe<CurrentCollectionsV2BoolExp>;
};
/** Ordering options when selecting data from "current_collections_v2". */
type CurrentCollectionsV2OrderBy = {
    cdn_asset_uris?: InputMaybe<NftMetadataCrawlerParsedAssetUrisOrderBy>;
    collection_id?: InputMaybe<OrderBy>;
    collection_name?: InputMaybe<OrderBy>;
    collection_properties?: InputMaybe<OrderBy>;
    creator_address?: InputMaybe<OrderBy>;
    current_supply?: InputMaybe<OrderBy>;
    description?: InputMaybe<OrderBy>;
    inserted_at?: InputMaybe<OrderBy>;
    last_transaction_timestamp?: InputMaybe<OrderBy>;
    last_transaction_version?: InputMaybe<OrderBy>;
    max_supply?: InputMaybe<OrderBy>;
    mutable_description?: InputMaybe<OrderBy>;
    mutable_uri?: InputMaybe<OrderBy>;
    table_handle_v1?: InputMaybe<OrderBy>;
    token_standard?: InputMaybe<OrderBy>;
    total_minted_v2?: InputMaybe<OrderBy>;
    uri?: InputMaybe<OrderBy>;
};
/** primary key columns input for table: current_collections_v2 */
type CurrentCollectionsV2PkColumnsInput = {
    collection_id: Scalars["String"]["input"];
};
/** prepend existing jsonb value of filtered columns with new jsonb value */
type CurrentCollectionsV2PrependInput = {
    collection_properties?: InputMaybe<Scalars["jsonb"]["input"]>;
};
/** select columns of table "current_collections_v2" */
declare enum CurrentCollectionsV2SelectColumn {
    /** column name */
    CollectionId = "collection_id",
    /** column name */
    CollectionName = "collection_name",
    /** column name */
    CollectionProperties = "collection_properties",
    /** column name */
    CreatorAddress = "creator_address",
    /** column name */
    CurrentSupply = "current_supply",
    /** column name */
    Description = "description",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    LastTransactionTimestamp = "last_transaction_timestamp",
    /** column name */
    LastTransactionVersion = "last_transaction_version",
    /** column name */
    MaxSupply = "max_supply",
    /** column name */
    MutableDescription = "mutable_description",
    /** column name */
    MutableUri = "mutable_uri",
    /** column name */
    TableHandleV1 = "table_handle_v1",
    /** column name */
    TokenStandard = "token_standard",
    /** column name */
    TotalMintedV2 = "total_minted_v2",
    /** column name */
    Uri = "uri"
}
/** input type for updating data in table "current_collections_v2" */
type CurrentCollectionsV2SetInput = {
    collection_id?: InputMaybe<Scalars["String"]["input"]>;
    collection_name?: InputMaybe<Scalars["String"]["input"]>;
    collection_properties?: InputMaybe<Scalars["jsonb"]["input"]>;
    creator_address?: InputMaybe<Scalars["String"]["input"]>;
    current_supply?: InputMaybe<Scalars["numeric"]["input"]>;
    description?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    last_transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    max_supply?: InputMaybe<Scalars["numeric"]["input"]>;
    mutable_description?: InputMaybe<Scalars["Boolean"]["input"]>;
    mutable_uri?: InputMaybe<Scalars["Boolean"]["input"]>;
    table_handle_v1?: InputMaybe<Scalars["String"]["input"]>;
    token_standard?: InputMaybe<Scalars["String"]["input"]>;
    total_minted_v2?: InputMaybe<Scalars["numeric"]["input"]>;
    uri?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregate stddev on columns */
type CurrentCollectionsV2StddevFields = {
    current_supply?: Maybe<Scalars["Float"]["output"]>;
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
    max_supply?: Maybe<Scalars["Float"]["output"]>;
    total_minted_v2?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_pop on columns */
type CurrentCollectionsV2StddevPopFields = {
    current_supply?: Maybe<Scalars["Float"]["output"]>;
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
    max_supply?: Maybe<Scalars["Float"]["output"]>;
    total_minted_v2?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_samp on columns */
type CurrentCollectionsV2StddevSampFields = {
    current_supply?: Maybe<Scalars["Float"]["output"]>;
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
    max_supply?: Maybe<Scalars["Float"]["output"]>;
    total_minted_v2?: Maybe<Scalars["Float"]["output"]>;
};
/** Streaming cursor of the table "current_collections_v2" */
type CurrentCollectionsV2StreamCursorInput = {
    /** Stream column input with initial value */
    initial_value: CurrentCollectionsV2StreamCursorValueInput;
    /** cursor ordering */
    ordering?: InputMaybe<CursorOrdering>;
};
/** Initial value of the column from where the streaming should start */
type CurrentCollectionsV2StreamCursorValueInput = {
    collection_id?: InputMaybe<Scalars["String"]["input"]>;
    collection_name?: InputMaybe<Scalars["String"]["input"]>;
    collection_properties?: InputMaybe<Scalars["jsonb"]["input"]>;
    creator_address?: InputMaybe<Scalars["String"]["input"]>;
    current_supply?: InputMaybe<Scalars["numeric"]["input"]>;
    description?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    last_transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    max_supply?: InputMaybe<Scalars["numeric"]["input"]>;
    mutable_description?: InputMaybe<Scalars["Boolean"]["input"]>;
    mutable_uri?: InputMaybe<Scalars["Boolean"]["input"]>;
    table_handle_v1?: InputMaybe<Scalars["String"]["input"]>;
    token_standard?: InputMaybe<Scalars["String"]["input"]>;
    total_minted_v2?: InputMaybe<Scalars["numeric"]["input"]>;
    uri?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregate sum on columns */
type CurrentCollectionsV2SumFields = {
    current_supply?: Maybe<Scalars["numeric"]["output"]>;
    last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    max_supply?: Maybe<Scalars["numeric"]["output"]>;
    total_minted_v2?: Maybe<Scalars["numeric"]["output"]>;
};
/** update columns of table "current_collections_v2" */
declare enum CurrentCollectionsV2UpdateColumn {
    /** column name */
    CollectionId = "collection_id",
    /** column name */
    CollectionName = "collection_name",
    /** column name */
    CollectionProperties = "collection_properties",
    /** column name */
    CreatorAddress = "creator_address",
    /** column name */
    CurrentSupply = "current_supply",
    /** column name */
    Description = "description",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    LastTransactionTimestamp = "last_transaction_timestamp",
    /** column name */
    LastTransactionVersion = "last_transaction_version",
    /** column name */
    MaxSupply = "max_supply",
    /** column name */
    MutableDescription = "mutable_description",
    /** column name */
    MutableUri = "mutable_uri",
    /** column name */
    TableHandleV1 = "table_handle_v1",
    /** column name */
    TokenStandard = "token_standard",
    /** column name */
    TotalMintedV2 = "total_minted_v2",
    /** column name */
    Uri = "uri"
}
type CurrentCollectionsV2Updates = {
    /** append existing jsonb value of filtered columns with new jsonb value */
    _append?: InputMaybe<CurrentCollectionsV2AppendInput>;
    /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
    _delete_at_path?: InputMaybe<CurrentCollectionsV2DeleteAtPathInput>;
    /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
    _delete_elem?: InputMaybe<CurrentCollectionsV2DeleteElemInput>;
    /** delete key/value pair or string element. key/value pairs are matched based on their key value */
    _delete_key?: InputMaybe<CurrentCollectionsV2DeleteKeyInput>;
    /** increments the numeric columns with given value of the filtered values */
    _inc?: InputMaybe<CurrentCollectionsV2IncInput>;
    /** prepend existing jsonb value of filtered columns with new jsonb value */
    _prepend?: InputMaybe<CurrentCollectionsV2PrependInput>;
    /** sets the columns of the filtered rows to the given values */
    _set?: InputMaybe<CurrentCollectionsV2SetInput>;
    /** filter the rows which have to be updated */
    where: CurrentCollectionsV2BoolExp;
};
/** aggregate var_pop on columns */
type CurrentCollectionsV2VarPopFields = {
    current_supply?: Maybe<Scalars["Float"]["output"]>;
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
    max_supply?: Maybe<Scalars["Float"]["output"]>;
    total_minted_v2?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate var_samp on columns */
type CurrentCollectionsV2VarSampFields = {
    current_supply?: Maybe<Scalars["Float"]["output"]>;
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
    max_supply?: Maybe<Scalars["Float"]["output"]>;
    total_minted_v2?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate variance on columns */
type CurrentCollectionsV2VarianceFields = {
    current_supply?: Maybe<Scalars["Float"]["output"]>;
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
    max_supply?: Maybe<Scalars["Float"]["output"]>;
    total_minted_v2?: Maybe<Scalars["Float"]["output"]>;
};
/** columns and relationships of "current_delegated_staking_pool_balances" */
type CurrentDelegatedStakingPoolBalances = {
    active_table_handle: Scalars["String"]["output"];
    inactive_table_handle: Scalars["String"]["output"];
    inserted_at: Scalars["timestamp"]["output"];
    last_transaction_version: Scalars["bigint"]["output"];
    operator_commission_percentage: Scalars["numeric"]["output"];
    staking_pool_address: Scalars["String"]["output"];
    total_coins: Scalars["numeric"]["output"];
    total_shares: Scalars["numeric"]["output"];
};
/** aggregated selection of "current_delegated_staking_pool_balances" */
type CurrentDelegatedStakingPoolBalancesAggregate = {
    aggregate?: Maybe<CurrentDelegatedStakingPoolBalancesAggregateFields>;
    nodes: Array<CurrentDelegatedStakingPoolBalances>;
};
/** aggregate fields of "current_delegated_staking_pool_balances" */
type CurrentDelegatedStakingPoolBalancesAggregateFields = {
    avg?: Maybe<CurrentDelegatedStakingPoolBalancesAvgFields>;
    count: Scalars["Int"]["output"];
    max?: Maybe<CurrentDelegatedStakingPoolBalancesMaxFields>;
    min?: Maybe<CurrentDelegatedStakingPoolBalancesMinFields>;
    stddev?: Maybe<CurrentDelegatedStakingPoolBalancesStddevFields>;
    stddev_pop?: Maybe<CurrentDelegatedStakingPoolBalancesStddevPopFields>;
    stddev_samp?: Maybe<CurrentDelegatedStakingPoolBalancesStddevSampFields>;
    sum?: Maybe<CurrentDelegatedStakingPoolBalancesSumFields>;
    var_pop?: Maybe<CurrentDelegatedStakingPoolBalancesVarPopFields>;
    var_samp?: Maybe<CurrentDelegatedStakingPoolBalancesVarSampFields>;
    variance?: Maybe<CurrentDelegatedStakingPoolBalancesVarianceFields>;
};
/** aggregate fields of "current_delegated_staking_pool_balances" */
type CurrentDelegatedStakingPoolBalancesAggregateFieldsCountArgs = {
    columns?: InputMaybe<Array<CurrentDelegatedStakingPoolBalancesSelectColumn>>;
    distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};
/** aggregate avg on columns */
type CurrentDelegatedStakingPoolBalancesAvgFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
    operator_commission_percentage?: Maybe<Scalars["Float"]["output"]>;
    total_coins?: Maybe<Scalars["Float"]["output"]>;
    total_shares?: Maybe<Scalars["Float"]["output"]>;
};
/** Boolean expression to filter rows from the table "current_delegated_staking_pool_balances". All fields are combined with a logical 'AND'. */
type CurrentDelegatedStakingPoolBalancesBoolExp = {
    _and?: InputMaybe<Array<CurrentDelegatedStakingPoolBalancesBoolExp>>;
    _not?: InputMaybe<CurrentDelegatedStakingPoolBalancesBoolExp>;
    _or?: InputMaybe<Array<CurrentDelegatedStakingPoolBalancesBoolExp>>;
    active_table_handle?: InputMaybe<StringComparisonExp>;
    inactive_table_handle?: InputMaybe<StringComparisonExp>;
    inserted_at?: InputMaybe<TimestampComparisonExp>;
    last_transaction_version?: InputMaybe<BigintComparisonExp>;
    operator_commission_percentage?: InputMaybe<NumericComparisonExp>;
    staking_pool_address?: InputMaybe<StringComparisonExp>;
    total_coins?: InputMaybe<NumericComparisonExp>;
    total_shares?: InputMaybe<NumericComparisonExp>;
};
/** unique or primary key constraints on table "current_delegated_staking_pool_balances" */
declare enum CurrentDelegatedStakingPoolBalancesConstraint {
    /** unique or primary key constraint on columns "staking_pool_address" */
    CurrentDelegatedStakingPoolBalancesPkey = "current_delegated_staking_pool_balances_pkey"
}
/** input type for incrementing numeric columns in table "current_delegated_staking_pool_balances" */
type CurrentDelegatedStakingPoolBalancesIncInput = {
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    operator_commission_percentage?: InputMaybe<Scalars["numeric"]["input"]>;
    total_coins?: InputMaybe<Scalars["numeric"]["input"]>;
    total_shares?: InputMaybe<Scalars["numeric"]["input"]>;
};
/** input type for inserting data into table "current_delegated_staking_pool_balances" */
type CurrentDelegatedStakingPoolBalancesInsertInput = {
    active_table_handle?: InputMaybe<Scalars["String"]["input"]>;
    inactive_table_handle?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    operator_commission_percentage?: InputMaybe<Scalars["numeric"]["input"]>;
    staking_pool_address?: InputMaybe<Scalars["String"]["input"]>;
    total_coins?: InputMaybe<Scalars["numeric"]["input"]>;
    total_shares?: InputMaybe<Scalars["numeric"]["input"]>;
};
/** aggregate max on columns */
type CurrentDelegatedStakingPoolBalancesMaxFields = {
    active_table_handle?: Maybe<Scalars["String"]["output"]>;
    inactive_table_handle?: Maybe<Scalars["String"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    operator_commission_percentage?: Maybe<Scalars["numeric"]["output"]>;
    staking_pool_address?: Maybe<Scalars["String"]["output"]>;
    total_coins?: Maybe<Scalars["numeric"]["output"]>;
    total_shares?: Maybe<Scalars["numeric"]["output"]>;
};
/** aggregate min on columns */
type CurrentDelegatedStakingPoolBalancesMinFields = {
    active_table_handle?: Maybe<Scalars["String"]["output"]>;
    inactive_table_handle?: Maybe<Scalars["String"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    operator_commission_percentage?: Maybe<Scalars["numeric"]["output"]>;
    staking_pool_address?: Maybe<Scalars["String"]["output"]>;
    total_coins?: Maybe<Scalars["numeric"]["output"]>;
    total_shares?: Maybe<Scalars["numeric"]["output"]>;
};
/** response of any mutation on the table "current_delegated_staking_pool_balances" */
type CurrentDelegatedStakingPoolBalancesMutationResponse = {
    /** number of rows affected by the mutation */
    affected_rows: Scalars["Int"]["output"];
    /** data from the rows affected by the mutation */
    returning: Array<CurrentDelegatedStakingPoolBalances>;
};
/** input type for inserting object relation for remote table "current_delegated_staking_pool_balances" */
type CurrentDelegatedStakingPoolBalancesObjRelInsertInput = {
    data: CurrentDelegatedStakingPoolBalancesInsertInput;
    /** upsert condition */
    on_conflict?: InputMaybe<CurrentDelegatedStakingPoolBalancesOnConflict>;
};
/** on_conflict condition type for table "current_delegated_staking_pool_balances" */
type CurrentDelegatedStakingPoolBalancesOnConflict = {
    constraint: CurrentDelegatedStakingPoolBalancesConstraint;
    update_columns?: Array<CurrentDelegatedStakingPoolBalancesUpdateColumn>;
    where?: InputMaybe<CurrentDelegatedStakingPoolBalancesBoolExp>;
};
/** Ordering options when selecting data from "current_delegated_staking_pool_balances". */
type CurrentDelegatedStakingPoolBalancesOrderBy = {
    active_table_handle?: InputMaybe<OrderBy>;
    inactive_table_handle?: InputMaybe<OrderBy>;
    inserted_at?: InputMaybe<OrderBy>;
    last_transaction_version?: InputMaybe<OrderBy>;
    operator_commission_percentage?: InputMaybe<OrderBy>;
    staking_pool_address?: InputMaybe<OrderBy>;
    total_coins?: InputMaybe<OrderBy>;
    total_shares?: InputMaybe<OrderBy>;
};
/** primary key columns input for table: current_delegated_staking_pool_balances */
type CurrentDelegatedStakingPoolBalancesPkColumnsInput = {
    staking_pool_address: Scalars["String"]["input"];
};
/** select columns of table "current_delegated_staking_pool_balances" */
declare enum CurrentDelegatedStakingPoolBalancesSelectColumn {
    /** column name */
    ActiveTableHandle = "active_table_handle",
    /** column name */
    InactiveTableHandle = "inactive_table_handle",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    LastTransactionVersion = "last_transaction_version",
    /** column name */
    OperatorCommissionPercentage = "operator_commission_percentage",
    /** column name */
    StakingPoolAddress = "staking_pool_address",
    /** column name */
    TotalCoins = "total_coins",
    /** column name */
    TotalShares = "total_shares"
}
/** input type for updating data in table "current_delegated_staking_pool_balances" */
type CurrentDelegatedStakingPoolBalancesSetInput = {
    active_table_handle?: InputMaybe<Scalars["String"]["input"]>;
    inactive_table_handle?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    operator_commission_percentage?: InputMaybe<Scalars["numeric"]["input"]>;
    staking_pool_address?: InputMaybe<Scalars["String"]["input"]>;
    total_coins?: InputMaybe<Scalars["numeric"]["input"]>;
    total_shares?: InputMaybe<Scalars["numeric"]["input"]>;
};
/** aggregate stddev on columns */
type CurrentDelegatedStakingPoolBalancesStddevFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
    operator_commission_percentage?: Maybe<Scalars["Float"]["output"]>;
    total_coins?: Maybe<Scalars["Float"]["output"]>;
    total_shares?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_pop on columns */
type CurrentDelegatedStakingPoolBalancesStddevPopFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
    operator_commission_percentage?: Maybe<Scalars["Float"]["output"]>;
    total_coins?: Maybe<Scalars["Float"]["output"]>;
    total_shares?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_samp on columns */
type CurrentDelegatedStakingPoolBalancesStddevSampFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
    operator_commission_percentage?: Maybe<Scalars["Float"]["output"]>;
    total_coins?: Maybe<Scalars["Float"]["output"]>;
    total_shares?: Maybe<Scalars["Float"]["output"]>;
};
/** Streaming cursor of the table "current_delegated_staking_pool_balances" */
type CurrentDelegatedStakingPoolBalancesStreamCursorInput = {
    /** Stream column input with initial value */
    initial_value: CurrentDelegatedStakingPoolBalancesStreamCursorValueInput;
    /** cursor ordering */
    ordering?: InputMaybe<CursorOrdering>;
};
/** Initial value of the column from where the streaming should start */
type CurrentDelegatedStakingPoolBalancesStreamCursorValueInput = {
    active_table_handle?: InputMaybe<Scalars["String"]["input"]>;
    inactive_table_handle?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    operator_commission_percentage?: InputMaybe<Scalars["numeric"]["input"]>;
    staking_pool_address?: InputMaybe<Scalars["String"]["input"]>;
    total_coins?: InputMaybe<Scalars["numeric"]["input"]>;
    total_shares?: InputMaybe<Scalars["numeric"]["input"]>;
};
/** aggregate sum on columns */
type CurrentDelegatedStakingPoolBalancesSumFields = {
    last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    operator_commission_percentage?: Maybe<Scalars["numeric"]["output"]>;
    total_coins?: Maybe<Scalars["numeric"]["output"]>;
    total_shares?: Maybe<Scalars["numeric"]["output"]>;
};
/** update columns of table "current_delegated_staking_pool_balances" */
declare enum CurrentDelegatedStakingPoolBalancesUpdateColumn {
    /** column name */
    ActiveTableHandle = "active_table_handle",
    /** column name */
    InactiveTableHandle = "inactive_table_handle",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    LastTransactionVersion = "last_transaction_version",
    /** column name */
    OperatorCommissionPercentage = "operator_commission_percentage",
    /** column name */
    StakingPoolAddress = "staking_pool_address",
    /** column name */
    TotalCoins = "total_coins",
    /** column name */
    TotalShares = "total_shares"
}
type CurrentDelegatedStakingPoolBalancesUpdates = {
    /** increments the numeric columns with given value of the filtered values */
    _inc?: InputMaybe<CurrentDelegatedStakingPoolBalancesIncInput>;
    /** sets the columns of the filtered rows to the given values */
    _set?: InputMaybe<CurrentDelegatedStakingPoolBalancesSetInput>;
    /** filter the rows which have to be updated */
    where: CurrentDelegatedStakingPoolBalancesBoolExp;
};
/** aggregate var_pop on columns */
type CurrentDelegatedStakingPoolBalancesVarPopFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
    operator_commission_percentage?: Maybe<Scalars["Float"]["output"]>;
    total_coins?: Maybe<Scalars["Float"]["output"]>;
    total_shares?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate var_samp on columns */
type CurrentDelegatedStakingPoolBalancesVarSampFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
    operator_commission_percentage?: Maybe<Scalars["Float"]["output"]>;
    total_coins?: Maybe<Scalars["Float"]["output"]>;
    total_shares?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate variance on columns */
type CurrentDelegatedStakingPoolBalancesVarianceFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
    operator_commission_percentage?: Maybe<Scalars["Float"]["output"]>;
    total_coins?: Maybe<Scalars["Float"]["output"]>;
    total_shares?: Maybe<Scalars["Float"]["output"]>;
};
/** columns and relationships of "current_delegated_voter" */
type CurrentDelegatedVoter = {
    delegation_pool_address: Scalars["String"]["output"];
    delegator_address: Scalars["String"]["output"];
    inserted_at: Scalars["timestamp"]["output"];
    last_transaction_timestamp: Scalars["timestamp"]["output"];
    last_transaction_version: Scalars["bigint"]["output"];
    pending_voter?: Maybe<Scalars["String"]["output"]>;
    table_handle?: Maybe<Scalars["String"]["output"]>;
    voter?: Maybe<Scalars["String"]["output"]>;
};
/** aggregated selection of "current_delegated_voter" */
type CurrentDelegatedVoterAggregate = {
    aggregate?: Maybe<CurrentDelegatedVoterAggregateFields>;
    nodes: Array<CurrentDelegatedVoter>;
};
/** aggregate fields of "current_delegated_voter" */
type CurrentDelegatedVoterAggregateFields = {
    avg?: Maybe<CurrentDelegatedVoterAvgFields>;
    count: Scalars["Int"]["output"];
    max?: Maybe<CurrentDelegatedVoterMaxFields>;
    min?: Maybe<CurrentDelegatedVoterMinFields>;
    stddev?: Maybe<CurrentDelegatedVoterStddevFields>;
    stddev_pop?: Maybe<CurrentDelegatedVoterStddevPopFields>;
    stddev_samp?: Maybe<CurrentDelegatedVoterStddevSampFields>;
    sum?: Maybe<CurrentDelegatedVoterSumFields>;
    var_pop?: Maybe<CurrentDelegatedVoterVarPopFields>;
    var_samp?: Maybe<CurrentDelegatedVoterVarSampFields>;
    variance?: Maybe<CurrentDelegatedVoterVarianceFields>;
};
/** aggregate fields of "current_delegated_voter" */
type CurrentDelegatedVoterAggregateFieldsCountArgs = {
    columns?: InputMaybe<Array<CurrentDelegatedVoterSelectColumn>>;
    distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};
/** aggregate avg on columns */
type CurrentDelegatedVoterAvgFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** Boolean expression to filter rows from the table "current_delegated_voter". All fields are combined with a logical 'AND'. */
type CurrentDelegatedVoterBoolExp = {
    _and?: InputMaybe<Array<CurrentDelegatedVoterBoolExp>>;
    _not?: InputMaybe<CurrentDelegatedVoterBoolExp>;
    _or?: InputMaybe<Array<CurrentDelegatedVoterBoolExp>>;
    delegation_pool_address?: InputMaybe<StringComparisonExp>;
    delegator_address?: InputMaybe<StringComparisonExp>;
    inserted_at?: InputMaybe<TimestampComparisonExp>;
    last_transaction_timestamp?: InputMaybe<TimestampComparisonExp>;
    last_transaction_version?: InputMaybe<BigintComparisonExp>;
    pending_voter?: InputMaybe<StringComparisonExp>;
    table_handle?: InputMaybe<StringComparisonExp>;
    voter?: InputMaybe<StringComparisonExp>;
};
/** unique or primary key constraints on table "current_delegated_voter" */
declare enum CurrentDelegatedVoterConstraint {
    /** unique or primary key constraint on columns "delegator_address", "delegation_pool_address" */
    CurrentDelegatedVoterPkey = "current_delegated_voter_pkey"
}
/** input type for incrementing numeric columns in table "current_delegated_voter" */
type CurrentDelegatedVoterIncInput = {
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** input type for inserting data into table "current_delegated_voter" */
type CurrentDelegatedVoterInsertInput = {
    delegation_pool_address?: InputMaybe<Scalars["String"]["input"]>;
    delegator_address?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    last_transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    pending_voter?: InputMaybe<Scalars["String"]["input"]>;
    table_handle?: InputMaybe<Scalars["String"]["input"]>;
    voter?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregate max on columns */
type CurrentDelegatedVoterMaxFields = {
    delegation_pool_address?: Maybe<Scalars["String"]["output"]>;
    delegator_address?: Maybe<Scalars["String"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    last_transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
    last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    pending_voter?: Maybe<Scalars["String"]["output"]>;
    table_handle?: Maybe<Scalars["String"]["output"]>;
    voter?: Maybe<Scalars["String"]["output"]>;
};
/** aggregate min on columns */
type CurrentDelegatedVoterMinFields = {
    delegation_pool_address?: Maybe<Scalars["String"]["output"]>;
    delegator_address?: Maybe<Scalars["String"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    last_transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
    last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    pending_voter?: Maybe<Scalars["String"]["output"]>;
    table_handle?: Maybe<Scalars["String"]["output"]>;
    voter?: Maybe<Scalars["String"]["output"]>;
};
/** response of any mutation on the table "current_delegated_voter" */
type CurrentDelegatedVoterMutationResponse = {
    /** number of rows affected by the mutation */
    affected_rows: Scalars["Int"]["output"];
    /** data from the rows affected by the mutation */
    returning: Array<CurrentDelegatedVoter>;
};
/** on_conflict condition type for table "current_delegated_voter" */
type CurrentDelegatedVoterOnConflict = {
    constraint: CurrentDelegatedVoterConstraint;
    update_columns?: Array<CurrentDelegatedVoterUpdateColumn>;
    where?: InputMaybe<CurrentDelegatedVoterBoolExp>;
};
/** Ordering options when selecting data from "current_delegated_voter". */
type CurrentDelegatedVoterOrderBy = {
    delegation_pool_address?: InputMaybe<OrderBy>;
    delegator_address?: InputMaybe<OrderBy>;
    inserted_at?: InputMaybe<OrderBy>;
    last_transaction_timestamp?: InputMaybe<OrderBy>;
    last_transaction_version?: InputMaybe<OrderBy>;
    pending_voter?: InputMaybe<OrderBy>;
    table_handle?: InputMaybe<OrderBy>;
    voter?: InputMaybe<OrderBy>;
};
/** primary key columns input for table: current_delegated_voter */
type CurrentDelegatedVoterPkColumnsInput = {
    delegation_pool_address: Scalars["String"]["input"];
    delegator_address: Scalars["String"]["input"];
};
/** select columns of table "current_delegated_voter" */
declare enum CurrentDelegatedVoterSelectColumn {
    /** column name */
    DelegationPoolAddress = "delegation_pool_address",
    /** column name */
    DelegatorAddress = "delegator_address",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    LastTransactionTimestamp = "last_transaction_timestamp",
    /** column name */
    LastTransactionVersion = "last_transaction_version",
    /** column name */
    PendingVoter = "pending_voter",
    /** column name */
    TableHandle = "table_handle",
    /** column name */
    Voter = "voter"
}
/** input type for updating data in table "current_delegated_voter" */
type CurrentDelegatedVoterSetInput = {
    delegation_pool_address?: InputMaybe<Scalars["String"]["input"]>;
    delegator_address?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    last_transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    pending_voter?: InputMaybe<Scalars["String"]["input"]>;
    table_handle?: InputMaybe<Scalars["String"]["input"]>;
    voter?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregate stddev on columns */
type CurrentDelegatedVoterStddevFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_pop on columns */
type CurrentDelegatedVoterStddevPopFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_samp on columns */
type CurrentDelegatedVoterStddevSampFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** Streaming cursor of the table "current_delegated_voter" */
type CurrentDelegatedVoterStreamCursorInput = {
    /** Stream column input with initial value */
    initial_value: CurrentDelegatedVoterStreamCursorValueInput;
    /** cursor ordering */
    ordering?: InputMaybe<CursorOrdering>;
};
/** Initial value of the column from where the streaming should start */
type CurrentDelegatedVoterStreamCursorValueInput = {
    delegation_pool_address?: InputMaybe<Scalars["String"]["input"]>;
    delegator_address?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    last_transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    pending_voter?: InputMaybe<Scalars["String"]["input"]>;
    table_handle?: InputMaybe<Scalars["String"]["input"]>;
    voter?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregate sum on columns */
type CurrentDelegatedVoterSumFields = {
    last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};
/** update columns of table "current_delegated_voter" */
declare enum CurrentDelegatedVoterUpdateColumn {
    /** column name */
    DelegationPoolAddress = "delegation_pool_address",
    /** column name */
    DelegatorAddress = "delegator_address",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    LastTransactionTimestamp = "last_transaction_timestamp",
    /** column name */
    LastTransactionVersion = "last_transaction_version",
    /** column name */
    PendingVoter = "pending_voter",
    /** column name */
    TableHandle = "table_handle",
    /** column name */
    Voter = "voter"
}
type CurrentDelegatedVoterUpdates = {
    /** increments the numeric columns with given value of the filtered values */
    _inc?: InputMaybe<CurrentDelegatedVoterIncInput>;
    /** sets the columns of the filtered rows to the given values */
    _set?: InputMaybe<CurrentDelegatedVoterSetInput>;
    /** filter the rows which have to be updated */
    where: CurrentDelegatedVoterBoolExp;
};
/** aggregate var_pop on columns */
type CurrentDelegatedVoterVarPopFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate var_samp on columns */
type CurrentDelegatedVoterVarSampFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate variance on columns */
type CurrentDelegatedVoterVarianceFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** columns and relationships of "current_delegator_balances" */
type CurrentDelegatorBalances = {
    /** An object relationship */
    current_pool_balance?: Maybe<CurrentDelegatedStakingPoolBalances>;
    delegator_address: Scalars["String"]["output"];
    inserted_at: Scalars["timestamp"]["output"];
    last_transaction_version: Scalars["bigint"]["output"];
    parent_table_handle: Scalars["String"]["output"];
    pool_address: Scalars["String"]["output"];
    pool_type: Scalars["String"]["output"];
    shares: Scalars["numeric"]["output"];
    /** An object relationship */
    staking_pool_metadata?: Maybe<CurrentStakingPoolVoter>;
    table_handle: Scalars["String"]["output"];
};
/** aggregated selection of "current_delegator_balances" */
type CurrentDelegatorBalancesAggregate = {
    aggregate?: Maybe<CurrentDelegatorBalancesAggregateFields>;
    nodes: Array<CurrentDelegatorBalances>;
};
/** aggregate fields of "current_delegator_balances" */
type CurrentDelegatorBalancesAggregateFields = {
    avg?: Maybe<CurrentDelegatorBalancesAvgFields>;
    count: Scalars["Int"]["output"];
    max?: Maybe<CurrentDelegatorBalancesMaxFields>;
    min?: Maybe<CurrentDelegatorBalancesMinFields>;
    stddev?: Maybe<CurrentDelegatorBalancesStddevFields>;
    stddev_pop?: Maybe<CurrentDelegatorBalancesStddevPopFields>;
    stddev_samp?: Maybe<CurrentDelegatorBalancesStddevSampFields>;
    sum?: Maybe<CurrentDelegatorBalancesSumFields>;
    var_pop?: Maybe<CurrentDelegatorBalancesVarPopFields>;
    var_samp?: Maybe<CurrentDelegatorBalancesVarSampFields>;
    variance?: Maybe<CurrentDelegatorBalancesVarianceFields>;
};
/** aggregate fields of "current_delegator_balances" */
type CurrentDelegatorBalancesAggregateFieldsCountArgs = {
    columns?: InputMaybe<Array<CurrentDelegatorBalancesSelectColumn>>;
    distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};
/** aggregate avg on columns */
type CurrentDelegatorBalancesAvgFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
    shares?: Maybe<Scalars["Float"]["output"]>;
};
/** Boolean expression to filter rows from the table "current_delegator_balances". All fields are combined with a logical 'AND'. */
type CurrentDelegatorBalancesBoolExp = {
    _and?: InputMaybe<Array<CurrentDelegatorBalancesBoolExp>>;
    _not?: InputMaybe<CurrentDelegatorBalancesBoolExp>;
    _or?: InputMaybe<Array<CurrentDelegatorBalancesBoolExp>>;
    current_pool_balance?: InputMaybe<CurrentDelegatedStakingPoolBalancesBoolExp>;
    delegator_address?: InputMaybe<StringComparisonExp>;
    inserted_at?: InputMaybe<TimestampComparisonExp>;
    last_transaction_version?: InputMaybe<BigintComparisonExp>;
    parent_table_handle?: InputMaybe<StringComparisonExp>;
    pool_address?: InputMaybe<StringComparisonExp>;
    pool_type?: InputMaybe<StringComparisonExp>;
    shares?: InputMaybe<NumericComparisonExp>;
    staking_pool_metadata?: InputMaybe<CurrentStakingPoolVoterBoolExp>;
    table_handle?: InputMaybe<StringComparisonExp>;
};
/** unique or primary key constraints on table "current_delegator_balances" */
declare enum CurrentDelegatorBalancesConstraint {
    /** unique or primary key constraint on columns "delegator_address", "pool_address", "pool_type", "table_handle" */
    CurrentDelegatorBalancesPkey = "current_delegator_balances_pkey"
}
/** input type for incrementing numeric columns in table "current_delegator_balances" */
type CurrentDelegatorBalancesIncInput = {
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    shares?: InputMaybe<Scalars["numeric"]["input"]>;
};
/** input type for inserting data into table "current_delegator_balances" */
type CurrentDelegatorBalancesInsertInput = {
    current_pool_balance?: InputMaybe<CurrentDelegatedStakingPoolBalancesObjRelInsertInput>;
    delegator_address?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    parent_table_handle?: InputMaybe<Scalars["String"]["input"]>;
    pool_address?: InputMaybe<Scalars["String"]["input"]>;
    pool_type?: InputMaybe<Scalars["String"]["input"]>;
    shares?: InputMaybe<Scalars["numeric"]["input"]>;
    staking_pool_metadata?: InputMaybe<CurrentStakingPoolVoterObjRelInsertInput>;
    table_handle?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregate max on columns */
type CurrentDelegatorBalancesMaxFields = {
    delegator_address?: Maybe<Scalars["String"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    parent_table_handle?: Maybe<Scalars["String"]["output"]>;
    pool_address?: Maybe<Scalars["String"]["output"]>;
    pool_type?: Maybe<Scalars["String"]["output"]>;
    shares?: Maybe<Scalars["numeric"]["output"]>;
    table_handle?: Maybe<Scalars["String"]["output"]>;
};
/** aggregate min on columns */
type CurrentDelegatorBalancesMinFields = {
    delegator_address?: Maybe<Scalars["String"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    parent_table_handle?: Maybe<Scalars["String"]["output"]>;
    pool_address?: Maybe<Scalars["String"]["output"]>;
    pool_type?: Maybe<Scalars["String"]["output"]>;
    shares?: Maybe<Scalars["numeric"]["output"]>;
    table_handle?: Maybe<Scalars["String"]["output"]>;
};
/** response of any mutation on the table "current_delegator_balances" */
type CurrentDelegatorBalancesMutationResponse = {
    /** number of rows affected by the mutation */
    affected_rows: Scalars["Int"]["output"];
    /** data from the rows affected by the mutation */
    returning: Array<CurrentDelegatorBalances>;
};
/** on_conflict condition type for table "current_delegator_balances" */
type CurrentDelegatorBalancesOnConflict = {
    constraint: CurrentDelegatorBalancesConstraint;
    update_columns?: Array<CurrentDelegatorBalancesUpdateColumn>;
    where?: InputMaybe<CurrentDelegatorBalancesBoolExp>;
};
/** Ordering options when selecting data from "current_delegator_balances". */
type CurrentDelegatorBalancesOrderBy = {
    current_pool_balance?: InputMaybe<CurrentDelegatedStakingPoolBalancesOrderBy>;
    delegator_address?: InputMaybe<OrderBy>;
    inserted_at?: InputMaybe<OrderBy>;
    last_transaction_version?: InputMaybe<OrderBy>;
    parent_table_handle?: InputMaybe<OrderBy>;
    pool_address?: InputMaybe<OrderBy>;
    pool_type?: InputMaybe<OrderBy>;
    shares?: InputMaybe<OrderBy>;
    staking_pool_metadata?: InputMaybe<CurrentStakingPoolVoterOrderBy>;
    table_handle?: InputMaybe<OrderBy>;
};
/** primary key columns input for table: current_delegator_balances */
type CurrentDelegatorBalancesPkColumnsInput = {
    delegator_address: Scalars["String"]["input"];
    pool_address: Scalars["String"]["input"];
    pool_type: Scalars["String"]["input"];
    table_handle: Scalars["String"]["input"];
};
/** select columns of table "current_delegator_balances" */
declare enum CurrentDelegatorBalancesSelectColumn {
    /** column name */
    DelegatorAddress = "delegator_address",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    LastTransactionVersion = "last_transaction_version",
    /** column name */
    ParentTableHandle = "parent_table_handle",
    /** column name */
    PoolAddress = "pool_address",
    /** column name */
    PoolType = "pool_type",
    /** column name */
    Shares = "shares",
    /** column name */
    TableHandle = "table_handle"
}
/** input type for updating data in table "current_delegator_balances" */
type CurrentDelegatorBalancesSetInput = {
    delegator_address?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    parent_table_handle?: InputMaybe<Scalars["String"]["input"]>;
    pool_address?: InputMaybe<Scalars["String"]["input"]>;
    pool_type?: InputMaybe<Scalars["String"]["input"]>;
    shares?: InputMaybe<Scalars["numeric"]["input"]>;
    table_handle?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregate stddev on columns */
type CurrentDelegatorBalancesStddevFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
    shares?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_pop on columns */
type CurrentDelegatorBalancesStddevPopFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
    shares?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_samp on columns */
type CurrentDelegatorBalancesStddevSampFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
    shares?: Maybe<Scalars["Float"]["output"]>;
};
/** Streaming cursor of the table "current_delegator_balances" */
type CurrentDelegatorBalancesStreamCursorInput = {
    /** Stream column input with initial value */
    initial_value: CurrentDelegatorBalancesStreamCursorValueInput;
    /** cursor ordering */
    ordering?: InputMaybe<CursorOrdering>;
};
/** Initial value of the column from where the streaming should start */
type CurrentDelegatorBalancesStreamCursorValueInput = {
    delegator_address?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    parent_table_handle?: InputMaybe<Scalars["String"]["input"]>;
    pool_address?: InputMaybe<Scalars["String"]["input"]>;
    pool_type?: InputMaybe<Scalars["String"]["input"]>;
    shares?: InputMaybe<Scalars["numeric"]["input"]>;
    table_handle?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregate sum on columns */
type CurrentDelegatorBalancesSumFields = {
    last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    shares?: Maybe<Scalars["numeric"]["output"]>;
};
/** update columns of table "current_delegator_balances" */
declare enum CurrentDelegatorBalancesUpdateColumn {
    /** column name */
    DelegatorAddress = "delegator_address",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    LastTransactionVersion = "last_transaction_version",
    /** column name */
    ParentTableHandle = "parent_table_handle",
    /** column name */
    PoolAddress = "pool_address",
    /** column name */
    PoolType = "pool_type",
    /** column name */
    Shares = "shares",
    /** column name */
    TableHandle = "table_handle"
}
type CurrentDelegatorBalancesUpdates = {
    /** increments the numeric columns with given value of the filtered values */
    _inc?: InputMaybe<CurrentDelegatorBalancesIncInput>;
    /** sets the columns of the filtered rows to the given values */
    _set?: InputMaybe<CurrentDelegatorBalancesSetInput>;
    /** filter the rows which have to be updated */
    where: CurrentDelegatorBalancesBoolExp;
};
/** aggregate var_pop on columns */
type CurrentDelegatorBalancesVarPopFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
    shares?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate var_samp on columns */
type CurrentDelegatorBalancesVarSampFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
    shares?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate variance on columns */
type CurrentDelegatorBalancesVarianceFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
    shares?: Maybe<Scalars["Float"]["output"]>;
};
/** columns and relationships of "current_fungible_asset_balances_legacy" */
type CurrentFungibleAssetBalances = {
    amount: Scalars["numeric"]["output"];
    asset_type: Scalars["String"]["output"];
    inserted_at: Scalars["timestamp"]["output"];
    is_frozen: Scalars["Boolean"]["output"];
    is_primary: Scalars["Boolean"]["output"];
    last_transaction_timestamp: Scalars["timestamp"]["output"];
    last_transaction_version: Scalars["bigint"]["output"];
    /** An object relationship */
    metadata?: Maybe<FungibleAssetMetadata>;
    owner_address: Scalars["String"]["output"];
    storage_id: Scalars["String"]["output"];
    token_standard: Scalars["String"]["output"];
};
/** aggregated selection of "current_fungible_asset_balances_legacy" */
type CurrentFungibleAssetBalancesAggregate = {
    aggregate?: Maybe<CurrentFungibleAssetBalancesAggregateFields>;
    nodes: Array<CurrentFungibleAssetBalances>;
};
/** aggregate fields of "current_fungible_asset_balances_legacy" */
type CurrentFungibleAssetBalancesAggregateFields = {
    avg?: Maybe<CurrentFungibleAssetBalancesAvgFields>;
    count: Scalars["Int"]["output"];
    max?: Maybe<CurrentFungibleAssetBalancesMaxFields>;
    min?: Maybe<CurrentFungibleAssetBalancesMinFields>;
    stddev?: Maybe<CurrentFungibleAssetBalancesStddevFields>;
    stddev_pop?: Maybe<CurrentFungibleAssetBalancesStddevPopFields>;
    stddev_samp?: Maybe<CurrentFungibleAssetBalancesStddevSampFields>;
    sum?: Maybe<CurrentFungibleAssetBalancesSumFields>;
    var_pop?: Maybe<CurrentFungibleAssetBalancesVarPopFields>;
    var_samp?: Maybe<CurrentFungibleAssetBalancesVarSampFields>;
    variance?: Maybe<CurrentFungibleAssetBalancesVarianceFields>;
};
/** aggregate fields of "current_fungible_asset_balances_legacy" */
type CurrentFungibleAssetBalancesAggregateFieldsCountArgs = {
    columns?: InputMaybe<Array<CurrentFungibleAssetBalancesSelectColumn>>;
    distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};
/** aggregate avg on columns */
type CurrentFungibleAssetBalancesAvgFields = {
    amount?: Maybe<Scalars["Float"]["output"]>;
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** Boolean expression to filter rows from the table "current_fungible_asset_balances_legacy". All fields are combined with a logical 'AND'. */
type CurrentFungibleAssetBalancesBoolExp = {
    _and?: InputMaybe<Array<CurrentFungibleAssetBalancesBoolExp>>;
    _not?: InputMaybe<CurrentFungibleAssetBalancesBoolExp>;
    _or?: InputMaybe<Array<CurrentFungibleAssetBalancesBoolExp>>;
    amount?: InputMaybe<NumericComparisonExp>;
    asset_type?: InputMaybe<StringComparisonExp>;
    inserted_at?: InputMaybe<TimestampComparisonExp>;
    is_frozen?: InputMaybe<BooleanComparisonExp>;
    is_primary?: InputMaybe<BooleanComparisonExp>;
    last_transaction_timestamp?: InputMaybe<TimestampComparisonExp>;
    last_transaction_version?: InputMaybe<BigintComparisonExp>;
    metadata?: InputMaybe<FungibleAssetMetadataBoolExp>;
    owner_address?: InputMaybe<StringComparisonExp>;
    storage_id?: InputMaybe<StringComparisonExp>;
    token_standard?: InputMaybe<StringComparisonExp>;
};
/** unique or primary key constraints on table "current_fungible_asset_balances_legacy" */
declare enum CurrentFungibleAssetBalancesConstraint {
    /** unique or primary key constraint on columns "storage_id" */
    CurrentFungibleAssetBalancesPkey = "current_fungible_asset_balances_pkey"
}
/** input type for incrementing numeric columns in table "current_fungible_asset_balances_legacy" */
type CurrentFungibleAssetBalancesIncInput = {
    amount?: InputMaybe<Scalars["numeric"]["input"]>;
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** input type for inserting data into table "current_fungible_asset_balances_legacy" */
type CurrentFungibleAssetBalancesInsertInput = {
    amount?: InputMaybe<Scalars["numeric"]["input"]>;
    asset_type?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    is_frozen?: InputMaybe<Scalars["Boolean"]["input"]>;
    is_primary?: InputMaybe<Scalars["Boolean"]["input"]>;
    last_transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    metadata?: InputMaybe<FungibleAssetMetadataObjRelInsertInput>;
    owner_address?: InputMaybe<Scalars["String"]["input"]>;
    storage_id?: InputMaybe<Scalars["String"]["input"]>;
    token_standard?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregate max on columns */
type CurrentFungibleAssetBalancesMaxFields = {
    amount?: Maybe<Scalars["numeric"]["output"]>;
    asset_type?: Maybe<Scalars["String"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    last_transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
    last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    owner_address?: Maybe<Scalars["String"]["output"]>;
    storage_id?: Maybe<Scalars["String"]["output"]>;
    token_standard?: Maybe<Scalars["String"]["output"]>;
};
/** aggregate min on columns */
type CurrentFungibleAssetBalancesMinFields = {
    amount?: Maybe<Scalars["numeric"]["output"]>;
    asset_type?: Maybe<Scalars["String"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    last_transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
    last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    owner_address?: Maybe<Scalars["String"]["output"]>;
    storage_id?: Maybe<Scalars["String"]["output"]>;
    token_standard?: Maybe<Scalars["String"]["output"]>;
};
/** response of any mutation on the table "current_fungible_asset_balances_legacy" */
type CurrentFungibleAssetBalancesMutationResponse = {
    /** number of rows affected by the mutation */
    affected_rows: Scalars["Int"]["output"];
    /** data from the rows affected by the mutation */
    returning: Array<CurrentFungibleAssetBalances>;
};
/** columns and relationships of "current_fungible_asset_balances" */
type CurrentFungibleAssetBalancesNew = {
    amount: Scalars["numeric"]["output"];
    amount_v1?: Maybe<Scalars["numeric"]["output"]>;
    amount_v2?: Maybe<Scalars["numeric"]["output"]>;
    asset_type: Scalars["String"]["output"];
    asset_type_v1?: Maybe<Scalars["String"]["output"]>;
    asset_type_v2?: Maybe<Scalars["String"]["output"]>;
    inserted_at: Scalars["timestamp"]["output"];
    is_frozen: Scalars["Boolean"]["output"];
    is_primary: Scalars["Boolean"]["output"];
    last_transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
    last_transaction_timestamp_v1?: Maybe<Scalars["timestamp"]["output"]>;
    last_transaction_timestamp_v2?: Maybe<Scalars["timestamp"]["output"]>;
    last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    last_transaction_version_v1?: Maybe<Scalars["bigint"]["output"]>;
    last_transaction_version_v2?: Maybe<Scalars["bigint"]["output"]>;
    /** An object relationship */
    metadata?: Maybe<FungibleAssetMetadata>;
    owner_address: Scalars["String"]["output"];
    storage_id: Scalars["String"]["output"];
    token_standard: Scalars["String"]["output"];
};
/** aggregated selection of "current_fungible_asset_balances" */
type CurrentFungibleAssetBalancesNewAggregate = {
    aggregate?: Maybe<CurrentFungibleAssetBalancesNewAggregateFields>;
    nodes: Array<CurrentFungibleAssetBalancesNew>;
};
/** aggregate fields of "current_fungible_asset_balances" */
type CurrentFungibleAssetBalancesNewAggregateFields = {
    avg?: Maybe<CurrentFungibleAssetBalancesNewAvgFields>;
    count: Scalars["Int"]["output"];
    max?: Maybe<CurrentFungibleAssetBalancesNewMaxFields>;
    min?: Maybe<CurrentFungibleAssetBalancesNewMinFields>;
    stddev?: Maybe<CurrentFungibleAssetBalancesNewStddevFields>;
    stddev_pop?: Maybe<CurrentFungibleAssetBalancesNewStddevPopFields>;
    stddev_samp?: Maybe<CurrentFungibleAssetBalancesNewStddevSampFields>;
    sum?: Maybe<CurrentFungibleAssetBalancesNewSumFields>;
    var_pop?: Maybe<CurrentFungibleAssetBalancesNewVarPopFields>;
    var_samp?: Maybe<CurrentFungibleAssetBalancesNewVarSampFields>;
    variance?: Maybe<CurrentFungibleAssetBalancesNewVarianceFields>;
};
/** aggregate fields of "current_fungible_asset_balances" */
type CurrentFungibleAssetBalancesNewAggregateFieldsCountArgs = {
    columns?: InputMaybe<Array<CurrentFungibleAssetBalancesNewSelectColumn>>;
    distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};
/** aggregate avg on columns */
type CurrentFungibleAssetBalancesNewAvgFields = {
    amount?: Maybe<Scalars["Float"]["output"]>;
    amount_v1?: Maybe<Scalars["Float"]["output"]>;
    amount_v2?: Maybe<Scalars["Float"]["output"]>;
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
    last_transaction_version_v1?: Maybe<Scalars["Float"]["output"]>;
    last_transaction_version_v2?: Maybe<Scalars["Float"]["output"]>;
};
/** Boolean expression to filter rows from the table "current_fungible_asset_balances". All fields are combined with a logical 'AND'. */
type CurrentFungibleAssetBalancesNewBoolExp = {
    _and?: InputMaybe<Array<CurrentFungibleAssetBalancesNewBoolExp>>;
    _not?: InputMaybe<CurrentFungibleAssetBalancesNewBoolExp>;
    _or?: InputMaybe<Array<CurrentFungibleAssetBalancesNewBoolExp>>;
    amount?: InputMaybe<NumericComparisonExp>;
    amount_v1?: InputMaybe<NumericComparisonExp>;
    amount_v2?: InputMaybe<NumericComparisonExp>;
    asset_type?: InputMaybe<StringComparisonExp>;
    asset_type_v1?: InputMaybe<StringComparisonExp>;
    asset_type_v2?: InputMaybe<StringComparisonExp>;
    inserted_at?: InputMaybe<TimestampComparisonExp>;
    is_frozen?: InputMaybe<BooleanComparisonExp>;
    is_primary?: InputMaybe<BooleanComparisonExp>;
    last_transaction_timestamp?: InputMaybe<TimestampComparisonExp>;
    last_transaction_timestamp_v1?: InputMaybe<TimestampComparisonExp>;
    last_transaction_timestamp_v2?: InputMaybe<TimestampComparisonExp>;
    last_transaction_version?: InputMaybe<BigintComparisonExp>;
    last_transaction_version_v1?: InputMaybe<BigintComparisonExp>;
    last_transaction_version_v2?: InputMaybe<BigintComparisonExp>;
    metadata?: InputMaybe<FungibleAssetMetadataBoolExp>;
    owner_address?: InputMaybe<StringComparisonExp>;
    storage_id?: InputMaybe<StringComparisonExp>;
    token_standard?: InputMaybe<StringComparisonExp>;
};
/** unique or primary key constraints on table "current_fungible_asset_balances" */
declare enum CurrentFungibleAssetBalancesNewConstraint {
    /** unique or primary key constraint on columns "storage_id" */
    CurrentUnifiedFungibleAssetBalancesPkey = "current_unified_fungible_asset_balances_pkey"
}
/** input type for incrementing numeric columns in table "current_fungible_asset_balances" */
type CurrentFungibleAssetBalancesNewIncInput = {
    amount_v1?: InputMaybe<Scalars["numeric"]["input"]>;
    amount_v2?: InputMaybe<Scalars["numeric"]["input"]>;
    last_transaction_version_v1?: InputMaybe<Scalars["bigint"]["input"]>;
    last_transaction_version_v2?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** input type for inserting data into table "current_fungible_asset_balances" */
type CurrentFungibleAssetBalancesNewInsertInput = {
    amount_v1?: InputMaybe<Scalars["numeric"]["input"]>;
    amount_v2?: InputMaybe<Scalars["numeric"]["input"]>;
    asset_type_v1?: InputMaybe<Scalars["String"]["input"]>;
    asset_type_v2?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    is_frozen?: InputMaybe<Scalars["Boolean"]["input"]>;
    is_primary?: InputMaybe<Scalars["Boolean"]["input"]>;
    last_transaction_timestamp_v1?: InputMaybe<Scalars["timestamp"]["input"]>;
    last_transaction_timestamp_v2?: InputMaybe<Scalars["timestamp"]["input"]>;
    last_transaction_version_v1?: InputMaybe<Scalars["bigint"]["input"]>;
    last_transaction_version_v2?: InputMaybe<Scalars["bigint"]["input"]>;
    metadata?: InputMaybe<FungibleAssetMetadataObjRelInsertInput>;
    owner_address?: InputMaybe<Scalars["String"]["input"]>;
    storage_id?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregate max on columns */
type CurrentFungibleAssetBalancesNewMaxFields = {
    amount?: Maybe<Scalars["numeric"]["output"]>;
    amount_v1?: Maybe<Scalars["numeric"]["output"]>;
    amount_v2?: Maybe<Scalars["numeric"]["output"]>;
    asset_type?: Maybe<Scalars["String"]["output"]>;
    asset_type_v1?: Maybe<Scalars["String"]["output"]>;
    asset_type_v2?: Maybe<Scalars["String"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    last_transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
    last_transaction_timestamp_v1?: Maybe<Scalars["timestamp"]["output"]>;
    last_transaction_timestamp_v2?: Maybe<Scalars["timestamp"]["output"]>;
    last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    last_transaction_version_v1?: Maybe<Scalars["bigint"]["output"]>;
    last_transaction_version_v2?: Maybe<Scalars["bigint"]["output"]>;
    owner_address?: Maybe<Scalars["String"]["output"]>;
    storage_id?: Maybe<Scalars["String"]["output"]>;
    token_standard?: Maybe<Scalars["String"]["output"]>;
};
/** aggregate min on columns */
type CurrentFungibleAssetBalancesNewMinFields = {
    amount?: Maybe<Scalars["numeric"]["output"]>;
    amount_v1?: Maybe<Scalars["numeric"]["output"]>;
    amount_v2?: Maybe<Scalars["numeric"]["output"]>;
    asset_type?: Maybe<Scalars["String"]["output"]>;
    asset_type_v1?: Maybe<Scalars["String"]["output"]>;
    asset_type_v2?: Maybe<Scalars["String"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    last_transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
    last_transaction_timestamp_v1?: Maybe<Scalars["timestamp"]["output"]>;
    last_transaction_timestamp_v2?: Maybe<Scalars["timestamp"]["output"]>;
    last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    last_transaction_version_v1?: Maybe<Scalars["bigint"]["output"]>;
    last_transaction_version_v2?: Maybe<Scalars["bigint"]["output"]>;
    owner_address?: Maybe<Scalars["String"]["output"]>;
    storage_id?: Maybe<Scalars["String"]["output"]>;
    token_standard?: Maybe<Scalars["String"]["output"]>;
};
/** response of any mutation on the table "current_fungible_asset_balances" */
type CurrentFungibleAssetBalancesNewMutationResponse = {
    /** number of rows affected by the mutation */
    affected_rows: Scalars["Int"]["output"];
    /** data from the rows affected by the mutation */
    returning: Array<CurrentFungibleAssetBalancesNew>;
};
/** on_conflict condition type for table "current_fungible_asset_balances" */
type CurrentFungibleAssetBalancesNewOnConflict = {
    constraint: CurrentFungibleAssetBalancesNewConstraint;
    update_columns?: Array<CurrentFungibleAssetBalancesNewUpdateColumn>;
    where?: InputMaybe<CurrentFungibleAssetBalancesNewBoolExp>;
};
/** Ordering options when selecting data from "current_fungible_asset_balances". */
type CurrentFungibleAssetBalancesNewOrderBy = {
    amount?: InputMaybe<OrderBy>;
    amount_v1?: InputMaybe<OrderBy>;
    amount_v2?: InputMaybe<OrderBy>;
    asset_type?: InputMaybe<OrderBy>;
    asset_type_v1?: InputMaybe<OrderBy>;
    asset_type_v2?: InputMaybe<OrderBy>;
    inserted_at?: InputMaybe<OrderBy>;
    is_frozen?: InputMaybe<OrderBy>;
    is_primary?: InputMaybe<OrderBy>;
    last_transaction_timestamp?: InputMaybe<OrderBy>;
    last_transaction_timestamp_v1?: InputMaybe<OrderBy>;
    last_transaction_timestamp_v2?: InputMaybe<OrderBy>;
    last_transaction_version?: InputMaybe<OrderBy>;
    last_transaction_version_v1?: InputMaybe<OrderBy>;
    last_transaction_version_v2?: InputMaybe<OrderBy>;
    metadata?: InputMaybe<FungibleAssetMetadataOrderBy>;
    owner_address?: InputMaybe<OrderBy>;
    storage_id?: InputMaybe<OrderBy>;
    token_standard?: InputMaybe<OrderBy>;
};
/** primary key columns input for table: current_fungible_asset_balances */
type CurrentFungibleAssetBalancesNewPkColumnsInput = {
    storage_id: Scalars["String"]["input"];
};
/** select columns of table "current_fungible_asset_balances" */
declare enum CurrentFungibleAssetBalancesNewSelectColumn {
    /** column name */
    Amount = "amount",
    /** column name */
    AmountV1 = "amount_v1",
    /** column name */
    AmountV2 = "amount_v2",
    /** column name */
    AssetType = "asset_type",
    /** column name */
    AssetTypeV1 = "asset_type_v1",
    /** column name */
    AssetTypeV2 = "asset_type_v2",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    IsFrozen = "is_frozen",
    /** column name */
    IsPrimary = "is_primary",
    /** column name */
    LastTransactionTimestamp = "last_transaction_timestamp",
    /** column name */
    LastTransactionTimestampV1 = "last_transaction_timestamp_v1",
    /** column name */
    LastTransactionTimestampV2 = "last_transaction_timestamp_v2",
    /** column name */
    LastTransactionVersion = "last_transaction_version",
    /** column name */
    LastTransactionVersionV1 = "last_transaction_version_v1",
    /** column name */
    LastTransactionVersionV2 = "last_transaction_version_v2",
    /** column name */
    OwnerAddress = "owner_address",
    /** column name */
    StorageId = "storage_id",
    /** column name */
    TokenStandard = "token_standard"
}
/** input type for updating data in table "current_fungible_asset_balances" */
type CurrentFungibleAssetBalancesNewSetInput = {
    amount_v1?: InputMaybe<Scalars["numeric"]["input"]>;
    amount_v2?: InputMaybe<Scalars["numeric"]["input"]>;
    asset_type_v1?: InputMaybe<Scalars["String"]["input"]>;
    asset_type_v2?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    is_frozen?: InputMaybe<Scalars["Boolean"]["input"]>;
    is_primary?: InputMaybe<Scalars["Boolean"]["input"]>;
    last_transaction_timestamp_v1?: InputMaybe<Scalars["timestamp"]["input"]>;
    last_transaction_timestamp_v2?: InputMaybe<Scalars["timestamp"]["input"]>;
    last_transaction_version_v1?: InputMaybe<Scalars["bigint"]["input"]>;
    last_transaction_version_v2?: InputMaybe<Scalars["bigint"]["input"]>;
    owner_address?: InputMaybe<Scalars["String"]["input"]>;
    storage_id?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregate stddev on columns */
type CurrentFungibleAssetBalancesNewStddevFields = {
    amount?: Maybe<Scalars["Float"]["output"]>;
    amount_v1?: Maybe<Scalars["Float"]["output"]>;
    amount_v2?: Maybe<Scalars["Float"]["output"]>;
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
    last_transaction_version_v1?: Maybe<Scalars["Float"]["output"]>;
    last_transaction_version_v2?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_pop on columns */
type CurrentFungibleAssetBalancesNewStddevPopFields = {
    amount?: Maybe<Scalars["Float"]["output"]>;
    amount_v1?: Maybe<Scalars["Float"]["output"]>;
    amount_v2?: Maybe<Scalars["Float"]["output"]>;
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
    last_transaction_version_v1?: Maybe<Scalars["Float"]["output"]>;
    last_transaction_version_v2?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_samp on columns */
type CurrentFungibleAssetBalancesNewStddevSampFields = {
    amount?: Maybe<Scalars["Float"]["output"]>;
    amount_v1?: Maybe<Scalars["Float"]["output"]>;
    amount_v2?: Maybe<Scalars["Float"]["output"]>;
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
    last_transaction_version_v1?: Maybe<Scalars["Float"]["output"]>;
    last_transaction_version_v2?: Maybe<Scalars["Float"]["output"]>;
};
/** Streaming cursor of the table "current_fungible_asset_balances_new" */
type CurrentFungibleAssetBalancesNewStreamCursorInput = {
    /** Stream column input with initial value */
    initial_value: CurrentFungibleAssetBalancesNewStreamCursorValueInput;
    /** cursor ordering */
    ordering?: InputMaybe<CursorOrdering>;
};
/** Initial value of the column from where the streaming should start */
type CurrentFungibleAssetBalancesNewStreamCursorValueInput = {
    amount?: InputMaybe<Scalars["numeric"]["input"]>;
    amount_v1?: InputMaybe<Scalars["numeric"]["input"]>;
    amount_v2?: InputMaybe<Scalars["numeric"]["input"]>;
    asset_type?: InputMaybe<Scalars["String"]["input"]>;
    asset_type_v1?: InputMaybe<Scalars["String"]["input"]>;
    asset_type_v2?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    is_frozen?: InputMaybe<Scalars["Boolean"]["input"]>;
    is_primary?: InputMaybe<Scalars["Boolean"]["input"]>;
    last_transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    last_transaction_timestamp_v1?: InputMaybe<Scalars["timestamp"]["input"]>;
    last_transaction_timestamp_v2?: InputMaybe<Scalars["timestamp"]["input"]>;
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    last_transaction_version_v1?: InputMaybe<Scalars["bigint"]["input"]>;
    last_transaction_version_v2?: InputMaybe<Scalars["bigint"]["input"]>;
    owner_address?: InputMaybe<Scalars["String"]["input"]>;
    storage_id?: InputMaybe<Scalars["String"]["input"]>;
    token_standard?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregate sum on columns */
type CurrentFungibleAssetBalancesNewSumFields = {
    amount?: Maybe<Scalars["numeric"]["output"]>;
    amount_v1?: Maybe<Scalars["numeric"]["output"]>;
    amount_v2?: Maybe<Scalars["numeric"]["output"]>;
    last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    last_transaction_version_v1?: Maybe<Scalars["bigint"]["output"]>;
    last_transaction_version_v2?: Maybe<Scalars["bigint"]["output"]>;
};
/** update columns of table "current_fungible_asset_balances" */
declare enum CurrentFungibleAssetBalancesNewUpdateColumn {
    /** column name */
    AmountV1 = "amount_v1",
    /** column name */
    AmountV2 = "amount_v2",
    /** column name */
    AssetTypeV1 = "asset_type_v1",
    /** column name */
    AssetTypeV2 = "asset_type_v2",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    IsFrozen = "is_frozen",
    /** column name */
    IsPrimary = "is_primary",
    /** column name */
    LastTransactionTimestampV1 = "last_transaction_timestamp_v1",
    /** column name */
    LastTransactionTimestampV2 = "last_transaction_timestamp_v2",
    /** column name */
    LastTransactionVersionV1 = "last_transaction_version_v1",
    /** column name */
    LastTransactionVersionV2 = "last_transaction_version_v2",
    /** column name */
    OwnerAddress = "owner_address",
    /** column name */
    StorageId = "storage_id"
}
type CurrentFungibleAssetBalancesNewUpdates = {
    /** increments the numeric columns with given value of the filtered values */
    _inc?: InputMaybe<CurrentFungibleAssetBalancesNewIncInput>;
    /** sets the columns of the filtered rows to the given values */
    _set?: InputMaybe<CurrentFungibleAssetBalancesNewSetInput>;
    /** filter the rows which have to be updated */
    where: CurrentFungibleAssetBalancesNewBoolExp;
};
/** aggregate var_pop on columns */
type CurrentFungibleAssetBalancesNewVarPopFields = {
    amount?: Maybe<Scalars["Float"]["output"]>;
    amount_v1?: Maybe<Scalars["Float"]["output"]>;
    amount_v2?: Maybe<Scalars["Float"]["output"]>;
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
    last_transaction_version_v1?: Maybe<Scalars["Float"]["output"]>;
    last_transaction_version_v2?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate var_samp on columns */
type CurrentFungibleAssetBalancesNewVarSampFields = {
    amount?: Maybe<Scalars["Float"]["output"]>;
    amount_v1?: Maybe<Scalars["Float"]["output"]>;
    amount_v2?: Maybe<Scalars["Float"]["output"]>;
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
    last_transaction_version_v1?: Maybe<Scalars["Float"]["output"]>;
    last_transaction_version_v2?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate variance on columns */
type CurrentFungibleAssetBalancesNewVarianceFields = {
    amount?: Maybe<Scalars["Float"]["output"]>;
    amount_v1?: Maybe<Scalars["Float"]["output"]>;
    amount_v2?: Maybe<Scalars["Float"]["output"]>;
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
    last_transaction_version_v1?: Maybe<Scalars["Float"]["output"]>;
    last_transaction_version_v2?: Maybe<Scalars["Float"]["output"]>;
};
/** on_conflict condition type for table "current_fungible_asset_balances_legacy" */
type CurrentFungibleAssetBalancesOnConflict = {
    constraint: CurrentFungibleAssetBalancesConstraint;
    update_columns?: Array<CurrentFungibleAssetBalancesUpdateColumn>;
    where?: InputMaybe<CurrentFungibleAssetBalancesBoolExp>;
};
/** Ordering options when selecting data from "current_fungible_asset_balances_legacy". */
type CurrentFungibleAssetBalancesOrderBy = {
    amount?: InputMaybe<OrderBy>;
    asset_type?: InputMaybe<OrderBy>;
    inserted_at?: InputMaybe<OrderBy>;
    is_frozen?: InputMaybe<OrderBy>;
    is_primary?: InputMaybe<OrderBy>;
    last_transaction_timestamp?: InputMaybe<OrderBy>;
    last_transaction_version?: InputMaybe<OrderBy>;
    metadata?: InputMaybe<FungibleAssetMetadataOrderBy>;
    owner_address?: InputMaybe<OrderBy>;
    storage_id?: InputMaybe<OrderBy>;
    token_standard?: InputMaybe<OrderBy>;
};
/** primary key columns input for table: current_fungible_asset_balances_legacy */
type CurrentFungibleAssetBalancesPkColumnsInput = {
    storage_id: Scalars["String"]["input"];
};
/** select columns of table "current_fungible_asset_balances_legacy" */
declare enum CurrentFungibleAssetBalancesSelectColumn {
    /** column name */
    Amount = "amount",
    /** column name */
    AssetType = "asset_type",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    IsFrozen = "is_frozen",
    /** column name */
    IsPrimary = "is_primary",
    /** column name */
    LastTransactionTimestamp = "last_transaction_timestamp",
    /** column name */
    LastTransactionVersion = "last_transaction_version",
    /** column name */
    OwnerAddress = "owner_address",
    /** column name */
    StorageId = "storage_id",
    /** column name */
    TokenStandard = "token_standard"
}
/** input type for updating data in table "current_fungible_asset_balances_legacy" */
type CurrentFungibleAssetBalancesSetInput = {
    amount?: InputMaybe<Scalars["numeric"]["input"]>;
    asset_type?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    is_frozen?: InputMaybe<Scalars["Boolean"]["input"]>;
    is_primary?: InputMaybe<Scalars["Boolean"]["input"]>;
    last_transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    owner_address?: InputMaybe<Scalars["String"]["input"]>;
    storage_id?: InputMaybe<Scalars["String"]["input"]>;
    token_standard?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregate stddev on columns */
type CurrentFungibleAssetBalancesStddevFields = {
    amount?: Maybe<Scalars["Float"]["output"]>;
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_pop on columns */
type CurrentFungibleAssetBalancesStddevPopFields = {
    amount?: Maybe<Scalars["Float"]["output"]>;
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_samp on columns */
type CurrentFungibleAssetBalancesStddevSampFields = {
    amount?: Maybe<Scalars["Float"]["output"]>;
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** Streaming cursor of the table "current_fungible_asset_balances" */
type CurrentFungibleAssetBalancesStreamCursorInput = {
    /** Stream column input with initial value */
    initial_value: CurrentFungibleAssetBalancesStreamCursorValueInput;
    /** cursor ordering */
    ordering?: InputMaybe<CursorOrdering>;
};
/** Initial value of the column from where the streaming should start */
type CurrentFungibleAssetBalancesStreamCursorValueInput = {
    amount?: InputMaybe<Scalars["numeric"]["input"]>;
    asset_type?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    is_frozen?: InputMaybe<Scalars["Boolean"]["input"]>;
    is_primary?: InputMaybe<Scalars["Boolean"]["input"]>;
    last_transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    owner_address?: InputMaybe<Scalars["String"]["input"]>;
    storage_id?: InputMaybe<Scalars["String"]["input"]>;
    token_standard?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregate sum on columns */
type CurrentFungibleAssetBalancesSumFields = {
    amount?: Maybe<Scalars["numeric"]["output"]>;
    last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};
/** update columns of table "current_fungible_asset_balances_legacy" */
declare enum CurrentFungibleAssetBalancesUpdateColumn {
    /** column name */
    Amount = "amount",
    /** column name */
    AssetType = "asset_type",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    IsFrozen = "is_frozen",
    /** column name */
    IsPrimary = "is_primary",
    /** column name */
    LastTransactionTimestamp = "last_transaction_timestamp",
    /** column name */
    LastTransactionVersion = "last_transaction_version",
    /** column name */
    OwnerAddress = "owner_address",
    /** column name */
    StorageId = "storage_id",
    /** column name */
    TokenStandard = "token_standard"
}
type CurrentFungibleAssetBalancesUpdates = {
    /** increments the numeric columns with given value of the filtered values */
    _inc?: InputMaybe<CurrentFungibleAssetBalancesIncInput>;
    /** sets the columns of the filtered rows to the given values */
    _set?: InputMaybe<CurrentFungibleAssetBalancesSetInput>;
    /** filter the rows which have to be updated */
    where: CurrentFungibleAssetBalancesBoolExp;
};
/** aggregate var_pop on columns */
type CurrentFungibleAssetBalancesVarPopFields = {
    amount?: Maybe<Scalars["Float"]["output"]>;
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate var_samp on columns */
type CurrentFungibleAssetBalancesVarSampFields = {
    amount?: Maybe<Scalars["Float"]["output"]>;
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate variance on columns */
type CurrentFungibleAssetBalancesVarianceFields = {
    amount?: Maybe<Scalars["Float"]["output"]>;
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** columns and relationships of "current_objects" */
type CurrentObjects = {
    allow_ungated_transfer: Scalars["Boolean"]["output"];
    inserted_at: Scalars["timestamp"]["output"];
    is_deleted: Scalars["Boolean"]["output"];
    last_guid_creation_num: Scalars["numeric"]["output"];
    last_transaction_version: Scalars["bigint"]["output"];
    object_address: Scalars["String"]["output"];
    owner_address: Scalars["String"]["output"];
    state_key_hash: Scalars["String"]["output"];
    untransferrable: Scalars["Boolean"]["output"];
};
/** aggregated selection of "current_objects" */
type CurrentObjectsAggregate = {
    aggregate?: Maybe<CurrentObjectsAggregateFields>;
    nodes: Array<CurrentObjects>;
};
/** aggregate fields of "current_objects" */
type CurrentObjectsAggregateFields = {
    avg?: Maybe<CurrentObjectsAvgFields>;
    count: Scalars["Int"]["output"];
    max?: Maybe<CurrentObjectsMaxFields>;
    min?: Maybe<CurrentObjectsMinFields>;
    stddev?: Maybe<CurrentObjectsStddevFields>;
    stddev_pop?: Maybe<CurrentObjectsStddevPopFields>;
    stddev_samp?: Maybe<CurrentObjectsStddevSampFields>;
    sum?: Maybe<CurrentObjectsSumFields>;
    var_pop?: Maybe<CurrentObjectsVarPopFields>;
    var_samp?: Maybe<CurrentObjectsVarSampFields>;
    variance?: Maybe<CurrentObjectsVarianceFields>;
};
/** aggregate fields of "current_objects" */
type CurrentObjectsAggregateFieldsCountArgs = {
    columns?: InputMaybe<Array<CurrentObjectsSelectColumn>>;
    distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};
/** aggregate avg on columns */
type CurrentObjectsAvgFields = {
    last_guid_creation_num?: Maybe<Scalars["Float"]["output"]>;
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** Boolean expression to filter rows from the table "current_objects". All fields are combined with a logical 'AND'. */
type CurrentObjectsBoolExp = {
    _and?: InputMaybe<Array<CurrentObjectsBoolExp>>;
    _not?: InputMaybe<CurrentObjectsBoolExp>;
    _or?: InputMaybe<Array<CurrentObjectsBoolExp>>;
    allow_ungated_transfer?: InputMaybe<BooleanComparisonExp>;
    inserted_at?: InputMaybe<TimestampComparisonExp>;
    is_deleted?: InputMaybe<BooleanComparisonExp>;
    last_guid_creation_num?: InputMaybe<NumericComparisonExp>;
    last_transaction_version?: InputMaybe<BigintComparisonExp>;
    object_address?: InputMaybe<StringComparisonExp>;
    owner_address?: InputMaybe<StringComparisonExp>;
    state_key_hash?: InputMaybe<StringComparisonExp>;
    untransferrable?: InputMaybe<BooleanComparisonExp>;
};
/** unique or primary key constraints on table "current_objects" */
declare enum CurrentObjectsConstraint {
    /** unique or primary key constraint on columns "object_address" */
    CurrentObjectsPkey = "current_objects_pkey"
}
/** input type for incrementing numeric columns in table "current_objects" */
type CurrentObjectsIncInput = {
    last_guid_creation_num?: InputMaybe<Scalars["numeric"]["input"]>;
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** input type for inserting data into table "current_objects" */
type CurrentObjectsInsertInput = {
    allow_ungated_transfer?: InputMaybe<Scalars["Boolean"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    is_deleted?: InputMaybe<Scalars["Boolean"]["input"]>;
    last_guid_creation_num?: InputMaybe<Scalars["numeric"]["input"]>;
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    object_address?: InputMaybe<Scalars["String"]["input"]>;
    owner_address?: InputMaybe<Scalars["String"]["input"]>;
    state_key_hash?: InputMaybe<Scalars["String"]["input"]>;
    untransferrable?: InputMaybe<Scalars["Boolean"]["input"]>;
};
/** aggregate max on columns */
type CurrentObjectsMaxFields = {
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    last_guid_creation_num?: Maybe<Scalars["numeric"]["output"]>;
    last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    object_address?: Maybe<Scalars["String"]["output"]>;
    owner_address?: Maybe<Scalars["String"]["output"]>;
    state_key_hash?: Maybe<Scalars["String"]["output"]>;
};
/** aggregate min on columns */
type CurrentObjectsMinFields = {
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    last_guid_creation_num?: Maybe<Scalars["numeric"]["output"]>;
    last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    object_address?: Maybe<Scalars["String"]["output"]>;
    owner_address?: Maybe<Scalars["String"]["output"]>;
    state_key_hash?: Maybe<Scalars["String"]["output"]>;
};
/** response of any mutation on the table "current_objects" */
type CurrentObjectsMutationResponse = {
    /** number of rows affected by the mutation */
    affected_rows: Scalars["Int"]["output"];
    /** data from the rows affected by the mutation */
    returning: Array<CurrentObjects>;
};
/** on_conflict condition type for table "current_objects" */
type CurrentObjectsOnConflict = {
    constraint: CurrentObjectsConstraint;
    update_columns?: Array<CurrentObjectsUpdateColumn>;
    where?: InputMaybe<CurrentObjectsBoolExp>;
};
/** Ordering options when selecting data from "current_objects". */
type CurrentObjectsOrderBy = {
    allow_ungated_transfer?: InputMaybe<OrderBy>;
    inserted_at?: InputMaybe<OrderBy>;
    is_deleted?: InputMaybe<OrderBy>;
    last_guid_creation_num?: InputMaybe<OrderBy>;
    last_transaction_version?: InputMaybe<OrderBy>;
    object_address?: InputMaybe<OrderBy>;
    owner_address?: InputMaybe<OrderBy>;
    state_key_hash?: InputMaybe<OrderBy>;
    untransferrable?: InputMaybe<OrderBy>;
};
/** primary key columns input for table: current_objects */
type CurrentObjectsPkColumnsInput = {
    object_address: Scalars["String"]["input"];
};
/** select columns of table "current_objects" */
declare enum CurrentObjectsSelectColumn {
    /** column name */
    AllowUngatedTransfer = "allow_ungated_transfer",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    IsDeleted = "is_deleted",
    /** column name */
    LastGuidCreationNum = "last_guid_creation_num",
    /** column name */
    LastTransactionVersion = "last_transaction_version",
    /** column name */
    ObjectAddress = "object_address",
    /** column name */
    OwnerAddress = "owner_address",
    /** column name */
    StateKeyHash = "state_key_hash",
    /** column name */
    Untransferrable = "untransferrable"
}
/** input type for updating data in table "current_objects" */
type CurrentObjectsSetInput = {
    allow_ungated_transfer?: InputMaybe<Scalars["Boolean"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    is_deleted?: InputMaybe<Scalars["Boolean"]["input"]>;
    last_guid_creation_num?: InputMaybe<Scalars["numeric"]["input"]>;
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    object_address?: InputMaybe<Scalars["String"]["input"]>;
    owner_address?: InputMaybe<Scalars["String"]["input"]>;
    state_key_hash?: InputMaybe<Scalars["String"]["input"]>;
    untransferrable?: InputMaybe<Scalars["Boolean"]["input"]>;
};
/** aggregate stddev on columns */
type CurrentObjectsStddevFields = {
    last_guid_creation_num?: Maybe<Scalars["Float"]["output"]>;
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_pop on columns */
type CurrentObjectsStddevPopFields = {
    last_guid_creation_num?: Maybe<Scalars["Float"]["output"]>;
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_samp on columns */
type CurrentObjectsStddevSampFields = {
    last_guid_creation_num?: Maybe<Scalars["Float"]["output"]>;
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** Streaming cursor of the table "current_objects" */
type CurrentObjectsStreamCursorInput = {
    /** Stream column input with initial value */
    initial_value: CurrentObjectsStreamCursorValueInput;
    /** cursor ordering */
    ordering?: InputMaybe<CursorOrdering>;
};
/** Initial value of the column from where the streaming should start */
type CurrentObjectsStreamCursorValueInput = {
    allow_ungated_transfer?: InputMaybe<Scalars["Boolean"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    is_deleted?: InputMaybe<Scalars["Boolean"]["input"]>;
    last_guid_creation_num?: InputMaybe<Scalars["numeric"]["input"]>;
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    object_address?: InputMaybe<Scalars["String"]["input"]>;
    owner_address?: InputMaybe<Scalars["String"]["input"]>;
    state_key_hash?: InputMaybe<Scalars["String"]["input"]>;
    untransferrable?: InputMaybe<Scalars["Boolean"]["input"]>;
};
/** aggregate sum on columns */
type CurrentObjectsSumFields = {
    last_guid_creation_num?: Maybe<Scalars["numeric"]["output"]>;
    last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};
/** update columns of table "current_objects" */
declare enum CurrentObjectsUpdateColumn {
    /** column name */
    AllowUngatedTransfer = "allow_ungated_transfer",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    IsDeleted = "is_deleted",
    /** column name */
    LastGuidCreationNum = "last_guid_creation_num",
    /** column name */
    LastTransactionVersion = "last_transaction_version",
    /** column name */
    ObjectAddress = "object_address",
    /** column name */
    OwnerAddress = "owner_address",
    /** column name */
    StateKeyHash = "state_key_hash",
    /** column name */
    Untransferrable = "untransferrable"
}
type CurrentObjectsUpdates = {
    /** increments the numeric columns with given value of the filtered values */
    _inc?: InputMaybe<CurrentObjectsIncInput>;
    /** sets the columns of the filtered rows to the given values */
    _set?: InputMaybe<CurrentObjectsSetInput>;
    /** filter the rows which have to be updated */
    where: CurrentObjectsBoolExp;
};
/** aggregate var_pop on columns */
type CurrentObjectsVarPopFields = {
    last_guid_creation_num?: Maybe<Scalars["Float"]["output"]>;
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate var_samp on columns */
type CurrentObjectsVarSampFields = {
    last_guid_creation_num?: Maybe<Scalars["Float"]["output"]>;
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate variance on columns */
type CurrentObjectsVarianceFields = {
    last_guid_creation_num?: Maybe<Scalars["Float"]["output"]>;
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** columns and relationships of "current_staking_pool_voter" */
type CurrentStakingPoolVoter = {
    inserted_at: Scalars["timestamp"]["output"];
    last_transaction_version: Scalars["bigint"]["output"];
    operator_address: Scalars["String"]["output"];
    /** An array relationship */
    operator_cedra_name: Array<CurrentCedraNames>;
    /** An aggregate relationship */
    operator_cedra_name_aggregate: CurrentCedraNamesAggregate;
    staking_pool_address: Scalars["String"]["output"];
    voter_address: Scalars["String"]["output"];
};
/** columns and relationships of "current_staking_pool_voter" */
type CurrentStakingPoolVoterOperatorCedraNameArgs = {
    distinct_on?: InputMaybe<Array<CurrentCedraNamesSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentCedraNamesOrderBy>>;
    where?: InputMaybe<CurrentCedraNamesBoolExp>;
};
/** columns and relationships of "current_staking_pool_voter" */
type CurrentStakingPoolVoterOperatorCedraNameAggregateArgs = {
    distinct_on?: InputMaybe<Array<CurrentCedraNamesSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentCedraNamesOrderBy>>;
    where?: InputMaybe<CurrentCedraNamesBoolExp>;
};
/** aggregated selection of "current_staking_pool_voter" */
type CurrentStakingPoolVoterAggregate = {
    aggregate?: Maybe<CurrentStakingPoolVoterAggregateFields>;
    nodes: Array<CurrentStakingPoolVoter>;
};
/** aggregate fields of "current_staking_pool_voter" */
type CurrentStakingPoolVoterAggregateFields = {
    avg?: Maybe<CurrentStakingPoolVoterAvgFields>;
    count: Scalars["Int"]["output"];
    max?: Maybe<CurrentStakingPoolVoterMaxFields>;
    min?: Maybe<CurrentStakingPoolVoterMinFields>;
    stddev?: Maybe<CurrentStakingPoolVoterStddevFields>;
    stddev_pop?: Maybe<CurrentStakingPoolVoterStddevPopFields>;
    stddev_samp?: Maybe<CurrentStakingPoolVoterStddevSampFields>;
    sum?: Maybe<CurrentStakingPoolVoterSumFields>;
    var_pop?: Maybe<CurrentStakingPoolVoterVarPopFields>;
    var_samp?: Maybe<CurrentStakingPoolVoterVarSampFields>;
    variance?: Maybe<CurrentStakingPoolVoterVarianceFields>;
};
/** aggregate fields of "current_staking_pool_voter" */
type CurrentStakingPoolVoterAggregateFieldsCountArgs = {
    columns?: InputMaybe<Array<CurrentStakingPoolVoterSelectColumn>>;
    distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};
/** aggregate avg on columns */
type CurrentStakingPoolVoterAvgFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** Boolean expression to filter rows from the table "current_staking_pool_voter". All fields are combined with a logical 'AND'. */
type CurrentStakingPoolVoterBoolExp = {
    _and?: InputMaybe<Array<CurrentStakingPoolVoterBoolExp>>;
    _not?: InputMaybe<CurrentStakingPoolVoterBoolExp>;
    _or?: InputMaybe<Array<CurrentStakingPoolVoterBoolExp>>;
    inserted_at?: InputMaybe<TimestampComparisonExp>;
    last_transaction_version?: InputMaybe<BigintComparisonExp>;
    operator_address?: InputMaybe<StringComparisonExp>;
    operator_cedra_name?: InputMaybe<CurrentCedraNamesBoolExp>;
    operator_cedra_name_aggregate?: InputMaybe<CurrentCedraNamesAggregateBoolExp>;
    staking_pool_address?: InputMaybe<StringComparisonExp>;
    voter_address?: InputMaybe<StringComparisonExp>;
};
/** unique or primary key constraints on table "current_staking_pool_voter" */
declare enum CurrentStakingPoolVoterConstraint {
    /** unique or primary key constraint on columns "staking_pool_address" */
    CurrentStakingPoolVoterPkey = "current_staking_pool_voter_pkey"
}
/** input type for incrementing numeric columns in table "current_staking_pool_voter" */
type CurrentStakingPoolVoterIncInput = {
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** input type for inserting data into table "current_staking_pool_voter" */
type CurrentStakingPoolVoterInsertInput = {
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    operator_address?: InputMaybe<Scalars["String"]["input"]>;
    operator_cedra_name?: InputMaybe<CurrentCedraNamesArrRelInsertInput>;
    staking_pool_address?: InputMaybe<Scalars["String"]["input"]>;
    voter_address?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregate max on columns */
type CurrentStakingPoolVoterMaxFields = {
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    operator_address?: Maybe<Scalars["String"]["output"]>;
    staking_pool_address?: Maybe<Scalars["String"]["output"]>;
    voter_address?: Maybe<Scalars["String"]["output"]>;
};
/** aggregate min on columns */
type CurrentStakingPoolVoterMinFields = {
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    operator_address?: Maybe<Scalars["String"]["output"]>;
    staking_pool_address?: Maybe<Scalars["String"]["output"]>;
    voter_address?: Maybe<Scalars["String"]["output"]>;
};
/** response of any mutation on the table "current_staking_pool_voter" */
type CurrentStakingPoolVoterMutationResponse = {
    /** number of rows affected by the mutation */
    affected_rows: Scalars["Int"]["output"];
    /** data from the rows affected by the mutation */
    returning: Array<CurrentStakingPoolVoter>;
};
/** input type for inserting object relation for remote table "current_staking_pool_voter" */
type CurrentStakingPoolVoterObjRelInsertInput = {
    data: CurrentStakingPoolVoterInsertInput;
    /** upsert condition */
    on_conflict?: InputMaybe<CurrentStakingPoolVoterOnConflict>;
};
/** on_conflict condition type for table "current_staking_pool_voter" */
type CurrentStakingPoolVoterOnConflict = {
    constraint: CurrentStakingPoolVoterConstraint;
    update_columns?: Array<CurrentStakingPoolVoterUpdateColumn>;
    where?: InputMaybe<CurrentStakingPoolVoterBoolExp>;
};
/** Ordering options when selecting data from "current_staking_pool_voter". */
type CurrentStakingPoolVoterOrderBy = {
    inserted_at?: InputMaybe<OrderBy>;
    last_transaction_version?: InputMaybe<OrderBy>;
    operator_address?: InputMaybe<OrderBy>;
    operator_cedra_name_aggregate?: InputMaybe<CurrentCedraNamesAggregateOrderBy>;
    staking_pool_address?: InputMaybe<OrderBy>;
    voter_address?: InputMaybe<OrderBy>;
};
/** primary key columns input for table: current_staking_pool_voter */
type CurrentStakingPoolVoterPkColumnsInput = {
    staking_pool_address: Scalars["String"]["input"];
};
/** select columns of table "current_staking_pool_voter" */
declare enum CurrentStakingPoolVoterSelectColumn {
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    LastTransactionVersion = "last_transaction_version",
    /** column name */
    OperatorAddress = "operator_address",
    /** column name */
    StakingPoolAddress = "staking_pool_address",
    /** column name */
    VoterAddress = "voter_address"
}
/** input type for updating data in table "current_staking_pool_voter" */
type CurrentStakingPoolVoterSetInput = {
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    operator_address?: InputMaybe<Scalars["String"]["input"]>;
    staking_pool_address?: InputMaybe<Scalars["String"]["input"]>;
    voter_address?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregate stddev on columns */
type CurrentStakingPoolVoterStddevFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_pop on columns */
type CurrentStakingPoolVoterStddevPopFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_samp on columns */
type CurrentStakingPoolVoterStddevSampFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** Streaming cursor of the table "current_staking_pool_voter" */
type CurrentStakingPoolVoterStreamCursorInput = {
    /** Stream column input with initial value */
    initial_value: CurrentStakingPoolVoterStreamCursorValueInput;
    /** cursor ordering */
    ordering?: InputMaybe<CursorOrdering>;
};
/** Initial value of the column from where the streaming should start */
type CurrentStakingPoolVoterStreamCursorValueInput = {
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    operator_address?: InputMaybe<Scalars["String"]["input"]>;
    staking_pool_address?: InputMaybe<Scalars["String"]["input"]>;
    voter_address?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregate sum on columns */
type CurrentStakingPoolVoterSumFields = {
    last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};
/** update columns of table "current_staking_pool_voter" */
declare enum CurrentStakingPoolVoterUpdateColumn {
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    LastTransactionVersion = "last_transaction_version",
    /** column name */
    OperatorAddress = "operator_address",
    /** column name */
    StakingPoolAddress = "staking_pool_address",
    /** column name */
    VoterAddress = "voter_address"
}
type CurrentStakingPoolVoterUpdates = {
    /** increments the numeric columns with given value of the filtered values */
    _inc?: InputMaybe<CurrentStakingPoolVoterIncInput>;
    /** sets the columns of the filtered rows to the given values */
    _set?: InputMaybe<CurrentStakingPoolVoterSetInput>;
    /** filter the rows which have to be updated */
    where: CurrentStakingPoolVoterBoolExp;
};
/** aggregate var_pop on columns */
type CurrentStakingPoolVoterVarPopFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate var_samp on columns */
type CurrentStakingPoolVoterVarSampFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate variance on columns */
type CurrentStakingPoolVoterVarianceFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** columns and relationships of "current_table_items" */
type CurrentTableItems = {
    decoded_key: Scalars["jsonb"]["output"];
    decoded_value?: Maybe<Scalars["jsonb"]["output"]>;
    inserted_at: Scalars["timestamp"]["output"];
    is_deleted: Scalars["Boolean"]["output"];
    key: Scalars["String"]["output"];
    key_hash: Scalars["String"]["output"];
    last_transaction_version: Scalars["bigint"]["output"];
    table_handle: Scalars["String"]["output"];
};
/** columns and relationships of "current_table_items" */
type CurrentTableItemsDecodedKeyArgs = {
    path?: InputMaybe<Scalars["String"]["input"]>;
};
/** columns and relationships of "current_table_items" */
type CurrentTableItemsDecodedValueArgs = {
    path?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregated selection of "current_table_items" */
type CurrentTableItemsAggregate = {
    aggregate?: Maybe<CurrentTableItemsAggregateFields>;
    nodes: Array<CurrentTableItems>;
};
/** aggregate fields of "current_table_items" */
type CurrentTableItemsAggregateFields = {
    avg?: Maybe<CurrentTableItemsAvgFields>;
    count: Scalars["Int"]["output"];
    max?: Maybe<CurrentTableItemsMaxFields>;
    min?: Maybe<CurrentTableItemsMinFields>;
    stddev?: Maybe<CurrentTableItemsStddevFields>;
    stddev_pop?: Maybe<CurrentTableItemsStddevPopFields>;
    stddev_samp?: Maybe<CurrentTableItemsStddevSampFields>;
    sum?: Maybe<CurrentTableItemsSumFields>;
    var_pop?: Maybe<CurrentTableItemsVarPopFields>;
    var_samp?: Maybe<CurrentTableItemsVarSampFields>;
    variance?: Maybe<CurrentTableItemsVarianceFields>;
};
/** aggregate fields of "current_table_items" */
type CurrentTableItemsAggregateFieldsCountArgs = {
    columns?: InputMaybe<Array<CurrentTableItemsSelectColumn>>;
    distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};
/** append existing jsonb value of filtered columns with new jsonb value */
type CurrentTableItemsAppendInput = {
    decoded_key?: InputMaybe<Scalars["jsonb"]["input"]>;
    decoded_value?: InputMaybe<Scalars["jsonb"]["input"]>;
};
/** aggregate avg on columns */
type CurrentTableItemsAvgFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** Boolean expression to filter rows from the table "current_table_items". All fields are combined with a logical 'AND'. */
type CurrentTableItemsBoolExp = {
    _and?: InputMaybe<Array<CurrentTableItemsBoolExp>>;
    _not?: InputMaybe<CurrentTableItemsBoolExp>;
    _or?: InputMaybe<Array<CurrentTableItemsBoolExp>>;
    decoded_key?: InputMaybe<JsonbComparisonExp>;
    decoded_value?: InputMaybe<JsonbComparisonExp>;
    inserted_at?: InputMaybe<TimestampComparisonExp>;
    is_deleted?: InputMaybe<BooleanComparisonExp>;
    key?: InputMaybe<StringComparisonExp>;
    key_hash?: InputMaybe<StringComparisonExp>;
    last_transaction_version?: InputMaybe<BigintComparisonExp>;
    table_handle?: InputMaybe<StringComparisonExp>;
};
/** unique or primary key constraints on table "current_table_items" */
declare enum CurrentTableItemsConstraint {
    /** unique or primary key constraint on columns "key_hash", "table_handle" */
    CurrentTableItemsPkey = "current_table_items_pkey"
}
/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
type CurrentTableItemsDeleteAtPathInput = {
    decoded_key?: InputMaybe<Array<Scalars["String"]["input"]>>;
    decoded_value?: InputMaybe<Array<Scalars["String"]["input"]>>;
};
/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
type CurrentTableItemsDeleteElemInput = {
    decoded_key?: InputMaybe<Scalars["Int"]["input"]>;
    decoded_value?: InputMaybe<Scalars["Int"]["input"]>;
};
/** delete key/value pair or string element. key/value pairs are matched based on their key value */
type CurrentTableItemsDeleteKeyInput = {
    decoded_key?: InputMaybe<Scalars["String"]["input"]>;
    decoded_value?: InputMaybe<Scalars["String"]["input"]>;
};
/** input type for incrementing numeric columns in table "current_table_items" */
type CurrentTableItemsIncInput = {
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** input type for inserting data into table "current_table_items" */
type CurrentTableItemsInsertInput = {
    decoded_key?: InputMaybe<Scalars["jsonb"]["input"]>;
    decoded_value?: InputMaybe<Scalars["jsonb"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    is_deleted?: InputMaybe<Scalars["Boolean"]["input"]>;
    key?: InputMaybe<Scalars["String"]["input"]>;
    key_hash?: InputMaybe<Scalars["String"]["input"]>;
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    table_handle?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregate max on columns */
type CurrentTableItemsMaxFields = {
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    key?: Maybe<Scalars["String"]["output"]>;
    key_hash?: Maybe<Scalars["String"]["output"]>;
    last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    table_handle?: Maybe<Scalars["String"]["output"]>;
};
/** aggregate min on columns */
type CurrentTableItemsMinFields = {
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    key?: Maybe<Scalars["String"]["output"]>;
    key_hash?: Maybe<Scalars["String"]["output"]>;
    last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    table_handle?: Maybe<Scalars["String"]["output"]>;
};
/** response of any mutation on the table "current_table_items" */
type CurrentTableItemsMutationResponse = {
    /** number of rows affected by the mutation */
    affected_rows: Scalars["Int"]["output"];
    /** data from the rows affected by the mutation */
    returning: Array<CurrentTableItems>;
};
/** on_conflict condition type for table "current_table_items" */
type CurrentTableItemsOnConflict = {
    constraint: CurrentTableItemsConstraint;
    update_columns?: Array<CurrentTableItemsUpdateColumn>;
    where?: InputMaybe<CurrentTableItemsBoolExp>;
};
/** Ordering options when selecting data from "current_table_items". */
type CurrentTableItemsOrderBy = {
    decoded_key?: InputMaybe<OrderBy>;
    decoded_value?: InputMaybe<OrderBy>;
    inserted_at?: InputMaybe<OrderBy>;
    is_deleted?: InputMaybe<OrderBy>;
    key?: InputMaybe<OrderBy>;
    key_hash?: InputMaybe<OrderBy>;
    last_transaction_version?: InputMaybe<OrderBy>;
    table_handle?: InputMaybe<OrderBy>;
};
/** primary key columns input for table: current_table_items */
type CurrentTableItemsPkColumnsInput = {
    key_hash: Scalars["String"]["input"];
    table_handle: Scalars["String"]["input"];
};
/** prepend existing jsonb value of filtered columns with new jsonb value */
type CurrentTableItemsPrependInput = {
    decoded_key?: InputMaybe<Scalars["jsonb"]["input"]>;
    decoded_value?: InputMaybe<Scalars["jsonb"]["input"]>;
};
/** select columns of table "current_table_items" */
declare enum CurrentTableItemsSelectColumn {
    /** column name */
    DecodedKey = "decoded_key",
    /** column name */
    DecodedValue = "decoded_value",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    IsDeleted = "is_deleted",
    /** column name */
    Key = "key",
    /** column name */
    KeyHash = "key_hash",
    /** column name */
    LastTransactionVersion = "last_transaction_version",
    /** column name */
    TableHandle = "table_handle"
}
/** input type for updating data in table "current_table_items" */
type CurrentTableItemsSetInput = {
    decoded_key?: InputMaybe<Scalars["jsonb"]["input"]>;
    decoded_value?: InputMaybe<Scalars["jsonb"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    is_deleted?: InputMaybe<Scalars["Boolean"]["input"]>;
    key?: InputMaybe<Scalars["String"]["input"]>;
    key_hash?: InputMaybe<Scalars["String"]["input"]>;
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    table_handle?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregate stddev on columns */
type CurrentTableItemsStddevFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_pop on columns */
type CurrentTableItemsStddevPopFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_samp on columns */
type CurrentTableItemsStddevSampFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** Streaming cursor of the table "current_table_items" */
type CurrentTableItemsStreamCursorInput = {
    /** Stream column input with initial value */
    initial_value: CurrentTableItemsStreamCursorValueInput;
    /** cursor ordering */
    ordering?: InputMaybe<CursorOrdering>;
};
/** Initial value of the column from where the streaming should start */
type CurrentTableItemsStreamCursorValueInput = {
    decoded_key?: InputMaybe<Scalars["jsonb"]["input"]>;
    decoded_value?: InputMaybe<Scalars["jsonb"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    is_deleted?: InputMaybe<Scalars["Boolean"]["input"]>;
    key?: InputMaybe<Scalars["String"]["input"]>;
    key_hash?: InputMaybe<Scalars["String"]["input"]>;
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    table_handle?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregate sum on columns */
type CurrentTableItemsSumFields = {
    last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};
/** update columns of table "current_table_items" */
declare enum CurrentTableItemsUpdateColumn {
    /** column name */
    DecodedKey = "decoded_key",
    /** column name */
    DecodedValue = "decoded_value",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    IsDeleted = "is_deleted",
    /** column name */
    Key = "key",
    /** column name */
    KeyHash = "key_hash",
    /** column name */
    LastTransactionVersion = "last_transaction_version",
    /** column name */
    TableHandle = "table_handle"
}
type CurrentTableItemsUpdates = {
    /** append existing jsonb value of filtered columns with new jsonb value */
    _append?: InputMaybe<CurrentTableItemsAppendInput>;
    /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
    _delete_at_path?: InputMaybe<CurrentTableItemsDeleteAtPathInput>;
    /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
    _delete_elem?: InputMaybe<CurrentTableItemsDeleteElemInput>;
    /** delete key/value pair or string element. key/value pairs are matched based on their key value */
    _delete_key?: InputMaybe<CurrentTableItemsDeleteKeyInput>;
    /** increments the numeric columns with given value of the filtered values */
    _inc?: InputMaybe<CurrentTableItemsIncInput>;
    /** prepend existing jsonb value of filtered columns with new jsonb value */
    _prepend?: InputMaybe<CurrentTableItemsPrependInput>;
    /** sets the columns of the filtered rows to the given values */
    _set?: InputMaybe<CurrentTableItemsSetInput>;
    /** filter the rows which have to be updated */
    where: CurrentTableItemsBoolExp;
};
/** aggregate var_pop on columns */
type CurrentTableItemsVarPopFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate var_samp on columns */
type CurrentTableItemsVarSampFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate variance on columns */
type CurrentTableItemsVarianceFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** columns and relationships of "current_table_items_view" */
type CurrentTableItemsView = {
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    is_deleted?: Maybe<Scalars["Boolean"]["output"]>;
    json_decoded_key?: Maybe<Scalars["String"]["output"]>;
    json_decoded_value?: Maybe<Scalars["String"]["output"]>;
    key?: Maybe<Scalars["String"]["output"]>;
    key_hash?: Maybe<Scalars["String"]["output"]>;
    last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    table_handle?: Maybe<Scalars["String"]["output"]>;
};
/** aggregated selection of "current_table_items_view" */
type CurrentTableItemsViewAggregate = {
    aggregate?: Maybe<CurrentTableItemsViewAggregateFields>;
    nodes: Array<CurrentTableItemsView>;
};
/** aggregate fields of "current_table_items_view" */
type CurrentTableItemsViewAggregateFields = {
    avg?: Maybe<CurrentTableItemsViewAvgFields>;
    count: Scalars["Int"]["output"];
    max?: Maybe<CurrentTableItemsViewMaxFields>;
    min?: Maybe<CurrentTableItemsViewMinFields>;
    stddev?: Maybe<CurrentTableItemsViewStddevFields>;
    stddev_pop?: Maybe<CurrentTableItemsViewStddevPopFields>;
    stddev_samp?: Maybe<CurrentTableItemsViewStddevSampFields>;
    sum?: Maybe<CurrentTableItemsViewSumFields>;
    var_pop?: Maybe<CurrentTableItemsViewVarPopFields>;
    var_samp?: Maybe<CurrentTableItemsViewVarSampFields>;
    variance?: Maybe<CurrentTableItemsViewVarianceFields>;
};
/** aggregate fields of "current_table_items_view" */
type CurrentTableItemsViewAggregateFieldsCountArgs = {
    columns?: InputMaybe<Array<CurrentTableItemsViewSelectColumn>>;
    distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};
/** aggregate avg on columns */
type CurrentTableItemsViewAvgFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** Boolean expression to filter rows from the table "current_table_items_view". All fields are combined with a logical 'AND'. */
type CurrentTableItemsViewBoolExp = {
    _and?: InputMaybe<Array<CurrentTableItemsViewBoolExp>>;
    _not?: InputMaybe<CurrentTableItemsViewBoolExp>;
    _or?: InputMaybe<Array<CurrentTableItemsViewBoolExp>>;
    inserted_at?: InputMaybe<TimestampComparisonExp>;
    is_deleted?: InputMaybe<BooleanComparisonExp>;
    json_decoded_key?: InputMaybe<StringComparisonExp>;
    json_decoded_value?: InputMaybe<StringComparisonExp>;
    key?: InputMaybe<StringComparisonExp>;
    key_hash?: InputMaybe<StringComparisonExp>;
    last_transaction_version?: InputMaybe<BigintComparisonExp>;
    table_handle?: InputMaybe<StringComparisonExp>;
};
/** input type for incrementing numeric columns in table "current_table_items_view" */
type CurrentTableItemsViewIncInput = {
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** input type for inserting data into table "current_table_items_view" */
type CurrentTableItemsViewInsertInput = {
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    is_deleted?: InputMaybe<Scalars["Boolean"]["input"]>;
    json_decoded_key?: InputMaybe<Scalars["String"]["input"]>;
    json_decoded_value?: InputMaybe<Scalars["String"]["input"]>;
    key?: InputMaybe<Scalars["String"]["input"]>;
    key_hash?: InputMaybe<Scalars["String"]["input"]>;
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    table_handle?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregate max on columns */
type CurrentTableItemsViewMaxFields = {
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    json_decoded_key?: Maybe<Scalars["String"]["output"]>;
    json_decoded_value?: Maybe<Scalars["String"]["output"]>;
    key?: Maybe<Scalars["String"]["output"]>;
    key_hash?: Maybe<Scalars["String"]["output"]>;
    last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    table_handle?: Maybe<Scalars["String"]["output"]>;
};
/** aggregate min on columns */
type CurrentTableItemsViewMinFields = {
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    json_decoded_key?: Maybe<Scalars["String"]["output"]>;
    json_decoded_value?: Maybe<Scalars["String"]["output"]>;
    key?: Maybe<Scalars["String"]["output"]>;
    key_hash?: Maybe<Scalars["String"]["output"]>;
    last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    table_handle?: Maybe<Scalars["String"]["output"]>;
};
/** response of any mutation on the table "current_table_items_view" */
type CurrentTableItemsViewMutationResponse = {
    /** number of rows affected by the mutation */
    affected_rows: Scalars["Int"]["output"];
    /** data from the rows affected by the mutation */
    returning: Array<CurrentTableItemsView>;
};
/** Ordering options when selecting data from "current_table_items_view". */
type CurrentTableItemsViewOrderBy = {
    inserted_at?: InputMaybe<OrderBy>;
    is_deleted?: InputMaybe<OrderBy>;
    json_decoded_key?: InputMaybe<OrderBy>;
    json_decoded_value?: InputMaybe<OrderBy>;
    key?: InputMaybe<OrderBy>;
    key_hash?: InputMaybe<OrderBy>;
    last_transaction_version?: InputMaybe<OrderBy>;
    table_handle?: InputMaybe<OrderBy>;
};
/** select columns of table "current_table_items_view" */
declare enum CurrentTableItemsViewSelectColumn {
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    IsDeleted = "is_deleted",
    /** column name */
    JsonDecodedKey = "json_decoded_key",
    /** column name */
    JsonDecodedValue = "json_decoded_value",
    /** column name */
    Key = "key",
    /** column name */
    KeyHash = "key_hash",
    /** column name */
    LastTransactionVersion = "last_transaction_version",
    /** column name */
    TableHandle = "table_handle"
}
/** input type for updating data in table "current_table_items_view" */
type CurrentTableItemsViewSetInput = {
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    is_deleted?: InputMaybe<Scalars["Boolean"]["input"]>;
    json_decoded_key?: InputMaybe<Scalars["String"]["input"]>;
    json_decoded_value?: InputMaybe<Scalars["String"]["input"]>;
    key?: InputMaybe<Scalars["String"]["input"]>;
    key_hash?: InputMaybe<Scalars["String"]["input"]>;
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    table_handle?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregate stddev on columns */
type CurrentTableItemsViewStddevFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_pop on columns */
type CurrentTableItemsViewStddevPopFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_samp on columns */
type CurrentTableItemsViewStddevSampFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** Streaming cursor of the table "current_table_items_view" */
type CurrentTableItemsViewStreamCursorInput = {
    /** Stream column input with initial value */
    initial_value: CurrentTableItemsViewStreamCursorValueInput;
    /** cursor ordering */
    ordering?: InputMaybe<CursorOrdering>;
};
/** Initial value of the column from where the streaming should start */
type CurrentTableItemsViewStreamCursorValueInput = {
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    is_deleted?: InputMaybe<Scalars["Boolean"]["input"]>;
    json_decoded_key?: InputMaybe<Scalars["String"]["input"]>;
    json_decoded_value?: InputMaybe<Scalars["String"]["input"]>;
    key?: InputMaybe<Scalars["String"]["input"]>;
    key_hash?: InputMaybe<Scalars["String"]["input"]>;
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    table_handle?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregate sum on columns */
type CurrentTableItemsViewSumFields = {
    last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};
type CurrentTableItemsViewUpdates = {
    /** increments the numeric columns with given value of the filtered values */
    _inc?: InputMaybe<CurrentTableItemsViewIncInput>;
    /** sets the columns of the filtered rows to the given values */
    _set?: InputMaybe<CurrentTableItemsViewSetInput>;
    /** filter the rows which have to be updated */
    where: CurrentTableItemsViewBoolExp;
};
/** aggregate var_pop on columns */
type CurrentTableItemsViewVarPopFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate var_samp on columns */
type CurrentTableItemsViewVarSampFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate variance on columns */
type CurrentTableItemsViewVarianceFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** columns and relationships of "current_token_datas" */
type CurrentTokenDatas = {
    collection_data_id_hash: Scalars["String"]["output"];
    collection_name: Scalars["String"]["output"];
    creator_address: Scalars["String"]["output"];
    default_properties: Scalars["jsonb"]["output"];
    description: Scalars["String"]["output"];
    description_mutable: Scalars["Boolean"]["output"];
    inserted_at: Scalars["timestamp"]["output"];
    largest_property_version: Scalars["numeric"]["output"];
    last_transaction_timestamp: Scalars["timestamp"]["output"];
    last_transaction_version: Scalars["bigint"]["output"];
    maximum: Scalars["numeric"]["output"];
    maximum_mutable: Scalars["Boolean"]["output"];
    metadata_uri: Scalars["String"]["output"];
    name: Scalars["String"]["output"];
    payee_address: Scalars["String"]["output"];
    properties_mutable: Scalars["Boolean"]["output"];
    royalty_mutable: Scalars["Boolean"]["output"];
    royalty_points_denominator: Scalars["numeric"]["output"];
    royalty_points_numerator: Scalars["numeric"]["output"];
    supply: Scalars["numeric"]["output"];
    token_data_id_hash: Scalars["String"]["output"];
    uri_mutable: Scalars["Boolean"]["output"];
};
/** columns and relationships of "current_token_datas" */
type CurrentTokenDatasDefaultPropertiesArgs = {
    path?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregated selection of "current_token_datas" */
type CurrentTokenDatasAggregate = {
    aggregate?: Maybe<CurrentTokenDatasAggregateFields>;
    nodes: Array<CurrentTokenDatas>;
};
/** aggregate fields of "current_token_datas" */
type CurrentTokenDatasAggregateFields = {
    avg?: Maybe<CurrentTokenDatasAvgFields>;
    count: Scalars["Int"]["output"];
    max?: Maybe<CurrentTokenDatasMaxFields>;
    min?: Maybe<CurrentTokenDatasMinFields>;
    stddev?: Maybe<CurrentTokenDatasStddevFields>;
    stddev_pop?: Maybe<CurrentTokenDatasStddevPopFields>;
    stddev_samp?: Maybe<CurrentTokenDatasStddevSampFields>;
    sum?: Maybe<CurrentTokenDatasSumFields>;
    var_pop?: Maybe<CurrentTokenDatasVarPopFields>;
    var_samp?: Maybe<CurrentTokenDatasVarSampFields>;
    variance?: Maybe<CurrentTokenDatasVarianceFields>;
};
/** aggregate fields of "current_token_datas" */
type CurrentTokenDatasAggregateFieldsCountArgs = {
    columns?: InputMaybe<Array<CurrentTokenDatasSelectColumn>>;
    distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};
/** append existing jsonb value of filtered columns with new jsonb value */
type CurrentTokenDatasAppendInput = {
    default_properties?: InputMaybe<Scalars["jsonb"]["input"]>;
};
/** aggregate avg on columns */
type CurrentTokenDatasAvgFields = {
    largest_property_version?: Maybe<Scalars["Float"]["output"]>;
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
    maximum?: Maybe<Scalars["Float"]["output"]>;
    royalty_points_denominator?: Maybe<Scalars["Float"]["output"]>;
    royalty_points_numerator?: Maybe<Scalars["Float"]["output"]>;
    supply?: Maybe<Scalars["Float"]["output"]>;
};
/** Boolean expression to filter rows from the table "current_token_datas". All fields are combined with a logical 'AND'. */
type CurrentTokenDatasBoolExp = {
    _and?: InputMaybe<Array<CurrentTokenDatasBoolExp>>;
    _not?: InputMaybe<CurrentTokenDatasBoolExp>;
    _or?: InputMaybe<Array<CurrentTokenDatasBoolExp>>;
    collection_data_id_hash?: InputMaybe<StringComparisonExp>;
    collection_name?: InputMaybe<StringComparisonExp>;
    creator_address?: InputMaybe<StringComparisonExp>;
    default_properties?: InputMaybe<JsonbComparisonExp>;
    description?: InputMaybe<StringComparisonExp>;
    description_mutable?: InputMaybe<BooleanComparisonExp>;
    inserted_at?: InputMaybe<TimestampComparisonExp>;
    largest_property_version?: InputMaybe<NumericComparisonExp>;
    last_transaction_timestamp?: InputMaybe<TimestampComparisonExp>;
    last_transaction_version?: InputMaybe<BigintComparisonExp>;
    maximum?: InputMaybe<NumericComparisonExp>;
    maximum_mutable?: InputMaybe<BooleanComparisonExp>;
    metadata_uri?: InputMaybe<StringComparisonExp>;
    name?: InputMaybe<StringComparisonExp>;
    payee_address?: InputMaybe<StringComparisonExp>;
    properties_mutable?: InputMaybe<BooleanComparisonExp>;
    royalty_mutable?: InputMaybe<BooleanComparisonExp>;
    royalty_points_denominator?: InputMaybe<NumericComparisonExp>;
    royalty_points_numerator?: InputMaybe<NumericComparisonExp>;
    supply?: InputMaybe<NumericComparisonExp>;
    token_data_id_hash?: InputMaybe<StringComparisonExp>;
    uri_mutable?: InputMaybe<BooleanComparisonExp>;
};
/** unique or primary key constraints on table "current_token_datas" */
declare enum CurrentTokenDatasConstraint {
    /** unique or primary key constraint on columns "token_data_id_hash" */
    CurrentTokenDatasPkey = "current_token_datas_pkey"
}
/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
type CurrentTokenDatasDeleteAtPathInput = {
    default_properties?: InputMaybe<Array<Scalars["String"]["input"]>>;
};
/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
type CurrentTokenDatasDeleteElemInput = {
    default_properties?: InputMaybe<Scalars["Int"]["input"]>;
};
/** delete key/value pair or string element. key/value pairs are matched based on their key value */
type CurrentTokenDatasDeleteKeyInput = {
    default_properties?: InputMaybe<Scalars["String"]["input"]>;
};
/** input type for incrementing numeric columns in table "current_token_datas" */
type CurrentTokenDatasIncInput = {
    largest_property_version?: InputMaybe<Scalars["numeric"]["input"]>;
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    maximum?: InputMaybe<Scalars["numeric"]["input"]>;
    royalty_points_denominator?: InputMaybe<Scalars["numeric"]["input"]>;
    royalty_points_numerator?: InputMaybe<Scalars["numeric"]["input"]>;
    supply?: InputMaybe<Scalars["numeric"]["input"]>;
};
/** input type for inserting data into table "current_token_datas" */
type CurrentTokenDatasInsertInput = {
    collection_data_id_hash?: InputMaybe<Scalars["String"]["input"]>;
    collection_name?: InputMaybe<Scalars["String"]["input"]>;
    creator_address?: InputMaybe<Scalars["String"]["input"]>;
    default_properties?: InputMaybe<Scalars["jsonb"]["input"]>;
    description?: InputMaybe<Scalars["String"]["input"]>;
    description_mutable?: InputMaybe<Scalars["Boolean"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    largest_property_version?: InputMaybe<Scalars["numeric"]["input"]>;
    last_transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    maximum?: InputMaybe<Scalars["numeric"]["input"]>;
    maximum_mutable?: InputMaybe<Scalars["Boolean"]["input"]>;
    metadata_uri?: InputMaybe<Scalars["String"]["input"]>;
    name?: InputMaybe<Scalars["String"]["input"]>;
    payee_address?: InputMaybe<Scalars["String"]["input"]>;
    properties_mutable?: InputMaybe<Scalars["Boolean"]["input"]>;
    royalty_mutable?: InputMaybe<Scalars["Boolean"]["input"]>;
    royalty_points_denominator?: InputMaybe<Scalars["numeric"]["input"]>;
    royalty_points_numerator?: InputMaybe<Scalars["numeric"]["input"]>;
    supply?: InputMaybe<Scalars["numeric"]["input"]>;
    token_data_id_hash?: InputMaybe<Scalars["String"]["input"]>;
    uri_mutable?: InputMaybe<Scalars["Boolean"]["input"]>;
};
/** aggregate max on columns */
type CurrentTokenDatasMaxFields = {
    collection_data_id_hash?: Maybe<Scalars["String"]["output"]>;
    collection_name?: Maybe<Scalars["String"]["output"]>;
    creator_address?: Maybe<Scalars["String"]["output"]>;
    description?: Maybe<Scalars["String"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    largest_property_version?: Maybe<Scalars["numeric"]["output"]>;
    last_transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
    last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    maximum?: Maybe<Scalars["numeric"]["output"]>;
    metadata_uri?: Maybe<Scalars["String"]["output"]>;
    name?: Maybe<Scalars["String"]["output"]>;
    payee_address?: Maybe<Scalars["String"]["output"]>;
    royalty_points_denominator?: Maybe<Scalars["numeric"]["output"]>;
    royalty_points_numerator?: Maybe<Scalars["numeric"]["output"]>;
    supply?: Maybe<Scalars["numeric"]["output"]>;
    token_data_id_hash?: Maybe<Scalars["String"]["output"]>;
};
/** aggregate min on columns */
type CurrentTokenDatasMinFields = {
    collection_data_id_hash?: Maybe<Scalars["String"]["output"]>;
    collection_name?: Maybe<Scalars["String"]["output"]>;
    creator_address?: Maybe<Scalars["String"]["output"]>;
    description?: Maybe<Scalars["String"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    largest_property_version?: Maybe<Scalars["numeric"]["output"]>;
    last_transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
    last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    maximum?: Maybe<Scalars["numeric"]["output"]>;
    metadata_uri?: Maybe<Scalars["String"]["output"]>;
    name?: Maybe<Scalars["String"]["output"]>;
    payee_address?: Maybe<Scalars["String"]["output"]>;
    royalty_points_denominator?: Maybe<Scalars["numeric"]["output"]>;
    royalty_points_numerator?: Maybe<Scalars["numeric"]["output"]>;
    supply?: Maybe<Scalars["numeric"]["output"]>;
    token_data_id_hash?: Maybe<Scalars["String"]["output"]>;
};
/** response of any mutation on the table "current_token_datas" */
type CurrentTokenDatasMutationResponse = {
    /** number of rows affected by the mutation */
    affected_rows: Scalars["Int"]["output"];
    /** data from the rows affected by the mutation */
    returning: Array<CurrentTokenDatas>;
};
/** on_conflict condition type for table "current_token_datas" */
type CurrentTokenDatasOnConflict = {
    constraint: CurrentTokenDatasConstraint;
    update_columns?: Array<CurrentTokenDatasUpdateColumn>;
    where?: InputMaybe<CurrentTokenDatasBoolExp>;
};
/** Ordering options when selecting data from "current_token_datas". */
type CurrentTokenDatasOrderBy = {
    collection_data_id_hash?: InputMaybe<OrderBy>;
    collection_name?: InputMaybe<OrderBy>;
    creator_address?: InputMaybe<OrderBy>;
    default_properties?: InputMaybe<OrderBy>;
    description?: InputMaybe<OrderBy>;
    description_mutable?: InputMaybe<OrderBy>;
    inserted_at?: InputMaybe<OrderBy>;
    largest_property_version?: InputMaybe<OrderBy>;
    last_transaction_timestamp?: InputMaybe<OrderBy>;
    last_transaction_version?: InputMaybe<OrderBy>;
    maximum?: InputMaybe<OrderBy>;
    maximum_mutable?: InputMaybe<OrderBy>;
    metadata_uri?: InputMaybe<OrderBy>;
    name?: InputMaybe<OrderBy>;
    payee_address?: InputMaybe<OrderBy>;
    properties_mutable?: InputMaybe<OrderBy>;
    royalty_mutable?: InputMaybe<OrderBy>;
    royalty_points_denominator?: InputMaybe<OrderBy>;
    royalty_points_numerator?: InputMaybe<OrderBy>;
    supply?: InputMaybe<OrderBy>;
    token_data_id_hash?: InputMaybe<OrderBy>;
    uri_mutable?: InputMaybe<OrderBy>;
};
/** primary key columns input for table: current_token_datas */
type CurrentTokenDatasPkColumnsInput = {
    token_data_id_hash: Scalars["String"]["input"];
};
/** prepend existing jsonb value of filtered columns with new jsonb value */
type CurrentTokenDatasPrependInput = {
    default_properties?: InputMaybe<Scalars["jsonb"]["input"]>;
};
/** select columns of table "current_token_datas" */
declare enum CurrentTokenDatasSelectColumn {
    /** column name */
    CollectionDataIdHash = "collection_data_id_hash",
    /** column name */
    CollectionName = "collection_name",
    /** column name */
    CreatorAddress = "creator_address",
    /** column name */
    DefaultProperties = "default_properties",
    /** column name */
    Description = "description",
    /** column name */
    DescriptionMutable = "description_mutable",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    LargestPropertyVersion = "largest_property_version",
    /** column name */
    LastTransactionTimestamp = "last_transaction_timestamp",
    /** column name */
    LastTransactionVersion = "last_transaction_version",
    /** column name */
    Maximum = "maximum",
    /** column name */
    MaximumMutable = "maximum_mutable",
    /** column name */
    MetadataUri = "metadata_uri",
    /** column name */
    Name = "name",
    /** column name */
    PayeeAddress = "payee_address",
    /** column name */
    PropertiesMutable = "properties_mutable",
    /** column name */
    RoyaltyMutable = "royalty_mutable",
    /** column name */
    RoyaltyPointsDenominator = "royalty_points_denominator",
    /** column name */
    RoyaltyPointsNumerator = "royalty_points_numerator",
    /** column name */
    Supply = "supply",
    /** column name */
    TokenDataIdHash = "token_data_id_hash",
    /** column name */
    UriMutable = "uri_mutable"
}
/** input type for updating data in table "current_token_datas" */
type CurrentTokenDatasSetInput = {
    collection_data_id_hash?: InputMaybe<Scalars["String"]["input"]>;
    collection_name?: InputMaybe<Scalars["String"]["input"]>;
    creator_address?: InputMaybe<Scalars["String"]["input"]>;
    default_properties?: InputMaybe<Scalars["jsonb"]["input"]>;
    description?: InputMaybe<Scalars["String"]["input"]>;
    description_mutable?: InputMaybe<Scalars["Boolean"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    largest_property_version?: InputMaybe<Scalars["numeric"]["input"]>;
    last_transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    maximum?: InputMaybe<Scalars["numeric"]["input"]>;
    maximum_mutable?: InputMaybe<Scalars["Boolean"]["input"]>;
    metadata_uri?: InputMaybe<Scalars["String"]["input"]>;
    name?: InputMaybe<Scalars["String"]["input"]>;
    payee_address?: InputMaybe<Scalars["String"]["input"]>;
    properties_mutable?: InputMaybe<Scalars["Boolean"]["input"]>;
    royalty_mutable?: InputMaybe<Scalars["Boolean"]["input"]>;
    royalty_points_denominator?: InputMaybe<Scalars["numeric"]["input"]>;
    royalty_points_numerator?: InputMaybe<Scalars["numeric"]["input"]>;
    supply?: InputMaybe<Scalars["numeric"]["input"]>;
    token_data_id_hash?: InputMaybe<Scalars["String"]["input"]>;
    uri_mutable?: InputMaybe<Scalars["Boolean"]["input"]>;
};
/** aggregate stddev on columns */
type CurrentTokenDatasStddevFields = {
    largest_property_version?: Maybe<Scalars["Float"]["output"]>;
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
    maximum?: Maybe<Scalars["Float"]["output"]>;
    royalty_points_denominator?: Maybe<Scalars["Float"]["output"]>;
    royalty_points_numerator?: Maybe<Scalars["Float"]["output"]>;
    supply?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_pop on columns */
type CurrentTokenDatasStddevPopFields = {
    largest_property_version?: Maybe<Scalars["Float"]["output"]>;
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
    maximum?: Maybe<Scalars["Float"]["output"]>;
    royalty_points_denominator?: Maybe<Scalars["Float"]["output"]>;
    royalty_points_numerator?: Maybe<Scalars["Float"]["output"]>;
    supply?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_samp on columns */
type CurrentTokenDatasStddevSampFields = {
    largest_property_version?: Maybe<Scalars["Float"]["output"]>;
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
    maximum?: Maybe<Scalars["Float"]["output"]>;
    royalty_points_denominator?: Maybe<Scalars["Float"]["output"]>;
    royalty_points_numerator?: Maybe<Scalars["Float"]["output"]>;
    supply?: Maybe<Scalars["Float"]["output"]>;
};
/** Streaming cursor of the table "current_token_datas" */
type CurrentTokenDatasStreamCursorInput = {
    /** Stream column input with initial value */
    initial_value: CurrentTokenDatasStreamCursorValueInput;
    /** cursor ordering */
    ordering?: InputMaybe<CursorOrdering>;
};
/** Initial value of the column from where the streaming should start */
type CurrentTokenDatasStreamCursorValueInput = {
    collection_data_id_hash?: InputMaybe<Scalars["String"]["input"]>;
    collection_name?: InputMaybe<Scalars["String"]["input"]>;
    creator_address?: InputMaybe<Scalars["String"]["input"]>;
    default_properties?: InputMaybe<Scalars["jsonb"]["input"]>;
    description?: InputMaybe<Scalars["String"]["input"]>;
    description_mutable?: InputMaybe<Scalars["Boolean"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    largest_property_version?: InputMaybe<Scalars["numeric"]["input"]>;
    last_transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    maximum?: InputMaybe<Scalars["numeric"]["input"]>;
    maximum_mutable?: InputMaybe<Scalars["Boolean"]["input"]>;
    metadata_uri?: InputMaybe<Scalars["String"]["input"]>;
    name?: InputMaybe<Scalars["String"]["input"]>;
    payee_address?: InputMaybe<Scalars["String"]["input"]>;
    properties_mutable?: InputMaybe<Scalars["Boolean"]["input"]>;
    royalty_mutable?: InputMaybe<Scalars["Boolean"]["input"]>;
    royalty_points_denominator?: InputMaybe<Scalars["numeric"]["input"]>;
    royalty_points_numerator?: InputMaybe<Scalars["numeric"]["input"]>;
    supply?: InputMaybe<Scalars["numeric"]["input"]>;
    token_data_id_hash?: InputMaybe<Scalars["String"]["input"]>;
    uri_mutable?: InputMaybe<Scalars["Boolean"]["input"]>;
};
/** aggregate sum on columns */
type CurrentTokenDatasSumFields = {
    largest_property_version?: Maybe<Scalars["numeric"]["output"]>;
    last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    maximum?: Maybe<Scalars["numeric"]["output"]>;
    royalty_points_denominator?: Maybe<Scalars["numeric"]["output"]>;
    royalty_points_numerator?: Maybe<Scalars["numeric"]["output"]>;
    supply?: Maybe<Scalars["numeric"]["output"]>;
};
/** update columns of table "current_token_datas" */
declare enum CurrentTokenDatasUpdateColumn {
    /** column name */
    CollectionDataIdHash = "collection_data_id_hash",
    /** column name */
    CollectionName = "collection_name",
    /** column name */
    CreatorAddress = "creator_address",
    /** column name */
    DefaultProperties = "default_properties",
    /** column name */
    Description = "description",
    /** column name */
    DescriptionMutable = "description_mutable",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    LargestPropertyVersion = "largest_property_version",
    /** column name */
    LastTransactionTimestamp = "last_transaction_timestamp",
    /** column name */
    LastTransactionVersion = "last_transaction_version",
    /** column name */
    Maximum = "maximum",
    /** column name */
    MaximumMutable = "maximum_mutable",
    /** column name */
    MetadataUri = "metadata_uri",
    /** column name */
    Name = "name",
    /** column name */
    PayeeAddress = "payee_address",
    /** column name */
    PropertiesMutable = "properties_mutable",
    /** column name */
    RoyaltyMutable = "royalty_mutable",
    /** column name */
    RoyaltyPointsDenominator = "royalty_points_denominator",
    /** column name */
    RoyaltyPointsNumerator = "royalty_points_numerator",
    /** column name */
    Supply = "supply",
    /** column name */
    TokenDataIdHash = "token_data_id_hash",
    /** column name */
    UriMutable = "uri_mutable"
}
type CurrentTokenDatasUpdates = {
    /** append existing jsonb value of filtered columns with new jsonb value */
    _append?: InputMaybe<CurrentTokenDatasAppendInput>;
    /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
    _delete_at_path?: InputMaybe<CurrentTokenDatasDeleteAtPathInput>;
    /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
    _delete_elem?: InputMaybe<CurrentTokenDatasDeleteElemInput>;
    /** delete key/value pair or string element. key/value pairs are matched based on their key value */
    _delete_key?: InputMaybe<CurrentTokenDatasDeleteKeyInput>;
    /** increments the numeric columns with given value of the filtered values */
    _inc?: InputMaybe<CurrentTokenDatasIncInput>;
    /** prepend existing jsonb value of filtered columns with new jsonb value */
    _prepend?: InputMaybe<CurrentTokenDatasPrependInput>;
    /** sets the columns of the filtered rows to the given values */
    _set?: InputMaybe<CurrentTokenDatasSetInput>;
    /** filter the rows which have to be updated */
    where: CurrentTokenDatasBoolExp;
};
/** columns and relationships of "current_token_datas_v2" */
type CurrentTokenDatasV2 = {
    /** An object relationship */
    cdn_asset_uris?: Maybe<NftMetadataCrawlerParsedAssetUris>;
    /** An object relationship */
    cedra_name?: Maybe<CurrentCedraNames>;
    collection_id: Scalars["String"]["output"];
    /** An object relationship */
    current_collection?: Maybe<CurrentCollectionsV2>;
    /** An object relationship */
    current_royalty_v1?: Maybe<CurrentTokenRoyaltyV1>;
    /** An array relationship */
    current_token_ownerships: Array<CurrentTokenOwnershipsV2>;
    /** An aggregate relationship */
    current_token_ownerships_aggregate: CurrentTokenOwnershipsV2Aggregate;
    decimals?: Maybe<Scalars["bigint"]["output"]>;
    description: Scalars["String"]["output"];
    inserted_at: Scalars["timestamp"]["output"];
    is_deleted_v2?: Maybe<Scalars["Boolean"]["output"]>;
    is_fungible_v2?: Maybe<Scalars["Boolean"]["output"]>;
    largest_property_version_v1?: Maybe<Scalars["numeric"]["output"]>;
    last_transaction_timestamp: Scalars["timestamp"]["output"];
    last_transaction_version: Scalars["bigint"]["output"];
    maximum?: Maybe<Scalars["numeric"]["output"]>;
    supply?: Maybe<Scalars["numeric"]["output"]>;
    token_data_id: Scalars["String"]["output"];
    token_name: Scalars["String"]["output"];
    token_properties: Scalars["jsonb"]["output"];
    token_standard: Scalars["String"]["output"];
    token_uri: Scalars["String"]["output"];
};
/** columns and relationships of "current_token_datas_v2" */
type CurrentTokenDatasV2CurrentTokenOwnershipsArgs = {
    distinct_on?: InputMaybe<Array<CurrentTokenOwnershipsV2SelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentTokenOwnershipsV2OrderBy>>;
    where?: InputMaybe<CurrentTokenOwnershipsV2BoolExp>;
};
/** columns and relationships of "current_token_datas_v2" */
type CurrentTokenDatasV2CurrentTokenOwnershipsAggregateArgs = {
    distinct_on?: InputMaybe<Array<CurrentTokenOwnershipsV2SelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentTokenOwnershipsV2OrderBy>>;
    where?: InputMaybe<CurrentTokenOwnershipsV2BoolExp>;
};
/** columns and relationships of "current_token_datas_v2" */
type CurrentTokenDatasV2TokenPropertiesArgs = {
    path?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregated selection of "current_token_datas_v2" */
type CurrentTokenDatasV2Aggregate = {
    aggregate?: Maybe<CurrentTokenDatasV2AggregateFields>;
    nodes: Array<CurrentTokenDatasV2>;
};
/** aggregate fields of "current_token_datas_v2" */
type CurrentTokenDatasV2AggregateFields = {
    avg?: Maybe<CurrentTokenDatasV2AvgFields>;
    count: Scalars["Int"]["output"];
    max?: Maybe<CurrentTokenDatasV2MaxFields>;
    min?: Maybe<CurrentTokenDatasV2MinFields>;
    stddev?: Maybe<CurrentTokenDatasV2StddevFields>;
    stddev_pop?: Maybe<CurrentTokenDatasV2StddevPopFields>;
    stddev_samp?: Maybe<CurrentTokenDatasV2StddevSampFields>;
    sum?: Maybe<CurrentTokenDatasV2SumFields>;
    var_pop?: Maybe<CurrentTokenDatasV2VarPopFields>;
    var_samp?: Maybe<CurrentTokenDatasV2VarSampFields>;
    variance?: Maybe<CurrentTokenDatasV2VarianceFields>;
};
/** aggregate fields of "current_token_datas_v2" */
type CurrentTokenDatasV2AggregateFieldsCountArgs = {
    columns?: InputMaybe<Array<CurrentTokenDatasV2SelectColumn>>;
    distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};
/** append existing jsonb value of filtered columns with new jsonb value */
type CurrentTokenDatasV2AppendInput = {
    token_properties?: InputMaybe<Scalars["jsonb"]["input"]>;
};
/** aggregate avg on columns */
type CurrentTokenDatasV2AvgFields = {
    decimals?: Maybe<Scalars["Float"]["output"]>;
    largest_property_version_v1?: Maybe<Scalars["Float"]["output"]>;
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
    maximum?: Maybe<Scalars["Float"]["output"]>;
    supply?: Maybe<Scalars["Float"]["output"]>;
};
/** Boolean expression to filter rows from the table "current_token_datas_v2". All fields are combined with a logical 'AND'. */
type CurrentTokenDatasV2BoolExp = {
    _and?: InputMaybe<Array<CurrentTokenDatasV2BoolExp>>;
    _not?: InputMaybe<CurrentTokenDatasV2BoolExp>;
    _or?: InputMaybe<Array<CurrentTokenDatasV2BoolExp>>;
    cdn_asset_uris?: InputMaybe<NftMetadataCrawlerParsedAssetUrisBoolExp>;
    cedra_name?: InputMaybe<CurrentCedraNamesBoolExp>;
    collection_id?: InputMaybe<StringComparisonExp>;
    current_collection?: InputMaybe<CurrentCollectionsV2BoolExp>;
    current_royalty_v1?: InputMaybe<CurrentTokenRoyaltyV1BoolExp>;
    current_token_ownerships?: InputMaybe<CurrentTokenOwnershipsV2BoolExp>;
    current_token_ownerships_aggregate?: InputMaybe<CurrentTokenOwnershipsV2AggregateBoolExp>;
    decimals?: InputMaybe<BigintComparisonExp>;
    description?: InputMaybe<StringComparisonExp>;
    inserted_at?: InputMaybe<TimestampComparisonExp>;
    is_deleted_v2?: InputMaybe<BooleanComparisonExp>;
    is_fungible_v2?: InputMaybe<BooleanComparisonExp>;
    largest_property_version_v1?: InputMaybe<NumericComparisonExp>;
    last_transaction_timestamp?: InputMaybe<TimestampComparisonExp>;
    last_transaction_version?: InputMaybe<BigintComparisonExp>;
    maximum?: InputMaybe<NumericComparisonExp>;
    supply?: InputMaybe<NumericComparisonExp>;
    token_data_id?: InputMaybe<StringComparisonExp>;
    token_name?: InputMaybe<StringComparisonExp>;
    token_properties?: InputMaybe<JsonbComparisonExp>;
    token_standard?: InputMaybe<StringComparisonExp>;
    token_uri?: InputMaybe<StringComparisonExp>;
};
/** unique or primary key constraints on table "current_token_datas_v2" */
declare enum CurrentTokenDatasV2Constraint {
    /** unique or primary key constraint on columns "token_data_id" */
    CurrentTokenDatasV2Pkey = "current_token_datas_v2_pkey"
}
/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
type CurrentTokenDatasV2DeleteAtPathInput = {
    token_properties?: InputMaybe<Array<Scalars["String"]["input"]>>;
};
/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
type CurrentTokenDatasV2DeleteElemInput = {
    token_properties?: InputMaybe<Scalars["Int"]["input"]>;
};
/** delete key/value pair or string element. key/value pairs are matched based on their key value */
type CurrentTokenDatasV2DeleteKeyInput = {
    token_properties?: InputMaybe<Scalars["String"]["input"]>;
};
/** input type for incrementing numeric columns in table "current_token_datas_v2" */
type CurrentTokenDatasV2IncInput = {
    decimals?: InputMaybe<Scalars["bigint"]["input"]>;
    largest_property_version_v1?: InputMaybe<Scalars["numeric"]["input"]>;
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    maximum?: InputMaybe<Scalars["numeric"]["input"]>;
    supply?: InputMaybe<Scalars["numeric"]["input"]>;
};
/** input type for inserting data into table "current_token_datas_v2" */
type CurrentTokenDatasV2InsertInput = {
    cdn_asset_uris?: InputMaybe<NftMetadataCrawlerParsedAssetUrisObjRelInsertInput>;
    cedra_name?: InputMaybe<CurrentCedraNamesObjRelInsertInput>;
    collection_id?: InputMaybe<Scalars["String"]["input"]>;
    current_collection?: InputMaybe<CurrentCollectionsV2ObjRelInsertInput>;
    current_royalty_v1?: InputMaybe<CurrentTokenRoyaltyV1ObjRelInsertInput>;
    current_token_ownerships?: InputMaybe<CurrentTokenOwnershipsV2ArrRelInsertInput>;
    decimals?: InputMaybe<Scalars["bigint"]["input"]>;
    description?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    is_deleted_v2?: InputMaybe<Scalars["Boolean"]["input"]>;
    is_fungible_v2?: InputMaybe<Scalars["Boolean"]["input"]>;
    largest_property_version_v1?: InputMaybe<Scalars["numeric"]["input"]>;
    last_transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    maximum?: InputMaybe<Scalars["numeric"]["input"]>;
    supply?: InputMaybe<Scalars["numeric"]["input"]>;
    token_data_id?: InputMaybe<Scalars["String"]["input"]>;
    token_name?: InputMaybe<Scalars["String"]["input"]>;
    token_properties?: InputMaybe<Scalars["jsonb"]["input"]>;
    token_standard?: InputMaybe<Scalars["String"]["input"]>;
    token_uri?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregate max on columns */
type CurrentTokenDatasV2MaxFields = {
    collection_id?: Maybe<Scalars["String"]["output"]>;
    decimals?: Maybe<Scalars["bigint"]["output"]>;
    description?: Maybe<Scalars["String"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    largest_property_version_v1?: Maybe<Scalars["numeric"]["output"]>;
    last_transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
    last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    maximum?: Maybe<Scalars["numeric"]["output"]>;
    supply?: Maybe<Scalars["numeric"]["output"]>;
    token_data_id?: Maybe<Scalars["String"]["output"]>;
    token_name?: Maybe<Scalars["String"]["output"]>;
    token_standard?: Maybe<Scalars["String"]["output"]>;
    token_uri?: Maybe<Scalars["String"]["output"]>;
};
/** aggregate min on columns */
type CurrentTokenDatasV2MinFields = {
    collection_id?: Maybe<Scalars["String"]["output"]>;
    decimals?: Maybe<Scalars["bigint"]["output"]>;
    description?: Maybe<Scalars["String"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    largest_property_version_v1?: Maybe<Scalars["numeric"]["output"]>;
    last_transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
    last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    maximum?: Maybe<Scalars["numeric"]["output"]>;
    supply?: Maybe<Scalars["numeric"]["output"]>;
    token_data_id?: Maybe<Scalars["String"]["output"]>;
    token_name?: Maybe<Scalars["String"]["output"]>;
    token_standard?: Maybe<Scalars["String"]["output"]>;
    token_uri?: Maybe<Scalars["String"]["output"]>;
};
/** response of any mutation on the table "current_token_datas_v2" */
type CurrentTokenDatasV2MutationResponse = {
    /** number of rows affected by the mutation */
    affected_rows: Scalars["Int"]["output"];
    /** data from the rows affected by the mutation */
    returning: Array<CurrentTokenDatasV2>;
};
/** input type for inserting object relation for remote table "current_token_datas_v2" */
type CurrentTokenDatasV2ObjRelInsertInput = {
    data: CurrentTokenDatasV2InsertInput;
    /** upsert condition */
    on_conflict?: InputMaybe<CurrentTokenDatasV2OnConflict>;
};
/** on_conflict condition type for table "current_token_datas_v2" */
type CurrentTokenDatasV2OnConflict = {
    constraint: CurrentTokenDatasV2Constraint;
    update_columns?: Array<CurrentTokenDatasV2UpdateColumn>;
    where?: InputMaybe<CurrentTokenDatasV2BoolExp>;
};
/** Ordering options when selecting data from "current_token_datas_v2". */
type CurrentTokenDatasV2OrderBy = {
    cdn_asset_uris?: InputMaybe<NftMetadataCrawlerParsedAssetUrisOrderBy>;
    cedra_name?: InputMaybe<CurrentCedraNamesOrderBy>;
    collection_id?: InputMaybe<OrderBy>;
    current_collection?: InputMaybe<CurrentCollectionsV2OrderBy>;
    current_royalty_v1?: InputMaybe<CurrentTokenRoyaltyV1OrderBy>;
    current_token_ownerships_aggregate?: InputMaybe<CurrentTokenOwnershipsV2AggregateOrderBy>;
    decimals?: InputMaybe<OrderBy>;
    description?: InputMaybe<OrderBy>;
    inserted_at?: InputMaybe<OrderBy>;
    is_deleted_v2?: InputMaybe<OrderBy>;
    is_fungible_v2?: InputMaybe<OrderBy>;
    largest_property_version_v1?: InputMaybe<OrderBy>;
    last_transaction_timestamp?: InputMaybe<OrderBy>;
    last_transaction_version?: InputMaybe<OrderBy>;
    maximum?: InputMaybe<OrderBy>;
    supply?: InputMaybe<OrderBy>;
    token_data_id?: InputMaybe<OrderBy>;
    token_name?: InputMaybe<OrderBy>;
    token_properties?: InputMaybe<OrderBy>;
    token_standard?: InputMaybe<OrderBy>;
    token_uri?: InputMaybe<OrderBy>;
};
/** primary key columns input for table: current_token_datas_v2 */
type CurrentTokenDatasV2PkColumnsInput = {
    token_data_id: Scalars["String"]["input"];
};
/** prepend existing jsonb value of filtered columns with new jsonb value */
type CurrentTokenDatasV2PrependInput = {
    token_properties?: InputMaybe<Scalars["jsonb"]["input"]>;
};
/** select columns of table "current_token_datas_v2" */
declare enum CurrentTokenDatasV2SelectColumn {
    /** column name */
    CollectionId = "collection_id",
    /** column name */
    Decimals = "decimals",
    /** column name */
    Description = "description",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    IsDeletedV2 = "is_deleted_v2",
    /** column name */
    IsFungibleV2 = "is_fungible_v2",
    /** column name */
    LargestPropertyVersionV1 = "largest_property_version_v1",
    /** column name */
    LastTransactionTimestamp = "last_transaction_timestamp",
    /** column name */
    LastTransactionVersion = "last_transaction_version",
    /** column name */
    Maximum = "maximum",
    /** column name */
    Supply = "supply",
    /** column name */
    TokenDataId = "token_data_id",
    /** column name */
    TokenName = "token_name",
    /** column name */
    TokenProperties = "token_properties",
    /** column name */
    TokenStandard = "token_standard",
    /** column name */
    TokenUri = "token_uri"
}
/** input type for updating data in table "current_token_datas_v2" */
type CurrentTokenDatasV2SetInput = {
    collection_id?: InputMaybe<Scalars["String"]["input"]>;
    decimals?: InputMaybe<Scalars["bigint"]["input"]>;
    description?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    is_deleted_v2?: InputMaybe<Scalars["Boolean"]["input"]>;
    is_fungible_v2?: InputMaybe<Scalars["Boolean"]["input"]>;
    largest_property_version_v1?: InputMaybe<Scalars["numeric"]["input"]>;
    last_transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    maximum?: InputMaybe<Scalars["numeric"]["input"]>;
    supply?: InputMaybe<Scalars["numeric"]["input"]>;
    token_data_id?: InputMaybe<Scalars["String"]["input"]>;
    token_name?: InputMaybe<Scalars["String"]["input"]>;
    token_properties?: InputMaybe<Scalars["jsonb"]["input"]>;
    token_standard?: InputMaybe<Scalars["String"]["input"]>;
    token_uri?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregate stddev on columns */
type CurrentTokenDatasV2StddevFields = {
    decimals?: Maybe<Scalars["Float"]["output"]>;
    largest_property_version_v1?: Maybe<Scalars["Float"]["output"]>;
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
    maximum?: Maybe<Scalars["Float"]["output"]>;
    supply?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_pop on columns */
type CurrentTokenDatasV2StddevPopFields = {
    decimals?: Maybe<Scalars["Float"]["output"]>;
    largest_property_version_v1?: Maybe<Scalars["Float"]["output"]>;
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
    maximum?: Maybe<Scalars["Float"]["output"]>;
    supply?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_samp on columns */
type CurrentTokenDatasV2StddevSampFields = {
    decimals?: Maybe<Scalars["Float"]["output"]>;
    largest_property_version_v1?: Maybe<Scalars["Float"]["output"]>;
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
    maximum?: Maybe<Scalars["Float"]["output"]>;
    supply?: Maybe<Scalars["Float"]["output"]>;
};
/** Streaming cursor of the table "current_token_datas_v2" */
type CurrentTokenDatasV2StreamCursorInput = {
    /** Stream column input with initial value */
    initial_value: CurrentTokenDatasV2StreamCursorValueInput;
    /** cursor ordering */
    ordering?: InputMaybe<CursorOrdering>;
};
/** Initial value of the column from where the streaming should start */
type CurrentTokenDatasV2StreamCursorValueInput = {
    collection_id?: InputMaybe<Scalars["String"]["input"]>;
    decimals?: InputMaybe<Scalars["bigint"]["input"]>;
    description?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    is_deleted_v2?: InputMaybe<Scalars["Boolean"]["input"]>;
    is_fungible_v2?: InputMaybe<Scalars["Boolean"]["input"]>;
    largest_property_version_v1?: InputMaybe<Scalars["numeric"]["input"]>;
    last_transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    maximum?: InputMaybe<Scalars["numeric"]["input"]>;
    supply?: InputMaybe<Scalars["numeric"]["input"]>;
    token_data_id?: InputMaybe<Scalars["String"]["input"]>;
    token_name?: InputMaybe<Scalars["String"]["input"]>;
    token_properties?: InputMaybe<Scalars["jsonb"]["input"]>;
    token_standard?: InputMaybe<Scalars["String"]["input"]>;
    token_uri?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregate sum on columns */
type CurrentTokenDatasV2SumFields = {
    decimals?: Maybe<Scalars["bigint"]["output"]>;
    largest_property_version_v1?: Maybe<Scalars["numeric"]["output"]>;
    last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    maximum?: Maybe<Scalars["numeric"]["output"]>;
    supply?: Maybe<Scalars["numeric"]["output"]>;
};
/** update columns of table "current_token_datas_v2" */
declare enum CurrentTokenDatasV2UpdateColumn {
    /** column name */
    CollectionId = "collection_id",
    /** column name */
    Decimals = "decimals",
    /** column name */
    Description = "description",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    IsDeletedV2 = "is_deleted_v2",
    /** column name */
    IsFungibleV2 = "is_fungible_v2",
    /** column name */
    LargestPropertyVersionV1 = "largest_property_version_v1",
    /** column name */
    LastTransactionTimestamp = "last_transaction_timestamp",
    /** column name */
    LastTransactionVersion = "last_transaction_version",
    /** column name */
    Maximum = "maximum",
    /** column name */
    Supply = "supply",
    /** column name */
    TokenDataId = "token_data_id",
    /** column name */
    TokenName = "token_name",
    /** column name */
    TokenProperties = "token_properties",
    /** column name */
    TokenStandard = "token_standard",
    /** column name */
    TokenUri = "token_uri"
}
type CurrentTokenDatasV2Updates = {
    /** append existing jsonb value of filtered columns with new jsonb value */
    _append?: InputMaybe<CurrentTokenDatasV2AppendInput>;
    /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
    _delete_at_path?: InputMaybe<CurrentTokenDatasV2DeleteAtPathInput>;
    /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
    _delete_elem?: InputMaybe<CurrentTokenDatasV2DeleteElemInput>;
    /** delete key/value pair or string element. key/value pairs are matched based on their key value */
    _delete_key?: InputMaybe<CurrentTokenDatasV2DeleteKeyInput>;
    /** increments the numeric columns with given value of the filtered values */
    _inc?: InputMaybe<CurrentTokenDatasV2IncInput>;
    /** prepend existing jsonb value of filtered columns with new jsonb value */
    _prepend?: InputMaybe<CurrentTokenDatasV2PrependInput>;
    /** sets the columns of the filtered rows to the given values */
    _set?: InputMaybe<CurrentTokenDatasV2SetInput>;
    /** filter the rows which have to be updated */
    where: CurrentTokenDatasV2BoolExp;
};
/** aggregate var_pop on columns */
type CurrentTokenDatasV2VarPopFields = {
    decimals?: Maybe<Scalars["Float"]["output"]>;
    largest_property_version_v1?: Maybe<Scalars["Float"]["output"]>;
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
    maximum?: Maybe<Scalars["Float"]["output"]>;
    supply?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate var_samp on columns */
type CurrentTokenDatasV2VarSampFields = {
    decimals?: Maybe<Scalars["Float"]["output"]>;
    largest_property_version_v1?: Maybe<Scalars["Float"]["output"]>;
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
    maximum?: Maybe<Scalars["Float"]["output"]>;
    supply?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate variance on columns */
type CurrentTokenDatasV2VarianceFields = {
    decimals?: Maybe<Scalars["Float"]["output"]>;
    largest_property_version_v1?: Maybe<Scalars["Float"]["output"]>;
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
    maximum?: Maybe<Scalars["Float"]["output"]>;
    supply?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate var_pop on columns */
type CurrentTokenDatasVarPopFields = {
    largest_property_version?: Maybe<Scalars["Float"]["output"]>;
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
    maximum?: Maybe<Scalars["Float"]["output"]>;
    royalty_points_denominator?: Maybe<Scalars["Float"]["output"]>;
    royalty_points_numerator?: Maybe<Scalars["Float"]["output"]>;
    supply?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate var_samp on columns */
type CurrentTokenDatasVarSampFields = {
    largest_property_version?: Maybe<Scalars["Float"]["output"]>;
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
    maximum?: Maybe<Scalars["Float"]["output"]>;
    royalty_points_denominator?: Maybe<Scalars["Float"]["output"]>;
    royalty_points_numerator?: Maybe<Scalars["Float"]["output"]>;
    supply?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate variance on columns */
type CurrentTokenDatasVarianceFields = {
    largest_property_version?: Maybe<Scalars["Float"]["output"]>;
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
    maximum?: Maybe<Scalars["Float"]["output"]>;
    royalty_points_denominator?: Maybe<Scalars["Float"]["output"]>;
    royalty_points_numerator?: Maybe<Scalars["Float"]["output"]>;
    supply?: Maybe<Scalars["Float"]["output"]>;
};
/** columns and relationships of "current_token_ownerships" */
type CurrentTokenOwnerships = {
    amount: Scalars["numeric"]["output"];
    collection_data_id_hash: Scalars["String"]["output"];
    collection_name: Scalars["String"]["output"];
    creator_address: Scalars["String"]["output"];
    inserted_at: Scalars["timestamp"]["output"];
    last_transaction_timestamp: Scalars["timestamp"]["output"];
    last_transaction_version: Scalars["bigint"]["output"];
    name: Scalars["String"]["output"];
    owner_address: Scalars["String"]["output"];
    property_version: Scalars["numeric"]["output"];
    table_type: Scalars["String"]["output"];
    token_data_id_hash: Scalars["String"]["output"];
    token_properties: Scalars["jsonb"]["output"];
};
/** columns and relationships of "current_token_ownerships" */
type CurrentTokenOwnershipsTokenPropertiesArgs = {
    path?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregated selection of "current_token_ownerships" */
type CurrentTokenOwnershipsAggregate = {
    aggregate?: Maybe<CurrentTokenOwnershipsAggregateFields>;
    nodes: Array<CurrentTokenOwnerships>;
};
/** aggregate fields of "current_token_ownerships" */
type CurrentTokenOwnershipsAggregateFields = {
    avg?: Maybe<CurrentTokenOwnershipsAvgFields>;
    count: Scalars["Int"]["output"];
    max?: Maybe<CurrentTokenOwnershipsMaxFields>;
    min?: Maybe<CurrentTokenOwnershipsMinFields>;
    stddev?: Maybe<CurrentTokenOwnershipsStddevFields>;
    stddev_pop?: Maybe<CurrentTokenOwnershipsStddevPopFields>;
    stddev_samp?: Maybe<CurrentTokenOwnershipsStddevSampFields>;
    sum?: Maybe<CurrentTokenOwnershipsSumFields>;
    var_pop?: Maybe<CurrentTokenOwnershipsVarPopFields>;
    var_samp?: Maybe<CurrentTokenOwnershipsVarSampFields>;
    variance?: Maybe<CurrentTokenOwnershipsVarianceFields>;
};
/** aggregate fields of "current_token_ownerships" */
type CurrentTokenOwnershipsAggregateFieldsCountArgs = {
    columns?: InputMaybe<Array<CurrentTokenOwnershipsSelectColumn>>;
    distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};
/** append existing jsonb value of filtered columns with new jsonb value */
type CurrentTokenOwnershipsAppendInput = {
    token_properties?: InputMaybe<Scalars["jsonb"]["input"]>;
};
/** aggregate avg on columns */
type CurrentTokenOwnershipsAvgFields = {
    amount?: Maybe<Scalars["Float"]["output"]>;
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
    property_version?: Maybe<Scalars["Float"]["output"]>;
};
/** Boolean expression to filter rows from the table "current_token_ownerships". All fields are combined with a logical 'AND'. */
type CurrentTokenOwnershipsBoolExp = {
    _and?: InputMaybe<Array<CurrentTokenOwnershipsBoolExp>>;
    _not?: InputMaybe<CurrentTokenOwnershipsBoolExp>;
    _or?: InputMaybe<Array<CurrentTokenOwnershipsBoolExp>>;
    amount?: InputMaybe<NumericComparisonExp>;
    collection_data_id_hash?: InputMaybe<StringComparisonExp>;
    collection_name?: InputMaybe<StringComparisonExp>;
    creator_address?: InputMaybe<StringComparisonExp>;
    inserted_at?: InputMaybe<TimestampComparisonExp>;
    last_transaction_timestamp?: InputMaybe<TimestampComparisonExp>;
    last_transaction_version?: InputMaybe<BigintComparisonExp>;
    name?: InputMaybe<StringComparisonExp>;
    owner_address?: InputMaybe<StringComparisonExp>;
    property_version?: InputMaybe<NumericComparisonExp>;
    table_type?: InputMaybe<StringComparisonExp>;
    token_data_id_hash?: InputMaybe<StringComparisonExp>;
    token_properties?: InputMaybe<JsonbComparisonExp>;
};
/** unique or primary key constraints on table "current_token_ownerships" */
declare enum CurrentTokenOwnershipsConstraint {
    /** unique or primary key constraint on columns "owner_address", "property_version", "token_data_id_hash" */
    CurrentTokenOwnershipsPkey = "current_token_ownerships_pkey"
}
/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
type CurrentTokenOwnershipsDeleteAtPathInput = {
    token_properties?: InputMaybe<Array<Scalars["String"]["input"]>>;
};
/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
type CurrentTokenOwnershipsDeleteElemInput = {
    token_properties?: InputMaybe<Scalars["Int"]["input"]>;
};
/** delete key/value pair or string element. key/value pairs are matched based on their key value */
type CurrentTokenOwnershipsDeleteKeyInput = {
    token_properties?: InputMaybe<Scalars["String"]["input"]>;
};
/** input type for incrementing numeric columns in table "current_token_ownerships" */
type CurrentTokenOwnershipsIncInput = {
    amount?: InputMaybe<Scalars["numeric"]["input"]>;
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    property_version?: InputMaybe<Scalars["numeric"]["input"]>;
};
/** input type for inserting data into table "current_token_ownerships" */
type CurrentTokenOwnershipsInsertInput = {
    amount?: InputMaybe<Scalars["numeric"]["input"]>;
    collection_data_id_hash?: InputMaybe<Scalars["String"]["input"]>;
    collection_name?: InputMaybe<Scalars["String"]["input"]>;
    creator_address?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    last_transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    name?: InputMaybe<Scalars["String"]["input"]>;
    owner_address?: InputMaybe<Scalars["String"]["input"]>;
    property_version?: InputMaybe<Scalars["numeric"]["input"]>;
    table_type?: InputMaybe<Scalars["String"]["input"]>;
    token_data_id_hash?: InputMaybe<Scalars["String"]["input"]>;
    token_properties?: InputMaybe<Scalars["jsonb"]["input"]>;
};
/** aggregate max on columns */
type CurrentTokenOwnershipsMaxFields = {
    amount?: Maybe<Scalars["numeric"]["output"]>;
    collection_data_id_hash?: Maybe<Scalars["String"]["output"]>;
    collection_name?: Maybe<Scalars["String"]["output"]>;
    creator_address?: Maybe<Scalars["String"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    last_transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
    last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    name?: Maybe<Scalars["String"]["output"]>;
    owner_address?: Maybe<Scalars["String"]["output"]>;
    property_version?: Maybe<Scalars["numeric"]["output"]>;
    table_type?: Maybe<Scalars["String"]["output"]>;
    token_data_id_hash?: Maybe<Scalars["String"]["output"]>;
};
/** aggregate min on columns */
type CurrentTokenOwnershipsMinFields = {
    amount?: Maybe<Scalars["numeric"]["output"]>;
    collection_data_id_hash?: Maybe<Scalars["String"]["output"]>;
    collection_name?: Maybe<Scalars["String"]["output"]>;
    creator_address?: Maybe<Scalars["String"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    last_transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
    last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    name?: Maybe<Scalars["String"]["output"]>;
    owner_address?: Maybe<Scalars["String"]["output"]>;
    property_version?: Maybe<Scalars["numeric"]["output"]>;
    table_type?: Maybe<Scalars["String"]["output"]>;
    token_data_id_hash?: Maybe<Scalars["String"]["output"]>;
};
/** response of any mutation on the table "current_token_ownerships" */
type CurrentTokenOwnershipsMutationResponse = {
    /** number of rows affected by the mutation */
    affected_rows: Scalars["Int"]["output"];
    /** data from the rows affected by the mutation */
    returning: Array<CurrentTokenOwnerships>;
};
/** on_conflict condition type for table "current_token_ownerships" */
type CurrentTokenOwnershipsOnConflict = {
    constraint: CurrentTokenOwnershipsConstraint;
    update_columns?: Array<CurrentTokenOwnershipsUpdateColumn>;
    where?: InputMaybe<CurrentTokenOwnershipsBoolExp>;
};
/** Ordering options when selecting data from "current_token_ownerships". */
type CurrentTokenOwnershipsOrderBy = {
    amount?: InputMaybe<OrderBy>;
    collection_data_id_hash?: InputMaybe<OrderBy>;
    collection_name?: InputMaybe<OrderBy>;
    creator_address?: InputMaybe<OrderBy>;
    inserted_at?: InputMaybe<OrderBy>;
    last_transaction_timestamp?: InputMaybe<OrderBy>;
    last_transaction_version?: InputMaybe<OrderBy>;
    name?: InputMaybe<OrderBy>;
    owner_address?: InputMaybe<OrderBy>;
    property_version?: InputMaybe<OrderBy>;
    table_type?: InputMaybe<OrderBy>;
    token_data_id_hash?: InputMaybe<OrderBy>;
    token_properties?: InputMaybe<OrderBy>;
};
/** primary key columns input for table: current_token_ownerships */
type CurrentTokenOwnershipsPkColumnsInput = {
    owner_address: Scalars["String"]["input"];
    property_version: Scalars["numeric"]["input"];
    token_data_id_hash: Scalars["String"]["input"];
};
/** prepend existing jsonb value of filtered columns with new jsonb value */
type CurrentTokenOwnershipsPrependInput = {
    token_properties?: InputMaybe<Scalars["jsonb"]["input"]>;
};
/** select columns of table "current_token_ownerships" */
declare enum CurrentTokenOwnershipsSelectColumn {
    /** column name */
    Amount = "amount",
    /** column name */
    CollectionDataIdHash = "collection_data_id_hash",
    /** column name */
    CollectionName = "collection_name",
    /** column name */
    CreatorAddress = "creator_address",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    LastTransactionTimestamp = "last_transaction_timestamp",
    /** column name */
    LastTransactionVersion = "last_transaction_version",
    /** column name */
    Name = "name",
    /** column name */
    OwnerAddress = "owner_address",
    /** column name */
    PropertyVersion = "property_version",
    /** column name */
    TableType = "table_type",
    /** column name */
    TokenDataIdHash = "token_data_id_hash",
    /** column name */
    TokenProperties = "token_properties"
}
/** input type for updating data in table "current_token_ownerships" */
type CurrentTokenOwnershipsSetInput = {
    amount?: InputMaybe<Scalars["numeric"]["input"]>;
    collection_data_id_hash?: InputMaybe<Scalars["String"]["input"]>;
    collection_name?: InputMaybe<Scalars["String"]["input"]>;
    creator_address?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    last_transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    name?: InputMaybe<Scalars["String"]["input"]>;
    owner_address?: InputMaybe<Scalars["String"]["input"]>;
    property_version?: InputMaybe<Scalars["numeric"]["input"]>;
    table_type?: InputMaybe<Scalars["String"]["input"]>;
    token_data_id_hash?: InputMaybe<Scalars["String"]["input"]>;
    token_properties?: InputMaybe<Scalars["jsonb"]["input"]>;
};
/** aggregate stddev on columns */
type CurrentTokenOwnershipsStddevFields = {
    amount?: Maybe<Scalars["Float"]["output"]>;
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
    property_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_pop on columns */
type CurrentTokenOwnershipsStddevPopFields = {
    amount?: Maybe<Scalars["Float"]["output"]>;
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
    property_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_samp on columns */
type CurrentTokenOwnershipsStddevSampFields = {
    amount?: Maybe<Scalars["Float"]["output"]>;
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
    property_version?: Maybe<Scalars["Float"]["output"]>;
};
/** Streaming cursor of the table "current_token_ownerships" */
type CurrentTokenOwnershipsStreamCursorInput = {
    /** Stream column input with initial value */
    initial_value: CurrentTokenOwnershipsStreamCursorValueInput;
    /** cursor ordering */
    ordering?: InputMaybe<CursorOrdering>;
};
/** Initial value of the column from where the streaming should start */
type CurrentTokenOwnershipsStreamCursorValueInput = {
    amount?: InputMaybe<Scalars["numeric"]["input"]>;
    collection_data_id_hash?: InputMaybe<Scalars["String"]["input"]>;
    collection_name?: InputMaybe<Scalars["String"]["input"]>;
    creator_address?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    last_transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    name?: InputMaybe<Scalars["String"]["input"]>;
    owner_address?: InputMaybe<Scalars["String"]["input"]>;
    property_version?: InputMaybe<Scalars["numeric"]["input"]>;
    table_type?: InputMaybe<Scalars["String"]["input"]>;
    token_data_id_hash?: InputMaybe<Scalars["String"]["input"]>;
    token_properties?: InputMaybe<Scalars["jsonb"]["input"]>;
};
/** aggregate sum on columns */
type CurrentTokenOwnershipsSumFields = {
    amount?: Maybe<Scalars["numeric"]["output"]>;
    last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    property_version?: Maybe<Scalars["numeric"]["output"]>;
};
/** update columns of table "current_token_ownerships" */
declare enum CurrentTokenOwnershipsUpdateColumn {
    /** column name */
    Amount = "amount",
    /** column name */
    CollectionDataIdHash = "collection_data_id_hash",
    /** column name */
    CollectionName = "collection_name",
    /** column name */
    CreatorAddress = "creator_address",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    LastTransactionTimestamp = "last_transaction_timestamp",
    /** column name */
    LastTransactionVersion = "last_transaction_version",
    /** column name */
    Name = "name",
    /** column name */
    OwnerAddress = "owner_address",
    /** column name */
    PropertyVersion = "property_version",
    /** column name */
    TableType = "table_type",
    /** column name */
    TokenDataIdHash = "token_data_id_hash",
    /** column name */
    TokenProperties = "token_properties"
}
type CurrentTokenOwnershipsUpdates = {
    /** append existing jsonb value of filtered columns with new jsonb value */
    _append?: InputMaybe<CurrentTokenOwnershipsAppendInput>;
    /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
    _delete_at_path?: InputMaybe<CurrentTokenOwnershipsDeleteAtPathInput>;
    /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
    _delete_elem?: InputMaybe<CurrentTokenOwnershipsDeleteElemInput>;
    /** delete key/value pair or string element. key/value pairs are matched based on their key value */
    _delete_key?: InputMaybe<CurrentTokenOwnershipsDeleteKeyInput>;
    /** increments the numeric columns with given value of the filtered values */
    _inc?: InputMaybe<CurrentTokenOwnershipsIncInput>;
    /** prepend existing jsonb value of filtered columns with new jsonb value */
    _prepend?: InputMaybe<CurrentTokenOwnershipsPrependInput>;
    /** sets the columns of the filtered rows to the given values */
    _set?: InputMaybe<CurrentTokenOwnershipsSetInput>;
    /** filter the rows which have to be updated */
    where: CurrentTokenOwnershipsBoolExp;
};
/** columns and relationships of "current_token_ownerships_v2" */
type CurrentTokenOwnershipsV2 = {
    amount: Scalars["numeric"]["output"];
    /** An array relationship */
    composed_nfts: Array<CurrentTokenOwnershipsV2>;
    /** An aggregate relationship */
    composed_nfts_aggregate: CurrentTokenOwnershipsV2Aggregate;
    /** An object relationship */
    current_token_data?: Maybe<CurrentTokenDatasV2>;
    inserted_at: Scalars["timestamp"]["output"];
    is_fungible_v2?: Maybe<Scalars["Boolean"]["output"]>;
    is_soulbound_v2?: Maybe<Scalars["Boolean"]["output"]>;
    last_transaction_timestamp: Scalars["timestamp"]["output"];
    last_transaction_version: Scalars["bigint"]["output"];
    non_transferrable_by_owner?: Maybe<Scalars["Boolean"]["output"]>;
    owner_address: Scalars["String"]["output"];
    property_version_v1: Scalars["numeric"]["output"];
    storage_id: Scalars["String"]["output"];
    table_type_v1?: Maybe<Scalars["String"]["output"]>;
    token_data_id: Scalars["String"]["output"];
    token_properties_mutated_v1?: Maybe<Scalars["jsonb"]["output"]>;
    token_standard: Scalars["String"]["output"];
};
/** columns and relationships of "current_token_ownerships_v2" */
type CurrentTokenOwnershipsV2ComposedNftsArgs = {
    distinct_on?: InputMaybe<Array<CurrentTokenOwnershipsV2SelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentTokenOwnershipsV2OrderBy>>;
    where?: InputMaybe<CurrentTokenOwnershipsV2BoolExp>;
};
/** columns and relationships of "current_token_ownerships_v2" */
type CurrentTokenOwnershipsV2ComposedNftsAggregateArgs = {
    distinct_on?: InputMaybe<Array<CurrentTokenOwnershipsV2SelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentTokenOwnershipsV2OrderBy>>;
    where?: InputMaybe<CurrentTokenOwnershipsV2BoolExp>;
};
/** columns and relationships of "current_token_ownerships_v2" */
type CurrentTokenOwnershipsV2TokenPropertiesMutatedV1Args = {
    path?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregated selection of "current_token_ownerships_v2" */
type CurrentTokenOwnershipsV2Aggregate = {
    aggregate?: Maybe<CurrentTokenOwnershipsV2AggregateFields>;
    nodes: Array<CurrentTokenOwnershipsV2>;
};
type CurrentTokenOwnershipsV2AggregateBoolExp = {
    bool_and?: InputMaybe<CurrentTokenOwnershipsV2AggregateBoolExpBoolAnd>;
    bool_or?: InputMaybe<CurrentTokenOwnershipsV2AggregateBoolExpBoolOr>;
    count?: InputMaybe<CurrentTokenOwnershipsV2AggregateBoolExpCount>;
};
type CurrentTokenOwnershipsV2AggregateBoolExpBoolAnd = {
    arguments: CurrentTokenOwnershipsV2SelectColumnCurrentTokenOwnershipsV2AggregateBoolExpBoolAndArgumentsColumns;
    distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
    filter?: InputMaybe<CurrentTokenOwnershipsV2BoolExp>;
    predicate: BooleanComparisonExp;
};
type CurrentTokenOwnershipsV2AggregateBoolExpBoolOr = {
    arguments: CurrentTokenOwnershipsV2SelectColumnCurrentTokenOwnershipsV2AggregateBoolExpBoolOrArgumentsColumns;
    distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
    filter?: InputMaybe<CurrentTokenOwnershipsV2BoolExp>;
    predicate: BooleanComparisonExp;
};
type CurrentTokenOwnershipsV2AggregateBoolExpCount = {
    arguments?: InputMaybe<Array<CurrentTokenOwnershipsV2SelectColumn>>;
    distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
    filter?: InputMaybe<CurrentTokenOwnershipsV2BoolExp>;
    predicate: IntComparisonExp;
};
/** aggregate fields of "current_token_ownerships_v2" */
type CurrentTokenOwnershipsV2AggregateFields = {
    avg?: Maybe<CurrentTokenOwnershipsV2AvgFields>;
    count: Scalars["Int"]["output"];
    max?: Maybe<CurrentTokenOwnershipsV2MaxFields>;
    min?: Maybe<CurrentTokenOwnershipsV2MinFields>;
    stddev?: Maybe<CurrentTokenOwnershipsV2StddevFields>;
    stddev_pop?: Maybe<CurrentTokenOwnershipsV2StddevPopFields>;
    stddev_samp?: Maybe<CurrentTokenOwnershipsV2StddevSampFields>;
    sum?: Maybe<CurrentTokenOwnershipsV2SumFields>;
    var_pop?: Maybe<CurrentTokenOwnershipsV2VarPopFields>;
    var_samp?: Maybe<CurrentTokenOwnershipsV2VarSampFields>;
    variance?: Maybe<CurrentTokenOwnershipsV2VarianceFields>;
};
/** aggregate fields of "current_token_ownerships_v2" */
type CurrentTokenOwnershipsV2AggregateFieldsCountArgs = {
    columns?: InputMaybe<Array<CurrentTokenOwnershipsV2SelectColumn>>;
    distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};
/** order by aggregate values of table "current_token_ownerships_v2" */
type CurrentTokenOwnershipsV2AggregateOrderBy = {
    avg?: InputMaybe<CurrentTokenOwnershipsV2AvgOrderBy>;
    count?: InputMaybe<OrderBy>;
    max?: InputMaybe<CurrentTokenOwnershipsV2MaxOrderBy>;
    min?: InputMaybe<CurrentTokenOwnershipsV2MinOrderBy>;
    stddev?: InputMaybe<CurrentTokenOwnershipsV2StddevOrderBy>;
    stddev_pop?: InputMaybe<CurrentTokenOwnershipsV2StddevPopOrderBy>;
    stddev_samp?: InputMaybe<CurrentTokenOwnershipsV2StddevSampOrderBy>;
    sum?: InputMaybe<CurrentTokenOwnershipsV2SumOrderBy>;
    var_pop?: InputMaybe<CurrentTokenOwnershipsV2VarPopOrderBy>;
    var_samp?: InputMaybe<CurrentTokenOwnershipsV2VarSampOrderBy>;
    variance?: InputMaybe<CurrentTokenOwnershipsV2VarianceOrderBy>;
};
/** append existing jsonb value of filtered columns with new jsonb value */
type CurrentTokenOwnershipsV2AppendInput = {
    token_properties_mutated_v1?: InputMaybe<Scalars["jsonb"]["input"]>;
};
/** input type for inserting array relation for remote table "current_token_ownerships_v2" */
type CurrentTokenOwnershipsV2ArrRelInsertInput = {
    data: Array<CurrentTokenOwnershipsV2InsertInput>;
    /** upsert condition */
    on_conflict?: InputMaybe<CurrentTokenOwnershipsV2OnConflict>;
};
/** aggregate avg on columns */
type CurrentTokenOwnershipsV2AvgFields = {
    amount?: Maybe<Scalars["Float"]["output"]>;
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
    property_version_v1?: Maybe<Scalars["Float"]["output"]>;
};
/** order by avg() on columns of table "current_token_ownerships_v2" */
type CurrentTokenOwnershipsV2AvgOrderBy = {
    amount?: InputMaybe<OrderBy>;
    last_transaction_version?: InputMaybe<OrderBy>;
    property_version_v1?: InputMaybe<OrderBy>;
};
/** Boolean expression to filter rows from the table "current_token_ownerships_v2". All fields are combined with a logical 'AND'. */
type CurrentTokenOwnershipsV2BoolExp = {
    _and?: InputMaybe<Array<CurrentTokenOwnershipsV2BoolExp>>;
    _not?: InputMaybe<CurrentTokenOwnershipsV2BoolExp>;
    _or?: InputMaybe<Array<CurrentTokenOwnershipsV2BoolExp>>;
    amount?: InputMaybe<NumericComparisonExp>;
    composed_nfts?: InputMaybe<CurrentTokenOwnershipsV2BoolExp>;
    composed_nfts_aggregate?: InputMaybe<CurrentTokenOwnershipsV2AggregateBoolExp>;
    current_token_data?: InputMaybe<CurrentTokenDatasV2BoolExp>;
    inserted_at?: InputMaybe<TimestampComparisonExp>;
    is_fungible_v2?: InputMaybe<BooleanComparisonExp>;
    is_soulbound_v2?: InputMaybe<BooleanComparisonExp>;
    last_transaction_timestamp?: InputMaybe<TimestampComparisonExp>;
    last_transaction_version?: InputMaybe<BigintComparisonExp>;
    non_transferrable_by_owner?: InputMaybe<BooleanComparisonExp>;
    owner_address?: InputMaybe<StringComparisonExp>;
    property_version_v1?: InputMaybe<NumericComparisonExp>;
    storage_id?: InputMaybe<StringComparisonExp>;
    table_type_v1?: InputMaybe<StringComparisonExp>;
    token_data_id?: InputMaybe<StringComparisonExp>;
    token_properties_mutated_v1?: InputMaybe<JsonbComparisonExp>;
    token_standard?: InputMaybe<StringComparisonExp>;
};
/** unique or primary key constraints on table "current_token_ownerships_v2" */
declare enum CurrentTokenOwnershipsV2Constraint {
    /** unique or primary key constraint on columns "owner_address", "property_version_v1", "storage_id", "token_data_id" */
    CurrentTokenOwnershipsV2Pkey = "current_token_ownerships_v2_pkey"
}
/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
type CurrentTokenOwnershipsV2DeleteAtPathInput = {
    token_properties_mutated_v1?: InputMaybe<Array<Scalars["String"]["input"]>>;
};
/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
type CurrentTokenOwnershipsV2DeleteElemInput = {
    token_properties_mutated_v1?: InputMaybe<Scalars["Int"]["input"]>;
};
/** delete key/value pair or string element. key/value pairs are matched based on their key value */
type CurrentTokenOwnershipsV2DeleteKeyInput = {
    token_properties_mutated_v1?: InputMaybe<Scalars["String"]["input"]>;
};
/** input type for incrementing numeric columns in table "current_token_ownerships_v2" */
type CurrentTokenOwnershipsV2IncInput = {
    amount?: InputMaybe<Scalars["numeric"]["input"]>;
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    property_version_v1?: InputMaybe<Scalars["numeric"]["input"]>;
};
/** input type for inserting data into table "current_token_ownerships_v2" */
type CurrentTokenOwnershipsV2InsertInput = {
    amount?: InputMaybe<Scalars["numeric"]["input"]>;
    composed_nfts?: InputMaybe<CurrentTokenOwnershipsV2ArrRelInsertInput>;
    current_token_data?: InputMaybe<CurrentTokenDatasV2ObjRelInsertInput>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    is_fungible_v2?: InputMaybe<Scalars["Boolean"]["input"]>;
    is_soulbound_v2?: InputMaybe<Scalars["Boolean"]["input"]>;
    last_transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    non_transferrable_by_owner?: InputMaybe<Scalars["Boolean"]["input"]>;
    owner_address?: InputMaybe<Scalars["String"]["input"]>;
    property_version_v1?: InputMaybe<Scalars["numeric"]["input"]>;
    storage_id?: InputMaybe<Scalars["String"]["input"]>;
    table_type_v1?: InputMaybe<Scalars["String"]["input"]>;
    token_data_id?: InputMaybe<Scalars["String"]["input"]>;
    token_properties_mutated_v1?: InputMaybe<Scalars["jsonb"]["input"]>;
    token_standard?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregate max on columns */
type CurrentTokenOwnershipsV2MaxFields = {
    amount?: Maybe<Scalars["numeric"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    last_transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
    last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    owner_address?: Maybe<Scalars["String"]["output"]>;
    property_version_v1?: Maybe<Scalars["numeric"]["output"]>;
    storage_id?: Maybe<Scalars["String"]["output"]>;
    table_type_v1?: Maybe<Scalars["String"]["output"]>;
    token_data_id?: Maybe<Scalars["String"]["output"]>;
    token_standard?: Maybe<Scalars["String"]["output"]>;
};
/** order by max() on columns of table "current_token_ownerships_v2" */
type CurrentTokenOwnershipsV2MaxOrderBy = {
    amount?: InputMaybe<OrderBy>;
    inserted_at?: InputMaybe<OrderBy>;
    last_transaction_timestamp?: InputMaybe<OrderBy>;
    last_transaction_version?: InputMaybe<OrderBy>;
    owner_address?: InputMaybe<OrderBy>;
    property_version_v1?: InputMaybe<OrderBy>;
    storage_id?: InputMaybe<OrderBy>;
    table_type_v1?: InputMaybe<OrderBy>;
    token_data_id?: InputMaybe<OrderBy>;
    token_standard?: InputMaybe<OrderBy>;
};
/** aggregate min on columns */
type CurrentTokenOwnershipsV2MinFields = {
    amount?: Maybe<Scalars["numeric"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    last_transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
    last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    owner_address?: Maybe<Scalars["String"]["output"]>;
    property_version_v1?: Maybe<Scalars["numeric"]["output"]>;
    storage_id?: Maybe<Scalars["String"]["output"]>;
    table_type_v1?: Maybe<Scalars["String"]["output"]>;
    token_data_id?: Maybe<Scalars["String"]["output"]>;
    token_standard?: Maybe<Scalars["String"]["output"]>;
};
/** order by min() on columns of table "current_token_ownerships_v2" */
type CurrentTokenOwnershipsV2MinOrderBy = {
    amount?: InputMaybe<OrderBy>;
    inserted_at?: InputMaybe<OrderBy>;
    last_transaction_timestamp?: InputMaybe<OrderBy>;
    last_transaction_version?: InputMaybe<OrderBy>;
    owner_address?: InputMaybe<OrderBy>;
    property_version_v1?: InputMaybe<OrderBy>;
    storage_id?: InputMaybe<OrderBy>;
    table_type_v1?: InputMaybe<OrderBy>;
    token_data_id?: InputMaybe<OrderBy>;
    token_standard?: InputMaybe<OrderBy>;
};
/** response of any mutation on the table "current_token_ownerships_v2" */
type CurrentTokenOwnershipsV2MutationResponse = {
    /** number of rows affected by the mutation */
    affected_rows: Scalars["Int"]["output"];
    /** data from the rows affected by the mutation */
    returning: Array<CurrentTokenOwnershipsV2>;
};
/** on_conflict condition type for table "current_token_ownerships_v2" */
type CurrentTokenOwnershipsV2OnConflict = {
    constraint: CurrentTokenOwnershipsV2Constraint;
    update_columns?: Array<CurrentTokenOwnershipsV2UpdateColumn>;
    where?: InputMaybe<CurrentTokenOwnershipsV2BoolExp>;
};
/** Ordering options when selecting data from "current_token_ownerships_v2". */
type CurrentTokenOwnershipsV2OrderBy = {
    amount?: InputMaybe<OrderBy>;
    composed_nfts_aggregate?: InputMaybe<CurrentTokenOwnershipsV2AggregateOrderBy>;
    current_token_data?: InputMaybe<CurrentTokenDatasV2OrderBy>;
    inserted_at?: InputMaybe<OrderBy>;
    is_fungible_v2?: InputMaybe<OrderBy>;
    is_soulbound_v2?: InputMaybe<OrderBy>;
    last_transaction_timestamp?: InputMaybe<OrderBy>;
    last_transaction_version?: InputMaybe<OrderBy>;
    non_transferrable_by_owner?: InputMaybe<OrderBy>;
    owner_address?: InputMaybe<OrderBy>;
    property_version_v1?: InputMaybe<OrderBy>;
    storage_id?: InputMaybe<OrderBy>;
    table_type_v1?: InputMaybe<OrderBy>;
    token_data_id?: InputMaybe<OrderBy>;
    token_properties_mutated_v1?: InputMaybe<OrderBy>;
    token_standard?: InputMaybe<OrderBy>;
};
/** primary key columns input for table: current_token_ownerships_v2 */
type CurrentTokenOwnershipsV2PkColumnsInput = {
    owner_address: Scalars["String"]["input"];
    property_version_v1: Scalars["numeric"]["input"];
    storage_id: Scalars["String"]["input"];
    token_data_id: Scalars["String"]["input"];
};
/** prepend existing jsonb value of filtered columns with new jsonb value */
type CurrentTokenOwnershipsV2PrependInput = {
    token_properties_mutated_v1?: InputMaybe<Scalars["jsonb"]["input"]>;
};
/** select columns of table "current_token_ownerships_v2" */
declare enum CurrentTokenOwnershipsV2SelectColumn {
    /** column name */
    Amount = "amount",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    IsFungibleV2 = "is_fungible_v2",
    /** column name */
    IsSoulboundV2 = "is_soulbound_v2",
    /** column name */
    LastTransactionTimestamp = "last_transaction_timestamp",
    /** column name */
    LastTransactionVersion = "last_transaction_version",
    /** column name */
    NonTransferrableByOwner = "non_transferrable_by_owner",
    /** column name */
    OwnerAddress = "owner_address",
    /** column name */
    PropertyVersionV1 = "property_version_v1",
    /** column name */
    StorageId = "storage_id",
    /** column name */
    TableTypeV1 = "table_type_v1",
    /** column name */
    TokenDataId = "token_data_id",
    /** column name */
    TokenPropertiesMutatedV1 = "token_properties_mutated_v1",
    /** column name */
    TokenStandard = "token_standard"
}
/** select "current_token_ownerships_v2_aggregate_bool_exp_bool_and_arguments_columns" columns of table "current_token_ownerships_v2" */
declare enum CurrentTokenOwnershipsV2SelectColumnCurrentTokenOwnershipsV2AggregateBoolExpBoolAndArgumentsColumns {
    /** column name */
    IsFungibleV2 = "is_fungible_v2",
    /** column name */
    IsSoulboundV2 = "is_soulbound_v2",
    /** column name */
    NonTransferrableByOwner = "non_transferrable_by_owner"
}
/** select "current_token_ownerships_v2_aggregate_bool_exp_bool_or_arguments_columns" columns of table "current_token_ownerships_v2" */
declare enum CurrentTokenOwnershipsV2SelectColumnCurrentTokenOwnershipsV2AggregateBoolExpBoolOrArgumentsColumns {
    /** column name */
    IsFungibleV2 = "is_fungible_v2",
    /** column name */
    IsSoulboundV2 = "is_soulbound_v2",
    /** column name */
    NonTransferrableByOwner = "non_transferrable_by_owner"
}
/** input type for updating data in table "current_token_ownerships_v2" */
type CurrentTokenOwnershipsV2SetInput = {
    amount?: InputMaybe<Scalars["numeric"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    is_fungible_v2?: InputMaybe<Scalars["Boolean"]["input"]>;
    is_soulbound_v2?: InputMaybe<Scalars["Boolean"]["input"]>;
    last_transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    non_transferrable_by_owner?: InputMaybe<Scalars["Boolean"]["input"]>;
    owner_address?: InputMaybe<Scalars["String"]["input"]>;
    property_version_v1?: InputMaybe<Scalars["numeric"]["input"]>;
    storage_id?: InputMaybe<Scalars["String"]["input"]>;
    table_type_v1?: InputMaybe<Scalars["String"]["input"]>;
    token_data_id?: InputMaybe<Scalars["String"]["input"]>;
    token_properties_mutated_v1?: InputMaybe<Scalars["jsonb"]["input"]>;
    token_standard?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregate stddev on columns */
type CurrentTokenOwnershipsV2StddevFields = {
    amount?: Maybe<Scalars["Float"]["output"]>;
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
    property_version_v1?: Maybe<Scalars["Float"]["output"]>;
};
/** order by stddev() on columns of table "current_token_ownerships_v2" */
type CurrentTokenOwnershipsV2StddevOrderBy = {
    amount?: InputMaybe<OrderBy>;
    last_transaction_version?: InputMaybe<OrderBy>;
    property_version_v1?: InputMaybe<OrderBy>;
};
/** aggregate stddev_pop on columns */
type CurrentTokenOwnershipsV2StddevPopFields = {
    amount?: Maybe<Scalars["Float"]["output"]>;
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
    property_version_v1?: Maybe<Scalars["Float"]["output"]>;
};
/** order by stddev_pop() on columns of table "current_token_ownerships_v2" */
type CurrentTokenOwnershipsV2StddevPopOrderBy = {
    amount?: InputMaybe<OrderBy>;
    last_transaction_version?: InputMaybe<OrderBy>;
    property_version_v1?: InputMaybe<OrderBy>;
};
/** aggregate stddev_samp on columns */
type CurrentTokenOwnershipsV2StddevSampFields = {
    amount?: Maybe<Scalars["Float"]["output"]>;
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
    property_version_v1?: Maybe<Scalars["Float"]["output"]>;
};
/** order by stddev_samp() on columns of table "current_token_ownerships_v2" */
type CurrentTokenOwnershipsV2StddevSampOrderBy = {
    amount?: InputMaybe<OrderBy>;
    last_transaction_version?: InputMaybe<OrderBy>;
    property_version_v1?: InputMaybe<OrderBy>;
};
/** Streaming cursor of the table "current_token_ownerships_v2" */
type CurrentTokenOwnershipsV2StreamCursorInput = {
    /** Stream column input with initial value */
    initial_value: CurrentTokenOwnershipsV2StreamCursorValueInput;
    /** cursor ordering */
    ordering?: InputMaybe<CursorOrdering>;
};
/** Initial value of the column from where the streaming should start */
type CurrentTokenOwnershipsV2StreamCursorValueInput = {
    amount?: InputMaybe<Scalars["numeric"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    is_fungible_v2?: InputMaybe<Scalars["Boolean"]["input"]>;
    is_soulbound_v2?: InputMaybe<Scalars["Boolean"]["input"]>;
    last_transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    non_transferrable_by_owner?: InputMaybe<Scalars["Boolean"]["input"]>;
    owner_address?: InputMaybe<Scalars["String"]["input"]>;
    property_version_v1?: InputMaybe<Scalars["numeric"]["input"]>;
    storage_id?: InputMaybe<Scalars["String"]["input"]>;
    table_type_v1?: InputMaybe<Scalars["String"]["input"]>;
    token_data_id?: InputMaybe<Scalars["String"]["input"]>;
    token_properties_mutated_v1?: InputMaybe<Scalars["jsonb"]["input"]>;
    token_standard?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregate sum on columns */
type CurrentTokenOwnershipsV2SumFields = {
    amount?: Maybe<Scalars["numeric"]["output"]>;
    last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    property_version_v1?: Maybe<Scalars["numeric"]["output"]>;
};
/** order by sum() on columns of table "current_token_ownerships_v2" */
type CurrentTokenOwnershipsV2SumOrderBy = {
    amount?: InputMaybe<OrderBy>;
    last_transaction_version?: InputMaybe<OrderBy>;
    property_version_v1?: InputMaybe<OrderBy>;
};
/** update columns of table "current_token_ownerships_v2" */
declare enum CurrentTokenOwnershipsV2UpdateColumn {
    /** column name */
    Amount = "amount",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    IsFungibleV2 = "is_fungible_v2",
    /** column name */
    IsSoulboundV2 = "is_soulbound_v2",
    /** column name */
    LastTransactionTimestamp = "last_transaction_timestamp",
    /** column name */
    LastTransactionVersion = "last_transaction_version",
    /** column name */
    NonTransferrableByOwner = "non_transferrable_by_owner",
    /** column name */
    OwnerAddress = "owner_address",
    /** column name */
    PropertyVersionV1 = "property_version_v1",
    /** column name */
    StorageId = "storage_id",
    /** column name */
    TableTypeV1 = "table_type_v1",
    /** column name */
    TokenDataId = "token_data_id",
    /** column name */
    TokenPropertiesMutatedV1 = "token_properties_mutated_v1",
    /** column name */
    TokenStandard = "token_standard"
}
type CurrentTokenOwnershipsV2Updates = {
    /** append existing jsonb value of filtered columns with new jsonb value */
    _append?: InputMaybe<CurrentTokenOwnershipsV2AppendInput>;
    /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
    _delete_at_path?: InputMaybe<CurrentTokenOwnershipsV2DeleteAtPathInput>;
    /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
    _delete_elem?: InputMaybe<CurrentTokenOwnershipsV2DeleteElemInput>;
    /** delete key/value pair or string element. key/value pairs are matched based on their key value */
    _delete_key?: InputMaybe<CurrentTokenOwnershipsV2DeleteKeyInput>;
    /** increments the numeric columns with given value of the filtered values */
    _inc?: InputMaybe<CurrentTokenOwnershipsV2IncInput>;
    /** prepend existing jsonb value of filtered columns with new jsonb value */
    _prepend?: InputMaybe<CurrentTokenOwnershipsV2PrependInput>;
    /** sets the columns of the filtered rows to the given values */
    _set?: InputMaybe<CurrentTokenOwnershipsV2SetInput>;
    /** filter the rows which have to be updated */
    where: CurrentTokenOwnershipsV2BoolExp;
};
/** aggregate var_pop on columns */
type CurrentTokenOwnershipsV2VarPopFields = {
    amount?: Maybe<Scalars["Float"]["output"]>;
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
    property_version_v1?: Maybe<Scalars["Float"]["output"]>;
};
/** order by var_pop() on columns of table "current_token_ownerships_v2" */
type CurrentTokenOwnershipsV2VarPopOrderBy = {
    amount?: InputMaybe<OrderBy>;
    last_transaction_version?: InputMaybe<OrderBy>;
    property_version_v1?: InputMaybe<OrderBy>;
};
/** aggregate var_samp on columns */
type CurrentTokenOwnershipsV2VarSampFields = {
    amount?: Maybe<Scalars["Float"]["output"]>;
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
    property_version_v1?: Maybe<Scalars["Float"]["output"]>;
};
/** order by var_samp() on columns of table "current_token_ownerships_v2" */
type CurrentTokenOwnershipsV2VarSampOrderBy = {
    amount?: InputMaybe<OrderBy>;
    last_transaction_version?: InputMaybe<OrderBy>;
    property_version_v1?: InputMaybe<OrderBy>;
};
/** aggregate variance on columns */
type CurrentTokenOwnershipsV2VarianceFields = {
    amount?: Maybe<Scalars["Float"]["output"]>;
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
    property_version_v1?: Maybe<Scalars["Float"]["output"]>;
};
/** order by variance() on columns of table "current_token_ownerships_v2" */
type CurrentTokenOwnershipsV2VarianceOrderBy = {
    amount?: InputMaybe<OrderBy>;
    last_transaction_version?: InputMaybe<OrderBy>;
    property_version_v1?: InputMaybe<OrderBy>;
};
/** aggregate var_pop on columns */
type CurrentTokenOwnershipsVarPopFields = {
    amount?: Maybe<Scalars["Float"]["output"]>;
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
    property_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate var_samp on columns */
type CurrentTokenOwnershipsVarSampFields = {
    amount?: Maybe<Scalars["Float"]["output"]>;
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
    property_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate variance on columns */
type CurrentTokenOwnershipsVarianceFields = {
    amount?: Maybe<Scalars["Float"]["output"]>;
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
    property_version?: Maybe<Scalars["Float"]["output"]>;
};
/** columns and relationships of "current_token_pending_claims" */
type CurrentTokenPendingClaims = {
    amount: Scalars["numeric"]["output"];
    collection_data_id_hash: Scalars["String"]["output"];
    collection_id: Scalars["String"]["output"];
    collection_name: Scalars["String"]["output"];
    creator_address: Scalars["String"]["output"];
    /** An object relationship */
    current_collection_v2?: Maybe<CurrentCollectionsV2>;
    /** An object relationship */
    current_token_data_v2?: Maybe<CurrentTokenDatasV2>;
    from_address: Scalars["String"]["output"];
    inserted_at: Scalars["timestamp"]["output"];
    last_transaction_timestamp: Scalars["timestamp"]["output"];
    last_transaction_version: Scalars["bigint"]["output"];
    name: Scalars["String"]["output"];
    property_version: Scalars["numeric"]["output"];
    table_handle: Scalars["String"]["output"];
    to_address: Scalars["String"]["output"];
    token_data_id: Scalars["String"]["output"];
    token_data_id_hash: Scalars["String"]["output"];
};
/** aggregated selection of "current_token_pending_claims" */
type CurrentTokenPendingClaimsAggregate = {
    aggregate?: Maybe<CurrentTokenPendingClaimsAggregateFields>;
    nodes: Array<CurrentTokenPendingClaims>;
};
/** aggregate fields of "current_token_pending_claims" */
type CurrentTokenPendingClaimsAggregateFields = {
    avg?: Maybe<CurrentTokenPendingClaimsAvgFields>;
    count: Scalars["Int"]["output"];
    max?: Maybe<CurrentTokenPendingClaimsMaxFields>;
    min?: Maybe<CurrentTokenPendingClaimsMinFields>;
    stddev?: Maybe<CurrentTokenPendingClaimsStddevFields>;
    stddev_pop?: Maybe<CurrentTokenPendingClaimsStddevPopFields>;
    stddev_samp?: Maybe<CurrentTokenPendingClaimsStddevSampFields>;
    sum?: Maybe<CurrentTokenPendingClaimsSumFields>;
    var_pop?: Maybe<CurrentTokenPendingClaimsVarPopFields>;
    var_samp?: Maybe<CurrentTokenPendingClaimsVarSampFields>;
    variance?: Maybe<CurrentTokenPendingClaimsVarianceFields>;
};
/** aggregate fields of "current_token_pending_claims" */
type CurrentTokenPendingClaimsAggregateFieldsCountArgs = {
    columns?: InputMaybe<Array<CurrentTokenPendingClaimsSelectColumn>>;
    distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};
/** aggregate avg on columns */
type CurrentTokenPendingClaimsAvgFields = {
    amount?: Maybe<Scalars["Float"]["output"]>;
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
    property_version?: Maybe<Scalars["Float"]["output"]>;
};
/** Boolean expression to filter rows from the table "current_token_pending_claims". All fields are combined with a logical 'AND'. */
type CurrentTokenPendingClaimsBoolExp = {
    _and?: InputMaybe<Array<CurrentTokenPendingClaimsBoolExp>>;
    _not?: InputMaybe<CurrentTokenPendingClaimsBoolExp>;
    _or?: InputMaybe<Array<CurrentTokenPendingClaimsBoolExp>>;
    amount?: InputMaybe<NumericComparisonExp>;
    collection_data_id_hash?: InputMaybe<StringComparisonExp>;
    collection_id?: InputMaybe<StringComparisonExp>;
    collection_name?: InputMaybe<StringComparisonExp>;
    creator_address?: InputMaybe<StringComparisonExp>;
    current_collection_v2?: InputMaybe<CurrentCollectionsV2BoolExp>;
    current_token_data_v2?: InputMaybe<CurrentTokenDatasV2BoolExp>;
    from_address?: InputMaybe<StringComparisonExp>;
    inserted_at?: InputMaybe<TimestampComparisonExp>;
    last_transaction_timestamp?: InputMaybe<TimestampComparisonExp>;
    last_transaction_version?: InputMaybe<BigintComparisonExp>;
    name?: InputMaybe<StringComparisonExp>;
    property_version?: InputMaybe<NumericComparisonExp>;
    table_handle?: InputMaybe<StringComparisonExp>;
    to_address?: InputMaybe<StringComparisonExp>;
    token_data_id?: InputMaybe<StringComparisonExp>;
    token_data_id_hash?: InputMaybe<StringComparisonExp>;
};
/** unique or primary key constraints on table "current_token_pending_claims" */
declare enum CurrentTokenPendingClaimsConstraint {
    /** unique or primary key constraint on columns "to_address", "property_version", "from_address", "token_data_id_hash" */
    CurrentTokenPendingClaimsPkey = "current_token_pending_claims_pkey"
}
/** input type for incrementing numeric columns in table "current_token_pending_claims" */
type CurrentTokenPendingClaimsIncInput = {
    amount?: InputMaybe<Scalars["numeric"]["input"]>;
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    property_version?: InputMaybe<Scalars["numeric"]["input"]>;
};
/** input type for inserting data into table "current_token_pending_claims" */
type CurrentTokenPendingClaimsInsertInput = {
    amount?: InputMaybe<Scalars["numeric"]["input"]>;
    collection_data_id_hash?: InputMaybe<Scalars["String"]["input"]>;
    collection_id?: InputMaybe<Scalars["String"]["input"]>;
    collection_name?: InputMaybe<Scalars["String"]["input"]>;
    creator_address?: InputMaybe<Scalars["String"]["input"]>;
    current_collection_v2?: InputMaybe<CurrentCollectionsV2ObjRelInsertInput>;
    current_token_data_v2?: InputMaybe<CurrentTokenDatasV2ObjRelInsertInput>;
    from_address?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    last_transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    name?: InputMaybe<Scalars["String"]["input"]>;
    property_version?: InputMaybe<Scalars["numeric"]["input"]>;
    table_handle?: InputMaybe<Scalars["String"]["input"]>;
    to_address?: InputMaybe<Scalars["String"]["input"]>;
    token_data_id?: InputMaybe<Scalars["String"]["input"]>;
    token_data_id_hash?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregate max on columns */
type CurrentTokenPendingClaimsMaxFields = {
    amount?: Maybe<Scalars["numeric"]["output"]>;
    collection_data_id_hash?: Maybe<Scalars["String"]["output"]>;
    collection_id?: Maybe<Scalars["String"]["output"]>;
    collection_name?: Maybe<Scalars["String"]["output"]>;
    creator_address?: Maybe<Scalars["String"]["output"]>;
    from_address?: Maybe<Scalars["String"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    last_transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
    last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    name?: Maybe<Scalars["String"]["output"]>;
    property_version?: Maybe<Scalars["numeric"]["output"]>;
    table_handle?: Maybe<Scalars["String"]["output"]>;
    to_address?: Maybe<Scalars["String"]["output"]>;
    token_data_id?: Maybe<Scalars["String"]["output"]>;
    token_data_id_hash?: Maybe<Scalars["String"]["output"]>;
};
/** aggregate min on columns */
type CurrentTokenPendingClaimsMinFields = {
    amount?: Maybe<Scalars["numeric"]["output"]>;
    collection_data_id_hash?: Maybe<Scalars["String"]["output"]>;
    collection_id?: Maybe<Scalars["String"]["output"]>;
    collection_name?: Maybe<Scalars["String"]["output"]>;
    creator_address?: Maybe<Scalars["String"]["output"]>;
    from_address?: Maybe<Scalars["String"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    last_transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
    last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    name?: Maybe<Scalars["String"]["output"]>;
    property_version?: Maybe<Scalars["numeric"]["output"]>;
    table_handle?: Maybe<Scalars["String"]["output"]>;
    to_address?: Maybe<Scalars["String"]["output"]>;
    token_data_id?: Maybe<Scalars["String"]["output"]>;
    token_data_id_hash?: Maybe<Scalars["String"]["output"]>;
};
/** response of any mutation on the table "current_token_pending_claims" */
type CurrentTokenPendingClaimsMutationResponse = {
    /** number of rows affected by the mutation */
    affected_rows: Scalars["Int"]["output"];
    /** data from the rows affected by the mutation */
    returning: Array<CurrentTokenPendingClaims>;
};
/** on_conflict condition type for table "current_token_pending_claims" */
type CurrentTokenPendingClaimsOnConflict = {
    constraint: CurrentTokenPendingClaimsConstraint;
    update_columns?: Array<CurrentTokenPendingClaimsUpdateColumn>;
    where?: InputMaybe<CurrentTokenPendingClaimsBoolExp>;
};
/** Ordering options when selecting data from "current_token_pending_claims". */
type CurrentTokenPendingClaimsOrderBy = {
    amount?: InputMaybe<OrderBy>;
    collection_data_id_hash?: InputMaybe<OrderBy>;
    collection_id?: InputMaybe<OrderBy>;
    collection_name?: InputMaybe<OrderBy>;
    creator_address?: InputMaybe<OrderBy>;
    current_collection_v2?: InputMaybe<CurrentCollectionsV2OrderBy>;
    current_token_data_v2?: InputMaybe<CurrentTokenDatasV2OrderBy>;
    from_address?: InputMaybe<OrderBy>;
    inserted_at?: InputMaybe<OrderBy>;
    last_transaction_timestamp?: InputMaybe<OrderBy>;
    last_transaction_version?: InputMaybe<OrderBy>;
    name?: InputMaybe<OrderBy>;
    property_version?: InputMaybe<OrderBy>;
    table_handle?: InputMaybe<OrderBy>;
    to_address?: InputMaybe<OrderBy>;
    token_data_id?: InputMaybe<OrderBy>;
    token_data_id_hash?: InputMaybe<OrderBy>;
};
/** primary key columns input for table: current_token_pending_claims */
type CurrentTokenPendingClaimsPkColumnsInput = {
    from_address: Scalars["String"]["input"];
    property_version: Scalars["numeric"]["input"];
    to_address: Scalars["String"]["input"];
    token_data_id_hash: Scalars["String"]["input"];
};
/** select columns of table "current_token_pending_claims" */
declare enum CurrentTokenPendingClaimsSelectColumn {
    /** column name */
    Amount = "amount",
    /** column name */
    CollectionDataIdHash = "collection_data_id_hash",
    /** column name */
    CollectionId = "collection_id",
    /** column name */
    CollectionName = "collection_name",
    /** column name */
    CreatorAddress = "creator_address",
    /** column name */
    FromAddress = "from_address",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    LastTransactionTimestamp = "last_transaction_timestamp",
    /** column name */
    LastTransactionVersion = "last_transaction_version",
    /** column name */
    Name = "name",
    /** column name */
    PropertyVersion = "property_version",
    /** column name */
    TableHandle = "table_handle",
    /** column name */
    ToAddress = "to_address",
    /** column name */
    TokenDataId = "token_data_id",
    /** column name */
    TokenDataIdHash = "token_data_id_hash"
}
/** input type for updating data in table "current_token_pending_claims" */
type CurrentTokenPendingClaimsSetInput = {
    amount?: InputMaybe<Scalars["numeric"]["input"]>;
    collection_data_id_hash?: InputMaybe<Scalars["String"]["input"]>;
    collection_id?: InputMaybe<Scalars["String"]["input"]>;
    collection_name?: InputMaybe<Scalars["String"]["input"]>;
    creator_address?: InputMaybe<Scalars["String"]["input"]>;
    from_address?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    last_transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    name?: InputMaybe<Scalars["String"]["input"]>;
    property_version?: InputMaybe<Scalars["numeric"]["input"]>;
    table_handle?: InputMaybe<Scalars["String"]["input"]>;
    to_address?: InputMaybe<Scalars["String"]["input"]>;
    token_data_id?: InputMaybe<Scalars["String"]["input"]>;
    token_data_id_hash?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregate stddev on columns */
type CurrentTokenPendingClaimsStddevFields = {
    amount?: Maybe<Scalars["Float"]["output"]>;
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
    property_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_pop on columns */
type CurrentTokenPendingClaimsStddevPopFields = {
    amount?: Maybe<Scalars["Float"]["output"]>;
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
    property_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_samp on columns */
type CurrentTokenPendingClaimsStddevSampFields = {
    amount?: Maybe<Scalars["Float"]["output"]>;
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
    property_version?: Maybe<Scalars["Float"]["output"]>;
};
/** Streaming cursor of the table "current_token_pending_claims" */
type CurrentTokenPendingClaimsStreamCursorInput = {
    /** Stream column input with initial value */
    initial_value: CurrentTokenPendingClaimsStreamCursorValueInput;
    /** cursor ordering */
    ordering?: InputMaybe<CursorOrdering>;
};
/** Initial value of the column from where the streaming should start */
type CurrentTokenPendingClaimsStreamCursorValueInput = {
    amount?: InputMaybe<Scalars["numeric"]["input"]>;
    collection_data_id_hash?: InputMaybe<Scalars["String"]["input"]>;
    collection_id?: InputMaybe<Scalars["String"]["input"]>;
    collection_name?: InputMaybe<Scalars["String"]["input"]>;
    creator_address?: InputMaybe<Scalars["String"]["input"]>;
    from_address?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    last_transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    name?: InputMaybe<Scalars["String"]["input"]>;
    property_version?: InputMaybe<Scalars["numeric"]["input"]>;
    table_handle?: InputMaybe<Scalars["String"]["input"]>;
    to_address?: InputMaybe<Scalars["String"]["input"]>;
    token_data_id?: InputMaybe<Scalars["String"]["input"]>;
    token_data_id_hash?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregate sum on columns */
type CurrentTokenPendingClaimsSumFields = {
    amount?: Maybe<Scalars["numeric"]["output"]>;
    last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    property_version?: Maybe<Scalars["numeric"]["output"]>;
};
/** update columns of table "current_token_pending_claims" */
declare enum CurrentTokenPendingClaimsUpdateColumn {
    /** column name */
    Amount = "amount",
    /** column name */
    CollectionDataIdHash = "collection_data_id_hash",
    /** column name */
    CollectionId = "collection_id",
    /** column name */
    CollectionName = "collection_name",
    /** column name */
    CreatorAddress = "creator_address",
    /** column name */
    FromAddress = "from_address",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    LastTransactionTimestamp = "last_transaction_timestamp",
    /** column name */
    LastTransactionVersion = "last_transaction_version",
    /** column name */
    Name = "name",
    /** column name */
    PropertyVersion = "property_version",
    /** column name */
    TableHandle = "table_handle",
    /** column name */
    ToAddress = "to_address",
    /** column name */
    TokenDataId = "token_data_id",
    /** column name */
    TokenDataIdHash = "token_data_id_hash"
}
type CurrentTokenPendingClaimsUpdates = {
    /** increments the numeric columns with given value of the filtered values */
    _inc?: InputMaybe<CurrentTokenPendingClaimsIncInput>;
    /** sets the columns of the filtered rows to the given values */
    _set?: InputMaybe<CurrentTokenPendingClaimsSetInput>;
    /** filter the rows which have to be updated */
    where: CurrentTokenPendingClaimsBoolExp;
};
/** aggregate var_pop on columns */
type CurrentTokenPendingClaimsVarPopFields = {
    amount?: Maybe<Scalars["Float"]["output"]>;
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
    property_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate var_samp on columns */
type CurrentTokenPendingClaimsVarSampFields = {
    amount?: Maybe<Scalars["Float"]["output"]>;
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
    property_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate variance on columns */
type CurrentTokenPendingClaimsVarianceFields = {
    amount?: Maybe<Scalars["Float"]["output"]>;
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
    property_version?: Maybe<Scalars["Float"]["output"]>;
};
/** columns and relationships of "current_token_royalty_v1" */
type CurrentTokenRoyaltyV1 = {
    inserted_at: Scalars["timestamp"]["output"];
    last_transaction_timestamp: Scalars["timestamp"]["output"];
    last_transaction_version: Scalars["bigint"]["output"];
    payee_address: Scalars["String"]["output"];
    royalty_points_denominator: Scalars["numeric"]["output"];
    royalty_points_numerator: Scalars["numeric"]["output"];
    token_data_id: Scalars["String"]["output"];
};
/** aggregated selection of "current_token_royalty_v1" */
type CurrentTokenRoyaltyV1Aggregate = {
    aggregate?: Maybe<CurrentTokenRoyaltyV1AggregateFields>;
    nodes: Array<CurrentTokenRoyaltyV1>;
};
/** aggregate fields of "current_token_royalty_v1" */
type CurrentTokenRoyaltyV1AggregateFields = {
    avg?: Maybe<CurrentTokenRoyaltyV1AvgFields>;
    count: Scalars["Int"]["output"];
    max?: Maybe<CurrentTokenRoyaltyV1MaxFields>;
    min?: Maybe<CurrentTokenRoyaltyV1MinFields>;
    stddev?: Maybe<CurrentTokenRoyaltyV1StddevFields>;
    stddev_pop?: Maybe<CurrentTokenRoyaltyV1StddevPopFields>;
    stddev_samp?: Maybe<CurrentTokenRoyaltyV1StddevSampFields>;
    sum?: Maybe<CurrentTokenRoyaltyV1SumFields>;
    var_pop?: Maybe<CurrentTokenRoyaltyV1VarPopFields>;
    var_samp?: Maybe<CurrentTokenRoyaltyV1VarSampFields>;
    variance?: Maybe<CurrentTokenRoyaltyV1VarianceFields>;
};
/** aggregate fields of "current_token_royalty_v1" */
type CurrentTokenRoyaltyV1AggregateFieldsCountArgs = {
    columns?: InputMaybe<Array<CurrentTokenRoyaltyV1SelectColumn>>;
    distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};
/** aggregate avg on columns */
type CurrentTokenRoyaltyV1AvgFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
    royalty_points_denominator?: Maybe<Scalars["Float"]["output"]>;
    royalty_points_numerator?: Maybe<Scalars["Float"]["output"]>;
};
/** Boolean expression to filter rows from the table "current_token_royalty_v1". All fields are combined with a logical 'AND'. */
type CurrentTokenRoyaltyV1BoolExp = {
    _and?: InputMaybe<Array<CurrentTokenRoyaltyV1BoolExp>>;
    _not?: InputMaybe<CurrentTokenRoyaltyV1BoolExp>;
    _or?: InputMaybe<Array<CurrentTokenRoyaltyV1BoolExp>>;
    inserted_at?: InputMaybe<TimestampComparisonExp>;
    last_transaction_timestamp?: InputMaybe<TimestampComparisonExp>;
    last_transaction_version?: InputMaybe<BigintComparisonExp>;
    payee_address?: InputMaybe<StringComparisonExp>;
    royalty_points_denominator?: InputMaybe<NumericComparisonExp>;
    royalty_points_numerator?: InputMaybe<NumericComparisonExp>;
    token_data_id?: InputMaybe<StringComparisonExp>;
};
/** unique or primary key constraints on table "current_token_royalty_v1" */
declare enum CurrentTokenRoyaltyV1Constraint {
    /** unique or primary key constraint on columns "token_data_id" */
    CurrentTokenRoyaltyV1Pkey = "current_token_royalty_v1_pkey"
}
/** input type for incrementing numeric columns in table "current_token_royalty_v1" */
type CurrentTokenRoyaltyV1IncInput = {
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    royalty_points_denominator?: InputMaybe<Scalars["numeric"]["input"]>;
    royalty_points_numerator?: InputMaybe<Scalars["numeric"]["input"]>;
};
/** input type for inserting data into table "current_token_royalty_v1" */
type CurrentTokenRoyaltyV1InsertInput = {
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    last_transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    payee_address?: InputMaybe<Scalars["String"]["input"]>;
    royalty_points_denominator?: InputMaybe<Scalars["numeric"]["input"]>;
    royalty_points_numerator?: InputMaybe<Scalars["numeric"]["input"]>;
    token_data_id?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregate max on columns */
type CurrentTokenRoyaltyV1MaxFields = {
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    last_transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
    last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    payee_address?: Maybe<Scalars["String"]["output"]>;
    royalty_points_denominator?: Maybe<Scalars["numeric"]["output"]>;
    royalty_points_numerator?: Maybe<Scalars["numeric"]["output"]>;
    token_data_id?: Maybe<Scalars["String"]["output"]>;
};
/** aggregate min on columns */
type CurrentTokenRoyaltyV1MinFields = {
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    last_transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
    last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    payee_address?: Maybe<Scalars["String"]["output"]>;
    royalty_points_denominator?: Maybe<Scalars["numeric"]["output"]>;
    royalty_points_numerator?: Maybe<Scalars["numeric"]["output"]>;
    token_data_id?: Maybe<Scalars["String"]["output"]>;
};
/** response of any mutation on the table "current_token_royalty_v1" */
type CurrentTokenRoyaltyV1MutationResponse = {
    /** number of rows affected by the mutation */
    affected_rows: Scalars["Int"]["output"];
    /** data from the rows affected by the mutation */
    returning: Array<CurrentTokenRoyaltyV1>;
};
/** input type for inserting object relation for remote table "current_token_royalty_v1" */
type CurrentTokenRoyaltyV1ObjRelInsertInput = {
    data: CurrentTokenRoyaltyV1InsertInput;
    /** upsert condition */
    on_conflict?: InputMaybe<CurrentTokenRoyaltyV1OnConflict>;
};
/** on_conflict condition type for table "current_token_royalty_v1" */
type CurrentTokenRoyaltyV1OnConflict = {
    constraint: CurrentTokenRoyaltyV1Constraint;
    update_columns?: Array<CurrentTokenRoyaltyV1UpdateColumn>;
    where?: InputMaybe<CurrentTokenRoyaltyV1BoolExp>;
};
/** Ordering options when selecting data from "current_token_royalty_v1". */
type CurrentTokenRoyaltyV1OrderBy = {
    inserted_at?: InputMaybe<OrderBy>;
    last_transaction_timestamp?: InputMaybe<OrderBy>;
    last_transaction_version?: InputMaybe<OrderBy>;
    payee_address?: InputMaybe<OrderBy>;
    royalty_points_denominator?: InputMaybe<OrderBy>;
    royalty_points_numerator?: InputMaybe<OrderBy>;
    token_data_id?: InputMaybe<OrderBy>;
};
/** primary key columns input for table: current_token_royalty_v1 */
type CurrentTokenRoyaltyV1PkColumnsInput = {
    token_data_id: Scalars["String"]["input"];
};
/** select columns of table "current_token_royalty_v1" */
declare enum CurrentTokenRoyaltyV1SelectColumn {
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    LastTransactionTimestamp = "last_transaction_timestamp",
    /** column name */
    LastTransactionVersion = "last_transaction_version",
    /** column name */
    PayeeAddress = "payee_address",
    /** column name */
    RoyaltyPointsDenominator = "royalty_points_denominator",
    /** column name */
    RoyaltyPointsNumerator = "royalty_points_numerator",
    /** column name */
    TokenDataId = "token_data_id"
}
/** input type for updating data in table "current_token_royalty_v1" */
type CurrentTokenRoyaltyV1SetInput = {
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    last_transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    payee_address?: InputMaybe<Scalars["String"]["input"]>;
    royalty_points_denominator?: InputMaybe<Scalars["numeric"]["input"]>;
    royalty_points_numerator?: InputMaybe<Scalars["numeric"]["input"]>;
    token_data_id?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregate stddev on columns */
type CurrentTokenRoyaltyV1StddevFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
    royalty_points_denominator?: Maybe<Scalars["Float"]["output"]>;
    royalty_points_numerator?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_pop on columns */
type CurrentTokenRoyaltyV1StddevPopFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
    royalty_points_denominator?: Maybe<Scalars["Float"]["output"]>;
    royalty_points_numerator?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_samp on columns */
type CurrentTokenRoyaltyV1StddevSampFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
    royalty_points_denominator?: Maybe<Scalars["Float"]["output"]>;
    royalty_points_numerator?: Maybe<Scalars["Float"]["output"]>;
};
/** Streaming cursor of the table "current_token_royalty_v1" */
type CurrentTokenRoyaltyV1StreamCursorInput = {
    /** Stream column input with initial value */
    initial_value: CurrentTokenRoyaltyV1StreamCursorValueInput;
    /** cursor ordering */
    ordering?: InputMaybe<CursorOrdering>;
};
/** Initial value of the column from where the streaming should start */
type CurrentTokenRoyaltyV1StreamCursorValueInput = {
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    last_transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    payee_address?: InputMaybe<Scalars["String"]["input"]>;
    royalty_points_denominator?: InputMaybe<Scalars["numeric"]["input"]>;
    royalty_points_numerator?: InputMaybe<Scalars["numeric"]["input"]>;
    token_data_id?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregate sum on columns */
type CurrentTokenRoyaltyV1SumFields = {
    last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    royalty_points_denominator?: Maybe<Scalars["numeric"]["output"]>;
    royalty_points_numerator?: Maybe<Scalars["numeric"]["output"]>;
};
/** update columns of table "current_token_royalty_v1" */
declare enum CurrentTokenRoyaltyV1UpdateColumn {
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    LastTransactionTimestamp = "last_transaction_timestamp",
    /** column name */
    LastTransactionVersion = "last_transaction_version",
    /** column name */
    PayeeAddress = "payee_address",
    /** column name */
    RoyaltyPointsDenominator = "royalty_points_denominator",
    /** column name */
    RoyaltyPointsNumerator = "royalty_points_numerator",
    /** column name */
    TokenDataId = "token_data_id"
}
type CurrentTokenRoyaltyV1Updates = {
    /** increments the numeric columns with given value of the filtered values */
    _inc?: InputMaybe<CurrentTokenRoyaltyV1IncInput>;
    /** sets the columns of the filtered rows to the given values */
    _set?: InputMaybe<CurrentTokenRoyaltyV1SetInput>;
    /** filter the rows which have to be updated */
    where: CurrentTokenRoyaltyV1BoolExp;
};
/** aggregate var_pop on columns */
type CurrentTokenRoyaltyV1VarPopFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
    royalty_points_denominator?: Maybe<Scalars["Float"]["output"]>;
    royalty_points_numerator?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate var_samp on columns */
type CurrentTokenRoyaltyV1VarSampFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
    royalty_points_denominator?: Maybe<Scalars["Float"]["output"]>;
    royalty_points_numerator?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate variance on columns */
type CurrentTokenRoyaltyV1VarianceFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
    royalty_points_denominator?: Maybe<Scalars["Float"]["output"]>;
    royalty_points_numerator?: Maybe<Scalars["Float"]["output"]>;
};
/** columns and relationships of "current_token_v2_metadata" */
type CurrentTokenV2Metadata = {
    data: Scalars["jsonb"]["output"];
    inserted_at: Scalars["timestamp"]["output"];
    last_transaction_version: Scalars["bigint"]["output"];
    object_address: Scalars["String"]["output"];
    resource_type: Scalars["String"]["output"];
    state_key_hash: Scalars["String"]["output"];
};
/** columns and relationships of "current_token_v2_metadata" */
type CurrentTokenV2MetadataDataArgs = {
    path?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregated selection of "current_token_v2_metadata" */
type CurrentTokenV2MetadataAggregate = {
    aggregate?: Maybe<CurrentTokenV2MetadataAggregateFields>;
    nodes: Array<CurrentTokenV2Metadata>;
};
/** aggregate fields of "current_token_v2_metadata" */
type CurrentTokenV2MetadataAggregateFields = {
    avg?: Maybe<CurrentTokenV2MetadataAvgFields>;
    count: Scalars["Int"]["output"];
    max?: Maybe<CurrentTokenV2MetadataMaxFields>;
    min?: Maybe<CurrentTokenV2MetadataMinFields>;
    stddev?: Maybe<CurrentTokenV2MetadataStddevFields>;
    stddev_pop?: Maybe<CurrentTokenV2MetadataStddevPopFields>;
    stddev_samp?: Maybe<CurrentTokenV2MetadataStddevSampFields>;
    sum?: Maybe<CurrentTokenV2MetadataSumFields>;
    var_pop?: Maybe<CurrentTokenV2MetadataVarPopFields>;
    var_samp?: Maybe<CurrentTokenV2MetadataVarSampFields>;
    variance?: Maybe<CurrentTokenV2MetadataVarianceFields>;
};
/** aggregate fields of "current_token_v2_metadata" */
type CurrentTokenV2MetadataAggregateFieldsCountArgs = {
    columns?: InputMaybe<Array<CurrentTokenV2MetadataSelectColumn>>;
    distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};
/** append existing jsonb value of filtered columns with new jsonb value */
type CurrentTokenV2MetadataAppendInput = {
    data?: InputMaybe<Scalars["jsonb"]["input"]>;
};
/** aggregate avg on columns */
type CurrentTokenV2MetadataAvgFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** Boolean expression to filter rows from the table "current_token_v2_metadata". All fields are combined with a logical 'AND'. */
type CurrentTokenV2MetadataBoolExp = {
    _and?: InputMaybe<Array<CurrentTokenV2MetadataBoolExp>>;
    _not?: InputMaybe<CurrentTokenV2MetadataBoolExp>;
    _or?: InputMaybe<Array<CurrentTokenV2MetadataBoolExp>>;
    data?: InputMaybe<JsonbComparisonExp>;
    inserted_at?: InputMaybe<TimestampComparisonExp>;
    last_transaction_version?: InputMaybe<BigintComparisonExp>;
    object_address?: InputMaybe<StringComparisonExp>;
    resource_type?: InputMaybe<StringComparisonExp>;
    state_key_hash?: InputMaybe<StringComparisonExp>;
};
/** unique or primary key constraints on table "current_token_v2_metadata" */
declare enum CurrentTokenV2MetadataConstraint {
    /** unique or primary key constraint on columns "object_address", "resource_type" */
    CurrentTokenV2MetadataPkey = "current_token_v2_metadata_pkey"
}
/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
type CurrentTokenV2MetadataDeleteAtPathInput = {
    data?: InputMaybe<Array<Scalars["String"]["input"]>>;
};
/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
type CurrentTokenV2MetadataDeleteElemInput = {
    data?: InputMaybe<Scalars["Int"]["input"]>;
};
/** delete key/value pair or string element. key/value pairs are matched based on their key value */
type CurrentTokenV2MetadataDeleteKeyInput = {
    data?: InputMaybe<Scalars["String"]["input"]>;
};
/** input type for incrementing numeric columns in table "current_token_v2_metadata" */
type CurrentTokenV2MetadataIncInput = {
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** input type for inserting data into table "current_token_v2_metadata" */
type CurrentTokenV2MetadataInsertInput = {
    data?: InputMaybe<Scalars["jsonb"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    object_address?: InputMaybe<Scalars["String"]["input"]>;
    resource_type?: InputMaybe<Scalars["String"]["input"]>;
    state_key_hash?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregate max on columns */
type CurrentTokenV2MetadataMaxFields = {
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    object_address?: Maybe<Scalars["String"]["output"]>;
    resource_type?: Maybe<Scalars["String"]["output"]>;
    state_key_hash?: Maybe<Scalars["String"]["output"]>;
};
/** aggregate min on columns */
type CurrentTokenV2MetadataMinFields = {
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    object_address?: Maybe<Scalars["String"]["output"]>;
    resource_type?: Maybe<Scalars["String"]["output"]>;
    state_key_hash?: Maybe<Scalars["String"]["output"]>;
};
/** response of any mutation on the table "current_token_v2_metadata" */
type CurrentTokenV2MetadataMutationResponse = {
    /** number of rows affected by the mutation */
    affected_rows: Scalars["Int"]["output"];
    /** data from the rows affected by the mutation */
    returning: Array<CurrentTokenV2Metadata>;
};
/** on_conflict condition type for table "current_token_v2_metadata" */
type CurrentTokenV2MetadataOnConflict = {
    constraint: CurrentTokenV2MetadataConstraint;
    update_columns?: Array<CurrentTokenV2MetadataUpdateColumn>;
    where?: InputMaybe<CurrentTokenV2MetadataBoolExp>;
};
/** Ordering options when selecting data from "current_token_v2_metadata". */
type CurrentTokenV2MetadataOrderBy = {
    data?: InputMaybe<OrderBy>;
    inserted_at?: InputMaybe<OrderBy>;
    last_transaction_version?: InputMaybe<OrderBy>;
    object_address?: InputMaybe<OrderBy>;
    resource_type?: InputMaybe<OrderBy>;
    state_key_hash?: InputMaybe<OrderBy>;
};
/** primary key columns input for table: current_token_v2_metadata */
type CurrentTokenV2MetadataPkColumnsInput = {
    object_address: Scalars["String"]["input"];
    resource_type: Scalars["String"]["input"];
};
/** prepend existing jsonb value of filtered columns with new jsonb value */
type CurrentTokenV2MetadataPrependInput = {
    data?: InputMaybe<Scalars["jsonb"]["input"]>;
};
/** select columns of table "current_token_v2_metadata" */
declare enum CurrentTokenV2MetadataSelectColumn {
    /** column name */
    Data = "data",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    LastTransactionVersion = "last_transaction_version",
    /** column name */
    ObjectAddress = "object_address",
    /** column name */
    ResourceType = "resource_type",
    /** column name */
    StateKeyHash = "state_key_hash"
}
/** input type for updating data in table "current_token_v2_metadata" */
type CurrentTokenV2MetadataSetInput = {
    data?: InputMaybe<Scalars["jsonb"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    object_address?: InputMaybe<Scalars["String"]["input"]>;
    resource_type?: InputMaybe<Scalars["String"]["input"]>;
    state_key_hash?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregate stddev on columns */
type CurrentTokenV2MetadataStddevFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_pop on columns */
type CurrentTokenV2MetadataStddevPopFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_samp on columns */
type CurrentTokenV2MetadataStddevSampFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** Streaming cursor of the table "current_token_v2_metadata" */
type CurrentTokenV2MetadataStreamCursorInput = {
    /** Stream column input with initial value */
    initial_value: CurrentTokenV2MetadataStreamCursorValueInput;
    /** cursor ordering */
    ordering?: InputMaybe<CursorOrdering>;
};
/** Initial value of the column from where the streaming should start */
type CurrentTokenV2MetadataStreamCursorValueInput = {
    data?: InputMaybe<Scalars["jsonb"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    object_address?: InputMaybe<Scalars["String"]["input"]>;
    resource_type?: InputMaybe<Scalars["String"]["input"]>;
    state_key_hash?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregate sum on columns */
type CurrentTokenV2MetadataSumFields = {
    last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};
/** update columns of table "current_token_v2_metadata" */
declare enum CurrentTokenV2MetadataUpdateColumn {
    /** column name */
    Data = "data",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    LastTransactionVersion = "last_transaction_version",
    /** column name */
    ObjectAddress = "object_address",
    /** column name */
    ResourceType = "resource_type",
    /** column name */
    StateKeyHash = "state_key_hash"
}
type CurrentTokenV2MetadataUpdates = {
    /** append existing jsonb value of filtered columns with new jsonb value */
    _append?: InputMaybe<CurrentTokenV2MetadataAppendInput>;
    /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
    _delete_at_path?: InputMaybe<CurrentTokenV2MetadataDeleteAtPathInput>;
    /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
    _delete_elem?: InputMaybe<CurrentTokenV2MetadataDeleteElemInput>;
    /** delete key/value pair or string element. key/value pairs are matched based on their key value */
    _delete_key?: InputMaybe<CurrentTokenV2MetadataDeleteKeyInput>;
    /** increments the numeric columns with given value of the filtered values */
    _inc?: InputMaybe<CurrentTokenV2MetadataIncInput>;
    /** prepend existing jsonb value of filtered columns with new jsonb value */
    _prepend?: InputMaybe<CurrentTokenV2MetadataPrependInput>;
    /** sets the columns of the filtered rows to the given values */
    _set?: InputMaybe<CurrentTokenV2MetadataSetInput>;
    /** filter the rows which have to be updated */
    where: CurrentTokenV2MetadataBoolExp;
};
/** aggregate var_pop on columns */
type CurrentTokenV2MetadataVarPopFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate var_samp on columns */
type CurrentTokenV2MetadataVarSampFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate variance on columns */
type CurrentTokenV2MetadataVarianceFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** ordering argument of a cursor */
declare enum CursorOrdering {
    /** ascending ordering of the cursor */
    Asc = "ASC",
    /** descending ordering of the cursor */
    Desc = "DESC"
}
/** columns and relationships of "delegated_staking_activities" */
type DelegatedStakingActivities = {
    amount: Scalars["numeric"]["output"];
    delegator_address: Scalars["String"]["output"];
    event_index: Scalars["bigint"]["output"];
    event_type: Scalars["String"]["output"];
    inserted_at: Scalars["timestamp"]["output"];
    pool_address: Scalars["String"]["output"];
    transaction_version: Scalars["bigint"]["output"];
};
/** aggregated selection of "delegated_staking_activities" */
type DelegatedStakingActivitiesAggregate = {
    aggregate?: Maybe<DelegatedStakingActivitiesAggregateFields>;
    nodes: Array<DelegatedStakingActivities>;
};
type DelegatedStakingActivitiesAggregateBoolExp = {
    count?: InputMaybe<DelegatedStakingActivitiesAggregateBoolExpCount>;
};
type DelegatedStakingActivitiesAggregateBoolExpCount = {
    arguments?: InputMaybe<Array<DelegatedStakingActivitiesSelectColumn>>;
    distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
    filter?: InputMaybe<DelegatedStakingActivitiesBoolExp>;
    predicate: IntComparisonExp;
};
/** aggregate fields of "delegated_staking_activities" */
type DelegatedStakingActivitiesAggregateFields = {
    avg?: Maybe<DelegatedStakingActivitiesAvgFields>;
    count: Scalars["Int"]["output"];
    max?: Maybe<DelegatedStakingActivitiesMaxFields>;
    min?: Maybe<DelegatedStakingActivitiesMinFields>;
    stddev?: Maybe<DelegatedStakingActivitiesStddevFields>;
    stddev_pop?: Maybe<DelegatedStakingActivitiesStddevPopFields>;
    stddev_samp?: Maybe<DelegatedStakingActivitiesStddevSampFields>;
    sum?: Maybe<DelegatedStakingActivitiesSumFields>;
    var_pop?: Maybe<DelegatedStakingActivitiesVarPopFields>;
    var_samp?: Maybe<DelegatedStakingActivitiesVarSampFields>;
    variance?: Maybe<DelegatedStakingActivitiesVarianceFields>;
};
/** aggregate fields of "delegated_staking_activities" */
type DelegatedStakingActivitiesAggregateFieldsCountArgs = {
    columns?: InputMaybe<Array<DelegatedStakingActivitiesSelectColumn>>;
    distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};
/** order by aggregate values of table "delegated_staking_activities" */
type DelegatedStakingActivitiesAggregateOrderBy = {
    avg?: InputMaybe<DelegatedStakingActivitiesAvgOrderBy>;
    count?: InputMaybe<OrderBy>;
    max?: InputMaybe<DelegatedStakingActivitiesMaxOrderBy>;
    min?: InputMaybe<DelegatedStakingActivitiesMinOrderBy>;
    stddev?: InputMaybe<DelegatedStakingActivitiesStddevOrderBy>;
    stddev_pop?: InputMaybe<DelegatedStakingActivitiesStddevPopOrderBy>;
    stddev_samp?: InputMaybe<DelegatedStakingActivitiesStddevSampOrderBy>;
    sum?: InputMaybe<DelegatedStakingActivitiesSumOrderBy>;
    var_pop?: InputMaybe<DelegatedStakingActivitiesVarPopOrderBy>;
    var_samp?: InputMaybe<DelegatedStakingActivitiesVarSampOrderBy>;
    variance?: InputMaybe<DelegatedStakingActivitiesVarianceOrderBy>;
};
/** input type for inserting array relation for remote table "delegated_staking_activities" */
type DelegatedStakingActivitiesArrRelInsertInput = {
    data: Array<DelegatedStakingActivitiesInsertInput>;
    /** upsert condition */
    on_conflict?: InputMaybe<DelegatedStakingActivitiesOnConflict>;
};
/** aggregate avg on columns */
type DelegatedStakingActivitiesAvgFields = {
    amount?: Maybe<Scalars["Float"]["output"]>;
    event_index?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** order by avg() on columns of table "delegated_staking_activities" */
type DelegatedStakingActivitiesAvgOrderBy = {
    amount?: InputMaybe<OrderBy>;
    event_index?: InputMaybe<OrderBy>;
    transaction_version?: InputMaybe<OrderBy>;
};
/** Boolean expression to filter rows from the table "delegated_staking_activities". All fields are combined with a logical 'AND'. */
type DelegatedStakingActivitiesBoolExp = {
    _and?: InputMaybe<Array<DelegatedStakingActivitiesBoolExp>>;
    _not?: InputMaybe<DelegatedStakingActivitiesBoolExp>;
    _or?: InputMaybe<Array<DelegatedStakingActivitiesBoolExp>>;
    amount?: InputMaybe<NumericComparisonExp>;
    delegator_address?: InputMaybe<StringComparisonExp>;
    event_index?: InputMaybe<BigintComparisonExp>;
    event_type?: InputMaybe<StringComparisonExp>;
    inserted_at?: InputMaybe<TimestampComparisonExp>;
    pool_address?: InputMaybe<StringComparisonExp>;
    transaction_version?: InputMaybe<BigintComparisonExp>;
};
/** unique or primary key constraints on table "delegated_staking_activities" */
declare enum DelegatedStakingActivitiesConstraint {
    /** unique or primary key constraint on columns "event_index", "transaction_version" */
    DelegatedStakingActivitiesPkey = "delegated_staking_activities_pkey"
}
/** input type for incrementing numeric columns in table "delegated_staking_activities" */
type DelegatedStakingActivitiesIncInput = {
    amount?: InputMaybe<Scalars["numeric"]["input"]>;
    event_index?: InputMaybe<Scalars["bigint"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** input type for inserting data into table "delegated_staking_activities" */
type DelegatedStakingActivitiesInsertInput = {
    amount?: InputMaybe<Scalars["numeric"]["input"]>;
    delegator_address?: InputMaybe<Scalars["String"]["input"]>;
    event_index?: InputMaybe<Scalars["bigint"]["input"]>;
    event_type?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    pool_address?: InputMaybe<Scalars["String"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** aggregate max on columns */
type DelegatedStakingActivitiesMaxFields = {
    amount?: Maybe<Scalars["numeric"]["output"]>;
    delegator_address?: Maybe<Scalars["String"]["output"]>;
    event_index?: Maybe<Scalars["bigint"]["output"]>;
    event_type?: Maybe<Scalars["String"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    pool_address?: Maybe<Scalars["String"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};
/** order by max() on columns of table "delegated_staking_activities" */
type DelegatedStakingActivitiesMaxOrderBy = {
    amount?: InputMaybe<OrderBy>;
    delegator_address?: InputMaybe<OrderBy>;
    event_index?: InputMaybe<OrderBy>;
    event_type?: InputMaybe<OrderBy>;
    inserted_at?: InputMaybe<OrderBy>;
    pool_address?: InputMaybe<OrderBy>;
    transaction_version?: InputMaybe<OrderBy>;
};
/** aggregate min on columns */
type DelegatedStakingActivitiesMinFields = {
    amount?: Maybe<Scalars["numeric"]["output"]>;
    delegator_address?: Maybe<Scalars["String"]["output"]>;
    event_index?: Maybe<Scalars["bigint"]["output"]>;
    event_type?: Maybe<Scalars["String"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    pool_address?: Maybe<Scalars["String"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};
/** order by min() on columns of table "delegated_staking_activities" */
type DelegatedStakingActivitiesMinOrderBy = {
    amount?: InputMaybe<OrderBy>;
    delegator_address?: InputMaybe<OrderBy>;
    event_index?: InputMaybe<OrderBy>;
    event_type?: InputMaybe<OrderBy>;
    inserted_at?: InputMaybe<OrderBy>;
    pool_address?: InputMaybe<OrderBy>;
    transaction_version?: InputMaybe<OrderBy>;
};
/** response of any mutation on the table "delegated_staking_activities" */
type DelegatedStakingActivitiesMutationResponse = {
    /** number of rows affected by the mutation */
    affected_rows: Scalars["Int"]["output"];
    /** data from the rows affected by the mutation */
    returning: Array<DelegatedStakingActivities>;
};
/** on_conflict condition type for table "delegated_staking_activities" */
type DelegatedStakingActivitiesOnConflict = {
    constraint: DelegatedStakingActivitiesConstraint;
    update_columns?: Array<DelegatedStakingActivitiesUpdateColumn>;
    where?: InputMaybe<DelegatedStakingActivitiesBoolExp>;
};
/** Ordering options when selecting data from "delegated_staking_activities". */
type DelegatedStakingActivitiesOrderBy = {
    amount?: InputMaybe<OrderBy>;
    delegator_address?: InputMaybe<OrderBy>;
    event_index?: InputMaybe<OrderBy>;
    event_type?: InputMaybe<OrderBy>;
    inserted_at?: InputMaybe<OrderBy>;
    pool_address?: InputMaybe<OrderBy>;
    transaction_version?: InputMaybe<OrderBy>;
};
/** primary key columns input for table: delegated_staking_activities */
type DelegatedStakingActivitiesPkColumnsInput = {
    event_index: Scalars["bigint"]["input"];
    transaction_version: Scalars["bigint"]["input"];
};
/** select columns of table "delegated_staking_activities" */
declare enum DelegatedStakingActivitiesSelectColumn {
    /** column name */
    Amount = "amount",
    /** column name */
    DelegatorAddress = "delegator_address",
    /** column name */
    EventIndex = "event_index",
    /** column name */
    EventType = "event_type",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    PoolAddress = "pool_address",
    /** column name */
    TransactionVersion = "transaction_version"
}
/** input type for updating data in table "delegated_staking_activities" */
type DelegatedStakingActivitiesSetInput = {
    amount?: InputMaybe<Scalars["numeric"]["input"]>;
    delegator_address?: InputMaybe<Scalars["String"]["input"]>;
    event_index?: InputMaybe<Scalars["bigint"]["input"]>;
    event_type?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    pool_address?: InputMaybe<Scalars["String"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** aggregate stddev on columns */
type DelegatedStakingActivitiesStddevFields = {
    amount?: Maybe<Scalars["Float"]["output"]>;
    event_index?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** order by stddev() on columns of table "delegated_staking_activities" */
type DelegatedStakingActivitiesStddevOrderBy = {
    amount?: InputMaybe<OrderBy>;
    event_index?: InputMaybe<OrderBy>;
    transaction_version?: InputMaybe<OrderBy>;
};
/** aggregate stddev_pop on columns */
type DelegatedStakingActivitiesStddevPopFields = {
    amount?: Maybe<Scalars["Float"]["output"]>;
    event_index?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** order by stddev_pop() on columns of table "delegated_staking_activities" */
type DelegatedStakingActivitiesStddevPopOrderBy = {
    amount?: InputMaybe<OrderBy>;
    event_index?: InputMaybe<OrderBy>;
    transaction_version?: InputMaybe<OrderBy>;
};
/** aggregate stddev_samp on columns */
type DelegatedStakingActivitiesStddevSampFields = {
    amount?: Maybe<Scalars["Float"]["output"]>;
    event_index?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** order by stddev_samp() on columns of table "delegated_staking_activities" */
type DelegatedStakingActivitiesStddevSampOrderBy = {
    amount?: InputMaybe<OrderBy>;
    event_index?: InputMaybe<OrderBy>;
    transaction_version?: InputMaybe<OrderBy>;
};
/** Streaming cursor of the table "delegated_staking_activities" */
type DelegatedStakingActivitiesStreamCursorInput = {
    /** Stream column input with initial value */
    initial_value: DelegatedStakingActivitiesStreamCursorValueInput;
    /** cursor ordering */
    ordering?: InputMaybe<CursorOrdering>;
};
/** Initial value of the column from where the streaming should start */
type DelegatedStakingActivitiesStreamCursorValueInput = {
    amount?: InputMaybe<Scalars["numeric"]["input"]>;
    delegator_address?: InputMaybe<Scalars["String"]["input"]>;
    event_index?: InputMaybe<Scalars["bigint"]["input"]>;
    event_type?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    pool_address?: InputMaybe<Scalars["String"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** aggregate sum on columns */
type DelegatedStakingActivitiesSumFields = {
    amount?: Maybe<Scalars["numeric"]["output"]>;
    event_index?: Maybe<Scalars["bigint"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};
/** order by sum() on columns of table "delegated_staking_activities" */
type DelegatedStakingActivitiesSumOrderBy = {
    amount?: InputMaybe<OrderBy>;
    event_index?: InputMaybe<OrderBy>;
    transaction_version?: InputMaybe<OrderBy>;
};
/** update columns of table "delegated_staking_activities" */
declare enum DelegatedStakingActivitiesUpdateColumn {
    /** column name */
    Amount = "amount",
    /** column name */
    DelegatorAddress = "delegator_address",
    /** column name */
    EventIndex = "event_index",
    /** column name */
    EventType = "event_type",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    PoolAddress = "pool_address",
    /** column name */
    TransactionVersion = "transaction_version"
}
type DelegatedStakingActivitiesUpdates = {
    /** increments the numeric columns with given value of the filtered values */
    _inc?: InputMaybe<DelegatedStakingActivitiesIncInput>;
    /** sets the columns of the filtered rows to the given values */
    _set?: InputMaybe<DelegatedStakingActivitiesSetInput>;
    /** filter the rows which have to be updated */
    where: DelegatedStakingActivitiesBoolExp;
};
/** aggregate var_pop on columns */
type DelegatedStakingActivitiesVarPopFields = {
    amount?: Maybe<Scalars["Float"]["output"]>;
    event_index?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** order by var_pop() on columns of table "delegated_staking_activities" */
type DelegatedStakingActivitiesVarPopOrderBy = {
    amount?: InputMaybe<OrderBy>;
    event_index?: InputMaybe<OrderBy>;
    transaction_version?: InputMaybe<OrderBy>;
};
/** aggregate var_samp on columns */
type DelegatedStakingActivitiesVarSampFields = {
    amount?: Maybe<Scalars["Float"]["output"]>;
    event_index?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** order by var_samp() on columns of table "delegated_staking_activities" */
type DelegatedStakingActivitiesVarSampOrderBy = {
    amount?: InputMaybe<OrderBy>;
    event_index?: InputMaybe<OrderBy>;
    transaction_version?: InputMaybe<OrderBy>;
};
/** aggregate variance on columns */
type DelegatedStakingActivitiesVarianceFields = {
    amount?: Maybe<Scalars["Float"]["output"]>;
    event_index?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** order by variance() on columns of table "delegated_staking_activities" */
type DelegatedStakingActivitiesVarianceOrderBy = {
    amount?: InputMaybe<OrderBy>;
    event_index?: InputMaybe<OrderBy>;
    transaction_version?: InputMaybe<OrderBy>;
};
/** columns and relationships of "delegated_staking_pool_balances" */
type DelegatedStakingPoolBalances = {
    active_table_handle: Scalars["String"]["output"];
    inactive_table_handle: Scalars["String"]["output"];
    inserted_at: Scalars["timestamp"]["output"];
    operator_commission_percentage: Scalars["numeric"]["output"];
    staking_pool_address: Scalars["String"]["output"];
    total_coins: Scalars["numeric"]["output"];
    total_shares: Scalars["numeric"]["output"];
    transaction_version: Scalars["bigint"]["output"];
};
/** aggregated selection of "delegated_staking_pool_balances" */
type DelegatedStakingPoolBalancesAggregate = {
    aggregate?: Maybe<DelegatedStakingPoolBalancesAggregateFields>;
    nodes: Array<DelegatedStakingPoolBalances>;
};
/** aggregate fields of "delegated_staking_pool_balances" */
type DelegatedStakingPoolBalancesAggregateFields = {
    avg?: Maybe<DelegatedStakingPoolBalancesAvgFields>;
    count: Scalars["Int"]["output"];
    max?: Maybe<DelegatedStakingPoolBalancesMaxFields>;
    min?: Maybe<DelegatedStakingPoolBalancesMinFields>;
    stddev?: Maybe<DelegatedStakingPoolBalancesStddevFields>;
    stddev_pop?: Maybe<DelegatedStakingPoolBalancesStddevPopFields>;
    stddev_samp?: Maybe<DelegatedStakingPoolBalancesStddevSampFields>;
    sum?: Maybe<DelegatedStakingPoolBalancesSumFields>;
    var_pop?: Maybe<DelegatedStakingPoolBalancesVarPopFields>;
    var_samp?: Maybe<DelegatedStakingPoolBalancesVarSampFields>;
    variance?: Maybe<DelegatedStakingPoolBalancesVarianceFields>;
};
/** aggregate fields of "delegated_staking_pool_balances" */
type DelegatedStakingPoolBalancesAggregateFieldsCountArgs = {
    columns?: InputMaybe<Array<DelegatedStakingPoolBalancesSelectColumn>>;
    distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};
/** aggregate avg on columns */
type DelegatedStakingPoolBalancesAvgFields = {
    operator_commission_percentage?: Maybe<Scalars["Float"]["output"]>;
    total_coins?: Maybe<Scalars["Float"]["output"]>;
    total_shares?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** Boolean expression to filter rows from the table "delegated_staking_pool_balances". All fields are combined with a logical 'AND'. */
type DelegatedStakingPoolBalancesBoolExp = {
    _and?: InputMaybe<Array<DelegatedStakingPoolBalancesBoolExp>>;
    _not?: InputMaybe<DelegatedStakingPoolBalancesBoolExp>;
    _or?: InputMaybe<Array<DelegatedStakingPoolBalancesBoolExp>>;
    active_table_handle?: InputMaybe<StringComparisonExp>;
    inactive_table_handle?: InputMaybe<StringComparisonExp>;
    inserted_at?: InputMaybe<TimestampComparisonExp>;
    operator_commission_percentage?: InputMaybe<NumericComparisonExp>;
    staking_pool_address?: InputMaybe<StringComparisonExp>;
    total_coins?: InputMaybe<NumericComparisonExp>;
    total_shares?: InputMaybe<NumericComparisonExp>;
    transaction_version?: InputMaybe<BigintComparisonExp>;
};
/** unique or primary key constraints on table "delegated_staking_pool_balances" */
declare enum DelegatedStakingPoolBalancesConstraint {
    /** unique or primary key constraint on columns "staking_pool_address", "transaction_version" */
    DelegatedStakingPoolBalancesPkey = "delegated_staking_pool_balances_pkey"
}
/** input type for incrementing numeric columns in table "delegated_staking_pool_balances" */
type DelegatedStakingPoolBalancesIncInput = {
    operator_commission_percentage?: InputMaybe<Scalars["numeric"]["input"]>;
    total_coins?: InputMaybe<Scalars["numeric"]["input"]>;
    total_shares?: InputMaybe<Scalars["numeric"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** input type for inserting data into table "delegated_staking_pool_balances" */
type DelegatedStakingPoolBalancesInsertInput = {
    active_table_handle?: InputMaybe<Scalars["String"]["input"]>;
    inactive_table_handle?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    operator_commission_percentage?: InputMaybe<Scalars["numeric"]["input"]>;
    staking_pool_address?: InputMaybe<Scalars["String"]["input"]>;
    total_coins?: InputMaybe<Scalars["numeric"]["input"]>;
    total_shares?: InputMaybe<Scalars["numeric"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** aggregate max on columns */
type DelegatedStakingPoolBalancesMaxFields = {
    active_table_handle?: Maybe<Scalars["String"]["output"]>;
    inactive_table_handle?: Maybe<Scalars["String"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    operator_commission_percentage?: Maybe<Scalars["numeric"]["output"]>;
    staking_pool_address?: Maybe<Scalars["String"]["output"]>;
    total_coins?: Maybe<Scalars["numeric"]["output"]>;
    total_shares?: Maybe<Scalars["numeric"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};
/** aggregate min on columns */
type DelegatedStakingPoolBalancesMinFields = {
    active_table_handle?: Maybe<Scalars["String"]["output"]>;
    inactive_table_handle?: Maybe<Scalars["String"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    operator_commission_percentage?: Maybe<Scalars["numeric"]["output"]>;
    staking_pool_address?: Maybe<Scalars["String"]["output"]>;
    total_coins?: Maybe<Scalars["numeric"]["output"]>;
    total_shares?: Maybe<Scalars["numeric"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};
/** response of any mutation on the table "delegated_staking_pool_balances" */
type DelegatedStakingPoolBalancesMutationResponse = {
    /** number of rows affected by the mutation */
    affected_rows: Scalars["Int"]["output"];
    /** data from the rows affected by the mutation */
    returning: Array<DelegatedStakingPoolBalances>;
};
/** on_conflict condition type for table "delegated_staking_pool_balances" */
type DelegatedStakingPoolBalancesOnConflict = {
    constraint: DelegatedStakingPoolBalancesConstraint;
    update_columns?: Array<DelegatedStakingPoolBalancesUpdateColumn>;
    where?: InputMaybe<DelegatedStakingPoolBalancesBoolExp>;
};
/** Ordering options when selecting data from "delegated_staking_pool_balances". */
type DelegatedStakingPoolBalancesOrderBy = {
    active_table_handle?: InputMaybe<OrderBy>;
    inactive_table_handle?: InputMaybe<OrderBy>;
    inserted_at?: InputMaybe<OrderBy>;
    operator_commission_percentage?: InputMaybe<OrderBy>;
    staking_pool_address?: InputMaybe<OrderBy>;
    total_coins?: InputMaybe<OrderBy>;
    total_shares?: InputMaybe<OrderBy>;
    transaction_version?: InputMaybe<OrderBy>;
};
/** primary key columns input for table: delegated_staking_pool_balances */
type DelegatedStakingPoolBalancesPkColumnsInput = {
    staking_pool_address: Scalars["String"]["input"];
    transaction_version: Scalars["bigint"]["input"];
};
/** select columns of table "delegated_staking_pool_balances" */
declare enum DelegatedStakingPoolBalancesSelectColumn {
    /** column name */
    ActiveTableHandle = "active_table_handle",
    /** column name */
    InactiveTableHandle = "inactive_table_handle",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    OperatorCommissionPercentage = "operator_commission_percentage",
    /** column name */
    StakingPoolAddress = "staking_pool_address",
    /** column name */
    TotalCoins = "total_coins",
    /** column name */
    TotalShares = "total_shares",
    /** column name */
    TransactionVersion = "transaction_version"
}
/** input type for updating data in table "delegated_staking_pool_balances" */
type DelegatedStakingPoolBalancesSetInput = {
    active_table_handle?: InputMaybe<Scalars["String"]["input"]>;
    inactive_table_handle?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    operator_commission_percentage?: InputMaybe<Scalars["numeric"]["input"]>;
    staking_pool_address?: InputMaybe<Scalars["String"]["input"]>;
    total_coins?: InputMaybe<Scalars["numeric"]["input"]>;
    total_shares?: InputMaybe<Scalars["numeric"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** aggregate stddev on columns */
type DelegatedStakingPoolBalancesStddevFields = {
    operator_commission_percentage?: Maybe<Scalars["Float"]["output"]>;
    total_coins?: Maybe<Scalars["Float"]["output"]>;
    total_shares?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_pop on columns */
type DelegatedStakingPoolBalancesStddevPopFields = {
    operator_commission_percentage?: Maybe<Scalars["Float"]["output"]>;
    total_coins?: Maybe<Scalars["Float"]["output"]>;
    total_shares?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_samp on columns */
type DelegatedStakingPoolBalancesStddevSampFields = {
    operator_commission_percentage?: Maybe<Scalars["Float"]["output"]>;
    total_coins?: Maybe<Scalars["Float"]["output"]>;
    total_shares?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** Streaming cursor of the table "delegated_staking_pool_balances" */
type DelegatedStakingPoolBalancesStreamCursorInput = {
    /** Stream column input with initial value */
    initial_value: DelegatedStakingPoolBalancesStreamCursorValueInput;
    /** cursor ordering */
    ordering?: InputMaybe<CursorOrdering>;
};
/** Initial value of the column from where the streaming should start */
type DelegatedStakingPoolBalancesStreamCursorValueInput = {
    active_table_handle?: InputMaybe<Scalars["String"]["input"]>;
    inactive_table_handle?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    operator_commission_percentage?: InputMaybe<Scalars["numeric"]["input"]>;
    staking_pool_address?: InputMaybe<Scalars["String"]["input"]>;
    total_coins?: InputMaybe<Scalars["numeric"]["input"]>;
    total_shares?: InputMaybe<Scalars["numeric"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** aggregate sum on columns */
type DelegatedStakingPoolBalancesSumFields = {
    operator_commission_percentage?: Maybe<Scalars["numeric"]["output"]>;
    total_coins?: Maybe<Scalars["numeric"]["output"]>;
    total_shares?: Maybe<Scalars["numeric"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};
/** update columns of table "delegated_staking_pool_balances" */
declare enum DelegatedStakingPoolBalancesUpdateColumn {
    /** column name */
    ActiveTableHandle = "active_table_handle",
    /** column name */
    InactiveTableHandle = "inactive_table_handle",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    OperatorCommissionPercentage = "operator_commission_percentage",
    /** column name */
    StakingPoolAddress = "staking_pool_address",
    /** column name */
    TotalCoins = "total_coins",
    /** column name */
    TotalShares = "total_shares",
    /** column name */
    TransactionVersion = "transaction_version"
}
type DelegatedStakingPoolBalancesUpdates = {
    /** increments the numeric columns with given value of the filtered values */
    _inc?: InputMaybe<DelegatedStakingPoolBalancesIncInput>;
    /** sets the columns of the filtered rows to the given values */
    _set?: InputMaybe<DelegatedStakingPoolBalancesSetInput>;
    /** filter the rows which have to be updated */
    where: DelegatedStakingPoolBalancesBoolExp;
};
/** aggregate var_pop on columns */
type DelegatedStakingPoolBalancesVarPopFields = {
    operator_commission_percentage?: Maybe<Scalars["Float"]["output"]>;
    total_coins?: Maybe<Scalars["Float"]["output"]>;
    total_shares?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate var_samp on columns */
type DelegatedStakingPoolBalancesVarSampFields = {
    operator_commission_percentage?: Maybe<Scalars["Float"]["output"]>;
    total_coins?: Maybe<Scalars["Float"]["output"]>;
    total_shares?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate variance on columns */
type DelegatedStakingPoolBalancesVarianceFields = {
    operator_commission_percentage?: Maybe<Scalars["Float"]["output"]>;
    total_coins?: Maybe<Scalars["Float"]["output"]>;
    total_shares?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** columns and relationships of "delegated_staking_pools" */
type DelegatedStakingPools = {
    /** An object relationship */
    current_staking_pool?: Maybe<CurrentStakingPoolVoter>;
    first_transaction_version: Scalars["bigint"]["output"];
    inserted_at: Scalars["timestamp"]["output"];
    staking_pool_address: Scalars["String"]["output"];
};
/** aggregated selection of "delegated_staking_pools" */
type DelegatedStakingPoolsAggregate = {
    aggregate?: Maybe<DelegatedStakingPoolsAggregateFields>;
    nodes: Array<DelegatedStakingPools>;
};
/** aggregate fields of "delegated_staking_pools" */
type DelegatedStakingPoolsAggregateFields = {
    avg?: Maybe<DelegatedStakingPoolsAvgFields>;
    count: Scalars["Int"]["output"];
    max?: Maybe<DelegatedStakingPoolsMaxFields>;
    min?: Maybe<DelegatedStakingPoolsMinFields>;
    stddev?: Maybe<DelegatedStakingPoolsStddevFields>;
    stddev_pop?: Maybe<DelegatedStakingPoolsStddevPopFields>;
    stddev_samp?: Maybe<DelegatedStakingPoolsStddevSampFields>;
    sum?: Maybe<DelegatedStakingPoolsSumFields>;
    var_pop?: Maybe<DelegatedStakingPoolsVarPopFields>;
    var_samp?: Maybe<DelegatedStakingPoolsVarSampFields>;
    variance?: Maybe<DelegatedStakingPoolsVarianceFields>;
};
/** aggregate fields of "delegated_staking_pools" */
type DelegatedStakingPoolsAggregateFieldsCountArgs = {
    columns?: InputMaybe<Array<DelegatedStakingPoolsSelectColumn>>;
    distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};
/** aggregate avg on columns */
type DelegatedStakingPoolsAvgFields = {
    first_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** Boolean expression to filter rows from the table "delegated_staking_pools". All fields are combined with a logical 'AND'. */
type DelegatedStakingPoolsBoolExp = {
    _and?: InputMaybe<Array<DelegatedStakingPoolsBoolExp>>;
    _not?: InputMaybe<DelegatedStakingPoolsBoolExp>;
    _or?: InputMaybe<Array<DelegatedStakingPoolsBoolExp>>;
    current_staking_pool?: InputMaybe<CurrentStakingPoolVoterBoolExp>;
    first_transaction_version?: InputMaybe<BigintComparisonExp>;
    inserted_at?: InputMaybe<TimestampComparisonExp>;
    staking_pool_address?: InputMaybe<StringComparisonExp>;
};
/** unique or primary key constraints on table "delegated_staking_pools" */
declare enum DelegatedStakingPoolsConstraint {
    /** unique or primary key constraint on columns "staking_pool_address" */
    DelegatedStakingPoolsPkey = "delegated_staking_pools_pkey"
}
/** input type for incrementing numeric columns in table "delegated_staking_pools" */
type DelegatedStakingPoolsIncInput = {
    first_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** input type for inserting data into table "delegated_staking_pools" */
type DelegatedStakingPoolsInsertInput = {
    current_staking_pool?: InputMaybe<CurrentStakingPoolVoterObjRelInsertInput>;
    first_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    staking_pool_address?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregate max on columns */
type DelegatedStakingPoolsMaxFields = {
    first_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    staking_pool_address?: Maybe<Scalars["String"]["output"]>;
};
/** aggregate min on columns */
type DelegatedStakingPoolsMinFields = {
    first_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    staking_pool_address?: Maybe<Scalars["String"]["output"]>;
};
/** response of any mutation on the table "delegated_staking_pools" */
type DelegatedStakingPoolsMutationResponse = {
    /** number of rows affected by the mutation */
    affected_rows: Scalars["Int"]["output"];
    /** data from the rows affected by the mutation */
    returning: Array<DelegatedStakingPools>;
};
/** on_conflict condition type for table "delegated_staking_pools" */
type DelegatedStakingPoolsOnConflict = {
    constraint: DelegatedStakingPoolsConstraint;
    update_columns?: Array<DelegatedStakingPoolsUpdateColumn>;
    where?: InputMaybe<DelegatedStakingPoolsBoolExp>;
};
/** Ordering options when selecting data from "delegated_staking_pools". */
type DelegatedStakingPoolsOrderBy = {
    current_staking_pool?: InputMaybe<CurrentStakingPoolVoterOrderBy>;
    first_transaction_version?: InputMaybe<OrderBy>;
    inserted_at?: InputMaybe<OrderBy>;
    staking_pool_address?: InputMaybe<OrderBy>;
};
/** primary key columns input for table: delegated_staking_pools */
type DelegatedStakingPoolsPkColumnsInput = {
    staking_pool_address: Scalars["String"]["input"];
};
/** select columns of table "delegated_staking_pools" */
declare enum DelegatedStakingPoolsSelectColumn {
    /** column name */
    FirstTransactionVersion = "first_transaction_version",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    StakingPoolAddress = "staking_pool_address"
}
/** input type for updating data in table "delegated_staking_pools" */
type DelegatedStakingPoolsSetInput = {
    first_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    staking_pool_address?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregate stddev on columns */
type DelegatedStakingPoolsStddevFields = {
    first_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_pop on columns */
type DelegatedStakingPoolsStddevPopFields = {
    first_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_samp on columns */
type DelegatedStakingPoolsStddevSampFields = {
    first_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** Streaming cursor of the table "delegated_staking_pools" */
type DelegatedStakingPoolsStreamCursorInput = {
    /** Stream column input with initial value */
    initial_value: DelegatedStakingPoolsStreamCursorValueInput;
    /** cursor ordering */
    ordering?: InputMaybe<CursorOrdering>;
};
/** Initial value of the column from where the streaming should start */
type DelegatedStakingPoolsStreamCursorValueInput = {
    first_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    staking_pool_address?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregate sum on columns */
type DelegatedStakingPoolsSumFields = {
    first_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};
/** update columns of table "delegated_staking_pools" */
declare enum DelegatedStakingPoolsUpdateColumn {
    /** column name */
    FirstTransactionVersion = "first_transaction_version",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    StakingPoolAddress = "staking_pool_address"
}
type DelegatedStakingPoolsUpdates = {
    /** increments the numeric columns with given value of the filtered values */
    _inc?: InputMaybe<DelegatedStakingPoolsIncInput>;
    /** sets the columns of the filtered rows to the given values */
    _set?: InputMaybe<DelegatedStakingPoolsSetInput>;
    /** filter the rows which have to be updated */
    where: DelegatedStakingPoolsBoolExp;
};
/** aggregate var_pop on columns */
type DelegatedStakingPoolsVarPopFields = {
    first_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate var_samp on columns */
type DelegatedStakingPoolsVarSampFields = {
    first_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate variance on columns */
type DelegatedStakingPoolsVarianceFields = {
    first_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** columns and relationships of "delegator_balances" */
type DelegatorBalances = {
    delegator_address: Scalars["String"]["output"];
    inserted_at: Scalars["timestamp"]["output"];
    parent_table_handle: Scalars["String"]["output"];
    pool_address: Scalars["String"]["output"];
    pool_type: Scalars["String"]["output"];
    shares: Scalars["numeric"]["output"];
    table_handle: Scalars["String"]["output"];
    transaction_version: Scalars["bigint"]["output"];
    write_set_change_index: Scalars["bigint"]["output"];
};
/** aggregated selection of "delegator_balances" */
type DelegatorBalancesAggregate = {
    aggregate?: Maybe<DelegatorBalancesAggregateFields>;
    nodes: Array<DelegatorBalances>;
};
/** aggregate fields of "delegator_balances" */
type DelegatorBalancesAggregateFields = {
    avg?: Maybe<DelegatorBalancesAvgFields>;
    count: Scalars["Int"]["output"];
    max?: Maybe<DelegatorBalancesMaxFields>;
    min?: Maybe<DelegatorBalancesMinFields>;
    stddev?: Maybe<DelegatorBalancesStddevFields>;
    stddev_pop?: Maybe<DelegatorBalancesStddevPopFields>;
    stddev_samp?: Maybe<DelegatorBalancesStddevSampFields>;
    sum?: Maybe<DelegatorBalancesSumFields>;
    var_pop?: Maybe<DelegatorBalancesVarPopFields>;
    var_samp?: Maybe<DelegatorBalancesVarSampFields>;
    variance?: Maybe<DelegatorBalancesVarianceFields>;
};
/** aggregate fields of "delegator_balances" */
type DelegatorBalancesAggregateFieldsCountArgs = {
    columns?: InputMaybe<Array<DelegatorBalancesSelectColumn>>;
    distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};
/** aggregate avg on columns */
type DelegatorBalancesAvgFields = {
    shares?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};
/** Boolean expression to filter rows from the table "delegator_balances". All fields are combined with a logical 'AND'. */
type DelegatorBalancesBoolExp = {
    _and?: InputMaybe<Array<DelegatorBalancesBoolExp>>;
    _not?: InputMaybe<DelegatorBalancesBoolExp>;
    _or?: InputMaybe<Array<DelegatorBalancesBoolExp>>;
    delegator_address?: InputMaybe<StringComparisonExp>;
    inserted_at?: InputMaybe<TimestampComparisonExp>;
    parent_table_handle?: InputMaybe<StringComparisonExp>;
    pool_address?: InputMaybe<StringComparisonExp>;
    pool_type?: InputMaybe<StringComparisonExp>;
    shares?: InputMaybe<NumericComparisonExp>;
    table_handle?: InputMaybe<StringComparisonExp>;
    transaction_version?: InputMaybe<BigintComparisonExp>;
    write_set_change_index?: InputMaybe<BigintComparisonExp>;
};
/** unique or primary key constraints on table "delegator_balances" */
declare enum DelegatorBalancesConstraint {
    /** unique or primary key constraint on columns "write_set_change_index", "transaction_version" */
    DelegatorBalancesPkey = "delegator_balances_pkey"
}
/** input type for incrementing numeric columns in table "delegator_balances" */
type DelegatorBalancesIncInput = {
    shares?: InputMaybe<Scalars["numeric"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** input type for inserting data into table "delegator_balances" */
type DelegatorBalancesInsertInput = {
    delegator_address?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    parent_table_handle?: InputMaybe<Scalars["String"]["input"]>;
    pool_address?: InputMaybe<Scalars["String"]["input"]>;
    pool_type?: InputMaybe<Scalars["String"]["input"]>;
    shares?: InputMaybe<Scalars["numeric"]["input"]>;
    table_handle?: InputMaybe<Scalars["String"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** aggregate max on columns */
type DelegatorBalancesMaxFields = {
    delegator_address?: Maybe<Scalars["String"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    parent_table_handle?: Maybe<Scalars["String"]["output"]>;
    pool_address?: Maybe<Scalars["String"]["output"]>;
    pool_type?: Maybe<Scalars["String"]["output"]>;
    shares?: Maybe<Scalars["numeric"]["output"]>;
    table_handle?: Maybe<Scalars["String"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    write_set_change_index?: Maybe<Scalars["bigint"]["output"]>;
};
/** aggregate min on columns */
type DelegatorBalancesMinFields = {
    delegator_address?: Maybe<Scalars["String"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    parent_table_handle?: Maybe<Scalars["String"]["output"]>;
    pool_address?: Maybe<Scalars["String"]["output"]>;
    pool_type?: Maybe<Scalars["String"]["output"]>;
    shares?: Maybe<Scalars["numeric"]["output"]>;
    table_handle?: Maybe<Scalars["String"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    write_set_change_index?: Maybe<Scalars["bigint"]["output"]>;
};
/** response of any mutation on the table "delegator_balances" */
type DelegatorBalancesMutationResponse = {
    /** number of rows affected by the mutation */
    affected_rows: Scalars["Int"]["output"];
    /** data from the rows affected by the mutation */
    returning: Array<DelegatorBalances>;
};
/** on_conflict condition type for table "delegator_balances" */
type DelegatorBalancesOnConflict = {
    constraint: DelegatorBalancesConstraint;
    update_columns?: Array<DelegatorBalancesUpdateColumn>;
    where?: InputMaybe<DelegatorBalancesBoolExp>;
};
/** Ordering options when selecting data from "delegator_balances". */
type DelegatorBalancesOrderBy = {
    delegator_address?: InputMaybe<OrderBy>;
    inserted_at?: InputMaybe<OrderBy>;
    parent_table_handle?: InputMaybe<OrderBy>;
    pool_address?: InputMaybe<OrderBy>;
    pool_type?: InputMaybe<OrderBy>;
    shares?: InputMaybe<OrderBy>;
    table_handle?: InputMaybe<OrderBy>;
    transaction_version?: InputMaybe<OrderBy>;
    write_set_change_index?: InputMaybe<OrderBy>;
};
/** primary key columns input for table: delegator_balances */
type DelegatorBalancesPkColumnsInput = {
    transaction_version: Scalars["bigint"]["input"];
    write_set_change_index: Scalars["bigint"]["input"];
};
/** select columns of table "delegator_balances" */
declare enum DelegatorBalancesSelectColumn {
    /** column name */
    DelegatorAddress = "delegator_address",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    ParentTableHandle = "parent_table_handle",
    /** column name */
    PoolAddress = "pool_address",
    /** column name */
    PoolType = "pool_type",
    /** column name */
    Shares = "shares",
    /** column name */
    TableHandle = "table_handle",
    /** column name */
    TransactionVersion = "transaction_version",
    /** column name */
    WriteSetChangeIndex = "write_set_change_index"
}
/** input type for updating data in table "delegator_balances" */
type DelegatorBalancesSetInput = {
    delegator_address?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    parent_table_handle?: InputMaybe<Scalars["String"]["input"]>;
    pool_address?: InputMaybe<Scalars["String"]["input"]>;
    pool_type?: InputMaybe<Scalars["String"]["input"]>;
    shares?: InputMaybe<Scalars["numeric"]["input"]>;
    table_handle?: InputMaybe<Scalars["String"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** aggregate stddev on columns */
type DelegatorBalancesStddevFields = {
    shares?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_pop on columns */
type DelegatorBalancesStddevPopFields = {
    shares?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_samp on columns */
type DelegatorBalancesStddevSampFields = {
    shares?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};
/** Streaming cursor of the table "delegator_balances" */
type DelegatorBalancesStreamCursorInput = {
    /** Stream column input with initial value */
    initial_value: DelegatorBalancesStreamCursorValueInput;
    /** cursor ordering */
    ordering?: InputMaybe<CursorOrdering>;
};
/** Initial value of the column from where the streaming should start */
type DelegatorBalancesStreamCursorValueInput = {
    delegator_address?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    parent_table_handle?: InputMaybe<Scalars["String"]["input"]>;
    pool_address?: InputMaybe<Scalars["String"]["input"]>;
    pool_type?: InputMaybe<Scalars["String"]["input"]>;
    shares?: InputMaybe<Scalars["numeric"]["input"]>;
    table_handle?: InputMaybe<Scalars["String"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** aggregate sum on columns */
type DelegatorBalancesSumFields = {
    shares?: Maybe<Scalars["numeric"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    write_set_change_index?: Maybe<Scalars["bigint"]["output"]>;
};
/** update columns of table "delegator_balances" */
declare enum DelegatorBalancesUpdateColumn {
    /** column name */
    DelegatorAddress = "delegator_address",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    ParentTableHandle = "parent_table_handle",
    /** column name */
    PoolAddress = "pool_address",
    /** column name */
    PoolType = "pool_type",
    /** column name */
    Shares = "shares",
    /** column name */
    TableHandle = "table_handle",
    /** column name */
    TransactionVersion = "transaction_version",
    /** column name */
    WriteSetChangeIndex = "write_set_change_index"
}
type DelegatorBalancesUpdates = {
    /** increments the numeric columns with given value of the filtered values */
    _inc?: InputMaybe<DelegatorBalancesIncInput>;
    /** sets the columns of the filtered rows to the given values */
    _set?: InputMaybe<DelegatorBalancesSetInput>;
    /** filter the rows which have to be updated */
    where: DelegatorBalancesBoolExp;
};
/** aggregate var_pop on columns */
type DelegatorBalancesVarPopFields = {
    shares?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate var_samp on columns */
type DelegatorBalancesVarSampFields = {
    shares?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate variance on columns */
type DelegatorBalancesVarianceFields = {
    shares?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};
/** columns and relationships of "delegator_distinct_pool" */
type DelegatorDistinctPool = {
    /** An object relationship */
    current_pool_balance?: Maybe<CurrentDelegatedStakingPoolBalances>;
    delegator_address?: Maybe<Scalars["String"]["output"]>;
    pool_address?: Maybe<Scalars["String"]["output"]>;
    /** An object relationship */
    staking_pool_metadata?: Maybe<CurrentStakingPoolVoter>;
};
/** aggregated selection of "delegator_distinct_pool" */
type DelegatorDistinctPoolAggregate = {
    aggregate?: Maybe<DelegatorDistinctPoolAggregateFields>;
    nodes: Array<DelegatorDistinctPool>;
};
/** aggregate fields of "delegator_distinct_pool" */
type DelegatorDistinctPoolAggregateFields = {
    count: Scalars["Int"]["output"];
    max?: Maybe<DelegatorDistinctPoolMaxFields>;
    min?: Maybe<DelegatorDistinctPoolMinFields>;
};
/** aggregate fields of "delegator_distinct_pool" */
type DelegatorDistinctPoolAggregateFieldsCountArgs = {
    columns?: InputMaybe<Array<DelegatorDistinctPoolSelectColumn>>;
    distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};
/** Boolean expression to filter rows from the table "delegator_distinct_pool". All fields are combined with a logical 'AND'. */
type DelegatorDistinctPoolBoolExp = {
    _and?: InputMaybe<Array<DelegatorDistinctPoolBoolExp>>;
    _not?: InputMaybe<DelegatorDistinctPoolBoolExp>;
    _or?: InputMaybe<Array<DelegatorDistinctPoolBoolExp>>;
    current_pool_balance?: InputMaybe<CurrentDelegatedStakingPoolBalancesBoolExp>;
    delegator_address?: InputMaybe<StringComparisonExp>;
    pool_address?: InputMaybe<StringComparisonExp>;
    staking_pool_metadata?: InputMaybe<CurrentStakingPoolVoterBoolExp>;
};
/** aggregate max on columns */
type DelegatorDistinctPoolMaxFields = {
    delegator_address?: Maybe<Scalars["String"]["output"]>;
    pool_address?: Maybe<Scalars["String"]["output"]>;
};
/** aggregate min on columns */
type DelegatorDistinctPoolMinFields = {
    delegator_address?: Maybe<Scalars["String"]["output"]>;
    pool_address?: Maybe<Scalars["String"]["output"]>;
};
/** Ordering options when selecting data from "delegator_distinct_pool". */
type DelegatorDistinctPoolOrderBy = {
    current_pool_balance?: InputMaybe<CurrentDelegatedStakingPoolBalancesOrderBy>;
    delegator_address?: InputMaybe<OrderBy>;
    pool_address?: InputMaybe<OrderBy>;
    staking_pool_metadata?: InputMaybe<CurrentStakingPoolVoterOrderBy>;
};
/** select columns of table "delegator_distinct_pool" */
declare enum DelegatorDistinctPoolSelectColumn {
    /** column name */
    DelegatorAddress = "delegator_address",
    /** column name */
    PoolAddress = "pool_address"
}
/** Streaming cursor of the table "delegator_distinct_pool" */
type DelegatorDistinctPoolStreamCursorInput = {
    /** Stream column input with initial value */
    initial_value: DelegatorDistinctPoolStreamCursorValueInput;
    /** cursor ordering */
    ordering?: InputMaybe<CursorOrdering>;
};
/** Initial value of the column from where the streaming should start */
type DelegatorDistinctPoolStreamCursorValueInput = {
    delegator_address?: InputMaybe<Scalars["String"]["input"]>;
    pool_address?: InputMaybe<Scalars["String"]["input"]>;
};
/** columns and relationships of "event_size_info" */
type EventSizeInfo = {
    index: Scalars["bigint"]["output"];
    inserted_at: Scalars["timestamp"]["output"];
    total_bytes: Scalars["bigint"]["output"];
    transaction_version: Scalars["bigint"]["output"];
    type_tag_bytes: Scalars["bigint"]["output"];
};
/** aggregated selection of "event_size_info" */
type EventSizeInfoAggregate = {
    aggregate?: Maybe<EventSizeInfoAggregateFields>;
    nodes: Array<EventSizeInfo>;
};
/** aggregate fields of "event_size_info" */
type EventSizeInfoAggregateFields = {
    avg?: Maybe<EventSizeInfoAvgFields>;
    count: Scalars["Int"]["output"];
    max?: Maybe<EventSizeInfoMaxFields>;
    min?: Maybe<EventSizeInfoMinFields>;
    stddev?: Maybe<EventSizeInfoStddevFields>;
    stddev_pop?: Maybe<EventSizeInfoStddevPopFields>;
    stddev_samp?: Maybe<EventSizeInfoStddevSampFields>;
    sum?: Maybe<EventSizeInfoSumFields>;
    var_pop?: Maybe<EventSizeInfoVarPopFields>;
    var_samp?: Maybe<EventSizeInfoVarSampFields>;
    variance?: Maybe<EventSizeInfoVarianceFields>;
};
/** aggregate fields of "event_size_info" */
type EventSizeInfoAggregateFieldsCountArgs = {
    columns?: InputMaybe<Array<EventSizeInfoSelectColumn>>;
    distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};
/** aggregate avg on columns */
type EventSizeInfoAvgFields = {
    index?: Maybe<Scalars["Float"]["output"]>;
    total_bytes?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    type_tag_bytes?: Maybe<Scalars["Float"]["output"]>;
};
/** Boolean expression to filter rows from the table "event_size_info". All fields are combined with a logical 'AND'. */
type EventSizeInfoBoolExp = {
    _and?: InputMaybe<Array<EventSizeInfoBoolExp>>;
    _not?: InputMaybe<EventSizeInfoBoolExp>;
    _or?: InputMaybe<Array<EventSizeInfoBoolExp>>;
    index?: InputMaybe<BigintComparisonExp>;
    inserted_at?: InputMaybe<TimestampComparisonExp>;
    total_bytes?: InputMaybe<BigintComparisonExp>;
    transaction_version?: InputMaybe<BigintComparisonExp>;
    type_tag_bytes?: InputMaybe<BigintComparisonExp>;
};
/** unique or primary key constraints on table "event_size_info" */
declare enum EventSizeInfoConstraint {
    /** unique or primary key constraint on columns "index", "transaction_version" */
    EventSizeInfoPkey = "event_size_info_pkey"
}
/** input type for incrementing numeric columns in table "event_size_info" */
type EventSizeInfoIncInput = {
    index?: InputMaybe<Scalars["bigint"]["input"]>;
    total_bytes?: InputMaybe<Scalars["bigint"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    type_tag_bytes?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** input type for inserting data into table "event_size_info" */
type EventSizeInfoInsertInput = {
    index?: InputMaybe<Scalars["bigint"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    total_bytes?: InputMaybe<Scalars["bigint"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    type_tag_bytes?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** aggregate max on columns */
type EventSizeInfoMaxFields = {
    index?: Maybe<Scalars["bigint"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    total_bytes?: Maybe<Scalars["bigint"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    type_tag_bytes?: Maybe<Scalars["bigint"]["output"]>;
};
/** aggregate min on columns */
type EventSizeInfoMinFields = {
    index?: Maybe<Scalars["bigint"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    total_bytes?: Maybe<Scalars["bigint"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    type_tag_bytes?: Maybe<Scalars["bigint"]["output"]>;
};
/** response of any mutation on the table "event_size_info" */
type EventSizeInfoMutationResponse = {
    /** number of rows affected by the mutation */
    affected_rows: Scalars["Int"]["output"];
    /** data from the rows affected by the mutation */
    returning: Array<EventSizeInfo>;
};
/** on_conflict condition type for table "event_size_info" */
type EventSizeInfoOnConflict = {
    constraint: EventSizeInfoConstraint;
    update_columns?: Array<EventSizeInfoUpdateColumn>;
    where?: InputMaybe<EventSizeInfoBoolExp>;
};
/** Ordering options when selecting data from "event_size_info". */
type EventSizeInfoOrderBy = {
    index?: InputMaybe<OrderBy>;
    inserted_at?: InputMaybe<OrderBy>;
    total_bytes?: InputMaybe<OrderBy>;
    transaction_version?: InputMaybe<OrderBy>;
    type_tag_bytes?: InputMaybe<OrderBy>;
};
/** primary key columns input for table: event_size_info */
type EventSizeInfoPkColumnsInput = {
    index: Scalars["bigint"]["input"];
    transaction_version: Scalars["bigint"]["input"];
};
/** select columns of table "event_size_info" */
declare enum EventSizeInfoSelectColumn {
    /** column name */
    Index = "index",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    TotalBytes = "total_bytes",
    /** column name */
    TransactionVersion = "transaction_version",
    /** column name */
    TypeTagBytes = "type_tag_bytes"
}
/** input type for updating data in table "event_size_info" */
type EventSizeInfoSetInput = {
    index?: InputMaybe<Scalars["bigint"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    total_bytes?: InputMaybe<Scalars["bigint"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    type_tag_bytes?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** aggregate stddev on columns */
type EventSizeInfoStddevFields = {
    index?: Maybe<Scalars["Float"]["output"]>;
    total_bytes?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    type_tag_bytes?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_pop on columns */
type EventSizeInfoStddevPopFields = {
    index?: Maybe<Scalars["Float"]["output"]>;
    total_bytes?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    type_tag_bytes?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_samp on columns */
type EventSizeInfoStddevSampFields = {
    index?: Maybe<Scalars["Float"]["output"]>;
    total_bytes?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    type_tag_bytes?: Maybe<Scalars["Float"]["output"]>;
};
/** Streaming cursor of the table "event_size_info" */
type EventSizeInfoStreamCursorInput = {
    /** Stream column input with initial value */
    initial_value: EventSizeInfoStreamCursorValueInput;
    /** cursor ordering */
    ordering?: InputMaybe<CursorOrdering>;
};
/** Initial value of the column from where the streaming should start */
type EventSizeInfoStreamCursorValueInput = {
    index?: InputMaybe<Scalars["bigint"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    total_bytes?: InputMaybe<Scalars["bigint"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    type_tag_bytes?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** aggregate sum on columns */
type EventSizeInfoSumFields = {
    index?: Maybe<Scalars["bigint"]["output"]>;
    total_bytes?: Maybe<Scalars["bigint"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    type_tag_bytes?: Maybe<Scalars["bigint"]["output"]>;
};
/** update columns of table "event_size_info" */
declare enum EventSizeInfoUpdateColumn {
    /** column name */
    Index = "index",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    TotalBytes = "total_bytes",
    /** column name */
    TransactionVersion = "transaction_version",
    /** column name */
    TypeTagBytes = "type_tag_bytes"
}
type EventSizeInfoUpdates = {
    /** increments the numeric columns with given value of the filtered values */
    _inc?: InputMaybe<EventSizeInfoIncInput>;
    /** sets the columns of the filtered rows to the given values */
    _set?: InputMaybe<EventSizeInfoSetInput>;
    /** filter the rows which have to be updated */
    where: EventSizeInfoBoolExp;
};
/** aggregate var_pop on columns */
type EventSizeInfoVarPopFields = {
    index?: Maybe<Scalars["Float"]["output"]>;
    total_bytes?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    type_tag_bytes?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate var_samp on columns */
type EventSizeInfoVarSampFields = {
    index?: Maybe<Scalars["Float"]["output"]>;
    total_bytes?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    type_tag_bytes?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate variance on columns */
type EventSizeInfoVarianceFields = {
    index?: Maybe<Scalars["Float"]["output"]>;
    total_bytes?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    type_tag_bytes?: Maybe<Scalars["Float"]["output"]>;
};
/** columns and relationships of "events" */
type Events = {
    account_address: Scalars["String"]["output"];
    creation_number: Scalars["bigint"]["output"];
    data: Scalars["jsonb"]["output"];
    event_index: Scalars["bigint"]["output"];
    indexed_type: Scalars["String"]["output"];
    inserted_at: Scalars["timestamp"]["output"];
    sequence_number: Scalars["bigint"]["output"];
    transaction_block_height: Scalars["bigint"]["output"];
    transaction_version: Scalars["bigint"]["output"];
    type: Scalars["String"]["output"];
};
/** columns and relationships of "events" */
type EventsDataArgs = {
    path?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregated selection of "events" */
type EventsAggregate = {
    aggregate?: Maybe<EventsAggregateFields>;
    nodes: Array<Events>;
};
/** aggregate fields of "events" */
type EventsAggregateFields = {
    avg?: Maybe<EventsAvgFields>;
    count: Scalars["Int"]["output"];
    max?: Maybe<EventsMaxFields>;
    min?: Maybe<EventsMinFields>;
    stddev?: Maybe<EventsStddevFields>;
    stddev_pop?: Maybe<EventsStddevPopFields>;
    stddev_samp?: Maybe<EventsStddevSampFields>;
    sum?: Maybe<EventsSumFields>;
    var_pop?: Maybe<EventsVarPopFields>;
    var_samp?: Maybe<EventsVarSampFields>;
    variance?: Maybe<EventsVarianceFields>;
};
/** aggregate fields of "events" */
type EventsAggregateFieldsCountArgs = {
    columns?: InputMaybe<Array<EventsSelectColumn>>;
    distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};
/** append existing jsonb value of filtered columns with new jsonb value */
type EventsAppendInput = {
    data?: InputMaybe<Scalars["jsonb"]["input"]>;
};
/** aggregate avg on columns */
type EventsAvgFields = {
    creation_number?: Maybe<Scalars["Float"]["output"]>;
    event_index?: Maybe<Scalars["Float"]["output"]>;
    sequence_number?: Maybe<Scalars["Float"]["output"]>;
    transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** Boolean expression to filter rows from the table "events". All fields are combined with a logical 'AND'. */
type EventsBoolExp = {
    _and?: InputMaybe<Array<EventsBoolExp>>;
    _not?: InputMaybe<EventsBoolExp>;
    _or?: InputMaybe<Array<EventsBoolExp>>;
    account_address?: InputMaybe<StringComparisonExp>;
    creation_number?: InputMaybe<BigintComparisonExp>;
    data?: InputMaybe<JsonbComparisonExp>;
    event_index?: InputMaybe<BigintComparisonExp>;
    indexed_type?: InputMaybe<StringComparisonExp>;
    inserted_at?: InputMaybe<TimestampComparisonExp>;
    sequence_number?: InputMaybe<BigintComparisonExp>;
    transaction_block_height?: InputMaybe<BigintComparisonExp>;
    transaction_version?: InputMaybe<BigintComparisonExp>;
    type?: InputMaybe<StringComparisonExp>;
};
/** unique or primary key constraints on table "events" */
declare enum EventsConstraint {
    /** unique or primary key constraint on columns "event_index", "transaction_version" */
    EventsPkey = "events_pkey"
}
/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
type EventsDeleteAtPathInput = {
    data?: InputMaybe<Array<Scalars["String"]["input"]>>;
};
/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
type EventsDeleteElemInput = {
    data?: InputMaybe<Scalars["Int"]["input"]>;
};
/** delete key/value pair or string element. key/value pairs are matched based on their key value */
type EventsDeleteKeyInput = {
    data?: InputMaybe<Scalars["String"]["input"]>;
};
/** input type for incrementing numeric columns in table "events" */
type EventsIncInput = {
    creation_number?: InputMaybe<Scalars["bigint"]["input"]>;
    event_index?: InputMaybe<Scalars["bigint"]["input"]>;
    sequence_number?: InputMaybe<Scalars["bigint"]["input"]>;
    transaction_block_height?: InputMaybe<Scalars["bigint"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** input type for inserting data into table "events" */
type EventsInsertInput = {
    account_address?: InputMaybe<Scalars["String"]["input"]>;
    creation_number?: InputMaybe<Scalars["bigint"]["input"]>;
    data?: InputMaybe<Scalars["jsonb"]["input"]>;
    event_index?: InputMaybe<Scalars["bigint"]["input"]>;
    indexed_type?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    sequence_number?: InputMaybe<Scalars["bigint"]["input"]>;
    transaction_block_height?: InputMaybe<Scalars["bigint"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    type?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregate max on columns */
type EventsMaxFields = {
    account_address?: Maybe<Scalars["String"]["output"]>;
    creation_number?: Maybe<Scalars["bigint"]["output"]>;
    event_index?: Maybe<Scalars["bigint"]["output"]>;
    indexed_type?: Maybe<Scalars["String"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    sequence_number?: Maybe<Scalars["bigint"]["output"]>;
    transaction_block_height?: Maybe<Scalars["bigint"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    type?: Maybe<Scalars["String"]["output"]>;
};
/** aggregate min on columns */
type EventsMinFields = {
    account_address?: Maybe<Scalars["String"]["output"]>;
    creation_number?: Maybe<Scalars["bigint"]["output"]>;
    event_index?: Maybe<Scalars["bigint"]["output"]>;
    indexed_type?: Maybe<Scalars["String"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    sequence_number?: Maybe<Scalars["bigint"]["output"]>;
    transaction_block_height?: Maybe<Scalars["bigint"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    type?: Maybe<Scalars["String"]["output"]>;
};
/** response of any mutation on the table "events" */
type EventsMutationResponse = {
    /** number of rows affected by the mutation */
    affected_rows: Scalars["Int"]["output"];
    /** data from the rows affected by the mutation */
    returning: Array<Events>;
};
/** on_conflict condition type for table "events" */
type EventsOnConflict = {
    constraint: EventsConstraint;
    update_columns?: Array<EventsUpdateColumn>;
    where?: InputMaybe<EventsBoolExp>;
};
/** Ordering options when selecting data from "events". */
type EventsOrderBy = {
    account_address?: InputMaybe<OrderBy>;
    creation_number?: InputMaybe<OrderBy>;
    data?: InputMaybe<OrderBy>;
    event_index?: InputMaybe<OrderBy>;
    indexed_type?: InputMaybe<OrderBy>;
    inserted_at?: InputMaybe<OrderBy>;
    sequence_number?: InputMaybe<OrderBy>;
    transaction_block_height?: InputMaybe<OrderBy>;
    transaction_version?: InputMaybe<OrderBy>;
    type?: InputMaybe<OrderBy>;
};
/** primary key columns input for table: events */
type EventsPkColumnsInput = {
    event_index: Scalars["bigint"]["input"];
    transaction_version: Scalars["bigint"]["input"];
};
/** prepend existing jsonb value of filtered columns with new jsonb value */
type EventsPrependInput = {
    data?: InputMaybe<Scalars["jsonb"]["input"]>;
};
/** select columns of table "events" */
declare enum EventsSelectColumn {
    /** column name */
    AccountAddress = "account_address",
    /** column name */
    CreationNumber = "creation_number",
    /** column name */
    Data = "data",
    /** column name */
    EventIndex = "event_index",
    /** column name */
    IndexedType = "indexed_type",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    SequenceNumber = "sequence_number",
    /** column name */
    TransactionBlockHeight = "transaction_block_height",
    /** column name */
    TransactionVersion = "transaction_version",
    /** column name */
    Type = "type"
}
/** input type for updating data in table "events" */
type EventsSetInput = {
    account_address?: InputMaybe<Scalars["String"]["input"]>;
    creation_number?: InputMaybe<Scalars["bigint"]["input"]>;
    data?: InputMaybe<Scalars["jsonb"]["input"]>;
    event_index?: InputMaybe<Scalars["bigint"]["input"]>;
    indexed_type?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    sequence_number?: InputMaybe<Scalars["bigint"]["input"]>;
    transaction_block_height?: InputMaybe<Scalars["bigint"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    type?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregate stddev on columns */
type EventsStddevFields = {
    creation_number?: Maybe<Scalars["Float"]["output"]>;
    event_index?: Maybe<Scalars["Float"]["output"]>;
    sequence_number?: Maybe<Scalars["Float"]["output"]>;
    transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_pop on columns */
type EventsStddevPopFields = {
    creation_number?: Maybe<Scalars["Float"]["output"]>;
    event_index?: Maybe<Scalars["Float"]["output"]>;
    sequence_number?: Maybe<Scalars["Float"]["output"]>;
    transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_samp on columns */
type EventsStddevSampFields = {
    creation_number?: Maybe<Scalars["Float"]["output"]>;
    event_index?: Maybe<Scalars["Float"]["output"]>;
    sequence_number?: Maybe<Scalars["Float"]["output"]>;
    transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** Streaming cursor of the table "events" */
type EventsStreamCursorInput = {
    /** Stream column input with initial value */
    initial_value: EventsStreamCursorValueInput;
    /** cursor ordering */
    ordering?: InputMaybe<CursorOrdering>;
};
/** Initial value of the column from where the streaming should start */
type EventsStreamCursorValueInput = {
    account_address?: InputMaybe<Scalars["String"]["input"]>;
    creation_number?: InputMaybe<Scalars["bigint"]["input"]>;
    data?: InputMaybe<Scalars["jsonb"]["input"]>;
    event_index?: InputMaybe<Scalars["bigint"]["input"]>;
    indexed_type?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    sequence_number?: InputMaybe<Scalars["bigint"]["input"]>;
    transaction_block_height?: InputMaybe<Scalars["bigint"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    type?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregate sum on columns */
type EventsSumFields = {
    creation_number?: Maybe<Scalars["bigint"]["output"]>;
    event_index?: Maybe<Scalars["bigint"]["output"]>;
    sequence_number?: Maybe<Scalars["bigint"]["output"]>;
    transaction_block_height?: Maybe<Scalars["bigint"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};
/** update columns of table "events" */
declare enum EventsUpdateColumn {
    /** column name */
    AccountAddress = "account_address",
    /** column name */
    CreationNumber = "creation_number",
    /** column name */
    Data = "data",
    /** column name */
    EventIndex = "event_index",
    /** column name */
    IndexedType = "indexed_type",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    SequenceNumber = "sequence_number",
    /** column name */
    TransactionBlockHeight = "transaction_block_height",
    /** column name */
    TransactionVersion = "transaction_version",
    /** column name */
    Type = "type"
}
type EventsUpdates = {
    /** append existing jsonb value of filtered columns with new jsonb value */
    _append?: InputMaybe<EventsAppendInput>;
    /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
    _delete_at_path?: InputMaybe<EventsDeleteAtPathInput>;
    /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
    _delete_elem?: InputMaybe<EventsDeleteElemInput>;
    /** delete key/value pair or string element. key/value pairs are matched based on their key value */
    _delete_key?: InputMaybe<EventsDeleteKeyInput>;
    /** increments the numeric columns with given value of the filtered values */
    _inc?: InputMaybe<EventsIncInput>;
    /** prepend existing jsonb value of filtered columns with new jsonb value */
    _prepend?: InputMaybe<EventsPrependInput>;
    /** sets the columns of the filtered rows to the given values */
    _set?: InputMaybe<EventsSetInput>;
    /** filter the rows which have to be updated */
    where: EventsBoolExp;
};
/** aggregate var_pop on columns */
type EventsVarPopFields = {
    creation_number?: Maybe<Scalars["Float"]["output"]>;
    event_index?: Maybe<Scalars["Float"]["output"]>;
    sequence_number?: Maybe<Scalars["Float"]["output"]>;
    transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate var_samp on columns */
type EventsVarSampFields = {
    creation_number?: Maybe<Scalars["Float"]["output"]>;
    event_index?: Maybe<Scalars["Float"]["output"]>;
    sequence_number?: Maybe<Scalars["Float"]["output"]>;
    transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate variance on columns */
type EventsVarianceFields = {
    creation_number?: Maybe<Scalars["Float"]["output"]>;
    event_index?: Maybe<Scalars["Float"]["output"]>;
    sequence_number?: Maybe<Scalars["Float"]["output"]>;
    transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** columns and relationships of "events_view" */
type EventsView = {
    account_address?: Maybe<Scalars["String"]["output"]>;
    creation_number?: Maybe<Scalars["bigint"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    json_data?: Maybe<Scalars["String"]["output"]>;
    sequence_number?: Maybe<Scalars["bigint"]["output"]>;
    transaction_block_height?: Maybe<Scalars["bigint"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    type?: Maybe<Scalars["String"]["output"]>;
};
/** aggregated selection of "events_view" */
type EventsViewAggregate = {
    aggregate?: Maybe<EventsViewAggregateFields>;
    nodes: Array<EventsView>;
};
/** aggregate fields of "events_view" */
type EventsViewAggregateFields = {
    avg?: Maybe<EventsViewAvgFields>;
    count: Scalars["Int"]["output"];
    max?: Maybe<EventsViewMaxFields>;
    min?: Maybe<EventsViewMinFields>;
    stddev?: Maybe<EventsViewStddevFields>;
    stddev_pop?: Maybe<EventsViewStddevPopFields>;
    stddev_samp?: Maybe<EventsViewStddevSampFields>;
    sum?: Maybe<EventsViewSumFields>;
    var_pop?: Maybe<EventsViewVarPopFields>;
    var_samp?: Maybe<EventsViewVarSampFields>;
    variance?: Maybe<EventsViewVarianceFields>;
};
/** aggregate fields of "events_view" */
type EventsViewAggregateFieldsCountArgs = {
    columns?: InputMaybe<Array<EventsViewSelectColumn>>;
    distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};
/** aggregate avg on columns */
type EventsViewAvgFields = {
    creation_number?: Maybe<Scalars["Float"]["output"]>;
    sequence_number?: Maybe<Scalars["Float"]["output"]>;
    transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** Boolean expression to filter rows from the table "events_view". All fields are combined with a logical 'AND'. */
type EventsViewBoolExp = {
    _and?: InputMaybe<Array<EventsViewBoolExp>>;
    _not?: InputMaybe<EventsViewBoolExp>;
    _or?: InputMaybe<Array<EventsViewBoolExp>>;
    account_address?: InputMaybe<StringComparisonExp>;
    creation_number?: InputMaybe<BigintComparisonExp>;
    inserted_at?: InputMaybe<TimestampComparisonExp>;
    json_data?: InputMaybe<StringComparisonExp>;
    sequence_number?: InputMaybe<BigintComparisonExp>;
    transaction_block_height?: InputMaybe<BigintComparisonExp>;
    transaction_version?: InputMaybe<BigintComparisonExp>;
    type?: InputMaybe<StringComparisonExp>;
};
/** input type for incrementing numeric columns in table "events_view" */
type EventsViewIncInput = {
    creation_number?: InputMaybe<Scalars["bigint"]["input"]>;
    sequence_number?: InputMaybe<Scalars["bigint"]["input"]>;
    transaction_block_height?: InputMaybe<Scalars["bigint"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** input type for inserting data into table "events_view" */
type EventsViewInsertInput = {
    account_address?: InputMaybe<Scalars["String"]["input"]>;
    creation_number?: InputMaybe<Scalars["bigint"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    json_data?: InputMaybe<Scalars["String"]["input"]>;
    sequence_number?: InputMaybe<Scalars["bigint"]["input"]>;
    transaction_block_height?: InputMaybe<Scalars["bigint"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    type?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregate max on columns */
type EventsViewMaxFields = {
    account_address?: Maybe<Scalars["String"]["output"]>;
    creation_number?: Maybe<Scalars["bigint"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    json_data?: Maybe<Scalars["String"]["output"]>;
    sequence_number?: Maybe<Scalars["bigint"]["output"]>;
    transaction_block_height?: Maybe<Scalars["bigint"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    type?: Maybe<Scalars["String"]["output"]>;
};
/** aggregate min on columns */
type EventsViewMinFields = {
    account_address?: Maybe<Scalars["String"]["output"]>;
    creation_number?: Maybe<Scalars["bigint"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    json_data?: Maybe<Scalars["String"]["output"]>;
    sequence_number?: Maybe<Scalars["bigint"]["output"]>;
    transaction_block_height?: Maybe<Scalars["bigint"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    type?: Maybe<Scalars["String"]["output"]>;
};
/** response of any mutation on the table "events_view" */
type EventsViewMutationResponse = {
    /** number of rows affected by the mutation */
    affected_rows: Scalars["Int"]["output"];
    /** data from the rows affected by the mutation */
    returning: Array<EventsView>;
};
/** Ordering options when selecting data from "events_view". */
type EventsViewOrderBy = {
    account_address?: InputMaybe<OrderBy>;
    creation_number?: InputMaybe<OrderBy>;
    inserted_at?: InputMaybe<OrderBy>;
    json_data?: InputMaybe<OrderBy>;
    sequence_number?: InputMaybe<OrderBy>;
    transaction_block_height?: InputMaybe<OrderBy>;
    transaction_version?: InputMaybe<OrderBy>;
    type?: InputMaybe<OrderBy>;
};
/** select columns of table "events_view" */
declare enum EventsViewSelectColumn {
    /** column name */
    AccountAddress = "account_address",
    /** column name */
    CreationNumber = "creation_number",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    JsonData = "json_data",
    /** column name */
    SequenceNumber = "sequence_number",
    /** column name */
    TransactionBlockHeight = "transaction_block_height",
    /** column name */
    TransactionVersion = "transaction_version",
    /** column name */
    Type = "type"
}
/** input type for updating data in table "events_view" */
type EventsViewSetInput = {
    account_address?: InputMaybe<Scalars["String"]["input"]>;
    creation_number?: InputMaybe<Scalars["bigint"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    json_data?: InputMaybe<Scalars["String"]["input"]>;
    sequence_number?: InputMaybe<Scalars["bigint"]["input"]>;
    transaction_block_height?: InputMaybe<Scalars["bigint"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    type?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregate stddev on columns */
type EventsViewStddevFields = {
    creation_number?: Maybe<Scalars["Float"]["output"]>;
    sequence_number?: Maybe<Scalars["Float"]["output"]>;
    transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_pop on columns */
type EventsViewStddevPopFields = {
    creation_number?: Maybe<Scalars["Float"]["output"]>;
    sequence_number?: Maybe<Scalars["Float"]["output"]>;
    transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_samp on columns */
type EventsViewStddevSampFields = {
    creation_number?: Maybe<Scalars["Float"]["output"]>;
    sequence_number?: Maybe<Scalars["Float"]["output"]>;
    transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** Streaming cursor of the table "events_view" */
type EventsViewStreamCursorInput = {
    /** Stream column input with initial value */
    initial_value: EventsViewStreamCursorValueInput;
    /** cursor ordering */
    ordering?: InputMaybe<CursorOrdering>;
};
/** Initial value of the column from where the streaming should start */
type EventsViewStreamCursorValueInput = {
    account_address?: InputMaybe<Scalars["String"]["input"]>;
    creation_number?: InputMaybe<Scalars["bigint"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    json_data?: InputMaybe<Scalars["String"]["input"]>;
    sequence_number?: InputMaybe<Scalars["bigint"]["input"]>;
    transaction_block_height?: InputMaybe<Scalars["bigint"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    type?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregate sum on columns */
type EventsViewSumFields = {
    creation_number?: Maybe<Scalars["bigint"]["output"]>;
    sequence_number?: Maybe<Scalars["bigint"]["output"]>;
    transaction_block_height?: Maybe<Scalars["bigint"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};
type EventsViewUpdates = {
    /** increments the numeric columns with given value of the filtered values */
    _inc?: InputMaybe<EventsViewIncInput>;
    /** sets the columns of the filtered rows to the given values */
    _set?: InputMaybe<EventsViewSetInput>;
    /** filter the rows which have to be updated */
    where: EventsViewBoolExp;
};
/** aggregate var_pop on columns */
type EventsViewVarPopFields = {
    creation_number?: Maybe<Scalars["Float"]["output"]>;
    sequence_number?: Maybe<Scalars["Float"]["output"]>;
    transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate var_samp on columns */
type EventsViewVarSampFields = {
    creation_number?: Maybe<Scalars["Float"]["output"]>;
    sequence_number?: Maybe<Scalars["Float"]["output"]>;
    transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate variance on columns */
type EventsViewVarianceFields = {
    creation_number?: Maybe<Scalars["Float"]["output"]>;
    sequence_number?: Maybe<Scalars["Float"]["output"]>;
    transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** columns and relationships of "fungible_asset_activities" */
type FungibleAssetActivities = {
    amount?: Maybe<Scalars["numeric"]["output"]>;
    asset_type?: Maybe<Scalars["String"]["output"]>;
    block_height: Scalars["bigint"]["output"];
    entry_function_id_str?: Maybe<Scalars["String"]["output"]>;
    event_index: Scalars["bigint"]["output"];
    gas_fee_payer_address?: Maybe<Scalars["String"]["output"]>;
    inserted_at: Scalars["timestamp"]["output"];
    is_frozen?: Maybe<Scalars["Boolean"]["output"]>;
    is_gas_fee: Scalars["Boolean"]["output"];
    is_transaction_success: Scalars["Boolean"]["output"];
    /** An object relationship */
    metadata?: Maybe<FungibleAssetMetadata>;
    owner_address?: Maybe<Scalars["String"]["output"]>;
    /** An array relationship */
    owner_cedra_names: Array<CurrentCedraNames>;
    /** An aggregate relationship */
    owner_cedra_names_aggregate: CurrentCedraNamesAggregate;
    storage_id: Scalars["String"]["output"];
    storage_refund_amount: Scalars["numeric"]["output"];
    token_standard: Scalars["String"]["output"];
    transaction_timestamp: Scalars["timestamp"]["output"];
    transaction_version: Scalars["bigint"]["output"];
    type: Scalars["String"]["output"];
};
/** columns and relationships of "fungible_asset_activities" */
type FungibleAssetActivitiesOwnerCedraNamesArgs = {
    distinct_on?: InputMaybe<Array<CurrentCedraNamesSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentCedraNamesOrderBy>>;
    where?: InputMaybe<CurrentCedraNamesBoolExp>;
};
/** columns and relationships of "fungible_asset_activities" */
type FungibleAssetActivitiesOwnerCedraNamesAggregateArgs = {
    distinct_on?: InputMaybe<Array<CurrentCedraNamesSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentCedraNamesOrderBy>>;
    where?: InputMaybe<CurrentCedraNamesBoolExp>;
};
/** aggregated selection of "fungible_asset_activities" */
type FungibleAssetActivitiesAggregate = {
    aggregate?: Maybe<FungibleAssetActivitiesAggregateFields>;
    nodes: Array<FungibleAssetActivities>;
};
type FungibleAssetActivitiesAggregateBoolExp = {
    bool_and?: InputMaybe<FungibleAssetActivitiesAggregateBoolExpBoolAnd>;
    bool_or?: InputMaybe<FungibleAssetActivitiesAggregateBoolExpBoolOr>;
    count?: InputMaybe<FungibleAssetActivitiesAggregateBoolExpCount>;
};
type FungibleAssetActivitiesAggregateBoolExpBoolAnd = {
    arguments: FungibleAssetActivitiesSelectColumnFungibleAssetActivitiesAggregateBoolExpBoolAndArgumentsColumns;
    distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
    filter?: InputMaybe<FungibleAssetActivitiesBoolExp>;
    predicate: BooleanComparisonExp;
};
type FungibleAssetActivitiesAggregateBoolExpBoolOr = {
    arguments: FungibleAssetActivitiesSelectColumnFungibleAssetActivitiesAggregateBoolExpBoolOrArgumentsColumns;
    distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
    filter?: InputMaybe<FungibleAssetActivitiesBoolExp>;
    predicate: BooleanComparisonExp;
};
type FungibleAssetActivitiesAggregateBoolExpCount = {
    arguments?: InputMaybe<Array<FungibleAssetActivitiesSelectColumn>>;
    distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
    filter?: InputMaybe<FungibleAssetActivitiesBoolExp>;
    predicate: IntComparisonExp;
};
/** aggregate fields of "fungible_asset_activities" */
type FungibleAssetActivitiesAggregateFields = {
    avg?: Maybe<FungibleAssetActivitiesAvgFields>;
    count: Scalars["Int"]["output"];
    max?: Maybe<FungibleAssetActivitiesMaxFields>;
    min?: Maybe<FungibleAssetActivitiesMinFields>;
    stddev?: Maybe<FungibleAssetActivitiesStddevFields>;
    stddev_pop?: Maybe<FungibleAssetActivitiesStddevPopFields>;
    stddev_samp?: Maybe<FungibleAssetActivitiesStddevSampFields>;
    sum?: Maybe<FungibleAssetActivitiesSumFields>;
    var_pop?: Maybe<FungibleAssetActivitiesVarPopFields>;
    var_samp?: Maybe<FungibleAssetActivitiesVarSampFields>;
    variance?: Maybe<FungibleAssetActivitiesVarianceFields>;
};
/** aggregate fields of "fungible_asset_activities" */
type FungibleAssetActivitiesAggregateFieldsCountArgs = {
    columns?: InputMaybe<Array<FungibleAssetActivitiesSelectColumn>>;
    distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};
/** order by aggregate values of table "fungible_asset_activities" */
type FungibleAssetActivitiesAggregateOrderBy = {
    avg?: InputMaybe<FungibleAssetActivitiesAvgOrderBy>;
    count?: InputMaybe<OrderBy>;
    max?: InputMaybe<FungibleAssetActivitiesMaxOrderBy>;
    min?: InputMaybe<FungibleAssetActivitiesMinOrderBy>;
    stddev?: InputMaybe<FungibleAssetActivitiesStddevOrderBy>;
    stddev_pop?: InputMaybe<FungibleAssetActivitiesStddevPopOrderBy>;
    stddev_samp?: InputMaybe<FungibleAssetActivitiesStddevSampOrderBy>;
    sum?: InputMaybe<FungibleAssetActivitiesSumOrderBy>;
    var_pop?: InputMaybe<FungibleAssetActivitiesVarPopOrderBy>;
    var_samp?: InputMaybe<FungibleAssetActivitiesVarSampOrderBy>;
    variance?: InputMaybe<FungibleAssetActivitiesVarianceOrderBy>;
};
/** input type for inserting array relation for remote table "fungible_asset_activities" */
type FungibleAssetActivitiesArrRelInsertInput = {
    data: Array<FungibleAssetActivitiesInsertInput>;
    /** upsert condition */
    on_conflict?: InputMaybe<FungibleAssetActivitiesOnConflict>;
};
/** aggregate avg on columns */
type FungibleAssetActivitiesAvgFields = {
    amount?: Maybe<Scalars["Float"]["output"]>;
    block_height?: Maybe<Scalars["Float"]["output"]>;
    event_index?: Maybe<Scalars["Float"]["output"]>;
    storage_refund_amount?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** order by avg() on columns of table "fungible_asset_activities" */
type FungibleAssetActivitiesAvgOrderBy = {
    amount?: InputMaybe<OrderBy>;
    block_height?: InputMaybe<OrderBy>;
    event_index?: InputMaybe<OrderBy>;
    storage_refund_amount?: InputMaybe<OrderBy>;
    transaction_version?: InputMaybe<OrderBy>;
};
/** Boolean expression to filter rows from the table "fungible_asset_activities". All fields are combined with a logical 'AND'. */
type FungibleAssetActivitiesBoolExp = {
    _and?: InputMaybe<Array<FungibleAssetActivitiesBoolExp>>;
    _not?: InputMaybe<FungibleAssetActivitiesBoolExp>;
    _or?: InputMaybe<Array<FungibleAssetActivitiesBoolExp>>;
    amount?: InputMaybe<NumericComparisonExp>;
    asset_type?: InputMaybe<StringComparisonExp>;
    block_height?: InputMaybe<BigintComparisonExp>;
    entry_function_id_str?: InputMaybe<StringComparisonExp>;
    event_index?: InputMaybe<BigintComparisonExp>;
    gas_fee_payer_address?: InputMaybe<StringComparisonExp>;
    inserted_at?: InputMaybe<TimestampComparisonExp>;
    is_frozen?: InputMaybe<BooleanComparisonExp>;
    is_gas_fee?: InputMaybe<BooleanComparisonExp>;
    is_transaction_success?: InputMaybe<BooleanComparisonExp>;
    metadata?: InputMaybe<FungibleAssetMetadataBoolExp>;
    owner_address?: InputMaybe<StringComparisonExp>;
    owner_cedra_names?: InputMaybe<CurrentCedraNamesBoolExp>;
    owner_cedra_names_aggregate?: InputMaybe<CurrentCedraNamesAggregateBoolExp>;
    storage_id?: InputMaybe<StringComparisonExp>;
    storage_refund_amount?: InputMaybe<NumericComparisonExp>;
    token_standard?: InputMaybe<StringComparisonExp>;
    transaction_timestamp?: InputMaybe<TimestampComparisonExp>;
    transaction_version?: InputMaybe<BigintComparisonExp>;
    type?: InputMaybe<StringComparisonExp>;
};
/** unique or primary key constraints on table "fungible_asset_activities" */
declare enum FungibleAssetActivitiesConstraint {
    /** unique or primary key constraint on columns "event_index", "transaction_version" */
    FungibleAssetActivitiesPkey = "fungible_asset_activities_pkey"
}
/** input type for incrementing numeric columns in table "fungible_asset_activities" */
type FungibleAssetActivitiesIncInput = {
    amount?: InputMaybe<Scalars["numeric"]["input"]>;
    block_height?: InputMaybe<Scalars["bigint"]["input"]>;
    event_index?: InputMaybe<Scalars["bigint"]["input"]>;
    storage_refund_amount?: InputMaybe<Scalars["numeric"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** input type for inserting data into table "fungible_asset_activities" */
type FungibleAssetActivitiesInsertInput = {
    amount?: InputMaybe<Scalars["numeric"]["input"]>;
    asset_type?: InputMaybe<Scalars["String"]["input"]>;
    block_height?: InputMaybe<Scalars["bigint"]["input"]>;
    entry_function_id_str?: InputMaybe<Scalars["String"]["input"]>;
    event_index?: InputMaybe<Scalars["bigint"]["input"]>;
    gas_fee_payer_address?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    is_frozen?: InputMaybe<Scalars["Boolean"]["input"]>;
    is_gas_fee?: InputMaybe<Scalars["Boolean"]["input"]>;
    is_transaction_success?: InputMaybe<Scalars["Boolean"]["input"]>;
    metadata?: InputMaybe<FungibleAssetMetadataObjRelInsertInput>;
    owner_address?: InputMaybe<Scalars["String"]["input"]>;
    owner_cedra_names?: InputMaybe<CurrentCedraNamesArrRelInsertInput>;
    storage_id?: InputMaybe<Scalars["String"]["input"]>;
    storage_refund_amount?: InputMaybe<Scalars["numeric"]["input"]>;
    token_standard?: InputMaybe<Scalars["String"]["input"]>;
    transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    type?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregate max on columns */
type FungibleAssetActivitiesMaxFields = {
    amount?: Maybe<Scalars["numeric"]["output"]>;
    asset_type?: Maybe<Scalars["String"]["output"]>;
    block_height?: Maybe<Scalars["bigint"]["output"]>;
    entry_function_id_str?: Maybe<Scalars["String"]["output"]>;
    event_index?: Maybe<Scalars["bigint"]["output"]>;
    gas_fee_payer_address?: Maybe<Scalars["String"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    owner_address?: Maybe<Scalars["String"]["output"]>;
    storage_id?: Maybe<Scalars["String"]["output"]>;
    storage_refund_amount?: Maybe<Scalars["numeric"]["output"]>;
    token_standard?: Maybe<Scalars["String"]["output"]>;
    transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    type?: Maybe<Scalars["String"]["output"]>;
};
/** order by max() on columns of table "fungible_asset_activities" */
type FungibleAssetActivitiesMaxOrderBy = {
    amount?: InputMaybe<OrderBy>;
    asset_type?: InputMaybe<OrderBy>;
    block_height?: InputMaybe<OrderBy>;
    entry_function_id_str?: InputMaybe<OrderBy>;
    event_index?: InputMaybe<OrderBy>;
    gas_fee_payer_address?: InputMaybe<OrderBy>;
    inserted_at?: InputMaybe<OrderBy>;
    owner_address?: InputMaybe<OrderBy>;
    storage_id?: InputMaybe<OrderBy>;
    storage_refund_amount?: InputMaybe<OrderBy>;
    token_standard?: InputMaybe<OrderBy>;
    transaction_timestamp?: InputMaybe<OrderBy>;
    transaction_version?: InputMaybe<OrderBy>;
    type?: InputMaybe<OrderBy>;
};
/** aggregate min on columns */
type FungibleAssetActivitiesMinFields = {
    amount?: Maybe<Scalars["numeric"]["output"]>;
    asset_type?: Maybe<Scalars["String"]["output"]>;
    block_height?: Maybe<Scalars["bigint"]["output"]>;
    entry_function_id_str?: Maybe<Scalars["String"]["output"]>;
    event_index?: Maybe<Scalars["bigint"]["output"]>;
    gas_fee_payer_address?: Maybe<Scalars["String"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    owner_address?: Maybe<Scalars["String"]["output"]>;
    storage_id?: Maybe<Scalars["String"]["output"]>;
    storage_refund_amount?: Maybe<Scalars["numeric"]["output"]>;
    token_standard?: Maybe<Scalars["String"]["output"]>;
    transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    type?: Maybe<Scalars["String"]["output"]>;
};
/** order by min() on columns of table "fungible_asset_activities" */
type FungibleAssetActivitiesMinOrderBy = {
    amount?: InputMaybe<OrderBy>;
    asset_type?: InputMaybe<OrderBy>;
    block_height?: InputMaybe<OrderBy>;
    entry_function_id_str?: InputMaybe<OrderBy>;
    event_index?: InputMaybe<OrderBy>;
    gas_fee_payer_address?: InputMaybe<OrderBy>;
    inserted_at?: InputMaybe<OrderBy>;
    owner_address?: InputMaybe<OrderBy>;
    storage_id?: InputMaybe<OrderBy>;
    storage_refund_amount?: InputMaybe<OrderBy>;
    token_standard?: InputMaybe<OrderBy>;
    transaction_timestamp?: InputMaybe<OrderBy>;
    transaction_version?: InputMaybe<OrderBy>;
    type?: InputMaybe<OrderBy>;
};
/** response of any mutation on the table "fungible_asset_activities" */
type FungibleAssetActivitiesMutationResponse = {
    /** number of rows affected by the mutation */
    affected_rows: Scalars["Int"]["output"];
    /** data from the rows affected by the mutation */
    returning: Array<FungibleAssetActivities>;
};
/** on_conflict condition type for table "fungible_asset_activities" */
type FungibleAssetActivitiesOnConflict = {
    constraint: FungibleAssetActivitiesConstraint;
    update_columns?: Array<FungibleAssetActivitiesUpdateColumn>;
    where?: InputMaybe<FungibleAssetActivitiesBoolExp>;
};
/** Ordering options when selecting data from "fungible_asset_activities". */
type FungibleAssetActivitiesOrderBy = {
    amount?: InputMaybe<OrderBy>;
    asset_type?: InputMaybe<OrderBy>;
    block_height?: InputMaybe<OrderBy>;
    entry_function_id_str?: InputMaybe<OrderBy>;
    event_index?: InputMaybe<OrderBy>;
    gas_fee_payer_address?: InputMaybe<OrderBy>;
    inserted_at?: InputMaybe<OrderBy>;
    is_frozen?: InputMaybe<OrderBy>;
    is_gas_fee?: InputMaybe<OrderBy>;
    is_transaction_success?: InputMaybe<OrderBy>;
    metadata?: InputMaybe<FungibleAssetMetadataOrderBy>;
    owner_address?: InputMaybe<OrderBy>;
    owner_cedra_names_aggregate?: InputMaybe<CurrentCedraNamesAggregateOrderBy>;
    storage_id?: InputMaybe<OrderBy>;
    storage_refund_amount?: InputMaybe<OrderBy>;
    token_standard?: InputMaybe<OrderBy>;
    transaction_timestamp?: InputMaybe<OrderBy>;
    transaction_version?: InputMaybe<OrderBy>;
    type?: InputMaybe<OrderBy>;
};
/** primary key columns input for table: fungible_asset_activities */
type FungibleAssetActivitiesPkColumnsInput = {
    event_index: Scalars["bigint"]["input"];
    transaction_version: Scalars["bigint"]["input"];
};
/** select columns of table "fungible_asset_activities" */
declare enum FungibleAssetActivitiesSelectColumn {
    /** column name */
    Amount = "amount",
    /** column name */
    AssetType = "asset_type",
    /** column name */
    BlockHeight = "block_height",
    /** column name */
    EntryFunctionIdStr = "entry_function_id_str",
    /** column name */
    EventIndex = "event_index",
    /** column name */
    GasFeePayerAddress = "gas_fee_payer_address",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    IsFrozen = "is_frozen",
    /** column name */
    IsGasFee = "is_gas_fee",
    /** column name */
    IsTransactionSuccess = "is_transaction_success",
    /** column name */
    OwnerAddress = "owner_address",
    /** column name */
    StorageId = "storage_id",
    /** column name */
    StorageRefundAmount = "storage_refund_amount",
    /** column name */
    TokenStandard = "token_standard",
    /** column name */
    TransactionTimestamp = "transaction_timestamp",
    /** column name */
    TransactionVersion = "transaction_version",
    /** column name */
    Type = "type"
}
/** select "fungible_asset_activities_aggregate_bool_exp_bool_and_arguments_columns" columns of table "fungible_asset_activities" */
declare enum FungibleAssetActivitiesSelectColumnFungibleAssetActivitiesAggregateBoolExpBoolAndArgumentsColumns {
    /** column name */
    IsFrozen = "is_frozen",
    /** column name */
    IsGasFee = "is_gas_fee",
    /** column name */
    IsTransactionSuccess = "is_transaction_success"
}
/** select "fungible_asset_activities_aggregate_bool_exp_bool_or_arguments_columns" columns of table "fungible_asset_activities" */
declare enum FungibleAssetActivitiesSelectColumnFungibleAssetActivitiesAggregateBoolExpBoolOrArgumentsColumns {
    /** column name */
    IsFrozen = "is_frozen",
    /** column name */
    IsGasFee = "is_gas_fee",
    /** column name */
    IsTransactionSuccess = "is_transaction_success"
}
/** input type for updating data in table "fungible_asset_activities" */
type FungibleAssetActivitiesSetInput = {
    amount?: InputMaybe<Scalars["numeric"]["input"]>;
    asset_type?: InputMaybe<Scalars["String"]["input"]>;
    block_height?: InputMaybe<Scalars["bigint"]["input"]>;
    entry_function_id_str?: InputMaybe<Scalars["String"]["input"]>;
    event_index?: InputMaybe<Scalars["bigint"]["input"]>;
    gas_fee_payer_address?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    is_frozen?: InputMaybe<Scalars["Boolean"]["input"]>;
    is_gas_fee?: InputMaybe<Scalars["Boolean"]["input"]>;
    is_transaction_success?: InputMaybe<Scalars["Boolean"]["input"]>;
    owner_address?: InputMaybe<Scalars["String"]["input"]>;
    storage_id?: InputMaybe<Scalars["String"]["input"]>;
    storage_refund_amount?: InputMaybe<Scalars["numeric"]["input"]>;
    token_standard?: InputMaybe<Scalars["String"]["input"]>;
    transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    type?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregate stddev on columns */
type FungibleAssetActivitiesStddevFields = {
    amount?: Maybe<Scalars["Float"]["output"]>;
    block_height?: Maybe<Scalars["Float"]["output"]>;
    event_index?: Maybe<Scalars["Float"]["output"]>;
    storage_refund_amount?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** order by stddev() on columns of table "fungible_asset_activities" */
type FungibleAssetActivitiesStddevOrderBy = {
    amount?: InputMaybe<OrderBy>;
    block_height?: InputMaybe<OrderBy>;
    event_index?: InputMaybe<OrderBy>;
    storage_refund_amount?: InputMaybe<OrderBy>;
    transaction_version?: InputMaybe<OrderBy>;
};
/** aggregate stddev_pop on columns */
type FungibleAssetActivitiesStddevPopFields = {
    amount?: Maybe<Scalars["Float"]["output"]>;
    block_height?: Maybe<Scalars["Float"]["output"]>;
    event_index?: Maybe<Scalars["Float"]["output"]>;
    storage_refund_amount?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** order by stddev_pop() on columns of table "fungible_asset_activities" */
type FungibleAssetActivitiesStddevPopOrderBy = {
    amount?: InputMaybe<OrderBy>;
    block_height?: InputMaybe<OrderBy>;
    event_index?: InputMaybe<OrderBy>;
    storage_refund_amount?: InputMaybe<OrderBy>;
    transaction_version?: InputMaybe<OrderBy>;
};
/** aggregate stddev_samp on columns */
type FungibleAssetActivitiesStddevSampFields = {
    amount?: Maybe<Scalars["Float"]["output"]>;
    block_height?: Maybe<Scalars["Float"]["output"]>;
    event_index?: Maybe<Scalars["Float"]["output"]>;
    storage_refund_amount?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** order by stddev_samp() on columns of table "fungible_asset_activities" */
type FungibleAssetActivitiesStddevSampOrderBy = {
    amount?: InputMaybe<OrderBy>;
    block_height?: InputMaybe<OrderBy>;
    event_index?: InputMaybe<OrderBy>;
    storage_refund_amount?: InputMaybe<OrderBy>;
    transaction_version?: InputMaybe<OrderBy>;
};
/** Streaming cursor of the table "fungible_asset_activities" */
type FungibleAssetActivitiesStreamCursorInput = {
    /** Stream column input with initial value */
    initial_value: FungibleAssetActivitiesStreamCursorValueInput;
    /** cursor ordering */
    ordering?: InputMaybe<CursorOrdering>;
};
/** Initial value of the column from where the streaming should start */
type FungibleAssetActivitiesStreamCursorValueInput = {
    amount?: InputMaybe<Scalars["numeric"]["input"]>;
    asset_type?: InputMaybe<Scalars["String"]["input"]>;
    block_height?: InputMaybe<Scalars["bigint"]["input"]>;
    entry_function_id_str?: InputMaybe<Scalars["String"]["input"]>;
    event_index?: InputMaybe<Scalars["bigint"]["input"]>;
    gas_fee_payer_address?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    is_frozen?: InputMaybe<Scalars["Boolean"]["input"]>;
    is_gas_fee?: InputMaybe<Scalars["Boolean"]["input"]>;
    is_transaction_success?: InputMaybe<Scalars["Boolean"]["input"]>;
    owner_address?: InputMaybe<Scalars["String"]["input"]>;
    storage_id?: InputMaybe<Scalars["String"]["input"]>;
    storage_refund_amount?: InputMaybe<Scalars["numeric"]["input"]>;
    token_standard?: InputMaybe<Scalars["String"]["input"]>;
    transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    type?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregate sum on columns */
type FungibleAssetActivitiesSumFields = {
    amount?: Maybe<Scalars["numeric"]["output"]>;
    block_height?: Maybe<Scalars["bigint"]["output"]>;
    event_index?: Maybe<Scalars["bigint"]["output"]>;
    storage_refund_amount?: Maybe<Scalars["numeric"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};
/** order by sum() on columns of table "fungible_asset_activities" */
type FungibleAssetActivitiesSumOrderBy = {
    amount?: InputMaybe<OrderBy>;
    block_height?: InputMaybe<OrderBy>;
    event_index?: InputMaybe<OrderBy>;
    storage_refund_amount?: InputMaybe<OrderBy>;
    transaction_version?: InputMaybe<OrderBy>;
};
/** update columns of table "fungible_asset_activities" */
declare enum FungibleAssetActivitiesUpdateColumn {
    /** column name */
    Amount = "amount",
    /** column name */
    AssetType = "asset_type",
    /** column name */
    BlockHeight = "block_height",
    /** column name */
    EntryFunctionIdStr = "entry_function_id_str",
    /** column name */
    EventIndex = "event_index",
    /** column name */
    GasFeePayerAddress = "gas_fee_payer_address",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    IsFrozen = "is_frozen",
    /** column name */
    IsGasFee = "is_gas_fee",
    /** column name */
    IsTransactionSuccess = "is_transaction_success",
    /** column name */
    OwnerAddress = "owner_address",
    /** column name */
    StorageId = "storage_id",
    /** column name */
    StorageRefundAmount = "storage_refund_amount",
    /** column name */
    TokenStandard = "token_standard",
    /** column name */
    TransactionTimestamp = "transaction_timestamp",
    /** column name */
    TransactionVersion = "transaction_version",
    /** column name */
    Type = "type"
}
type FungibleAssetActivitiesUpdates = {
    /** increments the numeric columns with given value of the filtered values */
    _inc?: InputMaybe<FungibleAssetActivitiesIncInput>;
    /** sets the columns of the filtered rows to the given values */
    _set?: InputMaybe<FungibleAssetActivitiesSetInput>;
    /** filter the rows which have to be updated */
    where: FungibleAssetActivitiesBoolExp;
};
/** aggregate var_pop on columns */
type FungibleAssetActivitiesVarPopFields = {
    amount?: Maybe<Scalars["Float"]["output"]>;
    block_height?: Maybe<Scalars["Float"]["output"]>;
    event_index?: Maybe<Scalars["Float"]["output"]>;
    storage_refund_amount?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** order by var_pop() on columns of table "fungible_asset_activities" */
type FungibleAssetActivitiesVarPopOrderBy = {
    amount?: InputMaybe<OrderBy>;
    block_height?: InputMaybe<OrderBy>;
    event_index?: InputMaybe<OrderBy>;
    storage_refund_amount?: InputMaybe<OrderBy>;
    transaction_version?: InputMaybe<OrderBy>;
};
/** aggregate var_samp on columns */
type FungibleAssetActivitiesVarSampFields = {
    amount?: Maybe<Scalars["Float"]["output"]>;
    block_height?: Maybe<Scalars["Float"]["output"]>;
    event_index?: Maybe<Scalars["Float"]["output"]>;
    storage_refund_amount?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** order by var_samp() on columns of table "fungible_asset_activities" */
type FungibleAssetActivitiesVarSampOrderBy = {
    amount?: InputMaybe<OrderBy>;
    block_height?: InputMaybe<OrderBy>;
    event_index?: InputMaybe<OrderBy>;
    storage_refund_amount?: InputMaybe<OrderBy>;
    transaction_version?: InputMaybe<OrderBy>;
};
/** aggregate variance on columns */
type FungibleAssetActivitiesVarianceFields = {
    amount?: Maybe<Scalars["Float"]["output"]>;
    block_height?: Maybe<Scalars["Float"]["output"]>;
    event_index?: Maybe<Scalars["Float"]["output"]>;
    storage_refund_amount?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** order by variance() on columns of table "fungible_asset_activities" */
type FungibleAssetActivitiesVarianceOrderBy = {
    amount?: InputMaybe<OrderBy>;
    block_height?: InputMaybe<OrderBy>;
    event_index?: InputMaybe<OrderBy>;
    storage_refund_amount?: InputMaybe<OrderBy>;
    transaction_version?: InputMaybe<OrderBy>;
};
/** columns and relationships of "fungible_asset_balances" */
type FungibleAssetBalances = {
    amount: Scalars["numeric"]["output"];
    asset_type: Scalars["String"]["output"];
    inserted_at: Scalars["timestamp"]["output"];
    is_frozen: Scalars["Boolean"]["output"];
    is_primary: Scalars["Boolean"]["output"];
    owner_address: Scalars["String"]["output"];
    storage_id: Scalars["String"]["output"];
    token_standard: Scalars["String"]["output"];
    transaction_timestamp: Scalars["timestamp"]["output"];
    transaction_version: Scalars["bigint"]["output"];
    write_set_change_index: Scalars["bigint"]["output"];
};
/** aggregated selection of "fungible_asset_balances" */
type FungibleAssetBalancesAggregate = {
    aggregate?: Maybe<FungibleAssetBalancesAggregateFields>;
    nodes: Array<FungibleAssetBalances>;
};
/** aggregate fields of "fungible_asset_balances" */
type FungibleAssetBalancesAggregateFields = {
    avg?: Maybe<FungibleAssetBalancesAvgFields>;
    count: Scalars["Int"]["output"];
    max?: Maybe<FungibleAssetBalancesMaxFields>;
    min?: Maybe<FungibleAssetBalancesMinFields>;
    stddev?: Maybe<FungibleAssetBalancesStddevFields>;
    stddev_pop?: Maybe<FungibleAssetBalancesStddevPopFields>;
    stddev_samp?: Maybe<FungibleAssetBalancesStddevSampFields>;
    sum?: Maybe<FungibleAssetBalancesSumFields>;
    var_pop?: Maybe<FungibleAssetBalancesVarPopFields>;
    var_samp?: Maybe<FungibleAssetBalancesVarSampFields>;
    variance?: Maybe<FungibleAssetBalancesVarianceFields>;
};
/** aggregate fields of "fungible_asset_balances" */
type FungibleAssetBalancesAggregateFieldsCountArgs = {
    columns?: InputMaybe<Array<FungibleAssetBalancesSelectColumn>>;
    distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};
/** aggregate avg on columns */
type FungibleAssetBalancesAvgFields = {
    amount?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};
/** Boolean expression to filter rows from the table "fungible_asset_balances". All fields are combined with a logical 'AND'. */
type FungibleAssetBalancesBoolExp = {
    _and?: InputMaybe<Array<FungibleAssetBalancesBoolExp>>;
    _not?: InputMaybe<FungibleAssetBalancesBoolExp>;
    _or?: InputMaybe<Array<FungibleAssetBalancesBoolExp>>;
    amount?: InputMaybe<NumericComparisonExp>;
    asset_type?: InputMaybe<StringComparisonExp>;
    inserted_at?: InputMaybe<TimestampComparisonExp>;
    is_frozen?: InputMaybe<BooleanComparisonExp>;
    is_primary?: InputMaybe<BooleanComparisonExp>;
    owner_address?: InputMaybe<StringComparisonExp>;
    storage_id?: InputMaybe<StringComparisonExp>;
    token_standard?: InputMaybe<StringComparisonExp>;
    transaction_timestamp?: InputMaybe<TimestampComparisonExp>;
    transaction_version?: InputMaybe<BigintComparisonExp>;
    write_set_change_index?: InputMaybe<BigintComparisonExp>;
};
/** unique or primary key constraints on table "fungible_asset_balances" */
declare enum FungibleAssetBalancesConstraint {
    /** unique or primary key constraint on columns "write_set_change_index", "transaction_version" */
    FungibleAssetBalancesPkey = "fungible_asset_balances_pkey"
}
/** input type for incrementing numeric columns in table "fungible_asset_balances" */
type FungibleAssetBalancesIncInput = {
    amount?: InputMaybe<Scalars["numeric"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** input type for inserting data into table "fungible_asset_balances" */
type FungibleAssetBalancesInsertInput = {
    amount?: InputMaybe<Scalars["numeric"]["input"]>;
    asset_type?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    is_frozen?: InputMaybe<Scalars["Boolean"]["input"]>;
    is_primary?: InputMaybe<Scalars["Boolean"]["input"]>;
    owner_address?: InputMaybe<Scalars["String"]["input"]>;
    storage_id?: InputMaybe<Scalars["String"]["input"]>;
    token_standard?: InputMaybe<Scalars["String"]["input"]>;
    transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** aggregate max on columns */
type FungibleAssetBalancesMaxFields = {
    amount?: Maybe<Scalars["numeric"]["output"]>;
    asset_type?: Maybe<Scalars["String"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    owner_address?: Maybe<Scalars["String"]["output"]>;
    storage_id?: Maybe<Scalars["String"]["output"]>;
    token_standard?: Maybe<Scalars["String"]["output"]>;
    transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    write_set_change_index?: Maybe<Scalars["bigint"]["output"]>;
};
/** aggregate min on columns */
type FungibleAssetBalancesMinFields = {
    amount?: Maybe<Scalars["numeric"]["output"]>;
    asset_type?: Maybe<Scalars["String"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    owner_address?: Maybe<Scalars["String"]["output"]>;
    storage_id?: Maybe<Scalars["String"]["output"]>;
    token_standard?: Maybe<Scalars["String"]["output"]>;
    transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    write_set_change_index?: Maybe<Scalars["bigint"]["output"]>;
};
/** response of any mutation on the table "fungible_asset_balances" */
type FungibleAssetBalancesMutationResponse = {
    /** number of rows affected by the mutation */
    affected_rows: Scalars["Int"]["output"];
    /** data from the rows affected by the mutation */
    returning: Array<FungibleAssetBalances>;
};
/** on_conflict condition type for table "fungible_asset_balances" */
type FungibleAssetBalancesOnConflict = {
    constraint: FungibleAssetBalancesConstraint;
    update_columns?: Array<FungibleAssetBalancesUpdateColumn>;
    where?: InputMaybe<FungibleAssetBalancesBoolExp>;
};
/** Ordering options when selecting data from "fungible_asset_balances". */
type FungibleAssetBalancesOrderBy = {
    amount?: InputMaybe<OrderBy>;
    asset_type?: InputMaybe<OrderBy>;
    inserted_at?: InputMaybe<OrderBy>;
    is_frozen?: InputMaybe<OrderBy>;
    is_primary?: InputMaybe<OrderBy>;
    owner_address?: InputMaybe<OrderBy>;
    storage_id?: InputMaybe<OrderBy>;
    token_standard?: InputMaybe<OrderBy>;
    transaction_timestamp?: InputMaybe<OrderBy>;
    transaction_version?: InputMaybe<OrderBy>;
    write_set_change_index?: InputMaybe<OrderBy>;
};
/** primary key columns input for table: fungible_asset_balances */
type FungibleAssetBalancesPkColumnsInput = {
    transaction_version: Scalars["bigint"]["input"];
    write_set_change_index: Scalars["bigint"]["input"];
};
/** select columns of table "fungible_asset_balances" */
declare enum FungibleAssetBalancesSelectColumn {
    /** column name */
    Amount = "amount",
    /** column name */
    AssetType = "asset_type",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    IsFrozen = "is_frozen",
    /** column name */
    IsPrimary = "is_primary",
    /** column name */
    OwnerAddress = "owner_address",
    /** column name */
    StorageId = "storage_id",
    /** column name */
    TokenStandard = "token_standard",
    /** column name */
    TransactionTimestamp = "transaction_timestamp",
    /** column name */
    TransactionVersion = "transaction_version",
    /** column name */
    WriteSetChangeIndex = "write_set_change_index"
}
/** input type for updating data in table "fungible_asset_balances" */
type FungibleAssetBalancesSetInput = {
    amount?: InputMaybe<Scalars["numeric"]["input"]>;
    asset_type?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    is_frozen?: InputMaybe<Scalars["Boolean"]["input"]>;
    is_primary?: InputMaybe<Scalars["Boolean"]["input"]>;
    owner_address?: InputMaybe<Scalars["String"]["input"]>;
    storage_id?: InputMaybe<Scalars["String"]["input"]>;
    token_standard?: InputMaybe<Scalars["String"]["input"]>;
    transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** aggregate stddev on columns */
type FungibleAssetBalancesStddevFields = {
    amount?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_pop on columns */
type FungibleAssetBalancesStddevPopFields = {
    amount?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_samp on columns */
type FungibleAssetBalancesStddevSampFields = {
    amount?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};
/** Streaming cursor of the table "fungible_asset_balances" */
type FungibleAssetBalancesStreamCursorInput = {
    /** Stream column input with initial value */
    initial_value: FungibleAssetBalancesStreamCursorValueInput;
    /** cursor ordering */
    ordering?: InputMaybe<CursorOrdering>;
};
/** Initial value of the column from where the streaming should start */
type FungibleAssetBalancesStreamCursorValueInput = {
    amount?: InputMaybe<Scalars["numeric"]["input"]>;
    asset_type?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    is_frozen?: InputMaybe<Scalars["Boolean"]["input"]>;
    is_primary?: InputMaybe<Scalars["Boolean"]["input"]>;
    owner_address?: InputMaybe<Scalars["String"]["input"]>;
    storage_id?: InputMaybe<Scalars["String"]["input"]>;
    token_standard?: InputMaybe<Scalars["String"]["input"]>;
    transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** aggregate sum on columns */
type FungibleAssetBalancesSumFields = {
    amount?: Maybe<Scalars["numeric"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    write_set_change_index?: Maybe<Scalars["bigint"]["output"]>;
};
/** update columns of table "fungible_asset_balances" */
declare enum FungibleAssetBalancesUpdateColumn {
    /** column name */
    Amount = "amount",
    /** column name */
    AssetType = "asset_type",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    IsFrozen = "is_frozen",
    /** column name */
    IsPrimary = "is_primary",
    /** column name */
    OwnerAddress = "owner_address",
    /** column name */
    StorageId = "storage_id",
    /** column name */
    TokenStandard = "token_standard",
    /** column name */
    TransactionTimestamp = "transaction_timestamp",
    /** column name */
    TransactionVersion = "transaction_version",
    /** column name */
    WriteSetChangeIndex = "write_set_change_index"
}
type FungibleAssetBalancesUpdates = {
    /** increments the numeric columns with given value of the filtered values */
    _inc?: InputMaybe<FungibleAssetBalancesIncInput>;
    /** sets the columns of the filtered rows to the given values */
    _set?: InputMaybe<FungibleAssetBalancesSetInput>;
    /** filter the rows which have to be updated */
    where: FungibleAssetBalancesBoolExp;
};
/** aggregate var_pop on columns */
type FungibleAssetBalancesVarPopFields = {
    amount?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate var_samp on columns */
type FungibleAssetBalancesVarSampFields = {
    amount?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate variance on columns */
type FungibleAssetBalancesVarianceFields = {
    amount?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};
/** columns and relationships of "fungible_asset_metadata" */
type FungibleAssetMetadata = {
    asset_type: Scalars["String"]["output"];
    creator_address: Scalars["String"]["output"];
    decimals: Scalars["Int"]["output"];
    icon_uri?: Maybe<Scalars["String"]["output"]>;
    inserted_at: Scalars["timestamp"]["output"];
    is_token_v2?: Maybe<Scalars["Boolean"]["output"]>;
    last_transaction_timestamp: Scalars["timestamp"]["output"];
    last_transaction_version: Scalars["bigint"]["output"];
    maximum_v2?: Maybe<Scalars["numeric"]["output"]>;
    name: Scalars["String"]["output"];
    project_uri?: Maybe<Scalars["String"]["output"]>;
    supply_aggregator_table_handle_v1?: Maybe<Scalars["String"]["output"]>;
    supply_aggregator_table_key_v1?: Maybe<Scalars["String"]["output"]>;
    supply_v2?: Maybe<Scalars["numeric"]["output"]>;
    symbol: Scalars["String"]["output"];
    token_standard: Scalars["String"]["output"];
};
/** aggregated selection of "fungible_asset_metadata" */
type FungibleAssetMetadataAggregate = {
    aggregate?: Maybe<FungibleAssetMetadataAggregateFields>;
    nodes: Array<FungibleAssetMetadata>;
};
/** aggregate fields of "fungible_asset_metadata" */
type FungibleAssetMetadataAggregateFields = {
    avg?: Maybe<FungibleAssetMetadataAvgFields>;
    count: Scalars["Int"]["output"];
    max?: Maybe<FungibleAssetMetadataMaxFields>;
    min?: Maybe<FungibleAssetMetadataMinFields>;
    stddev?: Maybe<FungibleAssetMetadataStddevFields>;
    stddev_pop?: Maybe<FungibleAssetMetadataStddevPopFields>;
    stddev_samp?: Maybe<FungibleAssetMetadataStddevSampFields>;
    sum?: Maybe<FungibleAssetMetadataSumFields>;
    var_pop?: Maybe<FungibleAssetMetadataVarPopFields>;
    var_samp?: Maybe<FungibleAssetMetadataVarSampFields>;
    variance?: Maybe<FungibleAssetMetadataVarianceFields>;
};
/** aggregate fields of "fungible_asset_metadata" */
type FungibleAssetMetadataAggregateFieldsCountArgs = {
    columns?: InputMaybe<Array<FungibleAssetMetadataSelectColumn>>;
    distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};
/** aggregate avg on columns */
type FungibleAssetMetadataAvgFields = {
    decimals?: Maybe<Scalars["Float"]["output"]>;
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
    maximum_v2?: Maybe<Scalars["Float"]["output"]>;
    supply_v2?: Maybe<Scalars["Float"]["output"]>;
};
/** Boolean expression to filter rows from the table "fungible_asset_metadata". All fields are combined with a logical 'AND'. */
type FungibleAssetMetadataBoolExp = {
    _and?: InputMaybe<Array<FungibleAssetMetadataBoolExp>>;
    _not?: InputMaybe<FungibleAssetMetadataBoolExp>;
    _or?: InputMaybe<Array<FungibleAssetMetadataBoolExp>>;
    asset_type?: InputMaybe<StringComparisonExp>;
    creator_address?: InputMaybe<StringComparisonExp>;
    decimals?: InputMaybe<IntComparisonExp>;
    icon_uri?: InputMaybe<StringComparisonExp>;
    inserted_at?: InputMaybe<TimestampComparisonExp>;
    is_token_v2?: InputMaybe<BooleanComparisonExp>;
    last_transaction_timestamp?: InputMaybe<TimestampComparisonExp>;
    last_transaction_version?: InputMaybe<BigintComparisonExp>;
    maximum_v2?: InputMaybe<NumericComparisonExp>;
    name?: InputMaybe<StringComparisonExp>;
    project_uri?: InputMaybe<StringComparisonExp>;
    supply_aggregator_table_handle_v1?: InputMaybe<StringComparisonExp>;
    supply_aggregator_table_key_v1?: InputMaybe<StringComparisonExp>;
    supply_v2?: InputMaybe<NumericComparisonExp>;
    symbol?: InputMaybe<StringComparisonExp>;
    token_standard?: InputMaybe<StringComparisonExp>;
};
/** unique or primary key constraints on table "fungible_asset_metadata" */
declare enum FungibleAssetMetadataConstraint {
    /** unique or primary key constraint on columns "asset_type" */
    FungibleAssetMetadataPkey = "fungible_asset_metadata_pkey"
}
/** input type for incrementing numeric columns in table "fungible_asset_metadata" */
type FungibleAssetMetadataIncInput = {
    decimals?: InputMaybe<Scalars["Int"]["input"]>;
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    maximum_v2?: InputMaybe<Scalars["numeric"]["input"]>;
    supply_v2?: InputMaybe<Scalars["numeric"]["input"]>;
};
/** input type for inserting data into table "fungible_asset_metadata" */
type FungibleAssetMetadataInsertInput = {
    asset_type?: InputMaybe<Scalars["String"]["input"]>;
    creator_address?: InputMaybe<Scalars["String"]["input"]>;
    decimals?: InputMaybe<Scalars["Int"]["input"]>;
    icon_uri?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    is_token_v2?: InputMaybe<Scalars["Boolean"]["input"]>;
    last_transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    maximum_v2?: InputMaybe<Scalars["numeric"]["input"]>;
    name?: InputMaybe<Scalars["String"]["input"]>;
    project_uri?: InputMaybe<Scalars["String"]["input"]>;
    supply_aggregator_table_handle_v1?: InputMaybe<Scalars["String"]["input"]>;
    supply_aggregator_table_key_v1?: InputMaybe<Scalars["String"]["input"]>;
    supply_v2?: InputMaybe<Scalars["numeric"]["input"]>;
    symbol?: InputMaybe<Scalars["String"]["input"]>;
    token_standard?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregate max on columns */
type FungibleAssetMetadataMaxFields = {
    asset_type?: Maybe<Scalars["String"]["output"]>;
    creator_address?: Maybe<Scalars["String"]["output"]>;
    decimals?: Maybe<Scalars["Int"]["output"]>;
    icon_uri?: Maybe<Scalars["String"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    last_transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
    last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    maximum_v2?: Maybe<Scalars["numeric"]["output"]>;
    name?: Maybe<Scalars["String"]["output"]>;
    project_uri?: Maybe<Scalars["String"]["output"]>;
    supply_aggregator_table_handle_v1?: Maybe<Scalars["String"]["output"]>;
    supply_aggregator_table_key_v1?: Maybe<Scalars["String"]["output"]>;
    supply_v2?: Maybe<Scalars["numeric"]["output"]>;
    symbol?: Maybe<Scalars["String"]["output"]>;
    token_standard?: Maybe<Scalars["String"]["output"]>;
};
/** aggregate min on columns */
type FungibleAssetMetadataMinFields = {
    asset_type?: Maybe<Scalars["String"]["output"]>;
    creator_address?: Maybe<Scalars["String"]["output"]>;
    decimals?: Maybe<Scalars["Int"]["output"]>;
    icon_uri?: Maybe<Scalars["String"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    last_transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
    last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    maximum_v2?: Maybe<Scalars["numeric"]["output"]>;
    name?: Maybe<Scalars["String"]["output"]>;
    project_uri?: Maybe<Scalars["String"]["output"]>;
    supply_aggregator_table_handle_v1?: Maybe<Scalars["String"]["output"]>;
    supply_aggregator_table_key_v1?: Maybe<Scalars["String"]["output"]>;
    supply_v2?: Maybe<Scalars["numeric"]["output"]>;
    symbol?: Maybe<Scalars["String"]["output"]>;
    token_standard?: Maybe<Scalars["String"]["output"]>;
};
/** response of any mutation on the table "fungible_asset_metadata" */
type FungibleAssetMetadataMutationResponse = {
    /** number of rows affected by the mutation */
    affected_rows: Scalars["Int"]["output"];
    /** data from the rows affected by the mutation */
    returning: Array<FungibleAssetMetadata>;
};
/** input type for inserting object relation for remote table "fungible_asset_metadata" */
type FungibleAssetMetadataObjRelInsertInput = {
    data: FungibleAssetMetadataInsertInput;
    /** upsert condition */
    on_conflict?: InputMaybe<FungibleAssetMetadataOnConflict>;
};
/** on_conflict condition type for table "fungible_asset_metadata" */
type FungibleAssetMetadataOnConflict = {
    constraint: FungibleAssetMetadataConstraint;
    update_columns?: Array<FungibleAssetMetadataUpdateColumn>;
    where?: InputMaybe<FungibleAssetMetadataBoolExp>;
};
/** Ordering options when selecting data from "fungible_asset_metadata". */
type FungibleAssetMetadataOrderBy = {
    asset_type?: InputMaybe<OrderBy>;
    creator_address?: InputMaybe<OrderBy>;
    decimals?: InputMaybe<OrderBy>;
    icon_uri?: InputMaybe<OrderBy>;
    inserted_at?: InputMaybe<OrderBy>;
    is_token_v2?: InputMaybe<OrderBy>;
    last_transaction_timestamp?: InputMaybe<OrderBy>;
    last_transaction_version?: InputMaybe<OrderBy>;
    maximum_v2?: InputMaybe<OrderBy>;
    name?: InputMaybe<OrderBy>;
    project_uri?: InputMaybe<OrderBy>;
    supply_aggregator_table_handle_v1?: InputMaybe<OrderBy>;
    supply_aggregator_table_key_v1?: InputMaybe<OrderBy>;
    supply_v2?: InputMaybe<OrderBy>;
    symbol?: InputMaybe<OrderBy>;
    token_standard?: InputMaybe<OrderBy>;
};
/** primary key columns input for table: fungible_asset_metadata */
type FungibleAssetMetadataPkColumnsInput = {
    asset_type: Scalars["String"]["input"];
};
/** select columns of table "fungible_asset_metadata" */
declare enum FungibleAssetMetadataSelectColumn {
    /** column name */
    AssetType = "asset_type",
    /** column name */
    CreatorAddress = "creator_address",
    /** column name */
    Decimals = "decimals",
    /** column name */
    IconUri = "icon_uri",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    IsTokenV2 = "is_token_v2",
    /** column name */
    LastTransactionTimestamp = "last_transaction_timestamp",
    /** column name */
    LastTransactionVersion = "last_transaction_version",
    /** column name */
    MaximumV2 = "maximum_v2",
    /** column name */
    Name = "name",
    /** column name */
    ProjectUri = "project_uri",
    /** column name */
    SupplyAggregatorTableHandleV1 = "supply_aggregator_table_handle_v1",
    /** column name */
    SupplyAggregatorTableKeyV1 = "supply_aggregator_table_key_v1",
    /** column name */
    SupplyV2 = "supply_v2",
    /** column name */
    Symbol = "symbol",
    /** column name */
    TokenStandard = "token_standard"
}
/** input type for updating data in table "fungible_asset_metadata" */
type FungibleAssetMetadataSetInput = {
    asset_type?: InputMaybe<Scalars["String"]["input"]>;
    creator_address?: InputMaybe<Scalars["String"]["input"]>;
    decimals?: InputMaybe<Scalars["Int"]["input"]>;
    icon_uri?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    is_token_v2?: InputMaybe<Scalars["Boolean"]["input"]>;
    last_transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    maximum_v2?: InputMaybe<Scalars["numeric"]["input"]>;
    name?: InputMaybe<Scalars["String"]["input"]>;
    project_uri?: InputMaybe<Scalars["String"]["input"]>;
    supply_aggregator_table_handle_v1?: InputMaybe<Scalars["String"]["input"]>;
    supply_aggregator_table_key_v1?: InputMaybe<Scalars["String"]["input"]>;
    supply_v2?: InputMaybe<Scalars["numeric"]["input"]>;
    symbol?: InputMaybe<Scalars["String"]["input"]>;
    token_standard?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregate stddev on columns */
type FungibleAssetMetadataStddevFields = {
    decimals?: Maybe<Scalars["Float"]["output"]>;
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
    maximum_v2?: Maybe<Scalars["Float"]["output"]>;
    supply_v2?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_pop on columns */
type FungibleAssetMetadataStddevPopFields = {
    decimals?: Maybe<Scalars["Float"]["output"]>;
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
    maximum_v2?: Maybe<Scalars["Float"]["output"]>;
    supply_v2?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_samp on columns */
type FungibleAssetMetadataStddevSampFields = {
    decimals?: Maybe<Scalars["Float"]["output"]>;
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
    maximum_v2?: Maybe<Scalars["Float"]["output"]>;
    supply_v2?: Maybe<Scalars["Float"]["output"]>;
};
/** Streaming cursor of the table "fungible_asset_metadata" */
type FungibleAssetMetadataStreamCursorInput = {
    /** Stream column input with initial value */
    initial_value: FungibleAssetMetadataStreamCursorValueInput;
    /** cursor ordering */
    ordering?: InputMaybe<CursorOrdering>;
};
/** Initial value of the column from where the streaming should start */
type FungibleAssetMetadataStreamCursorValueInput = {
    asset_type?: InputMaybe<Scalars["String"]["input"]>;
    creator_address?: InputMaybe<Scalars["String"]["input"]>;
    decimals?: InputMaybe<Scalars["Int"]["input"]>;
    icon_uri?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    is_token_v2?: InputMaybe<Scalars["Boolean"]["input"]>;
    last_transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    maximum_v2?: InputMaybe<Scalars["numeric"]["input"]>;
    name?: InputMaybe<Scalars["String"]["input"]>;
    project_uri?: InputMaybe<Scalars["String"]["input"]>;
    supply_aggregator_table_handle_v1?: InputMaybe<Scalars["String"]["input"]>;
    supply_aggregator_table_key_v1?: InputMaybe<Scalars["String"]["input"]>;
    supply_v2?: InputMaybe<Scalars["numeric"]["input"]>;
    symbol?: InputMaybe<Scalars["String"]["input"]>;
    token_standard?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregate sum on columns */
type FungibleAssetMetadataSumFields = {
    decimals?: Maybe<Scalars["Int"]["output"]>;
    last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    maximum_v2?: Maybe<Scalars["numeric"]["output"]>;
    supply_v2?: Maybe<Scalars["numeric"]["output"]>;
};
/** update columns of table "fungible_asset_metadata" */
declare enum FungibleAssetMetadataUpdateColumn {
    /** column name */
    AssetType = "asset_type",
    /** column name */
    CreatorAddress = "creator_address",
    /** column name */
    Decimals = "decimals",
    /** column name */
    IconUri = "icon_uri",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    IsTokenV2 = "is_token_v2",
    /** column name */
    LastTransactionTimestamp = "last_transaction_timestamp",
    /** column name */
    LastTransactionVersion = "last_transaction_version",
    /** column name */
    MaximumV2 = "maximum_v2",
    /** column name */
    Name = "name",
    /** column name */
    ProjectUri = "project_uri",
    /** column name */
    SupplyAggregatorTableHandleV1 = "supply_aggregator_table_handle_v1",
    /** column name */
    SupplyAggregatorTableKeyV1 = "supply_aggregator_table_key_v1",
    /** column name */
    SupplyV2 = "supply_v2",
    /** column name */
    Symbol = "symbol",
    /** column name */
    TokenStandard = "token_standard"
}
type FungibleAssetMetadataUpdates = {
    /** increments the numeric columns with given value of the filtered values */
    _inc?: InputMaybe<FungibleAssetMetadataIncInput>;
    /** sets the columns of the filtered rows to the given values */
    _set?: InputMaybe<FungibleAssetMetadataSetInput>;
    /** filter the rows which have to be updated */
    where: FungibleAssetMetadataBoolExp;
};
/** aggregate var_pop on columns */
type FungibleAssetMetadataVarPopFields = {
    decimals?: Maybe<Scalars["Float"]["output"]>;
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
    maximum_v2?: Maybe<Scalars["Float"]["output"]>;
    supply_v2?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate var_samp on columns */
type FungibleAssetMetadataVarSampFields = {
    decimals?: Maybe<Scalars["Float"]["output"]>;
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
    maximum_v2?: Maybe<Scalars["Float"]["output"]>;
    supply_v2?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate variance on columns */
type FungibleAssetMetadataVarianceFields = {
    decimals?: Maybe<Scalars["Float"]["output"]>;
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
    maximum_v2?: Maybe<Scalars["Float"]["output"]>;
    supply_v2?: Maybe<Scalars["Float"]["output"]>;
};
/** columns and relationships of "fungible_asset_to_coin_mappings" */
type FungibleAssetToCoinMappings = {
    coin_type: Scalars["String"]["output"];
    fungible_asset_metadata_address: Scalars["String"]["output"];
    last_transaction_version: Scalars["bigint"]["output"];
};
/** aggregated selection of "fungible_asset_to_coin_mappings" */
type FungibleAssetToCoinMappingsAggregate = {
    aggregate?: Maybe<FungibleAssetToCoinMappingsAggregateFields>;
    nodes: Array<FungibleAssetToCoinMappings>;
};
/** aggregate fields of "fungible_asset_to_coin_mappings" */
type FungibleAssetToCoinMappingsAggregateFields = {
    avg?: Maybe<FungibleAssetToCoinMappingsAvgFields>;
    count: Scalars["Int"]["output"];
    max?: Maybe<FungibleAssetToCoinMappingsMaxFields>;
    min?: Maybe<FungibleAssetToCoinMappingsMinFields>;
    stddev?: Maybe<FungibleAssetToCoinMappingsStddevFields>;
    stddev_pop?: Maybe<FungibleAssetToCoinMappingsStddevPopFields>;
    stddev_samp?: Maybe<FungibleAssetToCoinMappingsStddevSampFields>;
    sum?: Maybe<FungibleAssetToCoinMappingsSumFields>;
    var_pop?: Maybe<FungibleAssetToCoinMappingsVarPopFields>;
    var_samp?: Maybe<FungibleAssetToCoinMappingsVarSampFields>;
    variance?: Maybe<FungibleAssetToCoinMappingsVarianceFields>;
};
/** aggregate fields of "fungible_asset_to_coin_mappings" */
type FungibleAssetToCoinMappingsAggregateFieldsCountArgs = {
    columns?: InputMaybe<Array<FungibleAssetToCoinMappingsSelectColumn>>;
    distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};
/** aggregate avg on columns */
type FungibleAssetToCoinMappingsAvgFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** Boolean expression to filter rows from the table "fungible_asset_to_coin_mappings". All fields are combined with a logical 'AND'. */
type FungibleAssetToCoinMappingsBoolExp = {
    _and?: InputMaybe<Array<FungibleAssetToCoinMappingsBoolExp>>;
    _not?: InputMaybe<FungibleAssetToCoinMappingsBoolExp>;
    _or?: InputMaybe<Array<FungibleAssetToCoinMappingsBoolExp>>;
    coin_type?: InputMaybe<StringComparisonExp>;
    fungible_asset_metadata_address?: InputMaybe<StringComparisonExp>;
    last_transaction_version?: InputMaybe<BigintComparisonExp>;
};
/** unique or primary key constraints on table "fungible_asset_to_coin_mappings" */
declare enum FungibleAssetToCoinMappingsConstraint {
    /** unique or primary key constraint on columns "fungible_asset_metadata_address" */
    FungibleAssetToCoinMappingsPkey = "fungible_asset_to_coin_mappings_pkey"
}
/** input type for incrementing numeric columns in table "fungible_asset_to_coin_mappings" */
type FungibleAssetToCoinMappingsIncInput = {
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** input type for inserting data into table "fungible_asset_to_coin_mappings" */
type FungibleAssetToCoinMappingsInsertInput = {
    coin_type?: InputMaybe<Scalars["String"]["input"]>;
    fungible_asset_metadata_address?: InputMaybe<Scalars["String"]["input"]>;
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** aggregate max on columns */
type FungibleAssetToCoinMappingsMaxFields = {
    coin_type?: Maybe<Scalars["String"]["output"]>;
    fungible_asset_metadata_address?: Maybe<Scalars["String"]["output"]>;
    last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};
/** aggregate min on columns */
type FungibleAssetToCoinMappingsMinFields = {
    coin_type?: Maybe<Scalars["String"]["output"]>;
    fungible_asset_metadata_address?: Maybe<Scalars["String"]["output"]>;
    last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};
/** response of any mutation on the table "fungible_asset_to_coin_mappings" */
type FungibleAssetToCoinMappingsMutationResponse = {
    /** number of rows affected by the mutation */
    affected_rows: Scalars["Int"]["output"];
    /** data from the rows affected by the mutation */
    returning: Array<FungibleAssetToCoinMappings>;
};
/** on_conflict condition type for table "fungible_asset_to_coin_mappings" */
type FungibleAssetToCoinMappingsOnConflict = {
    constraint: FungibleAssetToCoinMappingsConstraint;
    update_columns?: Array<FungibleAssetToCoinMappingsUpdateColumn>;
    where?: InputMaybe<FungibleAssetToCoinMappingsBoolExp>;
};
/** Ordering options when selecting data from "fungible_asset_to_coin_mappings". */
type FungibleAssetToCoinMappingsOrderBy = {
    coin_type?: InputMaybe<OrderBy>;
    fungible_asset_metadata_address?: InputMaybe<OrderBy>;
    last_transaction_version?: InputMaybe<OrderBy>;
};
/** primary key columns input for table: fungible_asset_to_coin_mappings */
type FungibleAssetToCoinMappingsPkColumnsInput = {
    fungible_asset_metadata_address: Scalars["String"]["input"];
};
/** select columns of table "fungible_asset_to_coin_mappings" */
declare enum FungibleAssetToCoinMappingsSelectColumn {
    /** column name */
    CoinType = "coin_type",
    /** column name */
    FungibleAssetMetadataAddress = "fungible_asset_metadata_address",
    /** column name */
    LastTransactionVersion = "last_transaction_version"
}
/** input type for updating data in table "fungible_asset_to_coin_mappings" */
type FungibleAssetToCoinMappingsSetInput = {
    coin_type?: InputMaybe<Scalars["String"]["input"]>;
    fungible_asset_metadata_address?: InputMaybe<Scalars["String"]["input"]>;
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** aggregate stddev on columns */
type FungibleAssetToCoinMappingsStddevFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_pop on columns */
type FungibleAssetToCoinMappingsStddevPopFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_samp on columns */
type FungibleAssetToCoinMappingsStddevSampFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** Streaming cursor of the table "fungible_asset_to_coin_mappings" */
type FungibleAssetToCoinMappingsStreamCursorInput = {
    /** Stream column input with initial value */
    initial_value: FungibleAssetToCoinMappingsStreamCursorValueInput;
    /** cursor ordering */
    ordering?: InputMaybe<CursorOrdering>;
};
/** Initial value of the column from where the streaming should start */
type FungibleAssetToCoinMappingsStreamCursorValueInput = {
    coin_type?: InputMaybe<Scalars["String"]["input"]>;
    fungible_asset_metadata_address?: InputMaybe<Scalars["String"]["input"]>;
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** aggregate sum on columns */
type FungibleAssetToCoinMappingsSumFields = {
    last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};
/** update columns of table "fungible_asset_to_coin_mappings" */
declare enum FungibleAssetToCoinMappingsUpdateColumn {
    /** column name */
    CoinType = "coin_type",
    /** column name */
    FungibleAssetMetadataAddress = "fungible_asset_metadata_address",
    /** column name */
    LastTransactionVersion = "last_transaction_version"
}
type FungibleAssetToCoinMappingsUpdates = {
    /** increments the numeric columns with given value of the filtered values */
    _inc?: InputMaybe<FungibleAssetToCoinMappingsIncInput>;
    /** sets the columns of the filtered rows to the given values */
    _set?: InputMaybe<FungibleAssetToCoinMappingsSetInput>;
    /** filter the rows which have to be updated */
    where: FungibleAssetToCoinMappingsBoolExp;
};
/** aggregate var_pop on columns */
type FungibleAssetToCoinMappingsVarPopFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate var_samp on columns */
type FungibleAssetToCoinMappingsVarSampFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate variance on columns */
type FungibleAssetToCoinMappingsVarianceFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** columns and relationships of "gas_fees" */
type GasFees = {
    amount?: Maybe<Scalars["numeric"]["output"]>;
    block_height: Scalars["bigint"]["output"];
    entry_function_id_str?: Maybe<Scalars["String"]["output"]>;
    gas_fee_payer_address?: Maybe<Scalars["String"]["output"]>;
    is_transaction_success: Scalars["Boolean"]["output"];
    owner_address?: Maybe<Scalars["String"]["output"]>;
    storage_refund_amount: Scalars["numeric"]["output"];
    transaction_timestamp: Scalars["timestamp"]["output"];
    transaction_version: Scalars["bigint"]["output"];
};
/** aggregated selection of "gas_fees" */
type GasFeesAggregate = {
    aggregate?: Maybe<GasFeesAggregateFields>;
    nodes: Array<GasFees>;
};
/** aggregate fields of "gas_fees" */
type GasFeesAggregateFields = {
    avg?: Maybe<GasFeesAvgFields>;
    count: Scalars["Int"]["output"];
    max?: Maybe<GasFeesMaxFields>;
    min?: Maybe<GasFeesMinFields>;
    stddev?: Maybe<GasFeesStddevFields>;
    stddev_pop?: Maybe<GasFeesStddevPopFields>;
    stddev_samp?: Maybe<GasFeesStddevSampFields>;
    sum?: Maybe<GasFeesSumFields>;
    var_pop?: Maybe<GasFeesVarPopFields>;
    var_samp?: Maybe<GasFeesVarSampFields>;
    variance?: Maybe<GasFeesVarianceFields>;
};
/** aggregate fields of "gas_fees" */
type GasFeesAggregateFieldsCountArgs = {
    columns?: InputMaybe<Array<GasFeesSelectColumn>>;
    distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};
/** aggregate avg on columns */
type GasFeesAvgFields = {
    amount?: Maybe<Scalars["Float"]["output"]>;
    block_height?: Maybe<Scalars["Float"]["output"]>;
    storage_refund_amount?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** Boolean expression to filter rows from the table "gas_fees". All fields are combined with a logical 'AND'. */
type GasFeesBoolExp = {
    _and?: InputMaybe<Array<GasFeesBoolExp>>;
    _not?: InputMaybe<GasFeesBoolExp>;
    _or?: InputMaybe<Array<GasFeesBoolExp>>;
    amount?: InputMaybe<NumericComparisonExp>;
    block_height?: InputMaybe<BigintComparisonExp>;
    entry_function_id_str?: InputMaybe<StringComparisonExp>;
    gas_fee_payer_address?: InputMaybe<StringComparisonExp>;
    is_transaction_success?: InputMaybe<BooleanComparisonExp>;
    owner_address?: InputMaybe<StringComparisonExp>;
    storage_refund_amount?: InputMaybe<NumericComparisonExp>;
    transaction_timestamp?: InputMaybe<TimestampComparisonExp>;
    transaction_version?: InputMaybe<BigintComparisonExp>;
};
/** unique or primary key constraints on table "gas_fees" */
declare enum GasFeesConstraint {
    /** unique or primary key constraint on columns "transaction_version" */
    GasFeesPkey = "gas_fees_pkey"
}
/** input type for incrementing numeric columns in table "gas_fees" */
type GasFeesIncInput = {
    amount?: InputMaybe<Scalars["numeric"]["input"]>;
    block_height?: InputMaybe<Scalars["bigint"]["input"]>;
    storage_refund_amount?: InputMaybe<Scalars["numeric"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** input type for inserting data into table "gas_fees" */
type GasFeesInsertInput = {
    amount?: InputMaybe<Scalars["numeric"]["input"]>;
    block_height?: InputMaybe<Scalars["bigint"]["input"]>;
    entry_function_id_str?: InputMaybe<Scalars["String"]["input"]>;
    gas_fee_payer_address?: InputMaybe<Scalars["String"]["input"]>;
    is_transaction_success?: InputMaybe<Scalars["Boolean"]["input"]>;
    owner_address?: InputMaybe<Scalars["String"]["input"]>;
    storage_refund_amount?: InputMaybe<Scalars["numeric"]["input"]>;
    transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** aggregate max on columns */
type GasFeesMaxFields = {
    amount?: Maybe<Scalars["numeric"]["output"]>;
    block_height?: Maybe<Scalars["bigint"]["output"]>;
    entry_function_id_str?: Maybe<Scalars["String"]["output"]>;
    gas_fee_payer_address?: Maybe<Scalars["String"]["output"]>;
    owner_address?: Maybe<Scalars["String"]["output"]>;
    storage_refund_amount?: Maybe<Scalars["numeric"]["output"]>;
    transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};
/** aggregate min on columns */
type GasFeesMinFields = {
    amount?: Maybe<Scalars["numeric"]["output"]>;
    block_height?: Maybe<Scalars["bigint"]["output"]>;
    entry_function_id_str?: Maybe<Scalars["String"]["output"]>;
    gas_fee_payer_address?: Maybe<Scalars["String"]["output"]>;
    owner_address?: Maybe<Scalars["String"]["output"]>;
    storage_refund_amount?: Maybe<Scalars["numeric"]["output"]>;
    transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};
/** response of any mutation on the table "gas_fees" */
type GasFeesMutationResponse = {
    /** number of rows affected by the mutation */
    affected_rows: Scalars["Int"]["output"];
    /** data from the rows affected by the mutation */
    returning: Array<GasFees>;
};
/** on_conflict condition type for table "gas_fees" */
type GasFeesOnConflict = {
    constraint: GasFeesConstraint;
    update_columns?: Array<GasFeesUpdateColumn>;
    where?: InputMaybe<GasFeesBoolExp>;
};
/** Ordering options when selecting data from "gas_fees". */
type GasFeesOrderBy = {
    amount?: InputMaybe<OrderBy>;
    block_height?: InputMaybe<OrderBy>;
    entry_function_id_str?: InputMaybe<OrderBy>;
    gas_fee_payer_address?: InputMaybe<OrderBy>;
    is_transaction_success?: InputMaybe<OrderBy>;
    owner_address?: InputMaybe<OrderBy>;
    storage_refund_amount?: InputMaybe<OrderBy>;
    transaction_timestamp?: InputMaybe<OrderBy>;
    transaction_version?: InputMaybe<OrderBy>;
};
/** primary key columns input for table: gas_fees */
type GasFeesPkColumnsInput = {
    transaction_version: Scalars["bigint"]["input"];
};
/** select columns of table "gas_fees" */
declare enum GasFeesSelectColumn {
    /** column name */
    Amount = "amount",
    /** column name */
    BlockHeight = "block_height",
    /** column name */
    EntryFunctionIdStr = "entry_function_id_str",
    /** column name */
    GasFeePayerAddress = "gas_fee_payer_address",
    /** column name */
    IsTransactionSuccess = "is_transaction_success",
    /** column name */
    OwnerAddress = "owner_address",
    /** column name */
    StorageRefundAmount = "storage_refund_amount",
    /** column name */
    TransactionTimestamp = "transaction_timestamp",
    /** column name */
    TransactionVersion = "transaction_version"
}
/** input type for updating data in table "gas_fees" */
type GasFeesSetInput = {
    amount?: InputMaybe<Scalars["numeric"]["input"]>;
    block_height?: InputMaybe<Scalars["bigint"]["input"]>;
    entry_function_id_str?: InputMaybe<Scalars["String"]["input"]>;
    gas_fee_payer_address?: InputMaybe<Scalars["String"]["input"]>;
    is_transaction_success?: InputMaybe<Scalars["Boolean"]["input"]>;
    owner_address?: InputMaybe<Scalars["String"]["input"]>;
    storage_refund_amount?: InputMaybe<Scalars["numeric"]["input"]>;
    transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** aggregate stddev on columns */
type GasFeesStddevFields = {
    amount?: Maybe<Scalars["Float"]["output"]>;
    block_height?: Maybe<Scalars["Float"]["output"]>;
    storage_refund_amount?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_pop on columns */
type GasFeesStddevPopFields = {
    amount?: Maybe<Scalars["Float"]["output"]>;
    block_height?: Maybe<Scalars["Float"]["output"]>;
    storage_refund_amount?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_samp on columns */
type GasFeesStddevSampFields = {
    amount?: Maybe<Scalars["Float"]["output"]>;
    block_height?: Maybe<Scalars["Float"]["output"]>;
    storage_refund_amount?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** Streaming cursor of the table "gas_fees" */
type GasFeesStreamCursorInput = {
    /** Stream column input with initial value */
    initial_value: GasFeesStreamCursorValueInput;
    /** cursor ordering */
    ordering?: InputMaybe<CursorOrdering>;
};
/** Initial value of the column from where the streaming should start */
type GasFeesStreamCursorValueInput = {
    amount?: InputMaybe<Scalars["numeric"]["input"]>;
    block_height?: InputMaybe<Scalars["bigint"]["input"]>;
    entry_function_id_str?: InputMaybe<Scalars["String"]["input"]>;
    gas_fee_payer_address?: InputMaybe<Scalars["String"]["input"]>;
    is_transaction_success?: InputMaybe<Scalars["Boolean"]["input"]>;
    owner_address?: InputMaybe<Scalars["String"]["input"]>;
    storage_refund_amount?: InputMaybe<Scalars["numeric"]["input"]>;
    transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** aggregate sum on columns */
type GasFeesSumFields = {
    amount?: Maybe<Scalars["numeric"]["output"]>;
    block_height?: Maybe<Scalars["bigint"]["output"]>;
    storage_refund_amount?: Maybe<Scalars["numeric"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};
/** update columns of table "gas_fees" */
declare enum GasFeesUpdateColumn {
    /** column name */
    Amount = "amount",
    /** column name */
    BlockHeight = "block_height",
    /** column name */
    EntryFunctionIdStr = "entry_function_id_str",
    /** column name */
    GasFeePayerAddress = "gas_fee_payer_address",
    /** column name */
    IsTransactionSuccess = "is_transaction_success",
    /** column name */
    OwnerAddress = "owner_address",
    /** column name */
    StorageRefundAmount = "storage_refund_amount",
    /** column name */
    TransactionTimestamp = "transaction_timestamp",
    /** column name */
    TransactionVersion = "transaction_version"
}
type GasFeesUpdates = {
    /** increments the numeric columns with given value of the filtered values */
    _inc?: InputMaybe<GasFeesIncInput>;
    /** sets the columns of the filtered rows to the given values */
    _set?: InputMaybe<GasFeesSetInput>;
    /** filter the rows which have to be updated */
    where: GasFeesBoolExp;
};
/** aggregate var_pop on columns */
type GasFeesVarPopFields = {
    amount?: Maybe<Scalars["Float"]["output"]>;
    block_height?: Maybe<Scalars["Float"]["output"]>;
    storage_refund_amount?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate var_samp on columns */
type GasFeesVarSampFields = {
    amount?: Maybe<Scalars["Float"]["output"]>;
    block_height?: Maybe<Scalars["Float"]["output"]>;
    storage_refund_amount?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate variance on columns */
type GasFeesVarianceFields = {
    amount?: Maybe<Scalars["Float"]["output"]>;
    block_height?: Maybe<Scalars["Float"]["output"]>;
    storage_refund_amount?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** columns and relationships of "indexer_status" */
type IndexerStatus = {
    db: Scalars["String"]["output"];
    inserted_at: Scalars["timestamp"]["output"];
    is_indexer_up: Scalars["Boolean"]["output"];
};
/** aggregated selection of "indexer_status" */
type IndexerStatusAggregate = {
    aggregate?: Maybe<IndexerStatusAggregateFields>;
    nodes: Array<IndexerStatus>;
};
/** aggregate fields of "indexer_status" */
type IndexerStatusAggregateFields = {
    count: Scalars["Int"]["output"];
    max?: Maybe<IndexerStatusMaxFields>;
    min?: Maybe<IndexerStatusMinFields>;
};
/** aggregate fields of "indexer_status" */
type IndexerStatusAggregateFieldsCountArgs = {
    columns?: InputMaybe<Array<IndexerStatusSelectColumn>>;
    distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};
/** Boolean expression to filter rows from the table "indexer_status". All fields are combined with a logical 'AND'. */
type IndexerStatusBoolExp = {
    _and?: InputMaybe<Array<IndexerStatusBoolExp>>;
    _not?: InputMaybe<IndexerStatusBoolExp>;
    _or?: InputMaybe<Array<IndexerStatusBoolExp>>;
    db?: InputMaybe<StringComparisonExp>;
    inserted_at?: InputMaybe<TimestampComparisonExp>;
    is_indexer_up?: InputMaybe<BooleanComparisonExp>;
};
/** unique or primary key constraints on table "indexer_status" */
declare enum IndexerStatusConstraint {
    /** unique or primary key constraint on columns "db" */
    IndexerStatusPkey = "indexer_status_pkey"
}
/** input type for inserting data into table "indexer_status" */
type IndexerStatusInsertInput = {
    db?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    is_indexer_up?: InputMaybe<Scalars["Boolean"]["input"]>;
};
/** aggregate max on columns */
type IndexerStatusMaxFields = {
    db?: Maybe<Scalars["String"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
};
/** aggregate min on columns */
type IndexerStatusMinFields = {
    db?: Maybe<Scalars["String"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
};
/** response of any mutation on the table "indexer_status" */
type IndexerStatusMutationResponse = {
    /** number of rows affected by the mutation */
    affected_rows: Scalars["Int"]["output"];
    /** data from the rows affected by the mutation */
    returning: Array<IndexerStatus>;
};
/** on_conflict condition type for table "indexer_status" */
type IndexerStatusOnConflict = {
    constraint: IndexerStatusConstraint;
    update_columns?: Array<IndexerStatusUpdateColumn>;
    where?: InputMaybe<IndexerStatusBoolExp>;
};
/** Ordering options when selecting data from "indexer_status". */
type IndexerStatusOrderBy = {
    db?: InputMaybe<OrderBy>;
    inserted_at?: InputMaybe<OrderBy>;
    is_indexer_up?: InputMaybe<OrderBy>;
};
/** primary key columns input for table: indexer_status */
type IndexerStatusPkColumnsInput = {
    db: Scalars["String"]["input"];
};
/** select columns of table "indexer_status" */
declare enum IndexerStatusSelectColumn {
    /** column name */
    Db = "db",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    IsIndexerUp = "is_indexer_up"
}
/** input type for updating data in table "indexer_status" */
type IndexerStatusSetInput = {
    db?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    is_indexer_up?: InputMaybe<Scalars["Boolean"]["input"]>;
};
/** Streaming cursor of the table "indexer_status" */
type IndexerStatusStreamCursorInput = {
    /** Stream column input with initial value */
    initial_value: IndexerStatusStreamCursorValueInput;
    /** cursor ordering */
    ordering?: InputMaybe<CursorOrdering>;
};
/** Initial value of the column from where the streaming should start */
type IndexerStatusStreamCursorValueInput = {
    db?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    is_indexer_up?: InputMaybe<Scalars["Boolean"]["input"]>;
};
/** update columns of table "indexer_status" */
declare enum IndexerStatusUpdateColumn {
    /** column name */
    Db = "db",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    IsIndexerUp = "is_indexer_up"
}
type IndexerStatusUpdates = {
    /** sets the columns of the filtered rows to the given values */
    _set?: InputMaybe<IndexerStatusSetInput>;
    /** filter the rows which have to be updated */
    where: IndexerStatusBoolExp;
};
type JsonbCastExp = {
    String?: InputMaybe<StringComparisonExp>;
};
/** Boolean expression to compare columns of type "jsonb". All fields are combined with logical 'AND'. */
type JsonbComparisonExp = {
    _cast?: InputMaybe<JsonbCastExp>;
    /** is the column contained in the given json value */
    _contained_in?: InputMaybe<Scalars["jsonb"]["input"]>;
    /** does the column contain the given json value at the top level */
    _contains?: InputMaybe<Scalars["jsonb"]["input"]>;
    _eq?: InputMaybe<Scalars["jsonb"]["input"]>;
    _gt?: InputMaybe<Scalars["jsonb"]["input"]>;
    _gte?: InputMaybe<Scalars["jsonb"]["input"]>;
    /** does the string exist as a top-level key in the column */
    _has_key?: InputMaybe<Scalars["String"]["input"]>;
    /** do all of these strings exist as top-level keys in the column */
    _has_keys_all?: InputMaybe<Array<Scalars["String"]["input"]>>;
    /** do any of these strings exist as top-level keys in the column */
    _has_keys_any?: InputMaybe<Array<Scalars["String"]["input"]>>;
    _in?: InputMaybe<Array<Scalars["jsonb"]["input"]>>;
    _is_null?: InputMaybe<Scalars["Boolean"]["input"]>;
    _lt?: InputMaybe<Scalars["jsonb"]["input"]>;
    _lte?: InputMaybe<Scalars["jsonb"]["input"]>;
    _neq?: InputMaybe<Scalars["jsonb"]["input"]>;
    _nin?: InputMaybe<Array<Scalars["jsonb"]["input"]>>;
};
/** columns and relationships of "move_modules" */
type MoveModules = {
    address: Scalars["String"]["output"];
    bytecode?: Maybe<Scalars["bytea"]["output"]>;
    exposed_functions?: Maybe<Scalars["jsonb"]["output"]>;
    friends?: Maybe<Scalars["jsonb"]["output"]>;
    inserted_at: Scalars["timestamp"]["output"];
    is_deleted: Scalars["Boolean"]["output"];
    name: Scalars["String"]["output"];
    structs?: Maybe<Scalars["jsonb"]["output"]>;
    transaction_block_height: Scalars["bigint"]["output"];
    transaction_version: Scalars["bigint"]["output"];
    write_set_change_index: Scalars["bigint"]["output"];
};
/** columns and relationships of "move_modules" */
type MoveModulesExposedFunctionsArgs = {
    path?: InputMaybe<Scalars["String"]["input"]>;
};
/** columns and relationships of "move_modules" */
type MoveModulesFriendsArgs = {
    path?: InputMaybe<Scalars["String"]["input"]>;
};
/** columns and relationships of "move_modules" */
type MoveModulesStructsArgs = {
    path?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregated selection of "move_modules" */
type MoveModulesAggregate = {
    aggregate?: Maybe<MoveModulesAggregateFields>;
    nodes: Array<MoveModules>;
};
/** aggregate fields of "move_modules" */
type MoveModulesAggregateFields = {
    avg?: Maybe<MoveModulesAvgFields>;
    count: Scalars["Int"]["output"];
    max?: Maybe<MoveModulesMaxFields>;
    min?: Maybe<MoveModulesMinFields>;
    stddev?: Maybe<MoveModulesStddevFields>;
    stddev_pop?: Maybe<MoveModulesStddevPopFields>;
    stddev_samp?: Maybe<MoveModulesStddevSampFields>;
    sum?: Maybe<MoveModulesSumFields>;
    var_pop?: Maybe<MoveModulesVarPopFields>;
    var_samp?: Maybe<MoveModulesVarSampFields>;
    variance?: Maybe<MoveModulesVarianceFields>;
};
/** aggregate fields of "move_modules" */
type MoveModulesAggregateFieldsCountArgs = {
    columns?: InputMaybe<Array<MoveModulesSelectColumn>>;
    distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};
/** append existing jsonb value of filtered columns with new jsonb value */
type MoveModulesAppendInput = {
    exposed_functions?: InputMaybe<Scalars["jsonb"]["input"]>;
    friends?: InputMaybe<Scalars["jsonb"]["input"]>;
    structs?: InputMaybe<Scalars["jsonb"]["input"]>;
};
/** aggregate avg on columns */
type MoveModulesAvgFields = {
    transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};
/** Boolean expression to filter rows from the table "move_modules". All fields are combined with a logical 'AND'. */
type MoveModulesBoolExp = {
    _and?: InputMaybe<Array<MoveModulesBoolExp>>;
    _not?: InputMaybe<MoveModulesBoolExp>;
    _or?: InputMaybe<Array<MoveModulesBoolExp>>;
    address?: InputMaybe<StringComparisonExp>;
    bytecode?: InputMaybe<ByteaComparisonExp>;
    exposed_functions?: InputMaybe<JsonbComparisonExp>;
    friends?: InputMaybe<JsonbComparisonExp>;
    inserted_at?: InputMaybe<TimestampComparisonExp>;
    is_deleted?: InputMaybe<BooleanComparisonExp>;
    name?: InputMaybe<StringComparisonExp>;
    structs?: InputMaybe<JsonbComparisonExp>;
    transaction_block_height?: InputMaybe<BigintComparisonExp>;
    transaction_version?: InputMaybe<BigintComparisonExp>;
    write_set_change_index?: InputMaybe<BigintComparisonExp>;
};
/** unique or primary key constraints on table "move_modules" */
declare enum MoveModulesConstraint {
    /** unique or primary key constraint on columns "write_set_change_index", "transaction_version" */
    MoveModulesPkey = "move_modules_pkey"
}
/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
type MoveModulesDeleteAtPathInput = {
    exposed_functions?: InputMaybe<Array<Scalars["String"]["input"]>>;
    friends?: InputMaybe<Array<Scalars["String"]["input"]>>;
    structs?: InputMaybe<Array<Scalars["String"]["input"]>>;
};
/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
type MoveModulesDeleteElemInput = {
    exposed_functions?: InputMaybe<Scalars["Int"]["input"]>;
    friends?: InputMaybe<Scalars["Int"]["input"]>;
    structs?: InputMaybe<Scalars["Int"]["input"]>;
};
/** delete key/value pair or string element. key/value pairs are matched based on their key value */
type MoveModulesDeleteKeyInput = {
    exposed_functions?: InputMaybe<Scalars["String"]["input"]>;
    friends?: InputMaybe<Scalars["String"]["input"]>;
    structs?: InputMaybe<Scalars["String"]["input"]>;
};
/** input type for incrementing numeric columns in table "move_modules" */
type MoveModulesIncInput = {
    transaction_block_height?: InputMaybe<Scalars["bigint"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** input type for inserting data into table "move_modules" */
type MoveModulesInsertInput = {
    address?: InputMaybe<Scalars["String"]["input"]>;
    bytecode?: InputMaybe<Scalars["bytea"]["input"]>;
    exposed_functions?: InputMaybe<Scalars["jsonb"]["input"]>;
    friends?: InputMaybe<Scalars["jsonb"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    is_deleted?: InputMaybe<Scalars["Boolean"]["input"]>;
    name?: InputMaybe<Scalars["String"]["input"]>;
    structs?: InputMaybe<Scalars["jsonb"]["input"]>;
    transaction_block_height?: InputMaybe<Scalars["bigint"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** aggregate max on columns */
type MoveModulesMaxFields = {
    address?: Maybe<Scalars["String"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    name?: Maybe<Scalars["String"]["output"]>;
    transaction_block_height?: Maybe<Scalars["bigint"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    write_set_change_index?: Maybe<Scalars["bigint"]["output"]>;
};
/** aggregate min on columns */
type MoveModulesMinFields = {
    address?: Maybe<Scalars["String"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    name?: Maybe<Scalars["String"]["output"]>;
    transaction_block_height?: Maybe<Scalars["bigint"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    write_set_change_index?: Maybe<Scalars["bigint"]["output"]>;
};
/** response of any mutation on the table "move_modules" */
type MoveModulesMutationResponse = {
    /** number of rows affected by the mutation */
    affected_rows: Scalars["Int"]["output"];
    /** data from the rows affected by the mutation */
    returning: Array<MoveModules>;
};
/** on_conflict condition type for table "move_modules" */
type MoveModulesOnConflict = {
    constraint: MoveModulesConstraint;
    update_columns?: Array<MoveModulesUpdateColumn>;
    where?: InputMaybe<MoveModulesBoolExp>;
};
/** Ordering options when selecting data from "move_modules". */
type MoveModulesOrderBy = {
    address?: InputMaybe<OrderBy>;
    bytecode?: InputMaybe<OrderBy>;
    exposed_functions?: InputMaybe<OrderBy>;
    friends?: InputMaybe<OrderBy>;
    inserted_at?: InputMaybe<OrderBy>;
    is_deleted?: InputMaybe<OrderBy>;
    name?: InputMaybe<OrderBy>;
    structs?: InputMaybe<OrderBy>;
    transaction_block_height?: InputMaybe<OrderBy>;
    transaction_version?: InputMaybe<OrderBy>;
    write_set_change_index?: InputMaybe<OrderBy>;
};
/** primary key columns input for table: move_modules */
type MoveModulesPkColumnsInput = {
    transaction_version: Scalars["bigint"]["input"];
    write_set_change_index: Scalars["bigint"]["input"];
};
/** prepend existing jsonb value of filtered columns with new jsonb value */
type MoveModulesPrependInput = {
    exposed_functions?: InputMaybe<Scalars["jsonb"]["input"]>;
    friends?: InputMaybe<Scalars["jsonb"]["input"]>;
    structs?: InputMaybe<Scalars["jsonb"]["input"]>;
};
/** select columns of table "move_modules" */
declare enum MoveModulesSelectColumn {
    /** column name */
    Address = "address",
    /** column name */
    Bytecode = "bytecode",
    /** column name */
    ExposedFunctions = "exposed_functions",
    /** column name */
    Friends = "friends",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    IsDeleted = "is_deleted",
    /** column name */
    Name = "name",
    /** column name */
    Structs = "structs",
    /** column name */
    TransactionBlockHeight = "transaction_block_height",
    /** column name */
    TransactionVersion = "transaction_version",
    /** column name */
    WriteSetChangeIndex = "write_set_change_index"
}
/** input type for updating data in table "move_modules" */
type MoveModulesSetInput = {
    address?: InputMaybe<Scalars["String"]["input"]>;
    bytecode?: InputMaybe<Scalars["bytea"]["input"]>;
    exposed_functions?: InputMaybe<Scalars["jsonb"]["input"]>;
    friends?: InputMaybe<Scalars["jsonb"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    is_deleted?: InputMaybe<Scalars["Boolean"]["input"]>;
    name?: InputMaybe<Scalars["String"]["input"]>;
    structs?: InputMaybe<Scalars["jsonb"]["input"]>;
    transaction_block_height?: InputMaybe<Scalars["bigint"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** aggregate stddev on columns */
type MoveModulesStddevFields = {
    transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_pop on columns */
type MoveModulesStddevPopFields = {
    transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_samp on columns */
type MoveModulesStddevSampFields = {
    transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};
/** Streaming cursor of the table "move_modules" */
type MoveModulesStreamCursorInput = {
    /** Stream column input with initial value */
    initial_value: MoveModulesStreamCursorValueInput;
    /** cursor ordering */
    ordering?: InputMaybe<CursorOrdering>;
};
/** Initial value of the column from where the streaming should start */
type MoveModulesStreamCursorValueInput = {
    address?: InputMaybe<Scalars["String"]["input"]>;
    bytecode?: InputMaybe<Scalars["bytea"]["input"]>;
    exposed_functions?: InputMaybe<Scalars["jsonb"]["input"]>;
    friends?: InputMaybe<Scalars["jsonb"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    is_deleted?: InputMaybe<Scalars["Boolean"]["input"]>;
    name?: InputMaybe<Scalars["String"]["input"]>;
    structs?: InputMaybe<Scalars["jsonb"]["input"]>;
    transaction_block_height?: InputMaybe<Scalars["bigint"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** aggregate sum on columns */
type MoveModulesSumFields = {
    transaction_block_height?: Maybe<Scalars["bigint"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    write_set_change_index?: Maybe<Scalars["bigint"]["output"]>;
};
/** update columns of table "move_modules" */
declare enum MoveModulesUpdateColumn {
    /** column name */
    Address = "address",
    /** column name */
    Bytecode = "bytecode",
    /** column name */
    ExposedFunctions = "exposed_functions",
    /** column name */
    Friends = "friends",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    IsDeleted = "is_deleted",
    /** column name */
    Name = "name",
    /** column name */
    Structs = "structs",
    /** column name */
    TransactionBlockHeight = "transaction_block_height",
    /** column name */
    TransactionVersion = "transaction_version",
    /** column name */
    WriteSetChangeIndex = "write_set_change_index"
}
type MoveModulesUpdates = {
    /** append existing jsonb value of filtered columns with new jsonb value */
    _append?: InputMaybe<MoveModulesAppendInput>;
    /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
    _delete_at_path?: InputMaybe<MoveModulesDeleteAtPathInput>;
    /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
    _delete_elem?: InputMaybe<MoveModulesDeleteElemInput>;
    /** delete key/value pair or string element. key/value pairs are matched based on their key value */
    _delete_key?: InputMaybe<MoveModulesDeleteKeyInput>;
    /** increments the numeric columns with given value of the filtered values */
    _inc?: InputMaybe<MoveModulesIncInput>;
    /** prepend existing jsonb value of filtered columns with new jsonb value */
    _prepend?: InputMaybe<MoveModulesPrependInput>;
    /** sets the columns of the filtered rows to the given values */
    _set?: InputMaybe<MoveModulesSetInput>;
    /** filter the rows which have to be updated */
    where: MoveModulesBoolExp;
};
/** aggregate var_pop on columns */
type MoveModulesVarPopFields = {
    transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate var_samp on columns */
type MoveModulesVarSampFields = {
    transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate variance on columns */
type MoveModulesVarianceFields = {
    transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};
/** columns and relationships of "move_resources" */
type MoveResources = {
    address: Scalars["String"]["output"];
    data?: Maybe<Scalars["jsonb"]["output"]>;
    generic_type_params?: Maybe<Scalars["jsonb"]["output"]>;
    inserted_at: Scalars["timestamp"]["output"];
    is_deleted: Scalars["Boolean"]["output"];
    module: Scalars["String"]["output"];
    name: Scalars["String"]["output"];
    state_key_hash: Scalars["String"]["output"];
    transaction_block_height: Scalars["bigint"]["output"];
    transaction_version: Scalars["bigint"]["output"];
    type: Scalars["String"]["output"];
    write_set_change_index: Scalars["bigint"]["output"];
};
/** columns and relationships of "move_resources" */
type MoveResourcesDataArgs = {
    path?: InputMaybe<Scalars["String"]["input"]>;
};
/** columns and relationships of "move_resources" */
type MoveResourcesGenericTypeParamsArgs = {
    path?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregated selection of "move_resources" */
type MoveResourcesAggregate = {
    aggregate?: Maybe<MoveResourcesAggregateFields>;
    nodes: Array<MoveResources>;
};
/** aggregate fields of "move_resources" */
type MoveResourcesAggregateFields = {
    avg?: Maybe<MoveResourcesAvgFields>;
    count: Scalars["Int"]["output"];
    max?: Maybe<MoveResourcesMaxFields>;
    min?: Maybe<MoveResourcesMinFields>;
    stddev?: Maybe<MoveResourcesStddevFields>;
    stddev_pop?: Maybe<MoveResourcesStddevPopFields>;
    stddev_samp?: Maybe<MoveResourcesStddevSampFields>;
    sum?: Maybe<MoveResourcesSumFields>;
    var_pop?: Maybe<MoveResourcesVarPopFields>;
    var_samp?: Maybe<MoveResourcesVarSampFields>;
    variance?: Maybe<MoveResourcesVarianceFields>;
};
/** aggregate fields of "move_resources" */
type MoveResourcesAggregateFieldsCountArgs = {
    columns?: InputMaybe<Array<MoveResourcesSelectColumn>>;
    distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};
/** append existing jsonb value of filtered columns with new jsonb value */
type MoveResourcesAppendInput = {
    data?: InputMaybe<Scalars["jsonb"]["input"]>;
    generic_type_params?: InputMaybe<Scalars["jsonb"]["input"]>;
};
/** aggregate avg on columns */
type MoveResourcesAvgFields = {
    transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};
/** Boolean expression to filter rows from the table "move_resources". All fields are combined with a logical 'AND'. */
type MoveResourcesBoolExp = {
    _and?: InputMaybe<Array<MoveResourcesBoolExp>>;
    _not?: InputMaybe<MoveResourcesBoolExp>;
    _or?: InputMaybe<Array<MoveResourcesBoolExp>>;
    address?: InputMaybe<StringComparisonExp>;
    data?: InputMaybe<JsonbComparisonExp>;
    generic_type_params?: InputMaybe<JsonbComparisonExp>;
    inserted_at?: InputMaybe<TimestampComparisonExp>;
    is_deleted?: InputMaybe<BooleanComparisonExp>;
    module?: InputMaybe<StringComparisonExp>;
    name?: InputMaybe<StringComparisonExp>;
    state_key_hash?: InputMaybe<StringComparisonExp>;
    transaction_block_height?: InputMaybe<BigintComparisonExp>;
    transaction_version?: InputMaybe<BigintComparisonExp>;
    type?: InputMaybe<StringComparisonExp>;
    write_set_change_index?: InputMaybe<BigintComparisonExp>;
};
/** unique or primary key constraints on table "move_resources" */
declare enum MoveResourcesConstraint {
    /** unique or primary key constraint on columns "write_set_change_index", "transaction_version" */
    MoveResourcesPkey = "move_resources_pkey"
}
/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
type MoveResourcesDeleteAtPathInput = {
    data?: InputMaybe<Array<Scalars["String"]["input"]>>;
    generic_type_params?: InputMaybe<Array<Scalars["String"]["input"]>>;
};
/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
type MoveResourcesDeleteElemInput = {
    data?: InputMaybe<Scalars["Int"]["input"]>;
    generic_type_params?: InputMaybe<Scalars["Int"]["input"]>;
};
/** delete key/value pair or string element. key/value pairs are matched based on their key value */
type MoveResourcesDeleteKeyInput = {
    data?: InputMaybe<Scalars["String"]["input"]>;
    generic_type_params?: InputMaybe<Scalars["String"]["input"]>;
};
/** input type for incrementing numeric columns in table "move_resources" */
type MoveResourcesIncInput = {
    transaction_block_height?: InputMaybe<Scalars["bigint"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** input type for inserting data into table "move_resources" */
type MoveResourcesInsertInput = {
    address?: InputMaybe<Scalars["String"]["input"]>;
    data?: InputMaybe<Scalars["jsonb"]["input"]>;
    generic_type_params?: InputMaybe<Scalars["jsonb"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    is_deleted?: InputMaybe<Scalars["Boolean"]["input"]>;
    module?: InputMaybe<Scalars["String"]["input"]>;
    name?: InputMaybe<Scalars["String"]["input"]>;
    state_key_hash?: InputMaybe<Scalars["String"]["input"]>;
    transaction_block_height?: InputMaybe<Scalars["bigint"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    type?: InputMaybe<Scalars["String"]["input"]>;
    write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** aggregate max on columns */
type MoveResourcesMaxFields = {
    address?: Maybe<Scalars["String"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    module?: Maybe<Scalars["String"]["output"]>;
    name?: Maybe<Scalars["String"]["output"]>;
    state_key_hash?: Maybe<Scalars["String"]["output"]>;
    transaction_block_height?: Maybe<Scalars["bigint"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    type?: Maybe<Scalars["String"]["output"]>;
    write_set_change_index?: Maybe<Scalars["bigint"]["output"]>;
};
/** aggregate min on columns */
type MoveResourcesMinFields = {
    address?: Maybe<Scalars["String"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    module?: Maybe<Scalars["String"]["output"]>;
    name?: Maybe<Scalars["String"]["output"]>;
    state_key_hash?: Maybe<Scalars["String"]["output"]>;
    transaction_block_height?: Maybe<Scalars["bigint"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    type?: Maybe<Scalars["String"]["output"]>;
    write_set_change_index?: Maybe<Scalars["bigint"]["output"]>;
};
/** response of any mutation on the table "move_resources" */
type MoveResourcesMutationResponse = {
    /** number of rows affected by the mutation */
    affected_rows: Scalars["Int"]["output"];
    /** data from the rows affected by the mutation */
    returning: Array<MoveResources>;
};
/** on_conflict condition type for table "move_resources" */
type MoveResourcesOnConflict = {
    constraint: MoveResourcesConstraint;
    update_columns?: Array<MoveResourcesUpdateColumn>;
    where?: InputMaybe<MoveResourcesBoolExp>;
};
/** Ordering options when selecting data from "move_resources". */
type MoveResourcesOrderBy = {
    address?: InputMaybe<OrderBy>;
    data?: InputMaybe<OrderBy>;
    generic_type_params?: InputMaybe<OrderBy>;
    inserted_at?: InputMaybe<OrderBy>;
    is_deleted?: InputMaybe<OrderBy>;
    module?: InputMaybe<OrderBy>;
    name?: InputMaybe<OrderBy>;
    state_key_hash?: InputMaybe<OrderBy>;
    transaction_block_height?: InputMaybe<OrderBy>;
    transaction_version?: InputMaybe<OrderBy>;
    type?: InputMaybe<OrderBy>;
    write_set_change_index?: InputMaybe<OrderBy>;
};
/** primary key columns input for table: move_resources */
type MoveResourcesPkColumnsInput = {
    transaction_version: Scalars["bigint"]["input"];
    write_set_change_index: Scalars["bigint"]["input"];
};
/** prepend existing jsonb value of filtered columns with new jsonb value */
type MoveResourcesPrependInput = {
    data?: InputMaybe<Scalars["jsonb"]["input"]>;
    generic_type_params?: InputMaybe<Scalars["jsonb"]["input"]>;
};
/** select columns of table "move_resources" */
declare enum MoveResourcesSelectColumn {
    /** column name */
    Address = "address",
    /** column name */
    Data = "data",
    /** column name */
    GenericTypeParams = "generic_type_params",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    IsDeleted = "is_deleted",
    /** column name */
    Module = "module",
    /** column name */
    Name = "name",
    /** column name */
    StateKeyHash = "state_key_hash",
    /** column name */
    TransactionBlockHeight = "transaction_block_height",
    /** column name */
    TransactionVersion = "transaction_version",
    /** column name */
    Type = "type",
    /** column name */
    WriteSetChangeIndex = "write_set_change_index"
}
/** input type for updating data in table "move_resources" */
type MoveResourcesSetInput = {
    address?: InputMaybe<Scalars["String"]["input"]>;
    data?: InputMaybe<Scalars["jsonb"]["input"]>;
    generic_type_params?: InputMaybe<Scalars["jsonb"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    is_deleted?: InputMaybe<Scalars["Boolean"]["input"]>;
    module?: InputMaybe<Scalars["String"]["input"]>;
    name?: InputMaybe<Scalars["String"]["input"]>;
    state_key_hash?: InputMaybe<Scalars["String"]["input"]>;
    transaction_block_height?: InputMaybe<Scalars["bigint"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    type?: InputMaybe<Scalars["String"]["input"]>;
    write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** aggregate stddev on columns */
type MoveResourcesStddevFields = {
    transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_pop on columns */
type MoveResourcesStddevPopFields = {
    transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_samp on columns */
type MoveResourcesStddevSampFields = {
    transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};
/** Streaming cursor of the table "move_resources" */
type MoveResourcesStreamCursorInput = {
    /** Stream column input with initial value */
    initial_value: MoveResourcesStreamCursorValueInput;
    /** cursor ordering */
    ordering?: InputMaybe<CursorOrdering>;
};
/** Initial value of the column from where the streaming should start */
type MoveResourcesStreamCursorValueInput = {
    address?: InputMaybe<Scalars["String"]["input"]>;
    data?: InputMaybe<Scalars["jsonb"]["input"]>;
    generic_type_params?: InputMaybe<Scalars["jsonb"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    is_deleted?: InputMaybe<Scalars["Boolean"]["input"]>;
    module?: InputMaybe<Scalars["String"]["input"]>;
    name?: InputMaybe<Scalars["String"]["input"]>;
    state_key_hash?: InputMaybe<Scalars["String"]["input"]>;
    transaction_block_height?: InputMaybe<Scalars["bigint"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    type?: InputMaybe<Scalars["String"]["input"]>;
    write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** aggregate sum on columns */
type MoveResourcesSumFields = {
    transaction_block_height?: Maybe<Scalars["bigint"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    write_set_change_index?: Maybe<Scalars["bigint"]["output"]>;
};
/** update columns of table "move_resources" */
declare enum MoveResourcesUpdateColumn {
    /** column name */
    Address = "address",
    /** column name */
    Data = "data",
    /** column name */
    GenericTypeParams = "generic_type_params",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    IsDeleted = "is_deleted",
    /** column name */
    Module = "module",
    /** column name */
    Name = "name",
    /** column name */
    StateKeyHash = "state_key_hash",
    /** column name */
    TransactionBlockHeight = "transaction_block_height",
    /** column name */
    TransactionVersion = "transaction_version",
    /** column name */
    Type = "type",
    /** column name */
    WriteSetChangeIndex = "write_set_change_index"
}
type MoveResourcesUpdates = {
    /** append existing jsonb value of filtered columns with new jsonb value */
    _append?: InputMaybe<MoveResourcesAppendInput>;
    /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
    _delete_at_path?: InputMaybe<MoveResourcesDeleteAtPathInput>;
    /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
    _delete_elem?: InputMaybe<MoveResourcesDeleteElemInput>;
    /** delete key/value pair or string element. key/value pairs are matched based on their key value */
    _delete_key?: InputMaybe<MoveResourcesDeleteKeyInput>;
    /** increments the numeric columns with given value of the filtered values */
    _inc?: InputMaybe<MoveResourcesIncInput>;
    /** prepend existing jsonb value of filtered columns with new jsonb value */
    _prepend?: InputMaybe<MoveResourcesPrependInput>;
    /** sets the columns of the filtered rows to the given values */
    _set?: InputMaybe<MoveResourcesSetInput>;
    /** filter the rows which have to be updated */
    where: MoveResourcesBoolExp;
};
/** aggregate var_pop on columns */
type MoveResourcesVarPopFields = {
    transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate var_samp on columns */
type MoveResourcesVarSampFields = {
    transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate variance on columns */
type MoveResourcesVarianceFields = {
    transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};
/** columns and relationships of "move_resources_view" */
type MoveResourcesView = {
    address?: Maybe<Scalars["String"]["output"]>;
    generic_type_params?: Maybe<Scalars["jsonb"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    is_deleted?: Maybe<Scalars["Boolean"]["output"]>;
    json_data?: Maybe<Scalars["String"]["output"]>;
    module?: Maybe<Scalars["String"]["output"]>;
    name?: Maybe<Scalars["String"]["output"]>;
    transaction_block_height?: Maybe<Scalars["bigint"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    type?: Maybe<Scalars["String"]["output"]>;
    write_set_change_index?: Maybe<Scalars["bigint"]["output"]>;
};
/** columns and relationships of "move_resources_view" */
type MoveResourcesViewGenericTypeParamsArgs = {
    path?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregated selection of "move_resources_view" */
type MoveResourcesViewAggregate = {
    aggregate?: Maybe<MoveResourcesViewAggregateFields>;
    nodes: Array<MoveResourcesView>;
};
/** aggregate fields of "move_resources_view" */
type MoveResourcesViewAggregateFields = {
    avg?: Maybe<MoveResourcesViewAvgFields>;
    count: Scalars["Int"]["output"];
    max?: Maybe<MoveResourcesViewMaxFields>;
    min?: Maybe<MoveResourcesViewMinFields>;
    stddev?: Maybe<MoveResourcesViewStddevFields>;
    stddev_pop?: Maybe<MoveResourcesViewStddevPopFields>;
    stddev_samp?: Maybe<MoveResourcesViewStddevSampFields>;
    sum?: Maybe<MoveResourcesViewSumFields>;
    var_pop?: Maybe<MoveResourcesViewVarPopFields>;
    var_samp?: Maybe<MoveResourcesViewVarSampFields>;
    variance?: Maybe<MoveResourcesViewVarianceFields>;
};
/** aggregate fields of "move_resources_view" */
type MoveResourcesViewAggregateFieldsCountArgs = {
    columns?: InputMaybe<Array<MoveResourcesViewSelectColumn>>;
    distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};
/** append existing jsonb value of filtered columns with new jsonb value */
type MoveResourcesViewAppendInput = {
    generic_type_params?: InputMaybe<Scalars["jsonb"]["input"]>;
};
/** aggregate avg on columns */
type MoveResourcesViewAvgFields = {
    transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};
/** Boolean expression to filter rows from the table "move_resources_view". All fields are combined with a logical 'AND'. */
type MoveResourcesViewBoolExp = {
    _and?: InputMaybe<Array<MoveResourcesViewBoolExp>>;
    _not?: InputMaybe<MoveResourcesViewBoolExp>;
    _or?: InputMaybe<Array<MoveResourcesViewBoolExp>>;
    address?: InputMaybe<StringComparisonExp>;
    generic_type_params?: InputMaybe<JsonbComparisonExp>;
    inserted_at?: InputMaybe<TimestampComparisonExp>;
    is_deleted?: InputMaybe<BooleanComparisonExp>;
    json_data?: InputMaybe<StringComparisonExp>;
    module?: InputMaybe<StringComparisonExp>;
    name?: InputMaybe<StringComparisonExp>;
    transaction_block_height?: InputMaybe<BigintComparisonExp>;
    transaction_version?: InputMaybe<BigintComparisonExp>;
    type?: InputMaybe<StringComparisonExp>;
    write_set_change_index?: InputMaybe<BigintComparisonExp>;
};
/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
type MoveResourcesViewDeleteAtPathInput = {
    generic_type_params?: InputMaybe<Array<Scalars["String"]["input"]>>;
};
/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
type MoveResourcesViewDeleteElemInput = {
    generic_type_params?: InputMaybe<Scalars["Int"]["input"]>;
};
/** delete key/value pair or string element. key/value pairs are matched based on their key value */
type MoveResourcesViewDeleteKeyInput = {
    generic_type_params?: InputMaybe<Scalars["String"]["input"]>;
};
/** input type for incrementing numeric columns in table "move_resources_view" */
type MoveResourcesViewIncInput = {
    transaction_block_height?: InputMaybe<Scalars["bigint"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** input type for inserting data into table "move_resources_view" */
type MoveResourcesViewInsertInput = {
    address?: InputMaybe<Scalars["String"]["input"]>;
    generic_type_params?: InputMaybe<Scalars["jsonb"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    is_deleted?: InputMaybe<Scalars["Boolean"]["input"]>;
    json_data?: InputMaybe<Scalars["String"]["input"]>;
    module?: InputMaybe<Scalars["String"]["input"]>;
    name?: InputMaybe<Scalars["String"]["input"]>;
    transaction_block_height?: InputMaybe<Scalars["bigint"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    type?: InputMaybe<Scalars["String"]["input"]>;
    write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** aggregate max on columns */
type MoveResourcesViewMaxFields = {
    address?: Maybe<Scalars["String"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    json_data?: Maybe<Scalars["String"]["output"]>;
    module?: Maybe<Scalars["String"]["output"]>;
    name?: Maybe<Scalars["String"]["output"]>;
    transaction_block_height?: Maybe<Scalars["bigint"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    type?: Maybe<Scalars["String"]["output"]>;
    write_set_change_index?: Maybe<Scalars["bigint"]["output"]>;
};
/** aggregate min on columns */
type MoveResourcesViewMinFields = {
    address?: Maybe<Scalars["String"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    json_data?: Maybe<Scalars["String"]["output"]>;
    module?: Maybe<Scalars["String"]["output"]>;
    name?: Maybe<Scalars["String"]["output"]>;
    transaction_block_height?: Maybe<Scalars["bigint"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    type?: Maybe<Scalars["String"]["output"]>;
    write_set_change_index?: Maybe<Scalars["bigint"]["output"]>;
};
/** response of any mutation on the table "move_resources_view" */
type MoveResourcesViewMutationResponse = {
    /** number of rows affected by the mutation */
    affected_rows: Scalars["Int"]["output"];
    /** data from the rows affected by the mutation */
    returning: Array<MoveResourcesView>;
};
/** Ordering options when selecting data from "move_resources_view". */
type MoveResourcesViewOrderBy = {
    address?: InputMaybe<OrderBy>;
    generic_type_params?: InputMaybe<OrderBy>;
    inserted_at?: InputMaybe<OrderBy>;
    is_deleted?: InputMaybe<OrderBy>;
    json_data?: InputMaybe<OrderBy>;
    module?: InputMaybe<OrderBy>;
    name?: InputMaybe<OrderBy>;
    transaction_block_height?: InputMaybe<OrderBy>;
    transaction_version?: InputMaybe<OrderBy>;
    type?: InputMaybe<OrderBy>;
    write_set_change_index?: InputMaybe<OrderBy>;
};
/** prepend existing jsonb value of filtered columns with new jsonb value */
type MoveResourcesViewPrependInput = {
    generic_type_params?: InputMaybe<Scalars["jsonb"]["input"]>;
};
/** select columns of table "move_resources_view" */
declare enum MoveResourcesViewSelectColumn {
    /** column name */
    Address = "address",
    /** column name */
    GenericTypeParams = "generic_type_params",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    IsDeleted = "is_deleted",
    /** column name */
    JsonData = "json_data",
    /** column name */
    Module = "module",
    /** column name */
    Name = "name",
    /** column name */
    TransactionBlockHeight = "transaction_block_height",
    /** column name */
    TransactionVersion = "transaction_version",
    /** column name */
    Type = "type",
    /** column name */
    WriteSetChangeIndex = "write_set_change_index"
}
/** input type for updating data in table "move_resources_view" */
type MoveResourcesViewSetInput = {
    address?: InputMaybe<Scalars["String"]["input"]>;
    generic_type_params?: InputMaybe<Scalars["jsonb"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    is_deleted?: InputMaybe<Scalars["Boolean"]["input"]>;
    json_data?: InputMaybe<Scalars["String"]["input"]>;
    module?: InputMaybe<Scalars["String"]["input"]>;
    name?: InputMaybe<Scalars["String"]["input"]>;
    transaction_block_height?: InputMaybe<Scalars["bigint"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    type?: InputMaybe<Scalars["String"]["input"]>;
    write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** aggregate stddev on columns */
type MoveResourcesViewStddevFields = {
    transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_pop on columns */
type MoveResourcesViewStddevPopFields = {
    transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_samp on columns */
type MoveResourcesViewStddevSampFields = {
    transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};
/** Streaming cursor of the table "move_resources_view" */
type MoveResourcesViewStreamCursorInput = {
    /** Stream column input with initial value */
    initial_value: MoveResourcesViewStreamCursorValueInput;
    /** cursor ordering */
    ordering?: InputMaybe<CursorOrdering>;
};
/** Initial value of the column from where the streaming should start */
type MoveResourcesViewStreamCursorValueInput = {
    address?: InputMaybe<Scalars["String"]["input"]>;
    generic_type_params?: InputMaybe<Scalars["jsonb"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    is_deleted?: InputMaybe<Scalars["Boolean"]["input"]>;
    json_data?: InputMaybe<Scalars["String"]["input"]>;
    module?: InputMaybe<Scalars["String"]["input"]>;
    name?: InputMaybe<Scalars["String"]["input"]>;
    transaction_block_height?: InputMaybe<Scalars["bigint"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    type?: InputMaybe<Scalars["String"]["input"]>;
    write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** aggregate sum on columns */
type MoveResourcesViewSumFields = {
    transaction_block_height?: Maybe<Scalars["bigint"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    write_set_change_index?: Maybe<Scalars["bigint"]["output"]>;
};
type MoveResourcesViewUpdates = {
    /** append existing jsonb value of filtered columns with new jsonb value */
    _append?: InputMaybe<MoveResourcesViewAppendInput>;
    /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
    _delete_at_path?: InputMaybe<MoveResourcesViewDeleteAtPathInput>;
    /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
    _delete_elem?: InputMaybe<MoveResourcesViewDeleteElemInput>;
    /** delete key/value pair or string element. key/value pairs are matched based on their key value */
    _delete_key?: InputMaybe<MoveResourcesViewDeleteKeyInput>;
    /** increments the numeric columns with given value of the filtered values */
    _inc?: InputMaybe<MoveResourcesViewIncInput>;
    /** prepend existing jsonb value of filtered columns with new jsonb value */
    _prepend?: InputMaybe<MoveResourcesViewPrependInput>;
    /** sets the columns of the filtered rows to the given values */
    _set?: InputMaybe<MoveResourcesViewSetInput>;
    /** filter the rows which have to be updated */
    where: MoveResourcesViewBoolExp;
};
/** aggregate var_pop on columns */
type MoveResourcesViewVarPopFields = {
    transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate var_samp on columns */
type MoveResourcesViewVarSampFields = {
    transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate variance on columns */
type MoveResourcesViewVarianceFields = {
    transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};
/** mutation root */
type MutationRoot = {
    /** delete data from the table: "account_transactions" */
    delete_account_transactions?: Maybe<AccountTransactionsMutationResponse>;
    /** delete single row from the table: "account_transactions" */
    delete_account_transactions_by_pk?: Maybe<AccountTransactions>;
    /** delete data from the table: "ans_lookup" */
    delete_ans_lookup?: Maybe<AnsLookupMutationResponse>;
    /** delete single row from the table: "ans_lookup" */
    delete_ans_lookup_by_pk?: Maybe<AnsLookup>;
    /** delete data from the table: "ans_lookup_v2" */
    delete_ans_lookup_v2?: Maybe<AnsLookupV2MutationResponse>;
    /** delete single row from the table: "ans_lookup_v2" */
    delete_ans_lookup_v2_by_pk?: Maybe<AnsLookupV2>;
    /** delete data from the table: "ans_primary_name" */
    delete_ans_primary_name?: Maybe<AnsPrimaryNameMutationResponse>;
    /** delete single row from the table: "ans_primary_name" */
    delete_ans_primary_name_by_pk?: Maybe<AnsPrimaryName>;
    /** delete data from the table: "ans_primary_name_v2" */
    delete_ans_primary_name_v2?: Maybe<AnsPrimaryNameV2MutationResponse>;
    /** delete single row from the table: "ans_primary_name_v2" */
    delete_ans_primary_name_v2_by_pk?: Maybe<AnsPrimaryNameV2>;
    /** delete data from the table: "auth_key_account_addresses" */
    delete_auth_key_account_addresses?: Maybe<AuthKeyAccountAddressesMutationResponse>;
    /** delete single row from the table: "auth_key_account_addresses" */
    delete_auth_key_account_addresses_by_pk?: Maybe<AuthKeyAccountAddresses>;
    /** delete data from the table: "block_metadata_transactions" */
    delete_block_metadata_transactions?: Maybe<BlockMetadataTransactionsMutationResponse>;
    /** delete single row from the table: "block_metadata_transactions" */
    delete_block_metadata_transactions_by_pk?: Maybe<BlockMetadataTransactions>;
    /** delete data from the table: "coin_activities" */
    delete_coin_activities?: Maybe<CoinActivitiesMutationResponse>;
    /** delete single row from the table: "coin_activities" */
    delete_coin_activities_by_pk?: Maybe<CoinActivities>;
    /** delete data from the table: "coin_balances" */
    delete_coin_balances?: Maybe<CoinBalancesMutationResponse>;
    /** delete single row from the table: "coin_balances" */
    delete_coin_balances_by_pk?: Maybe<CoinBalances>;
    /** delete data from the table: "coin_infos" */
    delete_coin_infos?: Maybe<CoinInfosMutationResponse>;
    /** delete single row from the table: "coin_infos" */
    delete_coin_infos_by_pk?: Maybe<CoinInfos>;
    /** delete data from the table: "coin_supply" */
    delete_coin_supply?: Maybe<CoinSupplyMutationResponse>;
    /** delete single row from the table: "coin_supply" */
    delete_coin_supply_by_pk?: Maybe<CoinSupply>;
    /** delete data from the table: "collection_datas" */
    delete_collection_datas?: Maybe<CollectionDatasMutationResponse>;
    /** delete single row from the table: "collection_datas" */
    delete_collection_datas_by_pk?: Maybe<CollectionDatas>;
    /** delete data from the table: "collections_v2" */
    delete_collections_v2?: Maybe<CollectionsV2MutationResponse>;
    /** delete single row from the table: "collections_v2" */
    delete_collections_v2_by_pk?: Maybe<CollectionsV2>;
    /** delete data from the table: "current_ans_lookup" */
    delete_current_ans_lookup?: Maybe<CurrentAnsLookupMutationResponse>;
    /** delete single row from the table: "current_ans_lookup" */
    delete_current_ans_lookup_by_pk?: Maybe<CurrentAnsLookup>;
    /** delete data from the table: "current_ans_lookup_v2" */
    delete_current_ans_lookup_v2?: Maybe<CurrentAnsLookupV2MutationResponse>;
    /** delete single row from the table: "current_ans_lookup_v2" */
    delete_current_ans_lookup_v2_by_pk?: Maybe<CurrentAnsLookupV2>;
    /** delete data from the table: "current_ans_primary_name" */
    delete_current_ans_primary_name?: Maybe<CurrentAnsPrimaryNameMutationResponse>;
    /** delete single row from the table: "current_ans_primary_name" */
    delete_current_ans_primary_name_by_pk?: Maybe<CurrentAnsPrimaryName>;
    /** delete data from the table: "current_ans_primary_name_v2" */
    delete_current_ans_primary_name_v2?: Maybe<CurrentAnsPrimaryNameV2MutationResponse>;
    /** delete single row from the table: "current_ans_primary_name_v2" */
    delete_current_ans_primary_name_v2_by_pk?: Maybe<CurrentAnsPrimaryNameV2>;
    /** delete data from the table: "current_coin_balances" */
    delete_current_coin_balances?: Maybe<CurrentCoinBalancesMutationResponse>;
    /** delete single row from the table: "current_coin_balances" */
    delete_current_coin_balances_by_pk?: Maybe<CurrentCoinBalances>;
    /** delete data from the table: "current_collection_datas" */
    delete_current_collection_datas?: Maybe<CurrentCollectionDatasMutationResponse>;
    /** delete single row from the table: "current_collection_datas" */
    delete_current_collection_datas_by_pk?: Maybe<CurrentCollectionDatas>;
    /** delete data from the table: "current_collections_v2" */
    delete_current_collections_v2?: Maybe<CurrentCollectionsV2MutationResponse>;
    /** delete single row from the table: "current_collections_v2" */
    delete_current_collections_v2_by_pk?: Maybe<CurrentCollectionsV2>;
    /** delete data from the table: "current_delegated_staking_pool_balances" */
    delete_current_delegated_staking_pool_balances?: Maybe<CurrentDelegatedStakingPoolBalancesMutationResponse>;
    /** delete single row from the table: "current_delegated_staking_pool_balances" */
    delete_current_delegated_staking_pool_balances_by_pk?: Maybe<CurrentDelegatedStakingPoolBalances>;
    /** delete data from the table: "current_delegated_voter" */
    delete_current_delegated_voter?: Maybe<CurrentDelegatedVoterMutationResponse>;
    /** delete single row from the table: "current_delegated_voter" */
    delete_current_delegated_voter_by_pk?: Maybe<CurrentDelegatedVoter>;
    /** delete data from the table: "current_delegator_balances" */
    delete_current_delegator_balances?: Maybe<CurrentDelegatorBalancesMutationResponse>;
    /** delete single row from the table: "current_delegator_balances" */
    delete_current_delegator_balances_by_pk?: Maybe<CurrentDelegatorBalances>;
    /** delete data from the table: "current_fungible_asset_balances_legacy" */
    delete_current_fungible_asset_balances?: Maybe<CurrentFungibleAssetBalancesMutationResponse>;
    /** delete single row from the table: "current_fungible_asset_balances_legacy" */
    delete_current_fungible_asset_balances_by_pk?: Maybe<CurrentFungibleAssetBalances>;
    /** delete data from the table: "current_fungible_asset_balances" */
    delete_current_fungible_asset_balances_new?: Maybe<CurrentFungibleAssetBalancesNewMutationResponse>;
    /** delete single row from the table: "current_fungible_asset_balances" */
    delete_current_fungible_asset_balances_new_by_pk?: Maybe<CurrentFungibleAssetBalancesNew>;
    /** delete data from the table: "current_objects" */
    delete_current_objects?: Maybe<CurrentObjectsMutationResponse>;
    /** delete single row from the table: "current_objects" */
    delete_current_objects_by_pk?: Maybe<CurrentObjects>;
    /** delete data from the table: "current_staking_pool_voter" */
    delete_current_staking_pool_voter?: Maybe<CurrentStakingPoolVoterMutationResponse>;
    /** delete single row from the table: "current_staking_pool_voter" */
    delete_current_staking_pool_voter_by_pk?: Maybe<CurrentStakingPoolVoter>;
    /** delete data from the table: "current_table_items" */
    delete_current_table_items?: Maybe<CurrentTableItemsMutationResponse>;
    /** delete single row from the table: "current_table_items" */
    delete_current_table_items_by_pk?: Maybe<CurrentTableItems>;
    /** delete data from the table: "current_table_items_view" */
    delete_current_table_items_view?: Maybe<CurrentTableItemsViewMutationResponse>;
    /** delete data from the table: "current_token_datas" */
    delete_current_token_datas?: Maybe<CurrentTokenDatasMutationResponse>;
    /** delete single row from the table: "current_token_datas" */
    delete_current_token_datas_by_pk?: Maybe<CurrentTokenDatas>;
    /** delete data from the table: "current_token_datas_v2" */
    delete_current_token_datas_v2?: Maybe<CurrentTokenDatasV2MutationResponse>;
    /** delete single row from the table: "current_token_datas_v2" */
    delete_current_token_datas_v2_by_pk?: Maybe<CurrentTokenDatasV2>;
    /** delete data from the table: "current_token_ownerships" */
    delete_current_token_ownerships?: Maybe<CurrentTokenOwnershipsMutationResponse>;
    /** delete single row from the table: "current_token_ownerships" */
    delete_current_token_ownerships_by_pk?: Maybe<CurrentTokenOwnerships>;
    /** delete data from the table: "current_token_ownerships_v2" */
    delete_current_token_ownerships_v2?: Maybe<CurrentTokenOwnershipsV2MutationResponse>;
    /** delete single row from the table: "current_token_ownerships_v2" */
    delete_current_token_ownerships_v2_by_pk?: Maybe<CurrentTokenOwnershipsV2>;
    /** delete data from the table: "current_token_pending_claims" */
    delete_current_token_pending_claims?: Maybe<CurrentTokenPendingClaimsMutationResponse>;
    /** delete single row from the table: "current_token_pending_claims" */
    delete_current_token_pending_claims_by_pk?: Maybe<CurrentTokenPendingClaims>;
    /** delete data from the table: "current_token_royalty_v1" */
    delete_current_token_royalty_v1?: Maybe<CurrentTokenRoyaltyV1MutationResponse>;
    /** delete single row from the table: "current_token_royalty_v1" */
    delete_current_token_royalty_v1_by_pk?: Maybe<CurrentTokenRoyaltyV1>;
    /** delete data from the table: "current_token_v2_metadata" */
    delete_current_token_v2_metadata?: Maybe<CurrentTokenV2MetadataMutationResponse>;
    /** delete single row from the table: "current_token_v2_metadata" */
    delete_current_token_v2_metadata_by_pk?: Maybe<CurrentTokenV2Metadata>;
    /** delete data from the table: "delegated_staking_activities" */
    delete_delegated_staking_activities?: Maybe<DelegatedStakingActivitiesMutationResponse>;
    /** delete single row from the table: "delegated_staking_activities" */
    delete_delegated_staking_activities_by_pk?: Maybe<DelegatedStakingActivities>;
    /** delete data from the table: "delegated_staking_pool_balances" */
    delete_delegated_staking_pool_balances?: Maybe<DelegatedStakingPoolBalancesMutationResponse>;
    /** delete single row from the table: "delegated_staking_pool_balances" */
    delete_delegated_staking_pool_balances_by_pk?: Maybe<DelegatedStakingPoolBalances>;
    /** delete data from the table: "delegated_staking_pools" */
    delete_delegated_staking_pools?: Maybe<DelegatedStakingPoolsMutationResponse>;
    /** delete single row from the table: "delegated_staking_pools" */
    delete_delegated_staking_pools_by_pk?: Maybe<DelegatedStakingPools>;
    /** delete data from the table: "delegator_balances" */
    delete_delegator_balances?: Maybe<DelegatorBalancesMutationResponse>;
    /** delete single row from the table: "delegator_balances" */
    delete_delegator_balances_by_pk?: Maybe<DelegatorBalances>;
    /** delete data from the table: "event_size_info" */
    delete_event_size_info?: Maybe<EventSizeInfoMutationResponse>;
    /** delete single row from the table: "event_size_info" */
    delete_event_size_info_by_pk?: Maybe<EventSizeInfo>;
    /** delete data from the table: "events" */
    delete_events?: Maybe<EventsMutationResponse>;
    /** delete single row from the table: "events" */
    delete_events_by_pk?: Maybe<Events>;
    /** delete data from the table: "events_view" */
    delete_events_view?: Maybe<EventsViewMutationResponse>;
    /** delete data from the table: "fungible_asset_activities" */
    delete_fungible_asset_activities?: Maybe<FungibleAssetActivitiesMutationResponse>;
    /** delete single row from the table: "fungible_asset_activities" */
    delete_fungible_asset_activities_by_pk?: Maybe<FungibleAssetActivities>;
    /** delete data from the table: "fungible_asset_balances" */
    delete_fungible_asset_balances?: Maybe<FungibleAssetBalancesMutationResponse>;
    /** delete single row from the table: "fungible_asset_balances" */
    delete_fungible_asset_balances_by_pk?: Maybe<FungibleAssetBalances>;
    /** delete data from the table: "fungible_asset_metadata" */
    delete_fungible_asset_metadata?: Maybe<FungibleAssetMetadataMutationResponse>;
    /** delete single row from the table: "fungible_asset_metadata" */
    delete_fungible_asset_metadata_by_pk?: Maybe<FungibleAssetMetadata>;
    /** delete data from the table: "fungible_asset_to_coin_mappings" */
    delete_fungible_asset_to_coin_mappings?: Maybe<FungibleAssetToCoinMappingsMutationResponse>;
    /** delete single row from the table: "fungible_asset_to_coin_mappings" */
    delete_fungible_asset_to_coin_mappings_by_pk?: Maybe<FungibleAssetToCoinMappings>;
    /** delete data from the table: "gas_fees" */
    delete_gas_fees?: Maybe<GasFeesMutationResponse>;
    /** delete single row from the table: "gas_fees" */
    delete_gas_fees_by_pk?: Maybe<GasFees>;
    /** delete data from the table: "indexer_status" */
    delete_indexer_status?: Maybe<IndexerStatusMutationResponse>;
    /** delete single row from the table: "indexer_status" */
    delete_indexer_status_by_pk?: Maybe<IndexerStatus>;
    /** delete data from the table: "move_modules" */
    delete_move_modules?: Maybe<MoveModulesMutationResponse>;
    /** delete single row from the table: "move_modules" */
    delete_move_modules_by_pk?: Maybe<MoveModules>;
    /** delete data from the table: "move_resources" */
    delete_move_resources?: Maybe<MoveResourcesMutationResponse>;
    /** delete single row from the table: "move_resources" */
    delete_move_resources_by_pk?: Maybe<MoveResources>;
    /** delete data from the table: "move_resources_view" */
    delete_move_resources_view?: Maybe<MoveResourcesViewMutationResponse>;
    /** delete data from the table: "nft_metadata_crawler.parsed_asset_uris" */
    delete_nft_metadata_crawler_parsed_asset_uris?: Maybe<NftMetadataCrawlerParsedAssetUrisMutationResponse>;
    /** delete single row from the table: "nft_metadata_crawler.parsed_asset_uris" */
    delete_nft_metadata_crawler_parsed_asset_uris_by_pk?: Maybe<NftMetadataCrawlerParsedAssetUris>;
    /** delete data from the table: "nft_points" */
    delete_nft_points?: Maybe<NftPointsMutationResponse>;
    /** delete single row from the table: "nft_points" */
    delete_nft_points_by_pk?: Maybe<NftPoints>;
    /** delete data from the table: "objects" */
    delete_objects?: Maybe<ObjectsMutationResponse>;
    /** delete single row from the table: "objects" */
    delete_objects_by_pk?: Maybe<Objects>;
    /** delete data from the table: "processor_metadata.processor_status" */
    delete_processor_metadata_processor_status?: Maybe<ProcessorMetadataProcessorStatusMutationResponse>;
    /** delete single row from the table: "processor_metadata.processor_status" */
    delete_processor_metadata_processor_status_by_pk?: Maybe<ProcessorMetadataProcessorStatus>;
    /** delete data from the table: "processor_status" */
    delete_processor_status?: Maybe<ProcessorStatusMutationResponse>;
    /** delete single row from the table: "processor_status" */
    delete_processor_status_by_pk?: Maybe<ProcessorStatus>;
    /** delete data from the table: "proposal_votes" */
    delete_proposal_votes?: Maybe<ProposalVotesMutationResponse>;
    /** delete single row from the table: "proposal_votes" */
    delete_proposal_votes_by_pk?: Maybe<ProposalVotes>;
    /** delete data from the table: "public_key_auth_keys" */
    delete_public_key_auth_keys?: Maybe<PublicKeyAuthKeysMutationResponse>;
    /** delete single row from the table: "public_key_auth_keys" */
    delete_public_key_auth_keys_by_pk?: Maybe<PublicKeyAuthKeys>;
    /** delete data from the table: "signatures" */
    delete_signatures?: Maybe<SignaturesMutationResponse>;
    /** delete single row from the table: "signatures" */
    delete_signatures_by_pk?: Maybe<Signatures>;
    /** delete data from the table: "spam_assets" */
    delete_spam_assets?: Maybe<SpamAssetsMutationResponse>;
    /** delete single row from the table: "spam_assets" */
    delete_spam_assets_by_pk?: Maybe<SpamAssets>;
    /** delete data from the table: "table_items" */
    delete_table_items?: Maybe<TableItemsMutationResponse>;
    /** delete single row from the table: "table_items" */
    delete_table_items_by_pk?: Maybe<TableItems>;
    /** delete data from the table: "table_items_view" */
    delete_table_items_view?: Maybe<TableItemsViewMutationResponse>;
    /** delete data from the table: "table_metadatas" */
    delete_table_metadatas?: Maybe<TableMetadatasMutationResponse>;
    /** delete single row from the table: "table_metadatas" */
    delete_table_metadatas_by_pk?: Maybe<TableMetadatas>;
    /** delete data from the table: "token_activities" */
    delete_token_activities?: Maybe<TokenActivitiesMutationResponse>;
    /** delete single row from the table: "token_activities" */
    delete_token_activities_by_pk?: Maybe<TokenActivities>;
    /** delete data from the table: "token_activities_v2" */
    delete_token_activities_v2?: Maybe<TokenActivitiesV2MutationResponse>;
    /** delete single row from the table: "token_activities_v2" */
    delete_token_activities_v2_by_pk?: Maybe<TokenActivitiesV2>;
    /** delete data from the table: "token_datas" */
    delete_token_datas?: Maybe<TokenDatasMutationResponse>;
    /** delete single row from the table: "token_datas" */
    delete_token_datas_by_pk?: Maybe<TokenDatas>;
    /** delete data from the table: "token_datas_v2" */
    delete_token_datas_v2?: Maybe<TokenDatasV2MutationResponse>;
    /** delete single row from the table: "token_datas_v2" */
    delete_token_datas_v2_by_pk?: Maybe<TokenDatasV2>;
    /** delete data from the table: "token_ownerships" */
    delete_token_ownerships?: Maybe<TokenOwnershipsMutationResponse>;
    /** delete single row from the table: "token_ownerships" */
    delete_token_ownerships_by_pk?: Maybe<TokenOwnerships>;
    /** delete data from the table: "token_ownerships_v2" */
    delete_token_ownerships_v2?: Maybe<TokenOwnershipsV2MutationResponse>;
    /** delete single row from the table: "token_ownerships_v2" */
    delete_token_ownerships_v2_by_pk?: Maybe<TokenOwnershipsV2>;
    /** delete data from the table: "tokens" */
    delete_tokens?: Maybe<TokensMutationResponse>;
    /** delete single row from the table: "tokens" */
    delete_tokens_by_pk?: Maybe<Tokens>;
    /** delete data from the table: "transaction_size_info" */
    delete_transaction_size_info?: Maybe<TransactionSizeInfoMutationResponse>;
    /** delete single row from the table: "transaction_size_info" */
    delete_transaction_size_info_by_pk?: Maybe<TransactionSizeInfo>;
    /** delete data from the table: "transactions_view" */
    delete_transactions_view?: Maybe<TransactionsViewMutationResponse>;
    /** delete data from the table: "user_transactions" */
    delete_user_transactions?: Maybe<UserTransactionsMutationResponse>;
    /** delete single row from the table: "user_transactions" */
    delete_user_transactions_by_pk?: Maybe<UserTransactions>;
    /** insert data into the table: "account_transactions" */
    insert_account_transactions?: Maybe<AccountTransactionsMutationResponse>;
    /** insert a single row into the table: "account_transactions" */
    insert_account_transactions_one?: Maybe<AccountTransactions>;
    /** insert data into the table: "ans_lookup" */
    insert_ans_lookup?: Maybe<AnsLookupMutationResponse>;
    /** insert a single row into the table: "ans_lookup" */
    insert_ans_lookup_one?: Maybe<AnsLookup>;
    /** insert data into the table: "ans_lookup_v2" */
    insert_ans_lookup_v2?: Maybe<AnsLookupV2MutationResponse>;
    /** insert a single row into the table: "ans_lookup_v2" */
    insert_ans_lookup_v2_one?: Maybe<AnsLookupV2>;
    /** insert data into the table: "ans_primary_name" */
    insert_ans_primary_name?: Maybe<AnsPrimaryNameMutationResponse>;
    /** insert a single row into the table: "ans_primary_name" */
    insert_ans_primary_name_one?: Maybe<AnsPrimaryName>;
    /** insert data into the table: "ans_primary_name_v2" */
    insert_ans_primary_name_v2?: Maybe<AnsPrimaryNameV2MutationResponse>;
    /** insert a single row into the table: "ans_primary_name_v2" */
    insert_ans_primary_name_v2_one?: Maybe<AnsPrimaryNameV2>;
    /** insert data into the table: "auth_key_account_addresses" */
    insert_auth_key_account_addresses?: Maybe<AuthKeyAccountAddressesMutationResponse>;
    /** insert a single row into the table: "auth_key_account_addresses" */
    insert_auth_key_account_addresses_one?: Maybe<AuthKeyAccountAddresses>;
    /** insert data into the table: "block_metadata_transactions" */
    insert_block_metadata_transactions?: Maybe<BlockMetadataTransactionsMutationResponse>;
    /** insert a single row into the table: "block_metadata_transactions" */
    insert_block_metadata_transactions_one?: Maybe<BlockMetadataTransactions>;
    /** insert data into the table: "coin_activities" */
    insert_coin_activities?: Maybe<CoinActivitiesMutationResponse>;
    /** insert a single row into the table: "coin_activities" */
    insert_coin_activities_one?: Maybe<CoinActivities>;
    /** insert data into the table: "coin_balances" */
    insert_coin_balances?: Maybe<CoinBalancesMutationResponse>;
    /** insert a single row into the table: "coin_balances" */
    insert_coin_balances_one?: Maybe<CoinBalances>;
    /** insert data into the table: "coin_infos" */
    insert_coin_infos?: Maybe<CoinInfosMutationResponse>;
    /** insert a single row into the table: "coin_infos" */
    insert_coin_infos_one?: Maybe<CoinInfos>;
    /** insert data into the table: "coin_supply" */
    insert_coin_supply?: Maybe<CoinSupplyMutationResponse>;
    /** insert a single row into the table: "coin_supply" */
    insert_coin_supply_one?: Maybe<CoinSupply>;
    /** insert data into the table: "collection_datas" */
    insert_collection_datas?: Maybe<CollectionDatasMutationResponse>;
    /** insert a single row into the table: "collection_datas" */
    insert_collection_datas_one?: Maybe<CollectionDatas>;
    /** insert data into the table: "collections_v2" */
    insert_collections_v2?: Maybe<CollectionsV2MutationResponse>;
    /** insert a single row into the table: "collections_v2" */
    insert_collections_v2_one?: Maybe<CollectionsV2>;
    /** insert data into the table: "current_ans_lookup" */
    insert_current_ans_lookup?: Maybe<CurrentAnsLookupMutationResponse>;
    /** insert a single row into the table: "current_ans_lookup" */
    insert_current_ans_lookup_one?: Maybe<CurrentAnsLookup>;
    /** insert data into the table: "current_ans_lookup_v2" */
    insert_current_ans_lookup_v2?: Maybe<CurrentAnsLookupV2MutationResponse>;
    /** insert a single row into the table: "current_ans_lookup_v2" */
    insert_current_ans_lookup_v2_one?: Maybe<CurrentAnsLookupV2>;
    /** insert data into the table: "current_ans_primary_name" */
    insert_current_ans_primary_name?: Maybe<CurrentAnsPrimaryNameMutationResponse>;
    /** insert a single row into the table: "current_ans_primary_name" */
    insert_current_ans_primary_name_one?: Maybe<CurrentAnsPrimaryName>;
    /** insert data into the table: "current_ans_primary_name_v2" */
    insert_current_ans_primary_name_v2?: Maybe<CurrentAnsPrimaryNameV2MutationResponse>;
    /** insert a single row into the table: "current_ans_primary_name_v2" */
    insert_current_ans_primary_name_v2_one?: Maybe<CurrentAnsPrimaryNameV2>;
    /** insert data into the table: "current_coin_balances" */
    insert_current_coin_balances?: Maybe<CurrentCoinBalancesMutationResponse>;
    /** insert a single row into the table: "current_coin_balances" */
    insert_current_coin_balances_one?: Maybe<CurrentCoinBalances>;
    /** insert data into the table: "current_collection_datas" */
    insert_current_collection_datas?: Maybe<CurrentCollectionDatasMutationResponse>;
    /** insert a single row into the table: "current_collection_datas" */
    insert_current_collection_datas_one?: Maybe<CurrentCollectionDatas>;
    /** insert data into the table: "current_collections_v2" */
    insert_current_collections_v2?: Maybe<CurrentCollectionsV2MutationResponse>;
    /** insert a single row into the table: "current_collections_v2" */
    insert_current_collections_v2_one?: Maybe<CurrentCollectionsV2>;
    /** insert data into the table: "current_delegated_staking_pool_balances" */
    insert_current_delegated_staking_pool_balances?: Maybe<CurrentDelegatedStakingPoolBalancesMutationResponse>;
    /** insert a single row into the table: "current_delegated_staking_pool_balances" */
    insert_current_delegated_staking_pool_balances_one?: Maybe<CurrentDelegatedStakingPoolBalances>;
    /** insert data into the table: "current_delegated_voter" */
    insert_current_delegated_voter?: Maybe<CurrentDelegatedVoterMutationResponse>;
    /** insert a single row into the table: "current_delegated_voter" */
    insert_current_delegated_voter_one?: Maybe<CurrentDelegatedVoter>;
    /** insert data into the table: "current_delegator_balances" */
    insert_current_delegator_balances?: Maybe<CurrentDelegatorBalancesMutationResponse>;
    /** insert a single row into the table: "current_delegator_balances" */
    insert_current_delegator_balances_one?: Maybe<CurrentDelegatorBalances>;
    /** insert data into the table: "current_fungible_asset_balances_legacy" */
    insert_current_fungible_asset_balances?: Maybe<CurrentFungibleAssetBalancesMutationResponse>;
    /** insert data into the table: "current_fungible_asset_balances" */
    insert_current_fungible_asset_balances_new?: Maybe<CurrentFungibleAssetBalancesNewMutationResponse>;
    /** insert a single row into the table: "current_fungible_asset_balances" */
    insert_current_fungible_asset_balances_new_one?: Maybe<CurrentFungibleAssetBalancesNew>;
    /** insert a single row into the table: "current_fungible_asset_balances_legacy" */
    insert_current_fungible_asset_balances_one?: Maybe<CurrentFungibleAssetBalances>;
    /** insert data into the table: "current_objects" */
    insert_current_objects?: Maybe<CurrentObjectsMutationResponse>;
    /** insert a single row into the table: "current_objects" */
    insert_current_objects_one?: Maybe<CurrentObjects>;
    /** insert data into the table: "current_staking_pool_voter" */
    insert_current_staking_pool_voter?: Maybe<CurrentStakingPoolVoterMutationResponse>;
    /** insert a single row into the table: "current_staking_pool_voter" */
    insert_current_staking_pool_voter_one?: Maybe<CurrentStakingPoolVoter>;
    /** insert data into the table: "current_table_items" */
    insert_current_table_items?: Maybe<CurrentTableItemsMutationResponse>;
    /** insert a single row into the table: "current_table_items" */
    insert_current_table_items_one?: Maybe<CurrentTableItems>;
    /** insert data into the table: "current_table_items_view" */
    insert_current_table_items_view?: Maybe<CurrentTableItemsViewMutationResponse>;
    /** insert a single row into the table: "current_table_items_view" */
    insert_current_table_items_view_one?: Maybe<CurrentTableItemsView>;
    /** insert data into the table: "current_token_datas" */
    insert_current_token_datas?: Maybe<CurrentTokenDatasMutationResponse>;
    /** insert a single row into the table: "current_token_datas" */
    insert_current_token_datas_one?: Maybe<CurrentTokenDatas>;
    /** insert data into the table: "current_token_datas_v2" */
    insert_current_token_datas_v2?: Maybe<CurrentTokenDatasV2MutationResponse>;
    /** insert a single row into the table: "current_token_datas_v2" */
    insert_current_token_datas_v2_one?: Maybe<CurrentTokenDatasV2>;
    /** insert data into the table: "current_token_ownerships" */
    insert_current_token_ownerships?: Maybe<CurrentTokenOwnershipsMutationResponse>;
    /** insert a single row into the table: "current_token_ownerships" */
    insert_current_token_ownerships_one?: Maybe<CurrentTokenOwnerships>;
    /** insert data into the table: "current_token_ownerships_v2" */
    insert_current_token_ownerships_v2?: Maybe<CurrentTokenOwnershipsV2MutationResponse>;
    /** insert a single row into the table: "current_token_ownerships_v2" */
    insert_current_token_ownerships_v2_one?: Maybe<CurrentTokenOwnershipsV2>;
    /** insert data into the table: "current_token_pending_claims" */
    insert_current_token_pending_claims?: Maybe<CurrentTokenPendingClaimsMutationResponse>;
    /** insert a single row into the table: "current_token_pending_claims" */
    insert_current_token_pending_claims_one?: Maybe<CurrentTokenPendingClaims>;
    /** insert data into the table: "current_token_royalty_v1" */
    insert_current_token_royalty_v1?: Maybe<CurrentTokenRoyaltyV1MutationResponse>;
    /** insert a single row into the table: "current_token_royalty_v1" */
    insert_current_token_royalty_v1_one?: Maybe<CurrentTokenRoyaltyV1>;
    /** insert data into the table: "current_token_v2_metadata" */
    insert_current_token_v2_metadata?: Maybe<CurrentTokenV2MetadataMutationResponse>;
    /** insert a single row into the table: "current_token_v2_metadata" */
    insert_current_token_v2_metadata_one?: Maybe<CurrentTokenV2Metadata>;
    /** insert data into the table: "delegated_staking_activities" */
    insert_delegated_staking_activities?: Maybe<DelegatedStakingActivitiesMutationResponse>;
    /** insert a single row into the table: "delegated_staking_activities" */
    insert_delegated_staking_activities_one?: Maybe<DelegatedStakingActivities>;
    /** insert data into the table: "delegated_staking_pool_balances" */
    insert_delegated_staking_pool_balances?: Maybe<DelegatedStakingPoolBalancesMutationResponse>;
    /** insert a single row into the table: "delegated_staking_pool_balances" */
    insert_delegated_staking_pool_balances_one?: Maybe<DelegatedStakingPoolBalances>;
    /** insert data into the table: "delegated_staking_pools" */
    insert_delegated_staking_pools?: Maybe<DelegatedStakingPoolsMutationResponse>;
    /** insert a single row into the table: "delegated_staking_pools" */
    insert_delegated_staking_pools_one?: Maybe<DelegatedStakingPools>;
    /** insert data into the table: "delegator_balances" */
    insert_delegator_balances?: Maybe<DelegatorBalancesMutationResponse>;
    /** insert a single row into the table: "delegator_balances" */
    insert_delegator_balances_one?: Maybe<DelegatorBalances>;
    /** insert data into the table: "event_size_info" */
    insert_event_size_info?: Maybe<EventSizeInfoMutationResponse>;
    /** insert a single row into the table: "event_size_info" */
    insert_event_size_info_one?: Maybe<EventSizeInfo>;
    /** insert data into the table: "events" */
    insert_events?: Maybe<EventsMutationResponse>;
    /** insert a single row into the table: "events" */
    insert_events_one?: Maybe<Events>;
    /** insert data into the table: "events_view" */
    insert_events_view?: Maybe<EventsViewMutationResponse>;
    /** insert a single row into the table: "events_view" */
    insert_events_view_one?: Maybe<EventsView>;
    /** insert data into the table: "fungible_asset_activities" */
    insert_fungible_asset_activities?: Maybe<FungibleAssetActivitiesMutationResponse>;
    /** insert a single row into the table: "fungible_asset_activities" */
    insert_fungible_asset_activities_one?: Maybe<FungibleAssetActivities>;
    /** insert data into the table: "fungible_asset_balances" */
    insert_fungible_asset_balances?: Maybe<FungibleAssetBalancesMutationResponse>;
    /** insert a single row into the table: "fungible_asset_balances" */
    insert_fungible_asset_balances_one?: Maybe<FungibleAssetBalances>;
    /** insert data into the table: "fungible_asset_metadata" */
    insert_fungible_asset_metadata?: Maybe<FungibleAssetMetadataMutationResponse>;
    /** insert a single row into the table: "fungible_asset_metadata" */
    insert_fungible_asset_metadata_one?: Maybe<FungibleAssetMetadata>;
    /** insert data into the table: "fungible_asset_to_coin_mappings" */
    insert_fungible_asset_to_coin_mappings?: Maybe<FungibleAssetToCoinMappingsMutationResponse>;
    /** insert a single row into the table: "fungible_asset_to_coin_mappings" */
    insert_fungible_asset_to_coin_mappings_one?: Maybe<FungibleAssetToCoinMappings>;
    /** insert data into the table: "gas_fees" */
    insert_gas_fees?: Maybe<GasFeesMutationResponse>;
    /** insert a single row into the table: "gas_fees" */
    insert_gas_fees_one?: Maybe<GasFees>;
    /** insert data into the table: "indexer_status" */
    insert_indexer_status?: Maybe<IndexerStatusMutationResponse>;
    /** insert a single row into the table: "indexer_status" */
    insert_indexer_status_one?: Maybe<IndexerStatus>;
    /** insert data into the table: "move_modules" */
    insert_move_modules?: Maybe<MoveModulesMutationResponse>;
    /** insert a single row into the table: "move_modules" */
    insert_move_modules_one?: Maybe<MoveModules>;
    /** insert data into the table: "move_resources" */
    insert_move_resources?: Maybe<MoveResourcesMutationResponse>;
    /** insert a single row into the table: "move_resources" */
    insert_move_resources_one?: Maybe<MoveResources>;
    /** insert data into the table: "move_resources_view" */
    insert_move_resources_view?: Maybe<MoveResourcesViewMutationResponse>;
    /** insert a single row into the table: "move_resources_view" */
    insert_move_resources_view_one?: Maybe<MoveResourcesView>;
    /** insert data into the table: "nft_metadata_crawler.parsed_asset_uris" */
    insert_nft_metadata_crawler_parsed_asset_uris?: Maybe<NftMetadataCrawlerParsedAssetUrisMutationResponse>;
    /** insert a single row into the table: "nft_metadata_crawler.parsed_asset_uris" */
    insert_nft_metadata_crawler_parsed_asset_uris_one?: Maybe<NftMetadataCrawlerParsedAssetUris>;
    /** insert data into the table: "nft_points" */
    insert_nft_points?: Maybe<NftPointsMutationResponse>;
    /** insert a single row into the table: "nft_points" */
    insert_nft_points_one?: Maybe<NftPoints>;
    /** insert data into the table: "objects" */
    insert_objects?: Maybe<ObjectsMutationResponse>;
    /** insert a single row into the table: "objects" */
    insert_objects_one?: Maybe<Objects>;
    /** insert data into the table: "processor_metadata.processor_status" */
    insert_processor_metadata_processor_status?: Maybe<ProcessorMetadataProcessorStatusMutationResponse>;
    /** insert a single row into the table: "processor_metadata.processor_status" */
    insert_processor_metadata_processor_status_one?: Maybe<ProcessorMetadataProcessorStatus>;
    /** insert data into the table: "processor_status" */
    insert_processor_status?: Maybe<ProcessorStatusMutationResponse>;
    /** insert a single row into the table: "processor_status" */
    insert_processor_status_one?: Maybe<ProcessorStatus>;
    /** insert data into the table: "proposal_votes" */
    insert_proposal_votes?: Maybe<ProposalVotesMutationResponse>;
    /** insert a single row into the table: "proposal_votes" */
    insert_proposal_votes_one?: Maybe<ProposalVotes>;
    /** insert data into the table: "public_key_auth_keys" */
    insert_public_key_auth_keys?: Maybe<PublicKeyAuthKeysMutationResponse>;
    /** insert a single row into the table: "public_key_auth_keys" */
    insert_public_key_auth_keys_one?: Maybe<PublicKeyAuthKeys>;
    /** insert data into the table: "signatures" */
    insert_signatures?: Maybe<SignaturesMutationResponse>;
    /** insert a single row into the table: "signatures" */
    insert_signatures_one?: Maybe<Signatures>;
    /** insert data into the table: "spam_assets" */
    insert_spam_assets?: Maybe<SpamAssetsMutationResponse>;
    /** insert a single row into the table: "spam_assets" */
    insert_spam_assets_one?: Maybe<SpamAssets>;
    /** insert data into the table: "table_items" */
    insert_table_items?: Maybe<TableItemsMutationResponse>;
    /** insert a single row into the table: "table_items" */
    insert_table_items_one?: Maybe<TableItems>;
    /** insert data into the table: "table_items_view" */
    insert_table_items_view?: Maybe<TableItemsViewMutationResponse>;
    /** insert a single row into the table: "table_items_view" */
    insert_table_items_view_one?: Maybe<TableItemsView>;
    /** insert data into the table: "table_metadatas" */
    insert_table_metadatas?: Maybe<TableMetadatasMutationResponse>;
    /** insert a single row into the table: "table_metadatas" */
    insert_table_metadatas_one?: Maybe<TableMetadatas>;
    /** insert data into the table: "token_activities" */
    insert_token_activities?: Maybe<TokenActivitiesMutationResponse>;
    /** insert a single row into the table: "token_activities" */
    insert_token_activities_one?: Maybe<TokenActivities>;
    /** insert data into the table: "token_activities_v2" */
    insert_token_activities_v2?: Maybe<TokenActivitiesV2MutationResponse>;
    /** insert a single row into the table: "token_activities_v2" */
    insert_token_activities_v2_one?: Maybe<TokenActivitiesV2>;
    /** insert data into the table: "token_datas" */
    insert_token_datas?: Maybe<TokenDatasMutationResponse>;
    /** insert a single row into the table: "token_datas" */
    insert_token_datas_one?: Maybe<TokenDatas>;
    /** insert data into the table: "token_datas_v2" */
    insert_token_datas_v2?: Maybe<TokenDatasV2MutationResponse>;
    /** insert a single row into the table: "token_datas_v2" */
    insert_token_datas_v2_one?: Maybe<TokenDatasV2>;
    /** insert data into the table: "token_ownerships" */
    insert_token_ownerships?: Maybe<TokenOwnershipsMutationResponse>;
    /** insert a single row into the table: "token_ownerships" */
    insert_token_ownerships_one?: Maybe<TokenOwnerships>;
    /** insert data into the table: "token_ownerships_v2" */
    insert_token_ownerships_v2?: Maybe<TokenOwnershipsV2MutationResponse>;
    /** insert a single row into the table: "token_ownerships_v2" */
    insert_token_ownerships_v2_one?: Maybe<TokenOwnershipsV2>;
    /** insert data into the table: "tokens" */
    insert_tokens?: Maybe<TokensMutationResponse>;
    /** insert a single row into the table: "tokens" */
    insert_tokens_one?: Maybe<Tokens>;
    /** insert data into the table: "transaction_size_info" */
    insert_transaction_size_info?: Maybe<TransactionSizeInfoMutationResponse>;
    /** insert a single row into the table: "transaction_size_info" */
    insert_transaction_size_info_one?: Maybe<TransactionSizeInfo>;
    /** insert data into the table: "transactions_view" */
    insert_transactions_view?: Maybe<TransactionsViewMutationResponse>;
    /** insert a single row into the table: "transactions_view" */
    insert_transactions_view_one?: Maybe<TransactionsView>;
    /** insert data into the table: "user_transactions" */
    insert_user_transactions?: Maybe<UserTransactionsMutationResponse>;
    /** insert a single row into the table: "user_transactions" */
    insert_user_transactions_one?: Maybe<UserTransactions>;
    /** update data of the table: "account_transactions" */
    update_account_transactions?: Maybe<AccountTransactionsMutationResponse>;
    /** update single row of the table: "account_transactions" */
    update_account_transactions_by_pk?: Maybe<AccountTransactions>;
    /** update multiples rows of table: "account_transactions" */
    update_account_transactions_many?: Maybe<Array<Maybe<AccountTransactionsMutationResponse>>>;
    /** update data of the table: "ans_lookup" */
    update_ans_lookup?: Maybe<AnsLookupMutationResponse>;
    /** update single row of the table: "ans_lookup" */
    update_ans_lookup_by_pk?: Maybe<AnsLookup>;
    /** update multiples rows of table: "ans_lookup" */
    update_ans_lookup_many?: Maybe<Array<Maybe<AnsLookupMutationResponse>>>;
    /** update data of the table: "ans_lookup_v2" */
    update_ans_lookup_v2?: Maybe<AnsLookupV2MutationResponse>;
    /** update single row of the table: "ans_lookup_v2" */
    update_ans_lookup_v2_by_pk?: Maybe<AnsLookupV2>;
    /** update multiples rows of table: "ans_lookup_v2" */
    update_ans_lookup_v2_many?: Maybe<Array<Maybe<AnsLookupV2MutationResponse>>>;
    /** update data of the table: "ans_primary_name" */
    update_ans_primary_name?: Maybe<AnsPrimaryNameMutationResponse>;
    /** update single row of the table: "ans_primary_name" */
    update_ans_primary_name_by_pk?: Maybe<AnsPrimaryName>;
    /** update multiples rows of table: "ans_primary_name" */
    update_ans_primary_name_many?: Maybe<Array<Maybe<AnsPrimaryNameMutationResponse>>>;
    /** update data of the table: "ans_primary_name_v2" */
    update_ans_primary_name_v2?: Maybe<AnsPrimaryNameV2MutationResponse>;
    /** update single row of the table: "ans_primary_name_v2" */
    update_ans_primary_name_v2_by_pk?: Maybe<AnsPrimaryNameV2>;
    /** update multiples rows of table: "ans_primary_name_v2" */
    update_ans_primary_name_v2_many?: Maybe<Array<Maybe<AnsPrimaryNameV2MutationResponse>>>;
    /** update data of the table: "auth_key_account_addresses" */
    update_auth_key_account_addresses?: Maybe<AuthKeyAccountAddressesMutationResponse>;
    /** update single row of the table: "auth_key_account_addresses" */
    update_auth_key_account_addresses_by_pk?: Maybe<AuthKeyAccountAddresses>;
    /** update multiples rows of table: "auth_key_account_addresses" */
    update_auth_key_account_addresses_many?: Maybe<Array<Maybe<AuthKeyAccountAddressesMutationResponse>>>;
    /** update data of the table: "block_metadata_transactions" */
    update_block_metadata_transactions?: Maybe<BlockMetadataTransactionsMutationResponse>;
    /** update single row of the table: "block_metadata_transactions" */
    update_block_metadata_transactions_by_pk?: Maybe<BlockMetadataTransactions>;
    /** update multiples rows of table: "block_metadata_transactions" */
    update_block_metadata_transactions_many?: Maybe<Array<Maybe<BlockMetadataTransactionsMutationResponse>>>;
    /** update data of the table: "coin_activities" */
    update_coin_activities?: Maybe<CoinActivitiesMutationResponse>;
    /** update single row of the table: "coin_activities" */
    update_coin_activities_by_pk?: Maybe<CoinActivities>;
    /** update multiples rows of table: "coin_activities" */
    update_coin_activities_many?: Maybe<Array<Maybe<CoinActivitiesMutationResponse>>>;
    /** update data of the table: "coin_balances" */
    update_coin_balances?: Maybe<CoinBalancesMutationResponse>;
    /** update single row of the table: "coin_balances" */
    update_coin_balances_by_pk?: Maybe<CoinBalances>;
    /** update multiples rows of table: "coin_balances" */
    update_coin_balances_many?: Maybe<Array<Maybe<CoinBalancesMutationResponse>>>;
    /** update data of the table: "coin_infos" */
    update_coin_infos?: Maybe<CoinInfosMutationResponse>;
    /** update single row of the table: "coin_infos" */
    update_coin_infos_by_pk?: Maybe<CoinInfos>;
    /** update multiples rows of table: "coin_infos" */
    update_coin_infos_many?: Maybe<Array<Maybe<CoinInfosMutationResponse>>>;
    /** update data of the table: "coin_supply" */
    update_coin_supply?: Maybe<CoinSupplyMutationResponse>;
    /** update single row of the table: "coin_supply" */
    update_coin_supply_by_pk?: Maybe<CoinSupply>;
    /** update multiples rows of table: "coin_supply" */
    update_coin_supply_many?: Maybe<Array<Maybe<CoinSupplyMutationResponse>>>;
    /** update data of the table: "collection_datas" */
    update_collection_datas?: Maybe<CollectionDatasMutationResponse>;
    /** update single row of the table: "collection_datas" */
    update_collection_datas_by_pk?: Maybe<CollectionDatas>;
    /** update multiples rows of table: "collection_datas" */
    update_collection_datas_many?: Maybe<Array<Maybe<CollectionDatasMutationResponse>>>;
    /** update data of the table: "collections_v2" */
    update_collections_v2?: Maybe<CollectionsV2MutationResponse>;
    /** update single row of the table: "collections_v2" */
    update_collections_v2_by_pk?: Maybe<CollectionsV2>;
    /** update multiples rows of table: "collections_v2" */
    update_collections_v2_many?: Maybe<Array<Maybe<CollectionsV2MutationResponse>>>;
    /** update data of the table: "current_ans_lookup" */
    update_current_ans_lookup?: Maybe<CurrentAnsLookupMutationResponse>;
    /** update single row of the table: "current_ans_lookup" */
    update_current_ans_lookup_by_pk?: Maybe<CurrentAnsLookup>;
    /** update multiples rows of table: "current_ans_lookup" */
    update_current_ans_lookup_many?: Maybe<Array<Maybe<CurrentAnsLookupMutationResponse>>>;
    /** update data of the table: "current_ans_lookup_v2" */
    update_current_ans_lookup_v2?: Maybe<CurrentAnsLookupV2MutationResponse>;
    /** update single row of the table: "current_ans_lookup_v2" */
    update_current_ans_lookup_v2_by_pk?: Maybe<CurrentAnsLookupV2>;
    /** update multiples rows of table: "current_ans_lookup_v2" */
    update_current_ans_lookup_v2_many?: Maybe<Array<Maybe<CurrentAnsLookupV2MutationResponse>>>;
    /** update data of the table: "current_ans_primary_name" */
    update_current_ans_primary_name?: Maybe<CurrentAnsPrimaryNameMutationResponse>;
    /** update single row of the table: "current_ans_primary_name" */
    update_current_ans_primary_name_by_pk?: Maybe<CurrentAnsPrimaryName>;
    /** update multiples rows of table: "current_ans_primary_name" */
    update_current_ans_primary_name_many?: Maybe<Array<Maybe<CurrentAnsPrimaryNameMutationResponse>>>;
    /** update data of the table: "current_ans_primary_name_v2" */
    update_current_ans_primary_name_v2?: Maybe<CurrentAnsPrimaryNameV2MutationResponse>;
    /** update single row of the table: "current_ans_primary_name_v2" */
    update_current_ans_primary_name_v2_by_pk?: Maybe<CurrentAnsPrimaryNameV2>;
    /** update multiples rows of table: "current_ans_primary_name_v2" */
    update_current_ans_primary_name_v2_many?: Maybe<Array<Maybe<CurrentAnsPrimaryNameV2MutationResponse>>>;
    /** update data of the table: "current_coin_balances" */
    update_current_coin_balances?: Maybe<CurrentCoinBalancesMutationResponse>;
    /** update single row of the table: "current_coin_balances" */
    update_current_coin_balances_by_pk?: Maybe<CurrentCoinBalances>;
    /** update multiples rows of table: "current_coin_balances" */
    update_current_coin_balances_many?: Maybe<Array<Maybe<CurrentCoinBalancesMutationResponse>>>;
    /** update data of the table: "current_collection_datas" */
    update_current_collection_datas?: Maybe<CurrentCollectionDatasMutationResponse>;
    /** update single row of the table: "current_collection_datas" */
    update_current_collection_datas_by_pk?: Maybe<CurrentCollectionDatas>;
    /** update multiples rows of table: "current_collection_datas" */
    update_current_collection_datas_many?: Maybe<Array<Maybe<CurrentCollectionDatasMutationResponse>>>;
    /** update data of the table: "current_collections_v2" */
    update_current_collections_v2?: Maybe<CurrentCollectionsV2MutationResponse>;
    /** update single row of the table: "current_collections_v2" */
    update_current_collections_v2_by_pk?: Maybe<CurrentCollectionsV2>;
    /** update multiples rows of table: "current_collections_v2" */
    update_current_collections_v2_many?: Maybe<Array<Maybe<CurrentCollectionsV2MutationResponse>>>;
    /** update data of the table: "current_delegated_staking_pool_balances" */
    update_current_delegated_staking_pool_balances?: Maybe<CurrentDelegatedStakingPoolBalancesMutationResponse>;
    /** update single row of the table: "current_delegated_staking_pool_balances" */
    update_current_delegated_staking_pool_balances_by_pk?: Maybe<CurrentDelegatedStakingPoolBalances>;
    /** update multiples rows of table: "current_delegated_staking_pool_balances" */
    update_current_delegated_staking_pool_balances_many?: Maybe<Array<Maybe<CurrentDelegatedStakingPoolBalancesMutationResponse>>>;
    /** update data of the table: "current_delegated_voter" */
    update_current_delegated_voter?: Maybe<CurrentDelegatedVoterMutationResponse>;
    /** update single row of the table: "current_delegated_voter" */
    update_current_delegated_voter_by_pk?: Maybe<CurrentDelegatedVoter>;
    /** update multiples rows of table: "current_delegated_voter" */
    update_current_delegated_voter_many?: Maybe<Array<Maybe<CurrentDelegatedVoterMutationResponse>>>;
    /** update data of the table: "current_delegator_balances" */
    update_current_delegator_balances?: Maybe<CurrentDelegatorBalancesMutationResponse>;
    /** update single row of the table: "current_delegator_balances" */
    update_current_delegator_balances_by_pk?: Maybe<CurrentDelegatorBalances>;
    /** update multiples rows of table: "current_delegator_balances" */
    update_current_delegator_balances_many?: Maybe<Array<Maybe<CurrentDelegatorBalancesMutationResponse>>>;
    /** update data of the table: "current_fungible_asset_balances_legacy" */
    update_current_fungible_asset_balances?: Maybe<CurrentFungibleAssetBalancesMutationResponse>;
    /** update single row of the table: "current_fungible_asset_balances_legacy" */
    update_current_fungible_asset_balances_by_pk?: Maybe<CurrentFungibleAssetBalances>;
    /** update multiples rows of table: "current_fungible_asset_balances_legacy" */
    update_current_fungible_asset_balances_many?: Maybe<Array<Maybe<CurrentFungibleAssetBalancesMutationResponse>>>;
    /** update data of the table: "current_fungible_asset_balances" */
    update_current_fungible_asset_balances_new?: Maybe<CurrentFungibleAssetBalancesNewMutationResponse>;
    /** update single row of the table: "current_fungible_asset_balances" */
    update_current_fungible_asset_balances_new_by_pk?: Maybe<CurrentFungibleAssetBalancesNew>;
    /** update multiples rows of table: "current_fungible_asset_balances" */
    update_current_fungible_asset_balances_new_many?: Maybe<Array<Maybe<CurrentFungibleAssetBalancesNewMutationResponse>>>;
    /** update data of the table: "current_objects" */
    update_current_objects?: Maybe<CurrentObjectsMutationResponse>;
    /** update single row of the table: "current_objects" */
    update_current_objects_by_pk?: Maybe<CurrentObjects>;
    /** update multiples rows of table: "current_objects" */
    update_current_objects_many?: Maybe<Array<Maybe<CurrentObjectsMutationResponse>>>;
    /** update data of the table: "current_staking_pool_voter" */
    update_current_staking_pool_voter?: Maybe<CurrentStakingPoolVoterMutationResponse>;
    /** update single row of the table: "current_staking_pool_voter" */
    update_current_staking_pool_voter_by_pk?: Maybe<CurrentStakingPoolVoter>;
    /** update multiples rows of table: "current_staking_pool_voter" */
    update_current_staking_pool_voter_many?: Maybe<Array<Maybe<CurrentStakingPoolVoterMutationResponse>>>;
    /** update data of the table: "current_table_items" */
    update_current_table_items?: Maybe<CurrentTableItemsMutationResponse>;
    /** update single row of the table: "current_table_items" */
    update_current_table_items_by_pk?: Maybe<CurrentTableItems>;
    /** update multiples rows of table: "current_table_items" */
    update_current_table_items_many?: Maybe<Array<Maybe<CurrentTableItemsMutationResponse>>>;
    /** update data of the table: "current_table_items_view" */
    update_current_table_items_view?: Maybe<CurrentTableItemsViewMutationResponse>;
    /** update multiples rows of table: "current_table_items_view" */
    update_current_table_items_view_many?: Maybe<Array<Maybe<CurrentTableItemsViewMutationResponse>>>;
    /** update data of the table: "current_token_datas" */
    update_current_token_datas?: Maybe<CurrentTokenDatasMutationResponse>;
    /** update single row of the table: "current_token_datas" */
    update_current_token_datas_by_pk?: Maybe<CurrentTokenDatas>;
    /** update multiples rows of table: "current_token_datas" */
    update_current_token_datas_many?: Maybe<Array<Maybe<CurrentTokenDatasMutationResponse>>>;
    /** update data of the table: "current_token_datas_v2" */
    update_current_token_datas_v2?: Maybe<CurrentTokenDatasV2MutationResponse>;
    /** update single row of the table: "current_token_datas_v2" */
    update_current_token_datas_v2_by_pk?: Maybe<CurrentTokenDatasV2>;
    /** update multiples rows of table: "current_token_datas_v2" */
    update_current_token_datas_v2_many?: Maybe<Array<Maybe<CurrentTokenDatasV2MutationResponse>>>;
    /** update data of the table: "current_token_ownerships" */
    update_current_token_ownerships?: Maybe<CurrentTokenOwnershipsMutationResponse>;
    /** update single row of the table: "current_token_ownerships" */
    update_current_token_ownerships_by_pk?: Maybe<CurrentTokenOwnerships>;
    /** update multiples rows of table: "current_token_ownerships" */
    update_current_token_ownerships_many?: Maybe<Array<Maybe<CurrentTokenOwnershipsMutationResponse>>>;
    /** update data of the table: "current_token_ownerships_v2" */
    update_current_token_ownerships_v2?: Maybe<CurrentTokenOwnershipsV2MutationResponse>;
    /** update single row of the table: "current_token_ownerships_v2" */
    update_current_token_ownerships_v2_by_pk?: Maybe<CurrentTokenOwnershipsV2>;
    /** update multiples rows of table: "current_token_ownerships_v2" */
    update_current_token_ownerships_v2_many?: Maybe<Array<Maybe<CurrentTokenOwnershipsV2MutationResponse>>>;
    /** update data of the table: "current_token_pending_claims" */
    update_current_token_pending_claims?: Maybe<CurrentTokenPendingClaimsMutationResponse>;
    /** update single row of the table: "current_token_pending_claims" */
    update_current_token_pending_claims_by_pk?: Maybe<CurrentTokenPendingClaims>;
    /** update multiples rows of table: "current_token_pending_claims" */
    update_current_token_pending_claims_many?: Maybe<Array<Maybe<CurrentTokenPendingClaimsMutationResponse>>>;
    /** update data of the table: "current_token_royalty_v1" */
    update_current_token_royalty_v1?: Maybe<CurrentTokenRoyaltyV1MutationResponse>;
    /** update single row of the table: "current_token_royalty_v1" */
    update_current_token_royalty_v1_by_pk?: Maybe<CurrentTokenRoyaltyV1>;
    /** update multiples rows of table: "current_token_royalty_v1" */
    update_current_token_royalty_v1_many?: Maybe<Array<Maybe<CurrentTokenRoyaltyV1MutationResponse>>>;
    /** update data of the table: "current_token_v2_metadata" */
    update_current_token_v2_metadata?: Maybe<CurrentTokenV2MetadataMutationResponse>;
    /** update single row of the table: "current_token_v2_metadata" */
    update_current_token_v2_metadata_by_pk?: Maybe<CurrentTokenV2Metadata>;
    /** update multiples rows of table: "current_token_v2_metadata" */
    update_current_token_v2_metadata_many?: Maybe<Array<Maybe<CurrentTokenV2MetadataMutationResponse>>>;
    /** update data of the table: "delegated_staking_activities" */
    update_delegated_staking_activities?: Maybe<DelegatedStakingActivitiesMutationResponse>;
    /** update single row of the table: "delegated_staking_activities" */
    update_delegated_staking_activities_by_pk?: Maybe<DelegatedStakingActivities>;
    /** update multiples rows of table: "delegated_staking_activities" */
    update_delegated_staking_activities_many?: Maybe<Array<Maybe<DelegatedStakingActivitiesMutationResponse>>>;
    /** update data of the table: "delegated_staking_pool_balances" */
    update_delegated_staking_pool_balances?: Maybe<DelegatedStakingPoolBalancesMutationResponse>;
    /** update single row of the table: "delegated_staking_pool_balances" */
    update_delegated_staking_pool_balances_by_pk?: Maybe<DelegatedStakingPoolBalances>;
    /** update multiples rows of table: "delegated_staking_pool_balances" */
    update_delegated_staking_pool_balances_many?: Maybe<Array<Maybe<DelegatedStakingPoolBalancesMutationResponse>>>;
    /** update data of the table: "delegated_staking_pools" */
    update_delegated_staking_pools?: Maybe<DelegatedStakingPoolsMutationResponse>;
    /** update single row of the table: "delegated_staking_pools" */
    update_delegated_staking_pools_by_pk?: Maybe<DelegatedStakingPools>;
    /** update multiples rows of table: "delegated_staking_pools" */
    update_delegated_staking_pools_many?: Maybe<Array<Maybe<DelegatedStakingPoolsMutationResponse>>>;
    /** update data of the table: "delegator_balances" */
    update_delegator_balances?: Maybe<DelegatorBalancesMutationResponse>;
    /** update single row of the table: "delegator_balances" */
    update_delegator_balances_by_pk?: Maybe<DelegatorBalances>;
    /** update multiples rows of table: "delegator_balances" */
    update_delegator_balances_many?: Maybe<Array<Maybe<DelegatorBalancesMutationResponse>>>;
    /** update data of the table: "event_size_info" */
    update_event_size_info?: Maybe<EventSizeInfoMutationResponse>;
    /** update single row of the table: "event_size_info" */
    update_event_size_info_by_pk?: Maybe<EventSizeInfo>;
    /** update multiples rows of table: "event_size_info" */
    update_event_size_info_many?: Maybe<Array<Maybe<EventSizeInfoMutationResponse>>>;
    /** update data of the table: "events" */
    update_events?: Maybe<EventsMutationResponse>;
    /** update single row of the table: "events" */
    update_events_by_pk?: Maybe<Events>;
    /** update multiples rows of table: "events" */
    update_events_many?: Maybe<Array<Maybe<EventsMutationResponse>>>;
    /** update data of the table: "events_view" */
    update_events_view?: Maybe<EventsViewMutationResponse>;
    /** update multiples rows of table: "events_view" */
    update_events_view_many?: Maybe<Array<Maybe<EventsViewMutationResponse>>>;
    /** update data of the table: "fungible_asset_activities" */
    update_fungible_asset_activities?: Maybe<FungibleAssetActivitiesMutationResponse>;
    /** update single row of the table: "fungible_asset_activities" */
    update_fungible_asset_activities_by_pk?: Maybe<FungibleAssetActivities>;
    /** update multiples rows of table: "fungible_asset_activities" */
    update_fungible_asset_activities_many?: Maybe<Array<Maybe<FungibleAssetActivitiesMutationResponse>>>;
    /** update data of the table: "fungible_asset_balances" */
    update_fungible_asset_balances?: Maybe<FungibleAssetBalancesMutationResponse>;
    /** update single row of the table: "fungible_asset_balances" */
    update_fungible_asset_balances_by_pk?: Maybe<FungibleAssetBalances>;
    /** update multiples rows of table: "fungible_asset_balances" */
    update_fungible_asset_balances_many?: Maybe<Array<Maybe<FungibleAssetBalancesMutationResponse>>>;
    /** update data of the table: "fungible_asset_metadata" */
    update_fungible_asset_metadata?: Maybe<FungibleAssetMetadataMutationResponse>;
    /** update single row of the table: "fungible_asset_metadata" */
    update_fungible_asset_metadata_by_pk?: Maybe<FungibleAssetMetadata>;
    /** update multiples rows of table: "fungible_asset_metadata" */
    update_fungible_asset_metadata_many?: Maybe<Array<Maybe<FungibleAssetMetadataMutationResponse>>>;
    /** update data of the table: "fungible_asset_to_coin_mappings" */
    update_fungible_asset_to_coin_mappings?: Maybe<FungibleAssetToCoinMappingsMutationResponse>;
    /** update single row of the table: "fungible_asset_to_coin_mappings" */
    update_fungible_asset_to_coin_mappings_by_pk?: Maybe<FungibleAssetToCoinMappings>;
    /** update multiples rows of table: "fungible_asset_to_coin_mappings" */
    update_fungible_asset_to_coin_mappings_many?: Maybe<Array<Maybe<FungibleAssetToCoinMappingsMutationResponse>>>;
    /** update data of the table: "gas_fees" */
    update_gas_fees?: Maybe<GasFeesMutationResponse>;
    /** update single row of the table: "gas_fees" */
    update_gas_fees_by_pk?: Maybe<GasFees>;
    /** update multiples rows of table: "gas_fees" */
    update_gas_fees_many?: Maybe<Array<Maybe<GasFeesMutationResponse>>>;
    /** update data of the table: "indexer_status" */
    update_indexer_status?: Maybe<IndexerStatusMutationResponse>;
    /** update single row of the table: "indexer_status" */
    update_indexer_status_by_pk?: Maybe<IndexerStatus>;
    /** update multiples rows of table: "indexer_status" */
    update_indexer_status_many?: Maybe<Array<Maybe<IndexerStatusMutationResponse>>>;
    /** update data of the table: "move_modules" */
    update_move_modules?: Maybe<MoveModulesMutationResponse>;
    /** update single row of the table: "move_modules" */
    update_move_modules_by_pk?: Maybe<MoveModules>;
    /** update multiples rows of table: "move_modules" */
    update_move_modules_many?: Maybe<Array<Maybe<MoveModulesMutationResponse>>>;
    /** update data of the table: "move_resources" */
    update_move_resources?: Maybe<MoveResourcesMutationResponse>;
    /** update single row of the table: "move_resources" */
    update_move_resources_by_pk?: Maybe<MoveResources>;
    /** update multiples rows of table: "move_resources" */
    update_move_resources_many?: Maybe<Array<Maybe<MoveResourcesMutationResponse>>>;
    /** update data of the table: "move_resources_view" */
    update_move_resources_view?: Maybe<MoveResourcesViewMutationResponse>;
    /** update multiples rows of table: "move_resources_view" */
    update_move_resources_view_many?: Maybe<Array<Maybe<MoveResourcesViewMutationResponse>>>;
    /** update data of the table: "nft_metadata_crawler.parsed_asset_uris" */
    update_nft_metadata_crawler_parsed_asset_uris?: Maybe<NftMetadataCrawlerParsedAssetUrisMutationResponse>;
    /** update single row of the table: "nft_metadata_crawler.parsed_asset_uris" */
    update_nft_metadata_crawler_parsed_asset_uris_by_pk?: Maybe<NftMetadataCrawlerParsedAssetUris>;
    /** update multiples rows of table: "nft_metadata_crawler.parsed_asset_uris" */
    update_nft_metadata_crawler_parsed_asset_uris_many?: Maybe<Array<Maybe<NftMetadataCrawlerParsedAssetUrisMutationResponse>>>;
    /** update data of the table: "nft_points" */
    update_nft_points?: Maybe<NftPointsMutationResponse>;
    /** update single row of the table: "nft_points" */
    update_nft_points_by_pk?: Maybe<NftPoints>;
    /** update multiples rows of table: "nft_points" */
    update_nft_points_many?: Maybe<Array<Maybe<NftPointsMutationResponse>>>;
    /** update data of the table: "objects" */
    update_objects?: Maybe<ObjectsMutationResponse>;
    /** update single row of the table: "objects" */
    update_objects_by_pk?: Maybe<Objects>;
    /** update multiples rows of table: "objects" */
    update_objects_many?: Maybe<Array<Maybe<ObjectsMutationResponse>>>;
    /** update data of the table: "processor_metadata.processor_status" */
    update_processor_metadata_processor_status?: Maybe<ProcessorMetadataProcessorStatusMutationResponse>;
    /** update single row of the table: "processor_metadata.processor_status" */
    update_processor_metadata_processor_status_by_pk?: Maybe<ProcessorMetadataProcessorStatus>;
    /** update multiples rows of table: "processor_metadata.processor_status" */
    update_processor_metadata_processor_status_many?: Maybe<Array<Maybe<ProcessorMetadataProcessorStatusMutationResponse>>>;
    /** update data of the table: "processor_status" */
    update_processor_status?: Maybe<ProcessorStatusMutationResponse>;
    /** update single row of the table: "processor_status" */
    update_processor_status_by_pk?: Maybe<ProcessorStatus>;
    /** update multiples rows of table: "processor_status" */
    update_processor_status_many?: Maybe<Array<Maybe<ProcessorStatusMutationResponse>>>;
    /** update data of the table: "proposal_votes" */
    update_proposal_votes?: Maybe<ProposalVotesMutationResponse>;
    /** update single row of the table: "proposal_votes" */
    update_proposal_votes_by_pk?: Maybe<ProposalVotes>;
    /** update multiples rows of table: "proposal_votes" */
    update_proposal_votes_many?: Maybe<Array<Maybe<ProposalVotesMutationResponse>>>;
    /** update data of the table: "public_key_auth_keys" */
    update_public_key_auth_keys?: Maybe<PublicKeyAuthKeysMutationResponse>;
    /** update single row of the table: "public_key_auth_keys" */
    update_public_key_auth_keys_by_pk?: Maybe<PublicKeyAuthKeys>;
    /** update multiples rows of table: "public_key_auth_keys" */
    update_public_key_auth_keys_many?: Maybe<Array<Maybe<PublicKeyAuthKeysMutationResponse>>>;
    /** update data of the table: "signatures" */
    update_signatures?: Maybe<SignaturesMutationResponse>;
    /** update single row of the table: "signatures" */
    update_signatures_by_pk?: Maybe<Signatures>;
    /** update multiples rows of table: "signatures" */
    update_signatures_many?: Maybe<Array<Maybe<SignaturesMutationResponse>>>;
    /** update data of the table: "spam_assets" */
    update_spam_assets?: Maybe<SpamAssetsMutationResponse>;
    /** update single row of the table: "spam_assets" */
    update_spam_assets_by_pk?: Maybe<SpamAssets>;
    /** update multiples rows of table: "spam_assets" */
    update_spam_assets_many?: Maybe<Array<Maybe<SpamAssetsMutationResponse>>>;
    /** update data of the table: "table_items" */
    update_table_items?: Maybe<TableItemsMutationResponse>;
    /** update single row of the table: "table_items" */
    update_table_items_by_pk?: Maybe<TableItems>;
    /** update multiples rows of table: "table_items" */
    update_table_items_many?: Maybe<Array<Maybe<TableItemsMutationResponse>>>;
    /** update data of the table: "table_items_view" */
    update_table_items_view?: Maybe<TableItemsViewMutationResponse>;
    /** update multiples rows of table: "table_items_view" */
    update_table_items_view_many?: Maybe<Array<Maybe<TableItemsViewMutationResponse>>>;
    /** update data of the table: "table_metadatas" */
    update_table_metadatas?: Maybe<TableMetadatasMutationResponse>;
    /** update single row of the table: "table_metadatas" */
    update_table_metadatas_by_pk?: Maybe<TableMetadatas>;
    /** update multiples rows of table: "table_metadatas" */
    update_table_metadatas_many?: Maybe<Array<Maybe<TableMetadatasMutationResponse>>>;
    /** update data of the table: "token_activities" */
    update_token_activities?: Maybe<TokenActivitiesMutationResponse>;
    /** update single row of the table: "token_activities" */
    update_token_activities_by_pk?: Maybe<TokenActivities>;
    /** update multiples rows of table: "token_activities" */
    update_token_activities_many?: Maybe<Array<Maybe<TokenActivitiesMutationResponse>>>;
    /** update data of the table: "token_activities_v2" */
    update_token_activities_v2?: Maybe<TokenActivitiesV2MutationResponse>;
    /** update single row of the table: "token_activities_v2" */
    update_token_activities_v2_by_pk?: Maybe<TokenActivitiesV2>;
    /** update multiples rows of table: "token_activities_v2" */
    update_token_activities_v2_many?: Maybe<Array<Maybe<TokenActivitiesV2MutationResponse>>>;
    /** update data of the table: "token_datas" */
    update_token_datas?: Maybe<TokenDatasMutationResponse>;
    /** update single row of the table: "token_datas" */
    update_token_datas_by_pk?: Maybe<TokenDatas>;
    /** update multiples rows of table: "token_datas" */
    update_token_datas_many?: Maybe<Array<Maybe<TokenDatasMutationResponse>>>;
    /** update data of the table: "token_datas_v2" */
    update_token_datas_v2?: Maybe<TokenDatasV2MutationResponse>;
    /** update single row of the table: "token_datas_v2" */
    update_token_datas_v2_by_pk?: Maybe<TokenDatasV2>;
    /** update multiples rows of table: "token_datas_v2" */
    update_token_datas_v2_many?: Maybe<Array<Maybe<TokenDatasV2MutationResponse>>>;
    /** update data of the table: "token_ownerships" */
    update_token_ownerships?: Maybe<TokenOwnershipsMutationResponse>;
    /** update single row of the table: "token_ownerships" */
    update_token_ownerships_by_pk?: Maybe<TokenOwnerships>;
    /** update multiples rows of table: "token_ownerships" */
    update_token_ownerships_many?: Maybe<Array<Maybe<TokenOwnershipsMutationResponse>>>;
    /** update data of the table: "token_ownerships_v2" */
    update_token_ownerships_v2?: Maybe<TokenOwnershipsV2MutationResponse>;
    /** update single row of the table: "token_ownerships_v2" */
    update_token_ownerships_v2_by_pk?: Maybe<TokenOwnershipsV2>;
    /** update multiples rows of table: "token_ownerships_v2" */
    update_token_ownerships_v2_many?: Maybe<Array<Maybe<TokenOwnershipsV2MutationResponse>>>;
    /** update data of the table: "tokens" */
    update_tokens?: Maybe<TokensMutationResponse>;
    /** update single row of the table: "tokens" */
    update_tokens_by_pk?: Maybe<Tokens>;
    /** update multiples rows of table: "tokens" */
    update_tokens_many?: Maybe<Array<Maybe<TokensMutationResponse>>>;
    /** update data of the table: "transaction_size_info" */
    update_transaction_size_info?: Maybe<TransactionSizeInfoMutationResponse>;
    /** update single row of the table: "transaction_size_info" */
    update_transaction_size_info_by_pk?: Maybe<TransactionSizeInfo>;
    /** update multiples rows of table: "transaction_size_info" */
    update_transaction_size_info_many?: Maybe<Array<Maybe<TransactionSizeInfoMutationResponse>>>;
    /** update data of the table: "transactions_view" */
    update_transactions_view?: Maybe<TransactionsViewMutationResponse>;
    /** update multiples rows of table: "transactions_view" */
    update_transactions_view_many?: Maybe<Array<Maybe<TransactionsViewMutationResponse>>>;
    /** update data of the table: "user_transactions" */
    update_user_transactions?: Maybe<UserTransactionsMutationResponse>;
    /** update single row of the table: "user_transactions" */
    update_user_transactions_by_pk?: Maybe<UserTransactions>;
    /** update multiples rows of table: "user_transactions" */
    update_user_transactions_many?: Maybe<Array<Maybe<UserTransactionsMutationResponse>>>;
};
/** mutation root */
type MutationRootDeleteAccountTransactionsArgs = {
    where: AccountTransactionsBoolExp;
};
/** mutation root */
type MutationRootDeleteAccountTransactionsByPkArgs = {
    account_address: Scalars["String"]["input"];
    transaction_version: Scalars["bigint"]["input"];
};
/** mutation root */
type MutationRootDeleteAnsLookupArgs = {
    where: AnsLookupBoolExp;
};
/** mutation root */
type MutationRootDeleteAnsLookupByPkArgs = {
    transaction_version: Scalars["bigint"]["input"];
    write_set_change_index: Scalars["bigint"]["input"];
};
/** mutation root */
type MutationRootDeleteAnsLookupV2Args = {
    where: AnsLookupV2BoolExp;
};
/** mutation root */
type MutationRootDeleteAnsLookupV2ByPkArgs = {
    transaction_version: Scalars["bigint"]["input"];
    write_set_change_index: Scalars["bigint"]["input"];
};
/** mutation root */
type MutationRootDeleteAnsPrimaryNameArgs = {
    where: AnsPrimaryNameBoolExp;
};
/** mutation root */
type MutationRootDeleteAnsPrimaryNameByPkArgs = {
    transaction_version: Scalars["bigint"]["input"];
    write_set_change_index: Scalars["bigint"]["input"];
};
/** mutation root */
type MutationRootDeleteAnsPrimaryNameV2Args = {
    where: AnsPrimaryNameV2BoolExp;
};
/** mutation root */
type MutationRootDeleteAnsPrimaryNameV2ByPkArgs = {
    transaction_version: Scalars["bigint"]["input"];
    write_set_change_index: Scalars["bigint"]["input"];
};
/** mutation root */
type MutationRootDeleteAuthKeyAccountAddressesArgs = {
    where: AuthKeyAccountAddressesBoolExp;
};
/** mutation root */
type MutationRootDeleteAuthKeyAccountAddressesByPkArgs = {
    account_address: Scalars["String"]["input"];
};
/** mutation root */
type MutationRootDeleteBlockMetadataTransactionsArgs = {
    where: BlockMetadataTransactionsBoolExp;
};
/** mutation root */
type MutationRootDeleteBlockMetadataTransactionsByPkArgs = {
    version: Scalars["bigint"]["input"];
};
/** mutation root */
type MutationRootDeleteCoinActivitiesArgs = {
    where: CoinActivitiesBoolExp;
};
/** mutation root */
type MutationRootDeleteCoinActivitiesByPkArgs = {
    event_account_address: Scalars["String"]["input"];
    event_creation_number: Scalars["bigint"]["input"];
    event_sequence_number: Scalars["bigint"]["input"];
    transaction_version: Scalars["bigint"]["input"];
};
/** mutation root */
type MutationRootDeleteCoinBalancesArgs = {
    where: CoinBalancesBoolExp;
};
/** mutation root */
type MutationRootDeleteCoinBalancesByPkArgs = {
    coin_type_hash: Scalars["String"]["input"];
    owner_address: Scalars["String"]["input"];
    transaction_version: Scalars["bigint"]["input"];
};
/** mutation root */
type MutationRootDeleteCoinInfosArgs = {
    where: CoinInfosBoolExp;
};
/** mutation root */
type MutationRootDeleteCoinInfosByPkArgs = {
    coin_type_hash: Scalars["String"]["input"];
};
/** mutation root */
type MutationRootDeleteCoinSupplyArgs = {
    where: CoinSupplyBoolExp;
};
/** mutation root */
type MutationRootDeleteCoinSupplyByPkArgs = {
    coin_type_hash: Scalars["String"]["input"];
    transaction_version: Scalars["bigint"]["input"];
};
/** mutation root */
type MutationRootDeleteCollectionDatasArgs = {
    where: CollectionDatasBoolExp;
};
/** mutation root */
type MutationRootDeleteCollectionDatasByPkArgs = {
    collection_data_id_hash: Scalars["String"]["input"];
    transaction_version: Scalars["bigint"]["input"];
};
/** mutation root */
type MutationRootDeleteCollectionsV2Args = {
    where: CollectionsV2BoolExp;
};
/** mutation root */
type MutationRootDeleteCollectionsV2ByPkArgs = {
    transaction_version: Scalars["bigint"]["input"];
    write_set_change_index: Scalars["bigint"]["input"];
};
/** mutation root */
type MutationRootDeleteCurrentAnsLookupArgs = {
    where: CurrentAnsLookupBoolExp;
};
/** mutation root */
type MutationRootDeleteCurrentAnsLookupByPkArgs = {
    domain: Scalars["String"]["input"];
    subdomain: Scalars["String"]["input"];
};
/** mutation root */
type MutationRootDeleteCurrentAnsLookupV2Args = {
    where: CurrentAnsLookupV2BoolExp;
};
/** mutation root */
type MutationRootDeleteCurrentAnsLookupV2ByPkArgs = {
    domain: Scalars["String"]["input"];
    subdomain: Scalars["String"]["input"];
    token_standard: Scalars["String"]["input"];
};
/** mutation root */
type MutationRootDeleteCurrentAnsPrimaryNameArgs = {
    where: CurrentAnsPrimaryNameBoolExp;
};
/** mutation root */
type MutationRootDeleteCurrentAnsPrimaryNameByPkArgs = {
    registered_address: Scalars["String"]["input"];
};
/** mutation root */
type MutationRootDeleteCurrentAnsPrimaryNameV2Args = {
    where: CurrentAnsPrimaryNameV2BoolExp;
};
/** mutation root */
type MutationRootDeleteCurrentAnsPrimaryNameV2ByPkArgs = {
    registered_address: Scalars["String"]["input"];
    token_standard: Scalars["String"]["input"];
};
/** mutation root */
type MutationRootDeleteCurrentCoinBalancesArgs = {
    where: CurrentCoinBalancesBoolExp;
};
/** mutation root */
type MutationRootDeleteCurrentCoinBalancesByPkArgs = {
    coin_type_hash: Scalars["String"]["input"];
    owner_address: Scalars["String"]["input"];
};
/** mutation root */
type MutationRootDeleteCurrentCollectionDatasArgs = {
    where: CurrentCollectionDatasBoolExp;
};
/** mutation root */
type MutationRootDeleteCurrentCollectionDatasByPkArgs = {
    collection_data_id_hash: Scalars["String"]["input"];
};
/** mutation root */
type MutationRootDeleteCurrentCollectionsV2Args = {
    where: CurrentCollectionsV2BoolExp;
};
/** mutation root */
type MutationRootDeleteCurrentCollectionsV2ByPkArgs = {
    collection_id: Scalars["String"]["input"];
};
/** mutation root */
type MutationRootDeleteCurrentDelegatedStakingPoolBalancesArgs = {
    where: CurrentDelegatedStakingPoolBalancesBoolExp;
};
/** mutation root */
type MutationRootDeleteCurrentDelegatedStakingPoolBalancesByPkArgs = {
    staking_pool_address: Scalars["String"]["input"];
};
/** mutation root */
type MutationRootDeleteCurrentDelegatedVoterArgs = {
    where: CurrentDelegatedVoterBoolExp;
};
/** mutation root */
type MutationRootDeleteCurrentDelegatedVoterByPkArgs = {
    delegation_pool_address: Scalars["String"]["input"];
    delegator_address: Scalars["String"]["input"];
};
/** mutation root */
type MutationRootDeleteCurrentDelegatorBalancesArgs = {
    where: CurrentDelegatorBalancesBoolExp;
};
/** mutation root */
type MutationRootDeleteCurrentDelegatorBalancesByPkArgs = {
    delegator_address: Scalars["String"]["input"];
    pool_address: Scalars["String"]["input"];
    pool_type: Scalars["String"]["input"];
    table_handle: Scalars["String"]["input"];
};
/** mutation root */
type MutationRootDeleteCurrentFungibleAssetBalancesArgs = {
    where: CurrentFungibleAssetBalancesBoolExp;
};
/** mutation root */
type MutationRootDeleteCurrentFungibleAssetBalancesByPkArgs = {
    storage_id: Scalars["String"]["input"];
};
/** mutation root */
type MutationRootDeleteCurrentFungibleAssetBalancesNewArgs = {
    where: CurrentFungibleAssetBalancesNewBoolExp;
};
/** mutation root */
type MutationRootDeleteCurrentFungibleAssetBalancesNewByPkArgs = {
    storage_id: Scalars["String"]["input"];
};
/** mutation root */
type MutationRootDeleteCurrentObjectsArgs = {
    where: CurrentObjectsBoolExp;
};
/** mutation root */
type MutationRootDeleteCurrentObjectsByPkArgs = {
    object_address: Scalars["String"]["input"];
};
/** mutation root */
type MutationRootDeleteCurrentStakingPoolVoterArgs = {
    where: CurrentStakingPoolVoterBoolExp;
};
/** mutation root */
type MutationRootDeleteCurrentStakingPoolVoterByPkArgs = {
    staking_pool_address: Scalars["String"]["input"];
};
/** mutation root */
type MutationRootDeleteCurrentTableItemsArgs = {
    where: CurrentTableItemsBoolExp;
};
/** mutation root */
type MutationRootDeleteCurrentTableItemsByPkArgs = {
    key_hash: Scalars["String"]["input"];
    table_handle: Scalars["String"]["input"];
};
/** mutation root */
type MutationRootDeleteCurrentTableItemsViewArgs = {
    where: CurrentTableItemsViewBoolExp;
};
/** mutation root */
type MutationRootDeleteCurrentTokenDatasArgs = {
    where: CurrentTokenDatasBoolExp;
};
/** mutation root */
type MutationRootDeleteCurrentTokenDatasByPkArgs = {
    token_data_id_hash: Scalars["String"]["input"];
};
/** mutation root */
type MutationRootDeleteCurrentTokenDatasV2Args = {
    where: CurrentTokenDatasV2BoolExp;
};
/** mutation root */
type MutationRootDeleteCurrentTokenDatasV2ByPkArgs = {
    token_data_id: Scalars["String"]["input"];
};
/** mutation root */
type MutationRootDeleteCurrentTokenOwnershipsArgs = {
    where: CurrentTokenOwnershipsBoolExp;
};
/** mutation root */
type MutationRootDeleteCurrentTokenOwnershipsByPkArgs = {
    owner_address: Scalars["String"]["input"];
    property_version: Scalars["numeric"]["input"];
    token_data_id_hash: Scalars["String"]["input"];
};
/** mutation root */
type MutationRootDeleteCurrentTokenOwnershipsV2Args = {
    where: CurrentTokenOwnershipsV2BoolExp;
};
/** mutation root */
type MutationRootDeleteCurrentTokenOwnershipsV2ByPkArgs = {
    owner_address: Scalars["String"]["input"];
    property_version_v1: Scalars["numeric"]["input"];
    storage_id: Scalars["String"]["input"];
    token_data_id: Scalars["String"]["input"];
};
/** mutation root */
type MutationRootDeleteCurrentTokenPendingClaimsArgs = {
    where: CurrentTokenPendingClaimsBoolExp;
};
/** mutation root */
type MutationRootDeleteCurrentTokenPendingClaimsByPkArgs = {
    from_address: Scalars["String"]["input"];
    property_version: Scalars["numeric"]["input"];
    to_address: Scalars["String"]["input"];
    token_data_id_hash: Scalars["String"]["input"];
};
/** mutation root */
type MutationRootDeleteCurrentTokenRoyaltyV1Args = {
    where: CurrentTokenRoyaltyV1BoolExp;
};
/** mutation root */
type MutationRootDeleteCurrentTokenRoyaltyV1ByPkArgs = {
    token_data_id: Scalars["String"]["input"];
};
/** mutation root */
type MutationRootDeleteCurrentTokenV2MetadataArgs = {
    where: CurrentTokenV2MetadataBoolExp;
};
/** mutation root */
type MutationRootDeleteCurrentTokenV2MetadataByPkArgs = {
    object_address: Scalars["String"]["input"];
    resource_type: Scalars["String"]["input"];
};
/** mutation root */
type MutationRootDeleteDelegatedStakingActivitiesArgs = {
    where: DelegatedStakingActivitiesBoolExp;
};
/** mutation root */
type MutationRootDeleteDelegatedStakingActivitiesByPkArgs = {
    event_index: Scalars["bigint"]["input"];
    transaction_version: Scalars["bigint"]["input"];
};
/** mutation root */
type MutationRootDeleteDelegatedStakingPoolBalancesArgs = {
    where: DelegatedStakingPoolBalancesBoolExp;
};
/** mutation root */
type MutationRootDeleteDelegatedStakingPoolBalancesByPkArgs = {
    staking_pool_address: Scalars["String"]["input"];
    transaction_version: Scalars["bigint"]["input"];
};
/** mutation root */
type MutationRootDeleteDelegatedStakingPoolsArgs = {
    where: DelegatedStakingPoolsBoolExp;
};
/** mutation root */
type MutationRootDeleteDelegatedStakingPoolsByPkArgs = {
    staking_pool_address: Scalars["String"]["input"];
};
/** mutation root */
type MutationRootDeleteDelegatorBalancesArgs = {
    where: DelegatorBalancesBoolExp;
};
/** mutation root */
type MutationRootDeleteDelegatorBalancesByPkArgs = {
    transaction_version: Scalars["bigint"]["input"];
    write_set_change_index: Scalars["bigint"]["input"];
};
/** mutation root */
type MutationRootDeleteEventSizeInfoArgs = {
    where: EventSizeInfoBoolExp;
};
/** mutation root */
type MutationRootDeleteEventSizeInfoByPkArgs = {
    index: Scalars["bigint"]["input"];
    transaction_version: Scalars["bigint"]["input"];
};
/** mutation root */
type MutationRootDeleteEventsArgs = {
    where: EventsBoolExp;
};
/** mutation root */
type MutationRootDeleteEventsByPkArgs = {
    event_index: Scalars["bigint"]["input"];
    transaction_version: Scalars["bigint"]["input"];
};
/** mutation root */
type MutationRootDeleteEventsViewArgs = {
    where: EventsViewBoolExp;
};
/** mutation root */
type MutationRootDeleteFungibleAssetActivitiesArgs = {
    where: FungibleAssetActivitiesBoolExp;
};
/** mutation root */
type MutationRootDeleteFungibleAssetActivitiesByPkArgs = {
    event_index: Scalars["bigint"]["input"];
    transaction_version: Scalars["bigint"]["input"];
};
/** mutation root */
type MutationRootDeleteFungibleAssetBalancesArgs = {
    where: FungibleAssetBalancesBoolExp;
};
/** mutation root */
type MutationRootDeleteFungibleAssetBalancesByPkArgs = {
    transaction_version: Scalars["bigint"]["input"];
    write_set_change_index: Scalars["bigint"]["input"];
};
/** mutation root */
type MutationRootDeleteFungibleAssetMetadataArgs = {
    where: FungibleAssetMetadataBoolExp;
};
/** mutation root */
type MutationRootDeleteFungibleAssetMetadataByPkArgs = {
    asset_type: Scalars["String"]["input"];
};
/** mutation root */
type MutationRootDeleteFungibleAssetToCoinMappingsArgs = {
    where: FungibleAssetToCoinMappingsBoolExp;
};
/** mutation root */
type MutationRootDeleteFungibleAssetToCoinMappingsByPkArgs = {
    fungible_asset_metadata_address: Scalars["String"]["input"];
};
/** mutation root */
type MutationRootDeleteGasFeesArgs = {
    where: GasFeesBoolExp;
};
/** mutation root */
type MutationRootDeleteGasFeesByPkArgs = {
    transaction_version: Scalars["bigint"]["input"];
};
/** mutation root */
type MutationRootDeleteIndexerStatusArgs = {
    where: IndexerStatusBoolExp;
};
/** mutation root */
type MutationRootDeleteIndexerStatusByPkArgs = {
    db: Scalars["String"]["input"];
};
/** mutation root */
type MutationRootDeleteMoveModulesArgs = {
    where: MoveModulesBoolExp;
};
/** mutation root */
type MutationRootDeleteMoveModulesByPkArgs = {
    transaction_version: Scalars["bigint"]["input"];
    write_set_change_index: Scalars["bigint"]["input"];
};
/** mutation root */
type MutationRootDeleteMoveResourcesArgs = {
    where: MoveResourcesBoolExp;
};
/** mutation root */
type MutationRootDeleteMoveResourcesByPkArgs = {
    transaction_version: Scalars["bigint"]["input"];
    write_set_change_index: Scalars["bigint"]["input"];
};
/** mutation root */
type MutationRootDeleteMoveResourcesViewArgs = {
    where: MoveResourcesViewBoolExp;
};
/** mutation root */
type MutationRootDeleteNftMetadataCrawlerParsedAssetUrisArgs = {
    where: NftMetadataCrawlerParsedAssetUrisBoolExp;
};
/** mutation root */
type MutationRootDeleteNftMetadataCrawlerParsedAssetUrisByPkArgs = {
    asset_uri: Scalars["String"]["input"];
};
/** mutation root */
type MutationRootDeleteNftPointsArgs = {
    where: NftPointsBoolExp;
};
/** mutation root */
type MutationRootDeleteNftPointsByPkArgs = {
    transaction_version: Scalars["bigint"]["input"];
};
/** mutation root */
type MutationRootDeleteObjectsArgs = {
    where: ObjectsBoolExp;
};
/** mutation root */
type MutationRootDeleteObjectsByPkArgs = {
    transaction_version: Scalars["bigint"]["input"];
    write_set_change_index: Scalars["bigint"]["input"];
};
/** mutation root */
type MutationRootDeleteProcessorMetadataProcessorStatusArgs = {
    where: ProcessorMetadataProcessorStatusBoolExp;
};
/** mutation root */
type MutationRootDeleteProcessorMetadataProcessorStatusByPkArgs = {
    processor: Scalars["String"]["input"];
};
/** mutation root */
type MutationRootDeleteProcessorStatusArgs = {
    where: ProcessorStatusBoolExp;
};
/** mutation root */
type MutationRootDeleteProcessorStatusByPkArgs = {
    processor: Scalars["String"]["input"];
};
/** mutation root */
type MutationRootDeleteProposalVotesArgs = {
    where: ProposalVotesBoolExp;
};
/** mutation root */
type MutationRootDeleteProposalVotesByPkArgs = {
    proposal_id: Scalars["bigint"]["input"];
    transaction_version: Scalars["bigint"]["input"];
    voter_address: Scalars["String"]["input"];
};
/** mutation root */
type MutationRootDeletePublicKeyAuthKeysArgs = {
    where: PublicKeyAuthKeysBoolExp;
};
/** mutation root */
type MutationRootDeletePublicKeyAuthKeysByPkArgs = {
    auth_key: Scalars["String"]["input"];
    public_key: Scalars["String"]["input"];
    public_key_type: Scalars["String"]["input"];
};
/** mutation root */
type MutationRootDeleteSignaturesArgs = {
    where: SignaturesBoolExp;
};
/** mutation root */
type MutationRootDeleteSignaturesByPkArgs = {
    is_sender_primary: Scalars["Boolean"]["input"];
    multi_agent_index: Scalars["bigint"]["input"];
    multi_sig_index: Scalars["bigint"]["input"];
    transaction_version: Scalars["bigint"]["input"];
};
/** mutation root */
type MutationRootDeleteSpamAssetsArgs = {
    where: SpamAssetsBoolExp;
};
/** mutation root */
type MutationRootDeleteSpamAssetsByPkArgs = {
    asset: Scalars["String"]["input"];
};
/** mutation root */
type MutationRootDeleteTableItemsArgs = {
    where: TableItemsBoolExp;
};
/** mutation root */
type MutationRootDeleteTableItemsByPkArgs = {
    transaction_version: Scalars["bigint"]["input"];
    write_set_change_index: Scalars["bigint"]["input"];
};
/** mutation root */
type MutationRootDeleteTableItemsViewArgs = {
    where: TableItemsViewBoolExp;
};
/** mutation root */
type MutationRootDeleteTableMetadatasArgs = {
    where: TableMetadatasBoolExp;
};
/** mutation root */
type MutationRootDeleteTableMetadatasByPkArgs = {
    handle: Scalars["String"]["input"];
};
/** mutation root */
type MutationRootDeleteTokenActivitiesArgs = {
    where: TokenActivitiesBoolExp;
};
/** mutation root */
type MutationRootDeleteTokenActivitiesByPkArgs = {
    event_account_address: Scalars["String"]["input"];
    event_creation_number: Scalars["bigint"]["input"];
    event_sequence_number: Scalars["bigint"]["input"];
    transaction_version: Scalars["bigint"]["input"];
};
/** mutation root */
type MutationRootDeleteTokenActivitiesV2Args = {
    where: TokenActivitiesV2BoolExp;
};
/** mutation root */
type MutationRootDeleteTokenActivitiesV2ByPkArgs = {
    event_index: Scalars["bigint"]["input"];
    transaction_version: Scalars["bigint"]["input"];
};
/** mutation root */
type MutationRootDeleteTokenDatasArgs = {
    where: TokenDatasBoolExp;
};
/** mutation root */
type MutationRootDeleteTokenDatasByPkArgs = {
    token_data_id_hash: Scalars["String"]["input"];
    transaction_version: Scalars["bigint"]["input"];
};
/** mutation root */
type MutationRootDeleteTokenDatasV2Args = {
    where: TokenDatasV2BoolExp;
};
/** mutation root */
type MutationRootDeleteTokenDatasV2ByPkArgs = {
    transaction_version: Scalars["bigint"]["input"];
    write_set_change_index: Scalars["bigint"]["input"];
};
/** mutation root */
type MutationRootDeleteTokenOwnershipsArgs = {
    where: TokenOwnershipsBoolExp;
};
/** mutation root */
type MutationRootDeleteTokenOwnershipsByPkArgs = {
    property_version: Scalars["numeric"]["input"];
    table_handle: Scalars["String"]["input"];
    token_data_id_hash: Scalars["String"]["input"];
    transaction_version: Scalars["bigint"]["input"];
};
/** mutation root */
type MutationRootDeleteTokenOwnershipsV2Args = {
    where: TokenOwnershipsV2BoolExp;
};
/** mutation root */
type MutationRootDeleteTokenOwnershipsV2ByPkArgs = {
    transaction_version: Scalars["bigint"]["input"];
    write_set_change_index: Scalars["bigint"]["input"];
};
/** mutation root */
type MutationRootDeleteTokensArgs = {
    where: TokensBoolExp;
};
/** mutation root */
type MutationRootDeleteTokensByPkArgs = {
    property_version: Scalars["numeric"]["input"];
    token_data_id_hash: Scalars["String"]["input"];
    transaction_version: Scalars["bigint"]["input"];
};
/** mutation root */
type MutationRootDeleteTransactionSizeInfoArgs = {
    where: TransactionSizeInfoBoolExp;
};
/** mutation root */
type MutationRootDeleteTransactionSizeInfoByPkArgs = {
    transaction_version: Scalars["bigint"]["input"];
};
/** mutation root */
type MutationRootDeleteTransactionsViewArgs = {
    where: TransactionsViewBoolExp;
};
/** mutation root */
type MutationRootDeleteUserTransactionsArgs = {
    where: UserTransactionsBoolExp;
};
/** mutation root */
type MutationRootDeleteUserTransactionsByPkArgs = {
    version: Scalars["bigint"]["input"];
};
/** mutation root */
type MutationRootInsertAccountTransactionsArgs = {
    objects: Array<AccountTransactionsInsertInput>;
    on_conflict?: InputMaybe<AccountTransactionsOnConflict>;
};
/** mutation root */
type MutationRootInsertAccountTransactionsOneArgs = {
    object: AccountTransactionsInsertInput;
    on_conflict?: InputMaybe<AccountTransactionsOnConflict>;
};
/** mutation root */
type MutationRootInsertAnsLookupArgs = {
    objects: Array<AnsLookupInsertInput>;
    on_conflict?: InputMaybe<AnsLookupOnConflict>;
};
/** mutation root */
type MutationRootInsertAnsLookupOneArgs = {
    object: AnsLookupInsertInput;
    on_conflict?: InputMaybe<AnsLookupOnConflict>;
};
/** mutation root */
type MutationRootInsertAnsLookupV2Args = {
    objects: Array<AnsLookupV2InsertInput>;
    on_conflict?: InputMaybe<AnsLookupV2OnConflict>;
};
/** mutation root */
type MutationRootInsertAnsLookupV2OneArgs = {
    object: AnsLookupV2InsertInput;
    on_conflict?: InputMaybe<AnsLookupV2OnConflict>;
};
/** mutation root */
type MutationRootInsertAnsPrimaryNameArgs = {
    objects: Array<AnsPrimaryNameInsertInput>;
    on_conflict?: InputMaybe<AnsPrimaryNameOnConflict>;
};
/** mutation root */
type MutationRootInsertAnsPrimaryNameOneArgs = {
    object: AnsPrimaryNameInsertInput;
    on_conflict?: InputMaybe<AnsPrimaryNameOnConflict>;
};
/** mutation root */
type MutationRootInsertAnsPrimaryNameV2Args = {
    objects: Array<AnsPrimaryNameV2InsertInput>;
    on_conflict?: InputMaybe<AnsPrimaryNameV2OnConflict>;
};
/** mutation root */
type MutationRootInsertAnsPrimaryNameV2OneArgs = {
    object: AnsPrimaryNameV2InsertInput;
    on_conflict?: InputMaybe<AnsPrimaryNameV2OnConflict>;
};
/** mutation root */
type MutationRootInsertAuthKeyAccountAddressesArgs = {
    objects: Array<AuthKeyAccountAddressesInsertInput>;
    on_conflict?: InputMaybe<AuthKeyAccountAddressesOnConflict>;
};
/** mutation root */
type MutationRootInsertAuthKeyAccountAddressesOneArgs = {
    object: AuthKeyAccountAddressesInsertInput;
    on_conflict?: InputMaybe<AuthKeyAccountAddressesOnConflict>;
};
/** mutation root */
type MutationRootInsertBlockMetadataTransactionsArgs = {
    objects: Array<BlockMetadataTransactionsInsertInput>;
    on_conflict?: InputMaybe<BlockMetadataTransactionsOnConflict>;
};
/** mutation root */
type MutationRootInsertBlockMetadataTransactionsOneArgs = {
    object: BlockMetadataTransactionsInsertInput;
    on_conflict?: InputMaybe<BlockMetadataTransactionsOnConflict>;
};
/** mutation root */
type MutationRootInsertCoinActivitiesArgs = {
    objects: Array<CoinActivitiesInsertInput>;
    on_conflict?: InputMaybe<CoinActivitiesOnConflict>;
};
/** mutation root */
type MutationRootInsertCoinActivitiesOneArgs = {
    object: CoinActivitiesInsertInput;
    on_conflict?: InputMaybe<CoinActivitiesOnConflict>;
};
/** mutation root */
type MutationRootInsertCoinBalancesArgs = {
    objects: Array<CoinBalancesInsertInput>;
    on_conflict?: InputMaybe<CoinBalancesOnConflict>;
};
/** mutation root */
type MutationRootInsertCoinBalancesOneArgs = {
    object: CoinBalancesInsertInput;
    on_conflict?: InputMaybe<CoinBalancesOnConflict>;
};
/** mutation root */
type MutationRootInsertCoinInfosArgs = {
    objects: Array<CoinInfosInsertInput>;
    on_conflict?: InputMaybe<CoinInfosOnConflict>;
};
/** mutation root */
type MutationRootInsertCoinInfosOneArgs = {
    object: CoinInfosInsertInput;
    on_conflict?: InputMaybe<CoinInfosOnConflict>;
};
/** mutation root */
type MutationRootInsertCoinSupplyArgs = {
    objects: Array<CoinSupplyInsertInput>;
    on_conflict?: InputMaybe<CoinSupplyOnConflict>;
};
/** mutation root */
type MutationRootInsertCoinSupplyOneArgs = {
    object: CoinSupplyInsertInput;
    on_conflict?: InputMaybe<CoinSupplyOnConflict>;
};
/** mutation root */
type MutationRootInsertCollectionDatasArgs = {
    objects: Array<CollectionDatasInsertInput>;
    on_conflict?: InputMaybe<CollectionDatasOnConflict>;
};
/** mutation root */
type MutationRootInsertCollectionDatasOneArgs = {
    object: CollectionDatasInsertInput;
    on_conflict?: InputMaybe<CollectionDatasOnConflict>;
};
/** mutation root */
type MutationRootInsertCollectionsV2Args = {
    objects: Array<CollectionsV2InsertInput>;
    on_conflict?: InputMaybe<CollectionsV2OnConflict>;
};
/** mutation root */
type MutationRootInsertCollectionsV2OneArgs = {
    object: CollectionsV2InsertInput;
    on_conflict?: InputMaybe<CollectionsV2OnConflict>;
};
/** mutation root */
type MutationRootInsertCurrentAnsLookupArgs = {
    objects: Array<CurrentAnsLookupInsertInput>;
    on_conflict?: InputMaybe<CurrentAnsLookupOnConflict>;
};
/** mutation root */
type MutationRootInsertCurrentAnsLookupOneArgs = {
    object: CurrentAnsLookupInsertInput;
    on_conflict?: InputMaybe<CurrentAnsLookupOnConflict>;
};
/** mutation root */
type MutationRootInsertCurrentAnsLookupV2Args = {
    objects: Array<CurrentAnsLookupV2InsertInput>;
    on_conflict?: InputMaybe<CurrentAnsLookupV2OnConflict>;
};
/** mutation root */
type MutationRootInsertCurrentAnsLookupV2OneArgs = {
    object: CurrentAnsLookupV2InsertInput;
    on_conflict?: InputMaybe<CurrentAnsLookupV2OnConflict>;
};
/** mutation root */
type MutationRootInsertCurrentAnsPrimaryNameArgs = {
    objects: Array<CurrentAnsPrimaryNameInsertInput>;
    on_conflict?: InputMaybe<CurrentAnsPrimaryNameOnConflict>;
};
/** mutation root */
type MutationRootInsertCurrentAnsPrimaryNameOneArgs = {
    object: CurrentAnsPrimaryNameInsertInput;
    on_conflict?: InputMaybe<CurrentAnsPrimaryNameOnConflict>;
};
/** mutation root */
type MutationRootInsertCurrentAnsPrimaryNameV2Args = {
    objects: Array<CurrentAnsPrimaryNameV2InsertInput>;
    on_conflict?: InputMaybe<CurrentAnsPrimaryNameV2OnConflict>;
};
/** mutation root */
type MutationRootInsertCurrentAnsPrimaryNameV2OneArgs = {
    object: CurrentAnsPrimaryNameV2InsertInput;
    on_conflict?: InputMaybe<CurrentAnsPrimaryNameV2OnConflict>;
};
/** mutation root */
type MutationRootInsertCurrentCoinBalancesArgs = {
    objects: Array<CurrentCoinBalancesInsertInput>;
    on_conflict?: InputMaybe<CurrentCoinBalancesOnConflict>;
};
/** mutation root */
type MutationRootInsertCurrentCoinBalancesOneArgs = {
    object: CurrentCoinBalancesInsertInput;
    on_conflict?: InputMaybe<CurrentCoinBalancesOnConflict>;
};
/** mutation root */
type MutationRootInsertCurrentCollectionDatasArgs = {
    objects: Array<CurrentCollectionDatasInsertInput>;
    on_conflict?: InputMaybe<CurrentCollectionDatasOnConflict>;
};
/** mutation root */
type MutationRootInsertCurrentCollectionDatasOneArgs = {
    object: CurrentCollectionDatasInsertInput;
    on_conflict?: InputMaybe<CurrentCollectionDatasOnConflict>;
};
/** mutation root */
type MutationRootInsertCurrentCollectionsV2Args = {
    objects: Array<CurrentCollectionsV2InsertInput>;
    on_conflict?: InputMaybe<CurrentCollectionsV2OnConflict>;
};
/** mutation root */
type MutationRootInsertCurrentCollectionsV2OneArgs = {
    object: CurrentCollectionsV2InsertInput;
    on_conflict?: InputMaybe<CurrentCollectionsV2OnConflict>;
};
/** mutation root */
type MutationRootInsertCurrentDelegatedStakingPoolBalancesArgs = {
    objects: Array<CurrentDelegatedStakingPoolBalancesInsertInput>;
    on_conflict?: InputMaybe<CurrentDelegatedStakingPoolBalancesOnConflict>;
};
/** mutation root */
type MutationRootInsertCurrentDelegatedStakingPoolBalancesOneArgs = {
    object: CurrentDelegatedStakingPoolBalancesInsertInput;
    on_conflict?: InputMaybe<CurrentDelegatedStakingPoolBalancesOnConflict>;
};
/** mutation root */
type MutationRootInsertCurrentDelegatedVoterArgs = {
    objects: Array<CurrentDelegatedVoterInsertInput>;
    on_conflict?: InputMaybe<CurrentDelegatedVoterOnConflict>;
};
/** mutation root */
type MutationRootInsertCurrentDelegatedVoterOneArgs = {
    object: CurrentDelegatedVoterInsertInput;
    on_conflict?: InputMaybe<CurrentDelegatedVoterOnConflict>;
};
/** mutation root */
type MutationRootInsertCurrentDelegatorBalancesArgs = {
    objects: Array<CurrentDelegatorBalancesInsertInput>;
    on_conflict?: InputMaybe<CurrentDelegatorBalancesOnConflict>;
};
/** mutation root */
type MutationRootInsertCurrentDelegatorBalancesOneArgs = {
    object: CurrentDelegatorBalancesInsertInput;
    on_conflict?: InputMaybe<CurrentDelegatorBalancesOnConflict>;
};
/** mutation root */
type MutationRootInsertCurrentFungibleAssetBalancesArgs = {
    objects: Array<CurrentFungibleAssetBalancesInsertInput>;
    on_conflict?: InputMaybe<CurrentFungibleAssetBalancesOnConflict>;
};
/** mutation root */
type MutationRootInsertCurrentFungibleAssetBalancesNewArgs = {
    objects: Array<CurrentFungibleAssetBalancesNewInsertInput>;
    on_conflict?: InputMaybe<CurrentFungibleAssetBalancesNewOnConflict>;
};
/** mutation root */
type MutationRootInsertCurrentFungibleAssetBalancesNewOneArgs = {
    object: CurrentFungibleAssetBalancesNewInsertInput;
    on_conflict?: InputMaybe<CurrentFungibleAssetBalancesNewOnConflict>;
};
/** mutation root */
type MutationRootInsertCurrentFungibleAssetBalancesOneArgs = {
    object: CurrentFungibleAssetBalancesInsertInput;
    on_conflict?: InputMaybe<CurrentFungibleAssetBalancesOnConflict>;
};
/** mutation root */
type MutationRootInsertCurrentObjectsArgs = {
    objects: Array<CurrentObjectsInsertInput>;
    on_conflict?: InputMaybe<CurrentObjectsOnConflict>;
};
/** mutation root */
type MutationRootInsertCurrentObjectsOneArgs = {
    object: CurrentObjectsInsertInput;
    on_conflict?: InputMaybe<CurrentObjectsOnConflict>;
};
/** mutation root */
type MutationRootInsertCurrentStakingPoolVoterArgs = {
    objects: Array<CurrentStakingPoolVoterInsertInput>;
    on_conflict?: InputMaybe<CurrentStakingPoolVoterOnConflict>;
};
/** mutation root */
type MutationRootInsertCurrentStakingPoolVoterOneArgs = {
    object: CurrentStakingPoolVoterInsertInput;
    on_conflict?: InputMaybe<CurrentStakingPoolVoterOnConflict>;
};
/** mutation root */
type MutationRootInsertCurrentTableItemsArgs = {
    objects: Array<CurrentTableItemsInsertInput>;
    on_conflict?: InputMaybe<CurrentTableItemsOnConflict>;
};
/** mutation root */
type MutationRootInsertCurrentTableItemsOneArgs = {
    object: CurrentTableItemsInsertInput;
    on_conflict?: InputMaybe<CurrentTableItemsOnConflict>;
};
/** mutation root */
type MutationRootInsertCurrentTableItemsViewArgs = {
    objects: Array<CurrentTableItemsViewInsertInput>;
};
/** mutation root */
type MutationRootInsertCurrentTableItemsViewOneArgs = {
    object: CurrentTableItemsViewInsertInput;
};
/** mutation root */
type MutationRootInsertCurrentTokenDatasArgs = {
    objects: Array<CurrentTokenDatasInsertInput>;
    on_conflict?: InputMaybe<CurrentTokenDatasOnConflict>;
};
/** mutation root */
type MutationRootInsertCurrentTokenDatasOneArgs = {
    object: CurrentTokenDatasInsertInput;
    on_conflict?: InputMaybe<CurrentTokenDatasOnConflict>;
};
/** mutation root */
type MutationRootInsertCurrentTokenDatasV2Args = {
    objects: Array<CurrentTokenDatasV2InsertInput>;
    on_conflict?: InputMaybe<CurrentTokenDatasV2OnConflict>;
};
/** mutation root */
type MutationRootInsertCurrentTokenDatasV2OneArgs = {
    object: CurrentTokenDatasV2InsertInput;
    on_conflict?: InputMaybe<CurrentTokenDatasV2OnConflict>;
};
/** mutation root */
type MutationRootInsertCurrentTokenOwnershipsArgs = {
    objects: Array<CurrentTokenOwnershipsInsertInput>;
    on_conflict?: InputMaybe<CurrentTokenOwnershipsOnConflict>;
};
/** mutation root */
type MutationRootInsertCurrentTokenOwnershipsOneArgs = {
    object: CurrentTokenOwnershipsInsertInput;
    on_conflict?: InputMaybe<CurrentTokenOwnershipsOnConflict>;
};
/** mutation root */
type MutationRootInsertCurrentTokenOwnershipsV2Args = {
    objects: Array<CurrentTokenOwnershipsV2InsertInput>;
    on_conflict?: InputMaybe<CurrentTokenOwnershipsV2OnConflict>;
};
/** mutation root */
type MutationRootInsertCurrentTokenOwnershipsV2OneArgs = {
    object: CurrentTokenOwnershipsV2InsertInput;
    on_conflict?: InputMaybe<CurrentTokenOwnershipsV2OnConflict>;
};
/** mutation root */
type MutationRootInsertCurrentTokenPendingClaimsArgs = {
    objects: Array<CurrentTokenPendingClaimsInsertInput>;
    on_conflict?: InputMaybe<CurrentTokenPendingClaimsOnConflict>;
};
/** mutation root */
type MutationRootInsertCurrentTokenPendingClaimsOneArgs = {
    object: CurrentTokenPendingClaimsInsertInput;
    on_conflict?: InputMaybe<CurrentTokenPendingClaimsOnConflict>;
};
/** mutation root */
type MutationRootInsertCurrentTokenRoyaltyV1Args = {
    objects: Array<CurrentTokenRoyaltyV1InsertInput>;
    on_conflict?: InputMaybe<CurrentTokenRoyaltyV1OnConflict>;
};
/** mutation root */
type MutationRootInsertCurrentTokenRoyaltyV1OneArgs = {
    object: CurrentTokenRoyaltyV1InsertInput;
    on_conflict?: InputMaybe<CurrentTokenRoyaltyV1OnConflict>;
};
/** mutation root */
type MutationRootInsertCurrentTokenV2MetadataArgs = {
    objects: Array<CurrentTokenV2MetadataInsertInput>;
    on_conflict?: InputMaybe<CurrentTokenV2MetadataOnConflict>;
};
/** mutation root */
type MutationRootInsertCurrentTokenV2MetadataOneArgs = {
    object: CurrentTokenV2MetadataInsertInput;
    on_conflict?: InputMaybe<CurrentTokenV2MetadataOnConflict>;
};
/** mutation root */
type MutationRootInsertDelegatedStakingActivitiesArgs = {
    objects: Array<DelegatedStakingActivitiesInsertInput>;
    on_conflict?: InputMaybe<DelegatedStakingActivitiesOnConflict>;
};
/** mutation root */
type MutationRootInsertDelegatedStakingActivitiesOneArgs = {
    object: DelegatedStakingActivitiesInsertInput;
    on_conflict?: InputMaybe<DelegatedStakingActivitiesOnConflict>;
};
/** mutation root */
type MutationRootInsertDelegatedStakingPoolBalancesArgs = {
    objects: Array<DelegatedStakingPoolBalancesInsertInput>;
    on_conflict?: InputMaybe<DelegatedStakingPoolBalancesOnConflict>;
};
/** mutation root */
type MutationRootInsertDelegatedStakingPoolBalancesOneArgs = {
    object: DelegatedStakingPoolBalancesInsertInput;
    on_conflict?: InputMaybe<DelegatedStakingPoolBalancesOnConflict>;
};
/** mutation root */
type MutationRootInsertDelegatedStakingPoolsArgs = {
    objects: Array<DelegatedStakingPoolsInsertInput>;
    on_conflict?: InputMaybe<DelegatedStakingPoolsOnConflict>;
};
/** mutation root */
type MutationRootInsertDelegatedStakingPoolsOneArgs = {
    object: DelegatedStakingPoolsInsertInput;
    on_conflict?: InputMaybe<DelegatedStakingPoolsOnConflict>;
};
/** mutation root */
type MutationRootInsertDelegatorBalancesArgs = {
    objects: Array<DelegatorBalancesInsertInput>;
    on_conflict?: InputMaybe<DelegatorBalancesOnConflict>;
};
/** mutation root */
type MutationRootInsertDelegatorBalancesOneArgs = {
    object: DelegatorBalancesInsertInput;
    on_conflict?: InputMaybe<DelegatorBalancesOnConflict>;
};
/** mutation root */
type MutationRootInsertEventSizeInfoArgs = {
    objects: Array<EventSizeInfoInsertInput>;
    on_conflict?: InputMaybe<EventSizeInfoOnConflict>;
};
/** mutation root */
type MutationRootInsertEventSizeInfoOneArgs = {
    object: EventSizeInfoInsertInput;
    on_conflict?: InputMaybe<EventSizeInfoOnConflict>;
};
/** mutation root */
type MutationRootInsertEventsArgs = {
    objects: Array<EventsInsertInput>;
    on_conflict?: InputMaybe<EventsOnConflict>;
};
/** mutation root */
type MutationRootInsertEventsOneArgs = {
    object: EventsInsertInput;
    on_conflict?: InputMaybe<EventsOnConflict>;
};
/** mutation root */
type MutationRootInsertEventsViewArgs = {
    objects: Array<EventsViewInsertInput>;
};
/** mutation root */
type MutationRootInsertEventsViewOneArgs = {
    object: EventsViewInsertInput;
};
/** mutation root */
type MutationRootInsertFungibleAssetActivitiesArgs = {
    objects: Array<FungibleAssetActivitiesInsertInput>;
    on_conflict?: InputMaybe<FungibleAssetActivitiesOnConflict>;
};
/** mutation root */
type MutationRootInsertFungibleAssetActivitiesOneArgs = {
    object: FungibleAssetActivitiesInsertInput;
    on_conflict?: InputMaybe<FungibleAssetActivitiesOnConflict>;
};
/** mutation root */
type MutationRootInsertFungibleAssetBalancesArgs = {
    objects: Array<FungibleAssetBalancesInsertInput>;
    on_conflict?: InputMaybe<FungibleAssetBalancesOnConflict>;
};
/** mutation root */
type MutationRootInsertFungibleAssetBalancesOneArgs = {
    object: FungibleAssetBalancesInsertInput;
    on_conflict?: InputMaybe<FungibleAssetBalancesOnConflict>;
};
/** mutation root */
type MutationRootInsertFungibleAssetMetadataArgs = {
    objects: Array<FungibleAssetMetadataInsertInput>;
    on_conflict?: InputMaybe<FungibleAssetMetadataOnConflict>;
};
/** mutation root */
type MutationRootInsertFungibleAssetMetadataOneArgs = {
    object: FungibleAssetMetadataInsertInput;
    on_conflict?: InputMaybe<FungibleAssetMetadataOnConflict>;
};
/** mutation root */
type MutationRootInsertFungibleAssetToCoinMappingsArgs = {
    objects: Array<FungibleAssetToCoinMappingsInsertInput>;
    on_conflict?: InputMaybe<FungibleAssetToCoinMappingsOnConflict>;
};
/** mutation root */
type MutationRootInsertFungibleAssetToCoinMappingsOneArgs = {
    object: FungibleAssetToCoinMappingsInsertInput;
    on_conflict?: InputMaybe<FungibleAssetToCoinMappingsOnConflict>;
};
/** mutation root */
type MutationRootInsertGasFeesArgs = {
    objects: Array<GasFeesInsertInput>;
    on_conflict?: InputMaybe<GasFeesOnConflict>;
};
/** mutation root */
type MutationRootInsertGasFeesOneArgs = {
    object: GasFeesInsertInput;
    on_conflict?: InputMaybe<GasFeesOnConflict>;
};
/** mutation root */
type MutationRootInsertIndexerStatusArgs = {
    objects: Array<IndexerStatusInsertInput>;
    on_conflict?: InputMaybe<IndexerStatusOnConflict>;
};
/** mutation root */
type MutationRootInsertIndexerStatusOneArgs = {
    object: IndexerStatusInsertInput;
    on_conflict?: InputMaybe<IndexerStatusOnConflict>;
};
/** mutation root */
type MutationRootInsertMoveModulesArgs = {
    objects: Array<MoveModulesInsertInput>;
    on_conflict?: InputMaybe<MoveModulesOnConflict>;
};
/** mutation root */
type MutationRootInsertMoveModulesOneArgs = {
    object: MoveModulesInsertInput;
    on_conflict?: InputMaybe<MoveModulesOnConflict>;
};
/** mutation root */
type MutationRootInsertMoveResourcesArgs = {
    objects: Array<MoveResourcesInsertInput>;
    on_conflict?: InputMaybe<MoveResourcesOnConflict>;
};
/** mutation root */
type MutationRootInsertMoveResourcesOneArgs = {
    object: MoveResourcesInsertInput;
    on_conflict?: InputMaybe<MoveResourcesOnConflict>;
};
/** mutation root */
type MutationRootInsertMoveResourcesViewArgs = {
    objects: Array<MoveResourcesViewInsertInput>;
};
/** mutation root */
type MutationRootInsertMoveResourcesViewOneArgs = {
    object: MoveResourcesViewInsertInput;
};
/** mutation root */
type MutationRootInsertNftMetadataCrawlerParsedAssetUrisArgs = {
    objects: Array<NftMetadataCrawlerParsedAssetUrisInsertInput>;
    on_conflict?: InputMaybe<NftMetadataCrawlerParsedAssetUrisOnConflict>;
};
/** mutation root */
type MutationRootInsertNftMetadataCrawlerParsedAssetUrisOneArgs = {
    object: NftMetadataCrawlerParsedAssetUrisInsertInput;
    on_conflict?: InputMaybe<NftMetadataCrawlerParsedAssetUrisOnConflict>;
};
/** mutation root */
type MutationRootInsertNftPointsArgs = {
    objects: Array<NftPointsInsertInput>;
    on_conflict?: InputMaybe<NftPointsOnConflict>;
};
/** mutation root */
type MutationRootInsertNftPointsOneArgs = {
    object: NftPointsInsertInput;
    on_conflict?: InputMaybe<NftPointsOnConflict>;
};
/** mutation root */
type MutationRootInsertObjectsArgs = {
    objects: Array<ObjectsInsertInput>;
    on_conflict?: InputMaybe<ObjectsOnConflict>;
};
/** mutation root */
type MutationRootInsertObjectsOneArgs = {
    object: ObjectsInsertInput;
    on_conflict?: InputMaybe<ObjectsOnConflict>;
};
/** mutation root */
type MutationRootInsertProcessorMetadataProcessorStatusArgs = {
    objects: Array<ProcessorMetadataProcessorStatusInsertInput>;
    on_conflict?: InputMaybe<ProcessorMetadataProcessorStatusOnConflict>;
};
/** mutation root */
type MutationRootInsertProcessorMetadataProcessorStatusOneArgs = {
    object: ProcessorMetadataProcessorStatusInsertInput;
    on_conflict?: InputMaybe<ProcessorMetadataProcessorStatusOnConflict>;
};
/** mutation root */
type MutationRootInsertProcessorStatusArgs = {
    objects: Array<ProcessorStatusInsertInput>;
    on_conflict?: InputMaybe<ProcessorStatusOnConflict>;
};
/** mutation root */
type MutationRootInsertProcessorStatusOneArgs = {
    object: ProcessorStatusInsertInput;
    on_conflict?: InputMaybe<ProcessorStatusOnConflict>;
};
/** mutation root */
type MutationRootInsertProposalVotesArgs = {
    objects: Array<ProposalVotesInsertInput>;
    on_conflict?: InputMaybe<ProposalVotesOnConflict>;
};
/** mutation root */
type MutationRootInsertProposalVotesOneArgs = {
    object: ProposalVotesInsertInput;
    on_conflict?: InputMaybe<ProposalVotesOnConflict>;
};
/** mutation root */
type MutationRootInsertPublicKeyAuthKeysArgs = {
    objects: Array<PublicKeyAuthKeysInsertInput>;
    on_conflict?: InputMaybe<PublicKeyAuthKeysOnConflict>;
};
/** mutation root */
type MutationRootInsertPublicKeyAuthKeysOneArgs = {
    object: PublicKeyAuthKeysInsertInput;
    on_conflict?: InputMaybe<PublicKeyAuthKeysOnConflict>;
};
/** mutation root */
type MutationRootInsertSignaturesArgs = {
    objects: Array<SignaturesInsertInput>;
    on_conflict?: InputMaybe<SignaturesOnConflict>;
};
/** mutation root */
type MutationRootInsertSignaturesOneArgs = {
    object: SignaturesInsertInput;
    on_conflict?: InputMaybe<SignaturesOnConflict>;
};
/** mutation root */
type MutationRootInsertSpamAssetsArgs = {
    objects: Array<SpamAssetsInsertInput>;
    on_conflict?: InputMaybe<SpamAssetsOnConflict>;
};
/** mutation root */
type MutationRootInsertSpamAssetsOneArgs = {
    object: SpamAssetsInsertInput;
    on_conflict?: InputMaybe<SpamAssetsOnConflict>;
};
/** mutation root */
type MutationRootInsertTableItemsArgs = {
    objects: Array<TableItemsInsertInput>;
    on_conflict?: InputMaybe<TableItemsOnConflict>;
};
/** mutation root */
type MutationRootInsertTableItemsOneArgs = {
    object: TableItemsInsertInput;
    on_conflict?: InputMaybe<TableItemsOnConflict>;
};
/** mutation root */
type MutationRootInsertTableItemsViewArgs = {
    objects: Array<TableItemsViewInsertInput>;
};
/** mutation root */
type MutationRootInsertTableItemsViewOneArgs = {
    object: TableItemsViewInsertInput;
};
/** mutation root */
type MutationRootInsertTableMetadatasArgs = {
    objects: Array<TableMetadatasInsertInput>;
    on_conflict?: InputMaybe<TableMetadatasOnConflict>;
};
/** mutation root */
type MutationRootInsertTableMetadatasOneArgs = {
    object: TableMetadatasInsertInput;
    on_conflict?: InputMaybe<TableMetadatasOnConflict>;
};
/** mutation root */
type MutationRootInsertTokenActivitiesArgs = {
    objects: Array<TokenActivitiesInsertInput>;
    on_conflict?: InputMaybe<TokenActivitiesOnConflict>;
};
/** mutation root */
type MutationRootInsertTokenActivitiesOneArgs = {
    object: TokenActivitiesInsertInput;
    on_conflict?: InputMaybe<TokenActivitiesOnConflict>;
};
/** mutation root */
type MutationRootInsertTokenActivitiesV2Args = {
    objects: Array<TokenActivitiesV2InsertInput>;
    on_conflict?: InputMaybe<TokenActivitiesV2OnConflict>;
};
/** mutation root */
type MutationRootInsertTokenActivitiesV2OneArgs = {
    object: TokenActivitiesV2InsertInput;
    on_conflict?: InputMaybe<TokenActivitiesV2OnConflict>;
};
/** mutation root */
type MutationRootInsertTokenDatasArgs = {
    objects: Array<TokenDatasInsertInput>;
    on_conflict?: InputMaybe<TokenDatasOnConflict>;
};
/** mutation root */
type MutationRootInsertTokenDatasOneArgs = {
    object: TokenDatasInsertInput;
    on_conflict?: InputMaybe<TokenDatasOnConflict>;
};
/** mutation root */
type MutationRootInsertTokenDatasV2Args = {
    objects: Array<TokenDatasV2InsertInput>;
    on_conflict?: InputMaybe<TokenDatasV2OnConflict>;
};
/** mutation root */
type MutationRootInsertTokenDatasV2OneArgs = {
    object: TokenDatasV2InsertInput;
    on_conflict?: InputMaybe<TokenDatasV2OnConflict>;
};
/** mutation root */
type MutationRootInsertTokenOwnershipsArgs = {
    objects: Array<TokenOwnershipsInsertInput>;
    on_conflict?: InputMaybe<TokenOwnershipsOnConflict>;
};
/** mutation root */
type MutationRootInsertTokenOwnershipsOneArgs = {
    object: TokenOwnershipsInsertInput;
    on_conflict?: InputMaybe<TokenOwnershipsOnConflict>;
};
/** mutation root */
type MutationRootInsertTokenOwnershipsV2Args = {
    objects: Array<TokenOwnershipsV2InsertInput>;
    on_conflict?: InputMaybe<TokenOwnershipsV2OnConflict>;
};
/** mutation root */
type MutationRootInsertTokenOwnershipsV2OneArgs = {
    object: TokenOwnershipsV2InsertInput;
    on_conflict?: InputMaybe<TokenOwnershipsV2OnConflict>;
};
/** mutation root */
type MutationRootInsertTokensArgs = {
    objects: Array<TokensInsertInput>;
    on_conflict?: InputMaybe<TokensOnConflict>;
};
/** mutation root */
type MutationRootInsertTokensOneArgs = {
    object: TokensInsertInput;
    on_conflict?: InputMaybe<TokensOnConflict>;
};
/** mutation root */
type MutationRootInsertTransactionSizeInfoArgs = {
    objects: Array<TransactionSizeInfoInsertInput>;
    on_conflict?: InputMaybe<TransactionSizeInfoOnConflict>;
};
/** mutation root */
type MutationRootInsertTransactionSizeInfoOneArgs = {
    object: TransactionSizeInfoInsertInput;
    on_conflict?: InputMaybe<TransactionSizeInfoOnConflict>;
};
/** mutation root */
type MutationRootInsertTransactionsViewArgs = {
    objects: Array<TransactionsViewInsertInput>;
};
/** mutation root */
type MutationRootInsertTransactionsViewOneArgs = {
    object: TransactionsViewInsertInput;
};
/** mutation root */
type MutationRootInsertUserTransactionsArgs = {
    objects: Array<UserTransactionsInsertInput>;
    on_conflict?: InputMaybe<UserTransactionsOnConflict>;
};
/** mutation root */
type MutationRootInsertUserTransactionsOneArgs = {
    object: UserTransactionsInsertInput;
    on_conflict?: InputMaybe<UserTransactionsOnConflict>;
};
/** mutation root */
type MutationRootUpdateAccountTransactionsArgs = {
    _inc?: InputMaybe<AccountTransactionsIncInput>;
    _set?: InputMaybe<AccountTransactionsSetInput>;
    where: AccountTransactionsBoolExp;
};
/** mutation root */
type MutationRootUpdateAccountTransactionsByPkArgs = {
    _inc?: InputMaybe<AccountTransactionsIncInput>;
    _set?: InputMaybe<AccountTransactionsSetInput>;
    pk_columns: AccountTransactionsPkColumnsInput;
};
/** mutation root */
type MutationRootUpdateAccountTransactionsManyArgs = {
    updates: Array<AccountTransactionsUpdates>;
};
/** mutation root */
type MutationRootUpdateAnsLookupArgs = {
    _inc?: InputMaybe<AnsLookupIncInput>;
    _set?: InputMaybe<AnsLookupSetInput>;
    where: AnsLookupBoolExp;
};
/** mutation root */
type MutationRootUpdateAnsLookupByPkArgs = {
    _inc?: InputMaybe<AnsLookupIncInput>;
    _set?: InputMaybe<AnsLookupSetInput>;
    pk_columns: AnsLookupPkColumnsInput;
};
/** mutation root */
type MutationRootUpdateAnsLookupManyArgs = {
    updates: Array<AnsLookupUpdates>;
};
/** mutation root */
type MutationRootUpdateAnsLookupV2Args = {
    _inc?: InputMaybe<AnsLookupV2IncInput>;
    _set?: InputMaybe<AnsLookupV2SetInput>;
    where: AnsLookupV2BoolExp;
};
/** mutation root */
type MutationRootUpdateAnsLookupV2ByPkArgs = {
    _inc?: InputMaybe<AnsLookupV2IncInput>;
    _set?: InputMaybe<AnsLookupV2SetInput>;
    pk_columns: AnsLookupV2PkColumnsInput;
};
/** mutation root */
type MutationRootUpdateAnsLookupV2ManyArgs = {
    updates: Array<AnsLookupV2Updates>;
};
/** mutation root */
type MutationRootUpdateAnsPrimaryNameArgs = {
    _inc?: InputMaybe<AnsPrimaryNameIncInput>;
    _set?: InputMaybe<AnsPrimaryNameSetInput>;
    where: AnsPrimaryNameBoolExp;
};
/** mutation root */
type MutationRootUpdateAnsPrimaryNameByPkArgs = {
    _inc?: InputMaybe<AnsPrimaryNameIncInput>;
    _set?: InputMaybe<AnsPrimaryNameSetInput>;
    pk_columns: AnsPrimaryNamePkColumnsInput;
};
/** mutation root */
type MutationRootUpdateAnsPrimaryNameManyArgs = {
    updates: Array<AnsPrimaryNameUpdates>;
};
/** mutation root */
type MutationRootUpdateAnsPrimaryNameV2Args = {
    _inc?: InputMaybe<AnsPrimaryNameV2IncInput>;
    _set?: InputMaybe<AnsPrimaryNameV2SetInput>;
    where: AnsPrimaryNameV2BoolExp;
};
/** mutation root */
type MutationRootUpdateAnsPrimaryNameV2ByPkArgs = {
    _inc?: InputMaybe<AnsPrimaryNameV2IncInput>;
    _set?: InputMaybe<AnsPrimaryNameV2SetInput>;
    pk_columns: AnsPrimaryNameV2PkColumnsInput;
};
/** mutation root */
type MutationRootUpdateAnsPrimaryNameV2ManyArgs = {
    updates: Array<AnsPrimaryNameV2Updates>;
};
/** mutation root */
type MutationRootUpdateAuthKeyAccountAddressesArgs = {
    _inc?: InputMaybe<AuthKeyAccountAddressesIncInput>;
    _set?: InputMaybe<AuthKeyAccountAddressesSetInput>;
    where: AuthKeyAccountAddressesBoolExp;
};
/** mutation root */
type MutationRootUpdateAuthKeyAccountAddressesByPkArgs = {
    _inc?: InputMaybe<AuthKeyAccountAddressesIncInput>;
    _set?: InputMaybe<AuthKeyAccountAddressesSetInput>;
    pk_columns: AuthKeyAccountAddressesPkColumnsInput;
};
/** mutation root */
type MutationRootUpdateAuthKeyAccountAddressesManyArgs = {
    updates: Array<AuthKeyAccountAddressesUpdates>;
};
/** mutation root */
type MutationRootUpdateBlockMetadataTransactionsArgs = {
    _append?: InputMaybe<BlockMetadataTransactionsAppendInput>;
    _delete_at_path?: InputMaybe<BlockMetadataTransactionsDeleteAtPathInput>;
    _delete_elem?: InputMaybe<BlockMetadataTransactionsDeleteElemInput>;
    _delete_key?: InputMaybe<BlockMetadataTransactionsDeleteKeyInput>;
    _inc?: InputMaybe<BlockMetadataTransactionsIncInput>;
    _prepend?: InputMaybe<BlockMetadataTransactionsPrependInput>;
    _set?: InputMaybe<BlockMetadataTransactionsSetInput>;
    where: BlockMetadataTransactionsBoolExp;
};
/** mutation root */
type MutationRootUpdateBlockMetadataTransactionsByPkArgs = {
    _append?: InputMaybe<BlockMetadataTransactionsAppendInput>;
    _delete_at_path?: InputMaybe<BlockMetadataTransactionsDeleteAtPathInput>;
    _delete_elem?: InputMaybe<BlockMetadataTransactionsDeleteElemInput>;
    _delete_key?: InputMaybe<BlockMetadataTransactionsDeleteKeyInput>;
    _inc?: InputMaybe<BlockMetadataTransactionsIncInput>;
    _prepend?: InputMaybe<BlockMetadataTransactionsPrependInput>;
    _set?: InputMaybe<BlockMetadataTransactionsSetInput>;
    pk_columns: BlockMetadataTransactionsPkColumnsInput;
};
/** mutation root */
type MutationRootUpdateBlockMetadataTransactionsManyArgs = {
    updates: Array<BlockMetadataTransactionsUpdates>;
};
/** mutation root */
type MutationRootUpdateCoinActivitiesArgs = {
    _inc?: InputMaybe<CoinActivitiesIncInput>;
    _set?: InputMaybe<CoinActivitiesSetInput>;
    where: CoinActivitiesBoolExp;
};
/** mutation root */
type MutationRootUpdateCoinActivitiesByPkArgs = {
    _inc?: InputMaybe<CoinActivitiesIncInput>;
    _set?: InputMaybe<CoinActivitiesSetInput>;
    pk_columns: CoinActivitiesPkColumnsInput;
};
/** mutation root */
type MutationRootUpdateCoinActivitiesManyArgs = {
    updates: Array<CoinActivitiesUpdates>;
};
/** mutation root */
type MutationRootUpdateCoinBalancesArgs = {
    _inc?: InputMaybe<CoinBalancesIncInput>;
    _set?: InputMaybe<CoinBalancesSetInput>;
    where: CoinBalancesBoolExp;
};
/** mutation root */
type MutationRootUpdateCoinBalancesByPkArgs = {
    _inc?: InputMaybe<CoinBalancesIncInput>;
    _set?: InputMaybe<CoinBalancesSetInput>;
    pk_columns: CoinBalancesPkColumnsInput;
};
/** mutation root */
type MutationRootUpdateCoinBalancesManyArgs = {
    updates: Array<CoinBalancesUpdates>;
};
/** mutation root */
type MutationRootUpdateCoinInfosArgs = {
    _inc?: InputMaybe<CoinInfosIncInput>;
    _set?: InputMaybe<CoinInfosSetInput>;
    where: CoinInfosBoolExp;
};
/** mutation root */
type MutationRootUpdateCoinInfosByPkArgs = {
    _inc?: InputMaybe<CoinInfosIncInput>;
    _set?: InputMaybe<CoinInfosSetInput>;
    pk_columns: CoinInfosPkColumnsInput;
};
/** mutation root */
type MutationRootUpdateCoinInfosManyArgs = {
    updates: Array<CoinInfosUpdates>;
};
/** mutation root */
type MutationRootUpdateCoinSupplyArgs = {
    _inc?: InputMaybe<CoinSupplyIncInput>;
    _set?: InputMaybe<CoinSupplySetInput>;
    where: CoinSupplyBoolExp;
};
/** mutation root */
type MutationRootUpdateCoinSupplyByPkArgs = {
    _inc?: InputMaybe<CoinSupplyIncInput>;
    _set?: InputMaybe<CoinSupplySetInput>;
    pk_columns: CoinSupplyPkColumnsInput;
};
/** mutation root */
type MutationRootUpdateCoinSupplyManyArgs = {
    updates: Array<CoinSupplyUpdates>;
};
/** mutation root */
type MutationRootUpdateCollectionDatasArgs = {
    _inc?: InputMaybe<CollectionDatasIncInput>;
    _set?: InputMaybe<CollectionDatasSetInput>;
    where: CollectionDatasBoolExp;
};
/** mutation root */
type MutationRootUpdateCollectionDatasByPkArgs = {
    _inc?: InputMaybe<CollectionDatasIncInput>;
    _set?: InputMaybe<CollectionDatasSetInput>;
    pk_columns: CollectionDatasPkColumnsInput;
};
/** mutation root */
type MutationRootUpdateCollectionDatasManyArgs = {
    updates: Array<CollectionDatasUpdates>;
};
/** mutation root */
type MutationRootUpdateCollectionsV2Args = {
    _append?: InputMaybe<CollectionsV2AppendInput>;
    _delete_at_path?: InputMaybe<CollectionsV2DeleteAtPathInput>;
    _delete_elem?: InputMaybe<CollectionsV2DeleteElemInput>;
    _delete_key?: InputMaybe<CollectionsV2DeleteKeyInput>;
    _inc?: InputMaybe<CollectionsV2IncInput>;
    _prepend?: InputMaybe<CollectionsV2PrependInput>;
    _set?: InputMaybe<CollectionsV2SetInput>;
    where: CollectionsV2BoolExp;
};
/** mutation root */
type MutationRootUpdateCollectionsV2ByPkArgs = {
    _append?: InputMaybe<CollectionsV2AppendInput>;
    _delete_at_path?: InputMaybe<CollectionsV2DeleteAtPathInput>;
    _delete_elem?: InputMaybe<CollectionsV2DeleteElemInput>;
    _delete_key?: InputMaybe<CollectionsV2DeleteKeyInput>;
    _inc?: InputMaybe<CollectionsV2IncInput>;
    _prepend?: InputMaybe<CollectionsV2PrependInput>;
    _set?: InputMaybe<CollectionsV2SetInput>;
    pk_columns: CollectionsV2PkColumnsInput;
};
/** mutation root */
type MutationRootUpdateCollectionsV2ManyArgs = {
    updates: Array<CollectionsV2Updates>;
};
/** mutation root */
type MutationRootUpdateCurrentAnsLookupArgs = {
    _inc?: InputMaybe<CurrentAnsLookupIncInput>;
    _set?: InputMaybe<CurrentAnsLookupSetInput>;
    where: CurrentAnsLookupBoolExp;
};
/** mutation root */
type MutationRootUpdateCurrentAnsLookupByPkArgs = {
    _inc?: InputMaybe<CurrentAnsLookupIncInput>;
    _set?: InputMaybe<CurrentAnsLookupSetInput>;
    pk_columns: CurrentAnsLookupPkColumnsInput;
};
/** mutation root */
type MutationRootUpdateCurrentAnsLookupManyArgs = {
    updates: Array<CurrentAnsLookupUpdates>;
};
/** mutation root */
type MutationRootUpdateCurrentAnsLookupV2Args = {
    _inc?: InputMaybe<CurrentAnsLookupV2IncInput>;
    _set?: InputMaybe<CurrentAnsLookupV2SetInput>;
    where: CurrentAnsLookupV2BoolExp;
};
/** mutation root */
type MutationRootUpdateCurrentAnsLookupV2ByPkArgs = {
    _inc?: InputMaybe<CurrentAnsLookupV2IncInput>;
    _set?: InputMaybe<CurrentAnsLookupV2SetInput>;
    pk_columns: CurrentAnsLookupV2PkColumnsInput;
};
/** mutation root */
type MutationRootUpdateCurrentAnsLookupV2ManyArgs = {
    updates: Array<CurrentAnsLookupV2Updates>;
};
/** mutation root */
type MutationRootUpdateCurrentAnsPrimaryNameArgs = {
    _inc?: InputMaybe<CurrentAnsPrimaryNameIncInput>;
    _set?: InputMaybe<CurrentAnsPrimaryNameSetInput>;
    where: CurrentAnsPrimaryNameBoolExp;
};
/** mutation root */
type MutationRootUpdateCurrentAnsPrimaryNameByPkArgs = {
    _inc?: InputMaybe<CurrentAnsPrimaryNameIncInput>;
    _set?: InputMaybe<CurrentAnsPrimaryNameSetInput>;
    pk_columns: CurrentAnsPrimaryNamePkColumnsInput;
};
/** mutation root */
type MutationRootUpdateCurrentAnsPrimaryNameManyArgs = {
    updates: Array<CurrentAnsPrimaryNameUpdates>;
};
/** mutation root */
type MutationRootUpdateCurrentAnsPrimaryNameV2Args = {
    _inc?: InputMaybe<CurrentAnsPrimaryNameV2IncInput>;
    _set?: InputMaybe<CurrentAnsPrimaryNameV2SetInput>;
    where: CurrentAnsPrimaryNameV2BoolExp;
};
/** mutation root */
type MutationRootUpdateCurrentAnsPrimaryNameV2ByPkArgs = {
    _inc?: InputMaybe<CurrentAnsPrimaryNameV2IncInput>;
    _set?: InputMaybe<CurrentAnsPrimaryNameV2SetInput>;
    pk_columns: CurrentAnsPrimaryNameV2PkColumnsInput;
};
/** mutation root */
type MutationRootUpdateCurrentAnsPrimaryNameV2ManyArgs = {
    updates: Array<CurrentAnsPrimaryNameV2Updates>;
};
/** mutation root */
type MutationRootUpdateCurrentCoinBalancesArgs = {
    _inc?: InputMaybe<CurrentCoinBalancesIncInput>;
    _set?: InputMaybe<CurrentCoinBalancesSetInput>;
    where: CurrentCoinBalancesBoolExp;
};
/** mutation root */
type MutationRootUpdateCurrentCoinBalancesByPkArgs = {
    _inc?: InputMaybe<CurrentCoinBalancesIncInput>;
    _set?: InputMaybe<CurrentCoinBalancesSetInput>;
    pk_columns: CurrentCoinBalancesPkColumnsInput;
};
/** mutation root */
type MutationRootUpdateCurrentCoinBalancesManyArgs = {
    updates: Array<CurrentCoinBalancesUpdates>;
};
/** mutation root */
type MutationRootUpdateCurrentCollectionDatasArgs = {
    _inc?: InputMaybe<CurrentCollectionDatasIncInput>;
    _set?: InputMaybe<CurrentCollectionDatasSetInput>;
    where: CurrentCollectionDatasBoolExp;
};
/** mutation root */
type MutationRootUpdateCurrentCollectionDatasByPkArgs = {
    _inc?: InputMaybe<CurrentCollectionDatasIncInput>;
    _set?: InputMaybe<CurrentCollectionDatasSetInput>;
    pk_columns: CurrentCollectionDatasPkColumnsInput;
};
/** mutation root */
type MutationRootUpdateCurrentCollectionDatasManyArgs = {
    updates: Array<CurrentCollectionDatasUpdates>;
};
/** mutation root */
type MutationRootUpdateCurrentCollectionsV2Args = {
    _append?: InputMaybe<CurrentCollectionsV2AppendInput>;
    _delete_at_path?: InputMaybe<CurrentCollectionsV2DeleteAtPathInput>;
    _delete_elem?: InputMaybe<CurrentCollectionsV2DeleteElemInput>;
    _delete_key?: InputMaybe<CurrentCollectionsV2DeleteKeyInput>;
    _inc?: InputMaybe<CurrentCollectionsV2IncInput>;
    _prepend?: InputMaybe<CurrentCollectionsV2PrependInput>;
    _set?: InputMaybe<CurrentCollectionsV2SetInput>;
    where: CurrentCollectionsV2BoolExp;
};
/** mutation root */
type MutationRootUpdateCurrentCollectionsV2ByPkArgs = {
    _append?: InputMaybe<CurrentCollectionsV2AppendInput>;
    _delete_at_path?: InputMaybe<CurrentCollectionsV2DeleteAtPathInput>;
    _delete_elem?: InputMaybe<CurrentCollectionsV2DeleteElemInput>;
    _delete_key?: InputMaybe<CurrentCollectionsV2DeleteKeyInput>;
    _inc?: InputMaybe<CurrentCollectionsV2IncInput>;
    _prepend?: InputMaybe<CurrentCollectionsV2PrependInput>;
    _set?: InputMaybe<CurrentCollectionsV2SetInput>;
    pk_columns: CurrentCollectionsV2PkColumnsInput;
};
/** mutation root */
type MutationRootUpdateCurrentCollectionsV2ManyArgs = {
    updates: Array<CurrentCollectionsV2Updates>;
};
/** mutation root */
type MutationRootUpdateCurrentDelegatedStakingPoolBalancesArgs = {
    _inc?: InputMaybe<CurrentDelegatedStakingPoolBalancesIncInput>;
    _set?: InputMaybe<CurrentDelegatedStakingPoolBalancesSetInput>;
    where: CurrentDelegatedStakingPoolBalancesBoolExp;
};
/** mutation root */
type MutationRootUpdateCurrentDelegatedStakingPoolBalancesByPkArgs = {
    _inc?: InputMaybe<CurrentDelegatedStakingPoolBalancesIncInput>;
    _set?: InputMaybe<CurrentDelegatedStakingPoolBalancesSetInput>;
    pk_columns: CurrentDelegatedStakingPoolBalancesPkColumnsInput;
};
/** mutation root */
type MutationRootUpdateCurrentDelegatedStakingPoolBalancesManyArgs = {
    updates: Array<CurrentDelegatedStakingPoolBalancesUpdates>;
};
/** mutation root */
type MutationRootUpdateCurrentDelegatedVoterArgs = {
    _inc?: InputMaybe<CurrentDelegatedVoterIncInput>;
    _set?: InputMaybe<CurrentDelegatedVoterSetInput>;
    where: CurrentDelegatedVoterBoolExp;
};
/** mutation root */
type MutationRootUpdateCurrentDelegatedVoterByPkArgs = {
    _inc?: InputMaybe<CurrentDelegatedVoterIncInput>;
    _set?: InputMaybe<CurrentDelegatedVoterSetInput>;
    pk_columns: CurrentDelegatedVoterPkColumnsInput;
};
/** mutation root */
type MutationRootUpdateCurrentDelegatedVoterManyArgs = {
    updates: Array<CurrentDelegatedVoterUpdates>;
};
/** mutation root */
type MutationRootUpdateCurrentDelegatorBalancesArgs = {
    _inc?: InputMaybe<CurrentDelegatorBalancesIncInput>;
    _set?: InputMaybe<CurrentDelegatorBalancesSetInput>;
    where: CurrentDelegatorBalancesBoolExp;
};
/** mutation root */
type MutationRootUpdateCurrentDelegatorBalancesByPkArgs = {
    _inc?: InputMaybe<CurrentDelegatorBalancesIncInput>;
    _set?: InputMaybe<CurrentDelegatorBalancesSetInput>;
    pk_columns: CurrentDelegatorBalancesPkColumnsInput;
};
/** mutation root */
type MutationRootUpdateCurrentDelegatorBalancesManyArgs = {
    updates: Array<CurrentDelegatorBalancesUpdates>;
};
/** mutation root */
type MutationRootUpdateCurrentFungibleAssetBalancesArgs = {
    _inc?: InputMaybe<CurrentFungibleAssetBalancesIncInput>;
    _set?: InputMaybe<CurrentFungibleAssetBalancesSetInput>;
    where: CurrentFungibleAssetBalancesBoolExp;
};
/** mutation root */
type MutationRootUpdateCurrentFungibleAssetBalancesByPkArgs = {
    _inc?: InputMaybe<CurrentFungibleAssetBalancesIncInput>;
    _set?: InputMaybe<CurrentFungibleAssetBalancesSetInput>;
    pk_columns: CurrentFungibleAssetBalancesPkColumnsInput;
};
/** mutation root */
type MutationRootUpdateCurrentFungibleAssetBalancesManyArgs = {
    updates: Array<CurrentFungibleAssetBalancesUpdates>;
};
/** mutation root */
type MutationRootUpdateCurrentFungibleAssetBalancesNewArgs = {
    _inc?: InputMaybe<CurrentFungibleAssetBalancesNewIncInput>;
    _set?: InputMaybe<CurrentFungibleAssetBalancesNewSetInput>;
    where: CurrentFungibleAssetBalancesNewBoolExp;
};
/** mutation root */
type MutationRootUpdateCurrentFungibleAssetBalancesNewByPkArgs = {
    _inc?: InputMaybe<CurrentFungibleAssetBalancesNewIncInput>;
    _set?: InputMaybe<CurrentFungibleAssetBalancesNewSetInput>;
    pk_columns: CurrentFungibleAssetBalancesNewPkColumnsInput;
};
/** mutation root */
type MutationRootUpdateCurrentFungibleAssetBalancesNewManyArgs = {
    updates: Array<CurrentFungibleAssetBalancesNewUpdates>;
};
/** mutation root */
type MutationRootUpdateCurrentObjectsArgs = {
    _inc?: InputMaybe<CurrentObjectsIncInput>;
    _set?: InputMaybe<CurrentObjectsSetInput>;
    where: CurrentObjectsBoolExp;
};
/** mutation root */
type MutationRootUpdateCurrentObjectsByPkArgs = {
    _inc?: InputMaybe<CurrentObjectsIncInput>;
    _set?: InputMaybe<CurrentObjectsSetInput>;
    pk_columns: CurrentObjectsPkColumnsInput;
};
/** mutation root */
type MutationRootUpdateCurrentObjectsManyArgs = {
    updates: Array<CurrentObjectsUpdates>;
};
/** mutation root */
type MutationRootUpdateCurrentStakingPoolVoterArgs = {
    _inc?: InputMaybe<CurrentStakingPoolVoterIncInput>;
    _set?: InputMaybe<CurrentStakingPoolVoterSetInput>;
    where: CurrentStakingPoolVoterBoolExp;
};
/** mutation root */
type MutationRootUpdateCurrentStakingPoolVoterByPkArgs = {
    _inc?: InputMaybe<CurrentStakingPoolVoterIncInput>;
    _set?: InputMaybe<CurrentStakingPoolVoterSetInput>;
    pk_columns: CurrentStakingPoolVoterPkColumnsInput;
};
/** mutation root */
type MutationRootUpdateCurrentStakingPoolVoterManyArgs = {
    updates: Array<CurrentStakingPoolVoterUpdates>;
};
/** mutation root */
type MutationRootUpdateCurrentTableItemsArgs = {
    _append?: InputMaybe<CurrentTableItemsAppendInput>;
    _delete_at_path?: InputMaybe<CurrentTableItemsDeleteAtPathInput>;
    _delete_elem?: InputMaybe<CurrentTableItemsDeleteElemInput>;
    _delete_key?: InputMaybe<CurrentTableItemsDeleteKeyInput>;
    _inc?: InputMaybe<CurrentTableItemsIncInput>;
    _prepend?: InputMaybe<CurrentTableItemsPrependInput>;
    _set?: InputMaybe<CurrentTableItemsSetInput>;
    where: CurrentTableItemsBoolExp;
};
/** mutation root */
type MutationRootUpdateCurrentTableItemsByPkArgs = {
    _append?: InputMaybe<CurrentTableItemsAppendInput>;
    _delete_at_path?: InputMaybe<CurrentTableItemsDeleteAtPathInput>;
    _delete_elem?: InputMaybe<CurrentTableItemsDeleteElemInput>;
    _delete_key?: InputMaybe<CurrentTableItemsDeleteKeyInput>;
    _inc?: InputMaybe<CurrentTableItemsIncInput>;
    _prepend?: InputMaybe<CurrentTableItemsPrependInput>;
    _set?: InputMaybe<CurrentTableItemsSetInput>;
    pk_columns: CurrentTableItemsPkColumnsInput;
};
/** mutation root */
type MutationRootUpdateCurrentTableItemsManyArgs = {
    updates: Array<CurrentTableItemsUpdates>;
};
/** mutation root */
type MutationRootUpdateCurrentTableItemsViewArgs = {
    _inc?: InputMaybe<CurrentTableItemsViewIncInput>;
    _set?: InputMaybe<CurrentTableItemsViewSetInput>;
    where: CurrentTableItemsViewBoolExp;
};
/** mutation root */
type MutationRootUpdateCurrentTableItemsViewManyArgs = {
    updates: Array<CurrentTableItemsViewUpdates>;
};
/** mutation root */
type MutationRootUpdateCurrentTokenDatasArgs = {
    _append?: InputMaybe<CurrentTokenDatasAppendInput>;
    _delete_at_path?: InputMaybe<CurrentTokenDatasDeleteAtPathInput>;
    _delete_elem?: InputMaybe<CurrentTokenDatasDeleteElemInput>;
    _delete_key?: InputMaybe<CurrentTokenDatasDeleteKeyInput>;
    _inc?: InputMaybe<CurrentTokenDatasIncInput>;
    _prepend?: InputMaybe<CurrentTokenDatasPrependInput>;
    _set?: InputMaybe<CurrentTokenDatasSetInput>;
    where: CurrentTokenDatasBoolExp;
};
/** mutation root */
type MutationRootUpdateCurrentTokenDatasByPkArgs = {
    _append?: InputMaybe<CurrentTokenDatasAppendInput>;
    _delete_at_path?: InputMaybe<CurrentTokenDatasDeleteAtPathInput>;
    _delete_elem?: InputMaybe<CurrentTokenDatasDeleteElemInput>;
    _delete_key?: InputMaybe<CurrentTokenDatasDeleteKeyInput>;
    _inc?: InputMaybe<CurrentTokenDatasIncInput>;
    _prepend?: InputMaybe<CurrentTokenDatasPrependInput>;
    _set?: InputMaybe<CurrentTokenDatasSetInput>;
    pk_columns: CurrentTokenDatasPkColumnsInput;
};
/** mutation root */
type MutationRootUpdateCurrentTokenDatasManyArgs = {
    updates: Array<CurrentTokenDatasUpdates>;
};
/** mutation root */
type MutationRootUpdateCurrentTokenDatasV2Args = {
    _append?: InputMaybe<CurrentTokenDatasV2AppendInput>;
    _delete_at_path?: InputMaybe<CurrentTokenDatasV2DeleteAtPathInput>;
    _delete_elem?: InputMaybe<CurrentTokenDatasV2DeleteElemInput>;
    _delete_key?: InputMaybe<CurrentTokenDatasV2DeleteKeyInput>;
    _inc?: InputMaybe<CurrentTokenDatasV2IncInput>;
    _prepend?: InputMaybe<CurrentTokenDatasV2PrependInput>;
    _set?: InputMaybe<CurrentTokenDatasV2SetInput>;
    where: CurrentTokenDatasV2BoolExp;
};
/** mutation root */
type MutationRootUpdateCurrentTokenDatasV2ByPkArgs = {
    _append?: InputMaybe<CurrentTokenDatasV2AppendInput>;
    _delete_at_path?: InputMaybe<CurrentTokenDatasV2DeleteAtPathInput>;
    _delete_elem?: InputMaybe<CurrentTokenDatasV2DeleteElemInput>;
    _delete_key?: InputMaybe<CurrentTokenDatasV2DeleteKeyInput>;
    _inc?: InputMaybe<CurrentTokenDatasV2IncInput>;
    _prepend?: InputMaybe<CurrentTokenDatasV2PrependInput>;
    _set?: InputMaybe<CurrentTokenDatasV2SetInput>;
    pk_columns: CurrentTokenDatasV2PkColumnsInput;
};
/** mutation root */
type MutationRootUpdateCurrentTokenDatasV2ManyArgs = {
    updates: Array<CurrentTokenDatasV2Updates>;
};
/** mutation root */
type MutationRootUpdateCurrentTokenOwnershipsArgs = {
    _append?: InputMaybe<CurrentTokenOwnershipsAppendInput>;
    _delete_at_path?: InputMaybe<CurrentTokenOwnershipsDeleteAtPathInput>;
    _delete_elem?: InputMaybe<CurrentTokenOwnershipsDeleteElemInput>;
    _delete_key?: InputMaybe<CurrentTokenOwnershipsDeleteKeyInput>;
    _inc?: InputMaybe<CurrentTokenOwnershipsIncInput>;
    _prepend?: InputMaybe<CurrentTokenOwnershipsPrependInput>;
    _set?: InputMaybe<CurrentTokenOwnershipsSetInput>;
    where: CurrentTokenOwnershipsBoolExp;
};
/** mutation root */
type MutationRootUpdateCurrentTokenOwnershipsByPkArgs = {
    _append?: InputMaybe<CurrentTokenOwnershipsAppendInput>;
    _delete_at_path?: InputMaybe<CurrentTokenOwnershipsDeleteAtPathInput>;
    _delete_elem?: InputMaybe<CurrentTokenOwnershipsDeleteElemInput>;
    _delete_key?: InputMaybe<CurrentTokenOwnershipsDeleteKeyInput>;
    _inc?: InputMaybe<CurrentTokenOwnershipsIncInput>;
    _prepend?: InputMaybe<CurrentTokenOwnershipsPrependInput>;
    _set?: InputMaybe<CurrentTokenOwnershipsSetInput>;
    pk_columns: CurrentTokenOwnershipsPkColumnsInput;
};
/** mutation root */
type MutationRootUpdateCurrentTokenOwnershipsManyArgs = {
    updates: Array<CurrentTokenOwnershipsUpdates>;
};
/** mutation root */
type MutationRootUpdateCurrentTokenOwnershipsV2Args = {
    _append?: InputMaybe<CurrentTokenOwnershipsV2AppendInput>;
    _delete_at_path?: InputMaybe<CurrentTokenOwnershipsV2DeleteAtPathInput>;
    _delete_elem?: InputMaybe<CurrentTokenOwnershipsV2DeleteElemInput>;
    _delete_key?: InputMaybe<CurrentTokenOwnershipsV2DeleteKeyInput>;
    _inc?: InputMaybe<CurrentTokenOwnershipsV2IncInput>;
    _prepend?: InputMaybe<CurrentTokenOwnershipsV2PrependInput>;
    _set?: InputMaybe<CurrentTokenOwnershipsV2SetInput>;
    where: CurrentTokenOwnershipsV2BoolExp;
};
/** mutation root */
type MutationRootUpdateCurrentTokenOwnershipsV2ByPkArgs = {
    _append?: InputMaybe<CurrentTokenOwnershipsV2AppendInput>;
    _delete_at_path?: InputMaybe<CurrentTokenOwnershipsV2DeleteAtPathInput>;
    _delete_elem?: InputMaybe<CurrentTokenOwnershipsV2DeleteElemInput>;
    _delete_key?: InputMaybe<CurrentTokenOwnershipsV2DeleteKeyInput>;
    _inc?: InputMaybe<CurrentTokenOwnershipsV2IncInput>;
    _prepend?: InputMaybe<CurrentTokenOwnershipsV2PrependInput>;
    _set?: InputMaybe<CurrentTokenOwnershipsV2SetInput>;
    pk_columns: CurrentTokenOwnershipsV2PkColumnsInput;
};
/** mutation root */
type MutationRootUpdateCurrentTokenOwnershipsV2ManyArgs = {
    updates: Array<CurrentTokenOwnershipsV2Updates>;
};
/** mutation root */
type MutationRootUpdateCurrentTokenPendingClaimsArgs = {
    _inc?: InputMaybe<CurrentTokenPendingClaimsIncInput>;
    _set?: InputMaybe<CurrentTokenPendingClaimsSetInput>;
    where: CurrentTokenPendingClaimsBoolExp;
};
/** mutation root */
type MutationRootUpdateCurrentTokenPendingClaimsByPkArgs = {
    _inc?: InputMaybe<CurrentTokenPendingClaimsIncInput>;
    _set?: InputMaybe<CurrentTokenPendingClaimsSetInput>;
    pk_columns: CurrentTokenPendingClaimsPkColumnsInput;
};
/** mutation root */
type MutationRootUpdateCurrentTokenPendingClaimsManyArgs = {
    updates: Array<CurrentTokenPendingClaimsUpdates>;
};
/** mutation root */
type MutationRootUpdateCurrentTokenRoyaltyV1Args = {
    _inc?: InputMaybe<CurrentTokenRoyaltyV1IncInput>;
    _set?: InputMaybe<CurrentTokenRoyaltyV1SetInput>;
    where: CurrentTokenRoyaltyV1BoolExp;
};
/** mutation root */
type MutationRootUpdateCurrentTokenRoyaltyV1ByPkArgs = {
    _inc?: InputMaybe<CurrentTokenRoyaltyV1IncInput>;
    _set?: InputMaybe<CurrentTokenRoyaltyV1SetInput>;
    pk_columns: CurrentTokenRoyaltyV1PkColumnsInput;
};
/** mutation root */
type MutationRootUpdateCurrentTokenRoyaltyV1ManyArgs = {
    updates: Array<CurrentTokenRoyaltyV1Updates>;
};
/** mutation root */
type MutationRootUpdateCurrentTokenV2MetadataArgs = {
    _append?: InputMaybe<CurrentTokenV2MetadataAppendInput>;
    _delete_at_path?: InputMaybe<CurrentTokenV2MetadataDeleteAtPathInput>;
    _delete_elem?: InputMaybe<CurrentTokenV2MetadataDeleteElemInput>;
    _delete_key?: InputMaybe<CurrentTokenV2MetadataDeleteKeyInput>;
    _inc?: InputMaybe<CurrentTokenV2MetadataIncInput>;
    _prepend?: InputMaybe<CurrentTokenV2MetadataPrependInput>;
    _set?: InputMaybe<CurrentTokenV2MetadataSetInput>;
    where: CurrentTokenV2MetadataBoolExp;
};
/** mutation root */
type MutationRootUpdateCurrentTokenV2MetadataByPkArgs = {
    _append?: InputMaybe<CurrentTokenV2MetadataAppendInput>;
    _delete_at_path?: InputMaybe<CurrentTokenV2MetadataDeleteAtPathInput>;
    _delete_elem?: InputMaybe<CurrentTokenV2MetadataDeleteElemInput>;
    _delete_key?: InputMaybe<CurrentTokenV2MetadataDeleteKeyInput>;
    _inc?: InputMaybe<CurrentTokenV2MetadataIncInput>;
    _prepend?: InputMaybe<CurrentTokenV2MetadataPrependInput>;
    _set?: InputMaybe<CurrentTokenV2MetadataSetInput>;
    pk_columns: CurrentTokenV2MetadataPkColumnsInput;
};
/** mutation root */
type MutationRootUpdateCurrentTokenV2MetadataManyArgs = {
    updates: Array<CurrentTokenV2MetadataUpdates>;
};
/** mutation root */
type MutationRootUpdateDelegatedStakingActivitiesArgs = {
    _inc?: InputMaybe<DelegatedStakingActivitiesIncInput>;
    _set?: InputMaybe<DelegatedStakingActivitiesSetInput>;
    where: DelegatedStakingActivitiesBoolExp;
};
/** mutation root */
type MutationRootUpdateDelegatedStakingActivitiesByPkArgs = {
    _inc?: InputMaybe<DelegatedStakingActivitiesIncInput>;
    _set?: InputMaybe<DelegatedStakingActivitiesSetInput>;
    pk_columns: DelegatedStakingActivitiesPkColumnsInput;
};
/** mutation root */
type MutationRootUpdateDelegatedStakingActivitiesManyArgs = {
    updates: Array<DelegatedStakingActivitiesUpdates>;
};
/** mutation root */
type MutationRootUpdateDelegatedStakingPoolBalancesArgs = {
    _inc?: InputMaybe<DelegatedStakingPoolBalancesIncInput>;
    _set?: InputMaybe<DelegatedStakingPoolBalancesSetInput>;
    where: DelegatedStakingPoolBalancesBoolExp;
};
/** mutation root */
type MutationRootUpdateDelegatedStakingPoolBalancesByPkArgs = {
    _inc?: InputMaybe<DelegatedStakingPoolBalancesIncInput>;
    _set?: InputMaybe<DelegatedStakingPoolBalancesSetInput>;
    pk_columns: DelegatedStakingPoolBalancesPkColumnsInput;
};
/** mutation root */
type MutationRootUpdateDelegatedStakingPoolBalancesManyArgs = {
    updates: Array<DelegatedStakingPoolBalancesUpdates>;
};
/** mutation root */
type MutationRootUpdateDelegatedStakingPoolsArgs = {
    _inc?: InputMaybe<DelegatedStakingPoolsIncInput>;
    _set?: InputMaybe<DelegatedStakingPoolsSetInput>;
    where: DelegatedStakingPoolsBoolExp;
};
/** mutation root */
type MutationRootUpdateDelegatedStakingPoolsByPkArgs = {
    _inc?: InputMaybe<DelegatedStakingPoolsIncInput>;
    _set?: InputMaybe<DelegatedStakingPoolsSetInput>;
    pk_columns: DelegatedStakingPoolsPkColumnsInput;
};
/** mutation root */
type MutationRootUpdateDelegatedStakingPoolsManyArgs = {
    updates: Array<DelegatedStakingPoolsUpdates>;
};
/** mutation root */
type MutationRootUpdateDelegatorBalancesArgs = {
    _inc?: InputMaybe<DelegatorBalancesIncInput>;
    _set?: InputMaybe<DelegatorBalancesSetInput>;
    where: DelegatorBalancesBoolExp;
};
/** mutation root */
type MutationRootUpdateDelegatorBalancesByPkArgs = {
    _inc?: InputMaybe<DelegatorBalancesIncInput>;
    _set?: InputMaybe<DelegatorBalancesSetInput>;
    pk_columns: DelegatorBalancesPkColumnsInput;
};
/** mutation root */
type MutationRootUpdateDelegatorBalancesManyArgs = {
    updates: Array<DelegatorBalancesUpdates>;
};
/** mutation root */
type MutationRootUpdateEventSizeInfoArgs = {
    _inc?: InputMaybe<EventSizeInfoIncInput>;
    _set?: InputMaybe<EventSizeInfoSetInput>;
    where: EventSizeInfoBoolExp;
};
/** mutation root */
type MutationRootUpdateEventSizeInfoByPkArgs = {
    _inc?: InputMaybe<EventSizeInfoIncInput>;
    _set?: InputMaybe<EventSizeInfoSetInput>;
    pk_columns: EventSizeInfoPkColumnsInput;
};
/** mutation root */
type MutationRootUpdateEventSizeInfoManyArgs = {
    updates: Array<EventSizeInfoUpdates>;
};
/** mutation root */
type MutationRootUpdateEventsArgs = {
    _append?: InputMaybe<EventsAppendInput>;
    _delete_at_path?: InputMaybe<EventsDeleteAtPathInput>;
    _delete_elem?: InputMaybe<EventsDeleteElemInput>;
    _delete_key?: InputMaybe<EventsDeleteKeyInput>;
    _inc?: InputMaybe<EventsIncInput>;
    _prepend?: InputMaybe<EventsPrependInput>;
    _set?: InputMaybe<EventsSetInput>;
    where: EventsBoolExp;
};
/** mutation root */
type MutationRootUpdateEventsByPkArgs = {
    _append?: InputMaybe<EventsAppendInput>;
    _delete_at_path?: InputMaybe<EventsDeleteAtPathInput>;
    _delete_elem?: InputMaybe<EventsDeleteElemInput>;
    _delete_key?: InputMaybe<EventsDeleteKeyInput>;
    _inc?: InputMaybe<EventsIncInput>;
    _prepend?: InputMaybe<EventsPrependInput>;
    _set?: InputMaybe<EventsSetInput>;
    pk_columns: EventsPkColumnsInput;
};
/** mutation root */
type MutationRootUpdateEventsManyArgs = {
    updates: Array<EventsUpdates>;
};
/** mutation root */
type MutationRootUpdateEventsViewArgs = {
    _inc?: InputMaybe<EventsViewIncInput>;
    _set?: InputMaybe<EventsViewSetInput>;
    where: EventsViewBoolExp;
};
/** mutation root */
type MutationRootUpdateEventsViewManyArgs = {
    updates: Array<EventsViewUpdates>;
};
/** mutation root */
type MutationRootUpdateFungibleAssetActivitiesArgs = {
    _inc?: InputMaybe<FungibleAssetActivitiesIncInput>;
    _set?: InputMaybe<FungibleAssetActivitiesSetInput>;
    where: FungibleAssetActivitiesBoolExp;
};
/** mutation root */
type MutationRootUpdateFungibleAssetActivitiesByPkArgs = {
    _inc?: InputMaybe<FungibleAssetActivitiesIncInput>;
    _set?: InputMaybe<FungibleAssetActivitiesSetInput>;
    pk_columns: FungibleAssetActivitiesPkColumnsInput;
};
/** mutation root */
type MutationRootUpdateFungibleAssetActivitiesManyArgs = {
    updates: Array<FungibleAssetActivitiesUpdates>;
};
/** mutation root */
type MutationRootUpdateFungibleAssetBalancesArgs = {
    _inc?: InputMaybe<FungibleAssetBalancesIncInput>;
    _set?: InputMaybe<FungibleAssetBalancesSetInput>;
    where: FungibleAssetBalancesBoolExp;
};
/** mutation root */
type MutationRootUpdateFungibleAssetBalancesByPkArgs = {
    _inc?: InputMaybe<FungibleAssetBalancesIncInput>;
    _set?: InputMaybe<FungibleAssetBalancesSetInput>;
    pk_columns: FungibleAssetBalancesPkColumnsInput;
};
/** mutation root */
type MutationRootUpdateFungibleAssetBalancesManyArgs = {
    updates: Array<FungibleAssetBalancesUpdates>;
};
/** mutation root */
type MutationRootUpdateFungibleAssetMetadataArgs = {
    _inc?: InputMaybe<FungibleAssetMetadataIncInput>;
    _set?: InputMaybe<FungibleAssetMetadataSetInput>;
    where: FungibleAssetMetadataBoolExp;
};
/** mutation root */
type MutationRootUpdateFungibleAssetMetadataByPkArgs = {
    _inc?: InputMaybe<FungibleAssetMetadataIncInput>;
    _set?: InputMaybe<FungibleAssetMetadataSetInput>;
    pk_columns: FungibleAssetMetadataPkColumnsInput;
};
/** mutation root */
type MutationRootUpdateFungibleAssetMetadataManyArgs = {
    updates: Array<FungibleAssetMetadataUpdates>;
};
/** mutation root */
type MutationRootUpdateFungibleAssetToCoinMappingsArgs = {
    _inc?: InputMaybe<FungibleAssetToCoinMappingsIncInput>;
    _set?: InputMaybe<FungibleAssetToCoinMappingsSetInput>;
    where: FungibleAssetToCoinMappingsBoolExp;
};
/** mutation root */
type MutationRootUpdateFungibleAssetToCoinMappingsByPkArgs = {
    _inc?: InputMaybe<FungibleAssetToCoinMappingsIncInput>;
    _set?: InputMaybe<FungibleAssetToCoinMappingsSetInput>;
    pk_columns: FungibleAssetToCoinMappingsPkColumnsInput;
};
/** mutation root */
type MutationRootUpdateFungibleAssetToCoinMappingsManyArgs = {
    updates: Array<FungibleAssetToCoinMappingsUpdates>;
};
/** mutation root */
type MutationRootUpdateGasFeesArgs = {
    _inc?: InputMaybe<GasFeesIncInput>;
    _set?: InputMaybe<GasFeesSetInput>;
    where: GasFeesBoolExp;
};
/** mutation root */
type MutationRootUpdateGasFeesByPkArgs = {
    _inc?: InputMaybe<GasFeesIncInput>;
    _set?: InputMaybe<GasFeesSetInput>;
    pk_columns: GasFeesPkColumnsInput;
};
/** mutation root */
type MutationRootUpdateGasFeesManyArgs = {
    updates: Array<GasFeesUpdates>;
};
/** mutation root */
type MutationRootUpdateIndexerStatusArgs = {
    _set?: InputMaybe<IndexerStatusSetInput>;
    where: IndexerStatusBoolExp;
};
/** mutation root */
type MutationRootUpdateIndexerStatusByPkArgs = {
    _set?: InputMaybe<IndexerStatusSetInput>;
    pk_columns: IndexerStatusPkColumnsInput;
};
/** mutation root */
type MutationRootUpdateIndexerStatusManyArgs = {
    updates: Array<IndexerStatusUpdates>;
};
/** mutation root */
type MutationRootUpdateMoveModulesArgs = {
    _append?: InputMaybe<MoveModulesAppendInput>;
    _delete_at_path?: InputMaybe<MoveModulesDeleteAtPathInput>;
    _delete_elem?: InputMaybe<MoveModulesDeleteElemInput>;
    _delete_key?: InputMaybe<MoveModulesDeleteKeyInput>;
    _inc?: InputMaybe<MoveModulesIncInput>;
    _prepend?: InputMaybe<MoveModulesPrependInput>;
    _set?: InputMaybe<MoveModulesSetInput>;
    where: MoveModulesBoolExp;
};
/** mutation root */
type MutationRootUpdateMoveModulesByPkArgs = {
    _append?: InputMaybe<MoveModulesAppendInput>;
    _delete_at_path?: InputMaybe<MoveModulesDeleteAtPathInput>;
    _delete_elem?: InputMaybe<MoveModulesDeleteElemInput>;
    _delete_key?: InputMaybe<MoveModulesDeleteKeyInput>;
    _inc?: InputMaybe<MoveModulesIncInput>;
    _prepend?: InputMaybe<MoveModulesPrependInput>;
    _set?: InputMaybe<MoveModulesSetInput>;
    pk_columns: MoveModulesPkColumnsInput;
};
/** mutation root */
type MutationRootUpdateMoveModulesManyArgs = {
    updates: Array<MoveModulesUpdates>;
};
/** mutation root */
type MutationRootUpdateMoveResourcesArgs = {
    _append?: InputMaybe<MoveResourcesAppendInput>;
    _delete_at_path?: InputMaybe<MoveResourcesDeleteAtPathInput>;
    _delete_elem?: InputMaybe<MoveResourcesDeleteElemInput>;
    _delete_key?: InputMaybe<MoveResourcesDeleteKeyInput>;
    _inc?: InputMaybe<MoveResourcesIncInput>;
    _prepend?: InputMaybe<MoveResourcesPrependInput>;
    _set?: InputMaybe<MoveResourcesSetInput>;
    where: MoveResourcesBoolExp;
};
/** mutation root */
type MutationRootUpdateMoveResourcesByPkArgs = {
    _append?: InputMaybe<MoveResourcesAppendInput>;
    _delete_at_path?: InputMaybe<MoveResourcesDeleteAtPathInput>;
    _delete_elem?: InputMaybe<MoveResourcesDeleteElemInput>;
    _delete_key?: InputMaybe<MoveResourcesDeleteKeyInput>;
    _inc?: InputMaybe<MoveResourcesIncInput>;
    _prepend?: InputMaybe<MoveResourcesPrependInput>;
    _set?: InputMaybe<MoveResourcesSetInput>;
    pk_columns: MoveResourcesPkColumnsInput;
};
/** mutation root */
type MutationRootUpdateMoveResourcesManyArgs = {
    updates: Array<MoveResourcesUpdates>;
};
/** mutation root */
type MutationRootUpdateMoveResourcesViewArgs = {
    _append?: InputMaybe<MoveResourcesViewAppendInput>;
    _delete_at_path?: InputMaybe<MoveResourcesViewDeleteAtPathInput>;
    _delete_elem?: InputMaybe<MoveResourcesViewDeleteElemInput>;
    _delete_key?: InputMaybe<MoveResourcesViewDeleteKeyInput>;
    _inc?: InputMaybe<MoveResourcesViewIncInput>;
    _prepend?: InputMaybe<MoveResourcesViewPrependInput>;
    _set?: InputMaybe<MoveResourcesViewSetInput>;
    where: MoveResourcesViewBoolExp;
};
/** mutation root */
type MutationRootUpdateMoveResourcesViewManyArgs = {
    updates: Array<MoveResourcesViewUpdates>;
};
/** mutation root */
type MutationRootUpdateNftMetadataCrawlerParsedAssetUrisArgs = {
    _inc?: InputMaybe<NftMetadataCrawlerParsedAssetUrisIncInput>;
    _set?: InputMaybe<NftMetadataCrawlerParsedAssetUrisSetInput>;
    where: NftMetadataCrawlerParsedAssetUrisBoolExp;
};
/** mutation root */
type MutationRootUpdateNftMetadataCrawlerParsedAssetUrisByPkArgs = {
    _inc?: InputMaybe<NftMetadataCrawlerParsedAssetUrisIncInput>;
    _set?: InputMaybe<NftMetadataCrawlerParsedAssetUrisSetInput>;
    pk_columns: NftMetadataCrawlerParsedAssetUrisPkColumnsInput;
};
/** mutation root */
type MutationRootUpdateNftMetadataCrawlerParsedAssetUrisManyArgs = {
    updates: Array<NftMetadataCrawlerParsedAssetUrisUpdates>;
};
/** mutation root */
type MutationRootUpdateNftPointsArgs = {
    _inc?: InputMaybe<NftPointsIncInput>;
    _set?: InputMaybe<NftPointsSetInput>;
    where: NftPointsBoolExp;
};
/** mutation root */
type MutationRootUpdateNftPointsByPkArgs = {
    _inc?: InputMaybe<NftPointsIncInput>;
    _set?: InputMaybe<NftPointsSetInput>;
    pk_columns: NftPointsPkColumnsInput;
};
/** mutation root */
type MutationRootUpdateNftPointsManyArgs = {
    updates: Array<NftPointsUpdates>;
};
/** mutation root */
type MutationRootUpdateObjectsArgs = {
    _inc?: InputMaybe<ObjectsIncInput>;
    _set?: InputMaybe<ObjectsSetInput>;
    where: ObjectsBoolExp;
};
/** mutation root */
type MutationRootUpdateObjectsByPkArgs = {
    _inc?: InputMaybe<ObjectsIncInput>;
    _set?: InputMaybe<ObjectsSetInput>;
    pk_columns: ObjectsPkColumnsInput;
};
/** mutation root */
type MutationRootUpdateObjectsManyArgs = {
    updates: Array<ObjectsUpdates>;
};
/** mutation root */
type MutationRootUpdateProcessorMetadataProcessorStatusArgs = {
    _inc?: InputMaybe<ProcessorMetadataProcessorStatusIncInput>;
    _set?: InputMaybe<ProcessorMetadataProcessorStatusSetInput>;
    where: ProcessorMetadataProcessorStatusBoolExp;
};
/** mutation root */
type MutationRootUpdateProcessorMetadataProcessorStatusByPkArgs = {
    _inc?: InputMaybe<ProcessorMetadataProcessorStatusIncInput>;
    _set?: InputMaybe<ProcessorMetadataProcessorStatusSetInput>;
    pk_columns: ProcessorMetadataProcessorStatusPkColumnsInput;
};
/** mutation root */
type MutationRootUpdateProcessorMetadataProcessorStatusManyArgs = {
    updates: Array<ProcessorMetadataProcessorStatusUpdates>;
};
/** mutation root */
type MutationRootUpdateProcessorStatusArgs = {
    _inc?: InputMaybe<ProcessorStatusIncInput>;
    _set?: InputMaybe<ProcessorStatusSetInput>;
    where: ProcessorStatusBoolExp;
};
/** mutation root */
type MutationRootUpdateProcessorStatusByPkArgs = {
    _inc?: InputMaybe<ProcessorStatusIncInput>;
    _set?: InputMaybe<ProcessorStatusSetInput>;
    pk_columns: ProcessorStatusPkColumnsInput;
};
/** mutation root */
type MutationRootUpdateProcessorStatusManyArgs = {
    updates: Array<ProcessorStatusUpdates>;
};
/** mutation root */
type MutationRootUpdateProposalVotesArgs = {
    _inc?: InputMaybe<ProposalVotesIncInput>;
    _set?: InputMaybe<ProposalVotesSetInput>;
    where: ProposalVotesBoolExp;
};
/** mutation root */
type MutationRootUpdateProposalVotesByPkArgs = {
    _inc?: InputMaybe<ProposalVotesIncInput>;
    _set?: InputMaybe<ProposalVotesSetInput>;
    pk_columns: ProposalVotesPkColumnsInput;
};
/** mutation root */
type MutationRootUpdateProposalVotesManyArgs = {
    updates: Array<ProposalVotesUpdates>;
};
/** mutation root */
type MutationRootUpdatePublicKeyAuthKeysArgs = {
    _inc?: InputMaybe<PublicKeyAuthKeysIncInput>;
    _set?: InputMaybe<PublicKeyAuthKeysSetInput>;
    where: PublicKeyAuthKeysBoolExp;
};
/** mutation root */
type MutationRootUpdatePublicKeyAuthKeysByPkArgs = {
    _inc?: InputMaybe<PublicKeyAuthKeysIncInput>;
    _set?: InputMaybe<PublicKeyAuthKeysSetInput>;
    pk_columns: PublicKeyAuthKeysPkColumnsInput;
};
/** mutation root */
type MutationRootUpdatePublicKeyAuthKeysManyArgs = {
    updates: Array<PublicKeyAuthKeysUpdates>;
};
/** mutation root */
type MutationRootUpdateSignaturesArgs = {
    _append?: InputMaybe<SignaturesAppendInput>;
    _delete_at_path?: InputMaybe<SignaturesDeleteAtPathInput>;
    _delete_elem?: InputMaybe<SignaturesDeleteElemInput>;
    _delete_key?: InputMaybe<SignaturesDeleteKeyInput>;
    _inc?: InputMaybe<SignaturesIncInput>;
    _prepend?: InputMaybe<SignaturesPrependInput>;
    _set?: InputMaybe<SignaturesSetInput>;
    where: SignaturesBoolExp;
};
/** mutation root */
type MutationRootUpdateSignaturesByPkArgs = {
    _append?: InputMaybe<SignaturesAppendInput>;
    _delete_at_path?: InputMaybe<SignaturesDeleteAtPathInput>;
    _delete_elem?: InputMaybe<SignaturesDeleteElemInput>;
    _delete_key?: InputMaybe<SignaturesDeleteKeyInput>;
    _inc?: InputMaybe<SignaturesIncInput>;
    _prepend?: InputMaybe<SignaturesPrependInput>;
    _set?: InputMaybe<SignaturesSetInput>;
    pk_columns: SignaturesPkColumnsInput;
};
/** mutation root */
type MutationRootUpdateSignaturesManyArgs = {
    updates: Array<SignaturesUpdates>;
};
/** mutation root */
type MutationRootUpdateSpamAssetsArgs = {
    _set?: InputMaybe<SpamAssetsSetInput>;
    where: SpamAssetsBoolExp;
};
/** mutation root */
type MutationRootUpdateSpamAssetsByPkArgs = {
    _set?: InputMaybe<SpamAssetsSetInput>;
    pk_columns: SpamAssetsPkColumnsInput;
};
/** mutation root */
type MutationRootUpdateSpamAssetsManyArgs = {
    updates: Array<SpamAssetsUpdates>;
};
/** mutation root */
type MutationRootUpdateTableItemsArgs = {
    _append?: InputMaybe<TableItemsAppendInput>;
    _delete_at_path?: InputMaybe<TableItemsDeleteAtPathInput>;
    _delete_elem?: InputMaybe<TableItemsDeleteElemInput>;
    _delete_key?: InputMaybe<TableItemsDeleteKeyInput>;
    _inc?: InputMaybe<TableItemsIncInput>;
    _prepend?: InputMaybe<TableItemsPrependInput>;
    _set?: InputMaybe<TableItemsSetInput>;
    where: TableItemsBoolExp;
};
/** mutation root */
type MutationRootUpdateTableItemsByPkArgs = {
    _append?: InputMaybe<TableItemsAppendInput>;
    _delete_at_path?: InputMaybe<TableItemsDeleteAtPathInput>;
    _delete_elem?: InputMaybe<TableItemsDeleteElemInput>;
    _delete_key?: InputMaybe<TableItemsDeleteKeyInput>;
    _inc?: InputMaybe<TableItemsIncInput>;
    _prepend?: InputMaybe<TableItemsPrependInput>;
    _set?: InputMaybe<TableItemsSetInput>;
    pk_columns: TableItemsPkColumnsInput;
};
/** mutation root */
type MutationRootUpdateTableItemsManyArgs = {
    updates: Array<TableItemsUpdates>;
};
/** mutation root */
type MutationRootUpdateTableItemsViewArgs = {
    _inc?: InputMaybe<TableItemsViewIncInput>;
    _set?: InputMaybe<TableItemsViewSetInput>;
    where: TableItemsViewBoolExp;
};
/** mutation root */
type MutationRootUpdateTableItemsViewManyArgs = {
    updates: Array<TableItemsViewUpdates>;
};
/** mutation root */
type MutationRootUpdateTableMetadatasArgs = {
    _set?: InputMaybe<TableMetadatasSetInput>;
    where: TableMetadatasBoolExp;
};
/** mutation root */
type MutationRootUpdateTableMetadatasByPkArgs = {
    _set?: InputMaybe<TableMetadatasSetInput>;
    pk_columns: TableMetadatasPkColumnsInput;
};
/** mutation root */
type MutationRootUpdateTableMetadatasManyArgs = {
    updates: Array<TableMetadatasUpdates>;
};
/** mutation root */
type MutationRootUpdateTokenActivitiesArgs = {
    _inc?: InputMaybe<TokenActivitiesIncInput>;
    _set?: InputMaybe<TokenActivitiesSetInput>;
    where: TokenActivitiesBoolExp;
};
/** mutation root */
type MutationRootUpdateTokenActivitiesByPkArgs = {
    _inc?: InputMaybe<TokenActivitiesIncInput>;
    _set?: InputMaybe<TokenActivitiesSetInput>;
    pk_columns: TokenActivitiesPkColumnsInput;
};
/** mutation root */
type MutationRootUpdateTokenActivitiesManyArgs = {
    updates: Array<TokenActivitiesUpdates>;
};
/** mutation root */
type MutationRootUpdateTokenActivitiesV2Args = {
    _inc?: InputMaybe<TokenActivitiesV2IncInput>;
    _set?: InputMaybe<TokenActivitiesV2SetInput>;
    where: TokenActivitiesV2BoolExp;
};
/** mutation root */
type MutationRootUpdateTokenActivitiesV2ByPkArgs = {
    _inc?: InputMaybe<TokenActivitiesV2IncInput>;
    _set?: InputMaybe<TokenActivitiesV2SetInput>;
    pk_columns: TokenActivitiesV2PkColumnsInput;
};
/** mutation root */
type MutationRootUpdateTokenActivitiesV2ManyArgs = {
    updates: Array<TokenActivitiesV2Updates>;
};
/** mutation root */
type MutationRootUpdateTokenDatasArgs = {
    _append?: InputMaybe<TokenDatasAppendInput>;
    _delete_at_path?: InputMaybe<TokenDatasDeleteAtPathInput>;
    _delete_elem?: InputMaybe<TokenDatasDeleteElemInput>;
    _delete_key?: InputMaybe<TokenDatasDeleteKeyInput>;
    _inc?: InputMaybe<TokenDatasIncInput>;
    _prepend?: InputMaybe<TokenDatasPrependInput>;
    _set?: InputMaybe<TokenDatasSetInput>;
    where: TokenDatasBoolExp;
};
/** mutation root */
type MutationRootUpdateTokenDatasByPkArgs = {
    _append?: InputMaybe<TokenDatasAppendInput>;
    _delete_at_path?: InputMaybe<TokenDatasDeleteAtPathInput>;
    _delete_elem?: InputMaybe<TokenDatasDeleteElemInput>;
    _delete_key?: InputMaybe<TokenDatasDeleteKeyInput>;
    _inc?: InputMaybe<TokenDatasIncInput>;
    _prepend?: InputMaybe<TokenDatasPrependInput>;
    _set?: InputMaybe<TokenDatasSetInput>;
    pk_columns: TokenDatasPkColumnsInput;
};
/** mutation root */
type MutationRootUpdateTokenDatasManyArgs = {
    updates: Array<TokenDatasUpdates>;
};
/** mutation root */
type MutationRootUpdateTokenDatasV2Args = {
    _append?: InputMaybe<TokenDatasV2AppendInput>;
    _delete_at_path?: InputMaybe<TokenDatasV2DeleteAtPathInput>;
    _delete_elem?: InputMaybe<TokenDatasV2DeleteElemInput>;
    _delete_key?: InputMaybe<TokenDatasV2DeleteKeyInput>;
    _inc?: InputMaybe<TokenDatasV2IncInput>;
    _prepend?: InputMaybe<TokenDatasV2PrependInput>;
    _set?: InputMaybe<TokenDatasV2SetInput>;
    where: TokenDatasV2BoolExp;
};
/** mutation root */
type MutationRootUpdateTokenDatasV2ByPkArgs = {
    _append?: InputMaybe<TokenDatasV2AppendInput>;
    _delete_at_path?: InputMaybe<TokenDatasV2DeleteAtPathInput>;
    _delete_elem?: InputMaybe<TokenDatasV2DeleteElemInput>;
    _delete_key?: InputMaybe<TokenDatasV2DeleteKeyInput>;
    _inc?: InputMaybe<TokenDatasV2IncInput>;
    _prepend?: InputMaybe<TokenDatasV2PrependInput>;
    _set?: InputMaybe<TokenDatasV2SetInput>;
    pk_columns: TokenDatasV2PkColumnsInput;
};
/** mutation root */
type MutationRootUpdateTokenDatasV2ManyArgs = {
    updates: Array<TokenDatasV2Updates>;
};
/** mutation root */
type MutationRootUpdateTokenOwnershipsArgs = {
    _inc?: InputMaybe<TokenOwnershipsIncInput>;
    _set?: InputMaybe<TokenOwnershipsSetInput>;
    where: TokenOwnershipsBoolExp;
};
/** mutation root */
type MutationRootUpdateTokenOwnershipsByPkArgs = {
    _inc?: InputMaybe<TokenOwnershipsIncInput>;
    _set?: InputMaybe<TokenOwnershipsSetInput>;
    pk_columns: TokenOwnershipsPkColumnsInput;
};
/** mutation root */
type MutationRootUpdateTokenOwnershipsManyArgs = {
    updates: Array<TokenOwnershipsUpdates>;
};
/** mutation root */
type MutationRootUpdateTokenOwnershipsV2Args = {
    _append?: InputMaybe<TokenOwnershipsV2AppendInput>;
    _delete_at_path?: InputMaybe<TokenOwnershipsV2DeleteAtPathInput>;
    _delete_elem?: InputMaybe<TokenOwnershipsV2DeleteElemInput>;
    _delete_key?: InputMaybe<TokenOwnershipsV2DeleteKeyInput>;
    _inc?: InputMaybe<TokenOwnershipsV2IncInput>;
    _prepend?: InputMaybe<TokenOwnershipsV2PrependInput>;
    _set?: InputMaybe<TokenOwnershipsV2SetInput>;
    where: TokenOwnershipsV2BoolExp;
};
/** mutation root */
type MutationRootUpdateTokenOwnershipsV2ByPkArgs = {
    _append?: InputMaybe<TokenOwnershipsV2AppendInput>;
    _delete_at_path?: InputMaybe<TokenOwnershipsV2DeleteAtPathInput>;
    _delete_elem?: InputMaybe<TokenOwnershipsV2DeleteElemInput>;
    _delete_key?: InputMaybe<TokenOwnershipsV2DeleteKeyInput>;
    _inc?: InputMaybe<TokenOwnershipsV2IncInput>;
    _prepend?: InputMaybe<TokenOwnershipsV2PrependInput>;
    _set?: InputMaybe<TokenOwnershipsV2SetInput>;
    pk_columns: TokenOwnershipsV2PkColumnsInput;
};
/** mutation root */
type MutationRootUpdateTokenOwnershipsV2ManyArgs = {
    updates: Array<TokenOwnershipsV2Updates>;
};
/** mutation root */
type MutationRootUpdateTokensArgs = {
    _append?: InputMaybe<TokensAppendInput>;
    _delete_at_path?: InputMaybe<TokensDeleteAtPathInput>;
    _delete_elem?: InputMaybe<TokensDeleteElemInput>;
    _delete_key?: InputMaybe<TokensDeleteKeyInput>;
    _inc?: InputMaybe<TokensIncInput>;
    _prepend?: InputMaybe<TokensPrependInput>;
    _set?: InputMaybe<TokensSetInput>;
    where: TokensBoolExp;
};
/** mutation root */
type MutationRootUpdateTokensByPkArgs = {
    _append?: InputMaybe<TokensAppendInput>;
    _delete_at_path?: InputMaybe<TokensDeleteAtPathInput>;
    _delete_elem?: InputMaybe<TokensDeleteElemInput>;
    _delete_key?: InputMaybe<TokensDeleteKeyInput>;
    _inc?: InputMaybe<TokensIncInput>;
    _prepend?: InputMaybe<TokensPrependInput>;
    _set?: InputMaybe<TokensSetInput>;
    pk_columns: TokensPkColumnsInput;
};
/** mutation root */
type MutationRootUpdateTokensManyArgs = {
    updates: Array<TokensUpdates>;
};
/** mutation root */
type MutationRootUpdateTransactionSizeInfoArgs = {
    _inc?: InputMaybe<TransactionSizeInfoIncInput>;
    _set?: InputMaybe<TransactionSizeInfoSetInput>;
    where: TransactionSizeInfoBoolExp;
};
/** mutation root */
type MutationRootUpdateTransactionSizeInfoByPkArgs = {
    _inc?: InputMaybe<TransactionSizeInfoIncInput>;
    _set?: InputMaybe<TransactionSizeInfoSetInput>;
    pk_columns: TransactionSizeInfoPkColumnsInput;
};
/** mutation root */
type MutationRootUpdateTransactionSizeInfoManyArgs = {
    updates: Array<TransactionSizeInfoUpdates>;
};
/** mutation root */
type MutationRootUpdateTransactionsViewArgs = {
    _inc?: InputMaybe<TransactionsViewIncInput>;
    _set?: InputMaybe<TransactionsViewSetInput>;
    where: TransactionsViewBoolExp;
};
/** mutation root */
type MutationRootUpdateTransactionsViewManyArgs = {
    updates: Array<TransactionsViewUpdates>;
};
/** mutation root */
type MutationRootUpdateUserTransactionsArgs = {
    _inc?: InputMaybe<UserTransactionsIncInput>;
    _set?: InputMaybe<UserTransactionsSetInput>;
    where: UserTransactionsBoolExp;
};
/** mutation root */
type MutationRootUpdateUserTransactionsByPkArgs = {
    _inc?: InputMaybe<UserTransactionsIncInput>;
    _set?: InputMaybe<UserTransactionsSetInput>;
    pk_columns: UserTransactionsPkColumnsInput;
};
/** mutation root */
type MutationRootUpdateUserTransactionsManyArgs = {
    updates: Array<UserTransactionsUpdates>;
};
/** columns and relationships of "nft_metadata_crawler.parsed_asset_uris" */
type NftMetadataCrawlerParsedAssetUris = {
    animation_optimizer_retry_count: Scalars["Int"]["output"];
    asset_uri: Scalars["String"]["output"];
    cdn_animation_uri?: Maybe<Scalars["String"]["output"]>;
    cdn_image_uri?: Maybe<Scalars["String"]["output"]>;
    cdn_json_uri?: Maybe<Scalars["String"]["output"]>;
    image_optimizer_retry_count: Scalars["Int"]["output"];
    inserted_at: Scalars["timestamp"]["output"];
    json_parser_retry_count: Scalars["Int"]["output"];
    raw_animation_uri?: Maybe<Scalars["String"]["output"]>;
    raw_image_uri?: Maybe<Scalars["String"]["output"]>;
};
/** aggregated selection of "nft_metadata_crawler.parsed_asset_uris" */
type NftMetadataCrawlerParsedAssetUrisAggregate = {
    aggregate?: Maybe<NftMetadataCrawlerParsedAssetUrisAggregateFields>;
    nodes: Array<NftMetadataCrawlerParsedAssetUris>;
};
/** aggregate fields of "nft_metadata_crawler.parsed_asset_uris" */
type NftMetadataCrawlerParsedAssetUrisAggregateFields = {
    avg?: Maybe<NftMetadataCrawlerParsedAssetUrisAvgFields>;
    count: Scalars["Int"]["output"];
    max?: Maybe<NftMetadataCrawlerParsedAssetUrisMaxFields>;
    min?: Maybe<NftMetadataCrawlerParsedAssetUrisMinFields>;
    stddev?: Maybe<NftMetadataCrawlerParsedAssetUrisStddevFields>;
    stddev_pop?: Maybe<NftMetadataCrawlerParsedAssetUrisStddevPopFields>;
    stddev_samp?: Maybe<NftMetadataCrawlerParsedAssetUrisStddevSampFields>;
    sum?: Maybe<NftMetadataCrawlerParsedAssetUrisSumFields>;
    var_pop?: Maybe<NftMetadataCrawlerParsedAssetUrisVarPopFields>;
    var_samp?: Maybe<NftMetadataCrawlerParsedAssetUrisVarSampFields>;
    variance?: Maybe<NftMetadataCrawlerParsedAssetUrisVarianceFields>;
};
/** aggregate fields of "nft_metadata_crawler.parsed_asset_uris" */
type NftMetadataCrawlerParsedAssetUrisAggregateFieldsCountArgs = {
    columns?: InputMaybe<Array<NftMetadataCrawlerParsedAssetUrisSelectColumn>>;
    distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};
/** aggregate avg on columns */
type NftMetadataCrawlerParsedAssetUrisAvgFields = {
    animation_optimizer_retry_count?: Maybe<Scalars["Float"]["output"]>;
    image_optimizer_retry_count?: Maybe<Scalars["Float"]["output"]>;
    json_parser_retry_count?: Maybe<Scalars["Float"]["output"]>;
};
/** Boolean expression to filter rows from the table "nft_metadata_crawler.parsed_asset_uris". All fields are combined with a logical 'AND'. */
type NftMetadataCrawlerParsedAssetUrisBoolExp = {
    _and?: InputMaybe<Array<NftMetadataCrawlerParsedAssetUrisBoolExp>>;
    _not?: InputMaybe<NftMetadataCrawlerParsedAssetUrisBoolExp>;
    _or?: InputMaybe<Array<NftMetadataCrawlerParsedAssetUrisBoolExp>>;
    animation_optimizer_retry_count?: InputMaybe<IntComparisonExp>;
    asset_uri?: InputMaybe<StringComparisonExp>;
    cdn_animation_uri?: InputMaybe<StringComparisonExp>;
    cdn_image_uri?: InputMaybe<StringComparisonExp>;
    cdn_json_uri?: InputMaybe<StringComparisonExp>;
    image_optimizer_retry_count?: InputMaybe<IntComparisonExp>;
    inserted_at?: InputMaybe<TimestampComparisonExp>;
    json_parser_retry_count?: InputMaybe<IntComparisonExp>;
    raw_animation_uri?: InputMaybe<StringComparisonExp>;
    raw_image_uri?: InputMaybe<StringComparisonExp>;
};
/** unique or primary key constraints on table "nft_metadata_crawler.parsed_asset_uris" */
declare enum NftMetadataCrawlerParsedAssetUrisConstraint {
    /** unique or primary key constraint on columns "asset_uri" */
    ParsedAssetUrisPkey = "parsed_asset_uris_pkey"
}
/** input type for incrementing numeric columns in table "nft_metadata_crawler.parsed_asset_uris" */
type NftMetadataCrawlerParsedAssetUrisIncInput = {
    animation_optimizer_retry_count?: InputMaybe<Scalars["Int"]["input"]>;
    image_optimizer_retry_count?: InputMaybe<Scalars["Int"]["input"]>;
    json_parser_retry_count?: InputMaybe<Scalars["Int"]["input"]>;
};
/** input type for inserting data into table "nft_metadata_crawler.parsed_asset_uris" */
type NftMetadataCrawlerParsedAssetUrisInsertInput = {
    animation_optimizer_retry_count?: InputMaybe<Scalars["Int"]["input"]>;
    asset_uri?: InputMaybe<Scalars["String"]["input"]>;
    cdn_animation_uri?: InputMaybe<Scalars["String"]["input"]>;
    cdn_image_uri?: InputMaybe<Scalars["String"]["input"]>;
    cdn_json_uri?: InputMaybe<Scalars["String"]["input"]>;
    image_optimizer_retry_count?: InputMaybe<Scalars["Int"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    json_parser_retry_count?: InputMaybe<Scalars["Int"]["input"]>;
    raw_animation_uri?: InputMaybe<Scalars["String"]["input"]>;
    raw_image_uri?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregate max on columns */
type NftMetadataCrawlerParsedAssetUrisMaxFields = {
    animation_optimizer_retry_count?: Maybe<Scalars["Int"]["output"]>;
    asset_uri?: Maybe<Scalars["String"]["output"]>;
    cdn_animation_uri?: Maybe<Scalars["String"]["output"]>;
    cdn_image_uri?: Maybe<Scalars["String"]["output"]>;
    cdn_json_uri?: Maybe<Scalars["String"]["output"]>;
    image_optimizer_retry_count?: Maybe<Scalars["Int"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    json_parser_retry_count?: Maybe<Scalars["Int"]["output"]>;
    raw_animation_uri?: Maybe<Scalars["String"]["output"]>;
    raw_image_uri?: Maybe<Scalars["String"]["output"]>;
};
/** aggregate min on columns */
type NftMetadataCrawlerParsedAssetUrisMinFields = {
    animation_optimizer_retry_count?: Maybe<Scalars["Int"]["output"]>;
    asset_uri?: Maybe<Scalars["String"]["output"]>;
    cdn_animation_uri?: Maybe<Scalars["String"]["output"]>;
    cdn_image_uri?: Maybe<Scalars["String"]["output"]>;
    cdn_json_uri?: Maybe<Scalars["String"]["output"]>;
    image_optimizer_retry_count?: Maybe<Scalars["Int"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    json_parser_retry_count?: Maybe<Scalars["Int"]["output"]>;
    raw_animation_uri?: Maybe<Scalars["String"]["output"]>;
    raw_image_uri?: Maybe<Scalars["String"]["output"]>;
};
/** response of any mutation on the table "nft_metadata_crawler.parsed_asset_uris" */
type NftMetadataCrawlerParsedAssetUrisMutationResponse = {
    /** number of rows affected by the mutation */
    affected_rows: Scalars["Int"]["output"];
    /** data from the rows affected by the mutation */
    returning: Array<NftMetadataCrawlerParsedAssetUris>;
};
/** input type for inserting object relation for remote table "nft_metadata_crawler.parsed_asset_uris" */
type NftMetadataCrawlerParsedAssetUrisObjRelInsertInput = {
    data: NftMetadataCrawlerParsedAssetUrisInsertInput;
    /** upsert condition */
    on_conflict?: InputMaybe<NftMetadataCrawlerParsedAssetUrisOnConflict>;
};
/** on_conflict condition type for table "nft_metadata_crawler.parsed_asset_uris" */
type NftMetadataCrawlerParsedAssetUrisOnConflict = {
    constraint: NftMetadataCrawlerParsedAssetUrisConstraint;
    update_columns?: Array<NftMetadataCrawlerParsedAssetUrisUpdateColumn>;
    where?: InputMaybe<NftMetadataCrawlerParsedAssetUrisBoolExp>;
};
/** Ordering options when selecting data from "nft_metadata_crawler.parsed_asset_uris". */
type NftMetadataCrawlerParsedAssetUrisOrderBy = {
    animation_optimizer_retry_count?: InputMaybe<OrderBy>;
    asset_uri?: InputMaybe<OrderBy>;
    cdn_animation_uri?: InputMaybe<OrderBy>;
    cdn_image_uri?: InputMaybe<OrderBy>;
    cdn_json_uri?: InputMaybe<OrderBy>;
    image_optimizer_retry_count?: InputMaybe<OrderBy>;
    inserted_at?: InputMaybe<OrderBy>;
    json_parser_retry_count?: InputMaybe<OrderBy>;
    raw_animation_uri?: InputMaybe<OrderBy>;
    raw_image_uri?: InputMaybe<OrderBy>;
};
/** primary key columns input for table: nft_metadata_crawler.parsed_asset_uris */
type NftMetadataCrawlerParsedAssetUrisPkColumnsInput = {
    asset_uri: Scalars["String"]["input"];
};
/** select columns of table "nft_metadata_crawler.parsed_asset_uris" */
declare enum NftMetadataCrawlerParsedAssetUrisSelectColumn {
    /** column name */
    AnimationOptimizerRetryCount = "animation_optimizer_retry_count",
    /** column name */
    AssetUri = "asset_uri",
    /** column name */
    CdnAnimationUri = "cdn_animation_uri",
    /** column name */
    CdnImageUri = "cdn_image_uri",
    /** column name */
    CdnJsonUri = "cdn_json_uri",
    /** column name */
    ImageOptimizerRetryCount = "image_optimizer_retry_count",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    JsonParserRetryCount = "json_parser_retry_count",
    /** column name */
    RawAnimationUri = "raw_animation_uri",
    /** column name */
    RawImageUri = "raw_image_uri"
}
/** input type for updating data in table "nft_metadata_crawler.parsed_asset_uris" */
type NftMetadataCrawlerParsedAssetUrisSetInput = {
    animation_optimizer_retry_count?: InputMaybe<Scalars["Int"]["input"]>;
    asset_uri?: InputMaybe<Scalars["String"]["input"]>;
    cdn_animation_uri?: InputMaybe<Scalars["String"]["input"]>;
    cdn_image_uri?: InputMaybe<Scalars["String"]["input"]>;
    cdn_json_uri?: InputMaybe<Scalars["String"]["input"]>;
    image_optimizer_retry_count?: InputMaybe<Scalars["Int"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    json_parser_retry_count?: InputMaybe<Scalars["Int"]["input"]>;
    raw_animation_uri?: InputMaybe<Scalars["String"]["input"]>;
    raw_image_uri?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregate stddev on columns */
type NftMetadataCrawlerParsedAssetUrisStddevFields = {
    animation_optimizer_retry_count?: Maybe<Scalars["Float"]["output"]>;
    image_optimizer_retry_count?: Maybe<Scalars["Float"]["output"]>;
    json_parser_retry_count?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_pop on columns */
type NftMetadataCrawlerParsedAssetUrisStddevPopFields = {
    animation_optimizer_retry_count?: Maybe<Scalars["Float"]["output"]>;
    image_optimizer_retry_count?: Maybe<Scalars["Float"]["output"]>;
    json_parser_retry_count?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_samp on columns */
type NftMetadataCrawlerParsedAssetUrisStddevSampFields = {
    animation_optimizer_retry_count?: Maybe<Scalars["Float"]["output"]>;
    image_optimizer_retry_count?: Maybe<Scalars["Float"]["output"]>;
    json_parser_retry_count?: Maybe<Scalars["Float"]["output"]>;
};
/** Streaming cursor of the table "nft_metadata_crawler_parsed_asset_uris" */
type NftMetadataCrawlerParsedAssetUrisStreamCursorInput = {
    /** Stream column input with initial value */
    initial_value: NftMetadataCrawlerParsedAssetUrisStreamCursorValueInput;
    /** cursor ordering */
    ordering?: InputMaybe<CursorOrdering>;
};
/** Initial value of the column from where the streaming should start */
type NftMetadataCrawlerParsedAssetUrisStreamCursorValueInput = {
    animation_optimizer_retry_count?: InputMaybe<Scalars["Int"]["input"]>;
    asset_uri?: InputMaybe<Scalars["String"]["input"]>;
    cdn_animation_uri?: InputMaybe<Scalars["String"]["input"]>;
    cdn_image_uri?: InputMaybe<Scalars["String"]["input"]>;
    cdn_json_uri?: InputMaybe<Scalars["String"]["input"]>;
    image_optimizer_retry_count?: InputMaybe<Scalars["Int"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    json_parser_retry_count?: InputMaybe<Scalars["Int"]["input"]>;
    raw_animation_uri?: InputMaybe<Scalars["String"]["input"]>;
    raw_image_uri?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregate sum on columns */
type NftMetadataCrawlerParsedAssetUrisSumFields = {
    animation_optimizer_retry_count?: Maybe<Scalars["Int"]["output"]>;
    image_optimizer_retry_count?: Maybe<Scalars["Int"]["output"]>;
    json_parser_retry_count?: Maybe<Scalars["Int"]["output"]>;
};
/** update columns of table "nft_metadata_crawler.parsed_asset_uris" */
declare enum NftMetadataCrawlerParsedAssetUrisUpdateColumn {
    /** column name */
    AnimationOptimizerRetryCount = "animation_optimizer_retry_count",
    /** column name */
    AssetUri = "asset_uri",
    /** column name */
    CdnAnimationUri = "cdn_animation_uri",
    /** column name */
    CdnImageUri = "cdn_image_uri",
    /** column name */
    CdnJsonUri = "cdn_json_uri",
    /** column name */
    ImageOptimizerRetryCount = "image_optimizer_retry_count",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    JsonParserRetryCount = "json_parser_retry_count",
    /** column name */
    RawAnimationUri = "raw_animation_uri",
    /** column name */
    RawImageUri = "raw_image_uri"
}
type NftMetadataCrawlerParsedAssetUrisUpdates = {
    /** increments the numeric columns with given value of the filtered values */
    _inc?: InputMaybe<NftMetadataCrawlerParsedAssetUrisIncInput>;
    /** sets the columns of the filtered rows to the given values */
    _set?: InputMaybe<NftMetadataCrawlerParsedAssetUrisSetInput>;
    /** filter the rows which have to be updated */
    where: NftMetadataCrawlerParsedAssetUrisBoolExp;
};
/** aggregate var_pop on columns */
type NftMetadataCrawlerParsedAssetUrisVarPopFields = {
    animation_optimizer_retry_count?: Maybe<Scalars["Float"]["output"]>;
    image_optimizer_retry_count?: Maybe<Scalars["Float"]["output"]>;
    json_parser_retry_count?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate var_samp on columns */
type NftMetadataCrawlerParsedAssetUrisVarSampFields = {
    animation_optimizer_retry_count?: Maybe<Scalars["Float"]["output"]>;
    image_optimizer_retry_count?: Maybe<Scalars["Float"]["output"]>;
    json_parser_retry_count?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate variance on columns */
type NftMetadataCrawlerParsedAssetUrisVarianceFields = {
    animation_optimizer_retry_count?: Maybe<Scalars["Float"]["output"]>;
    image_optimizer_retry_count?: Maybe<Scalars["Float"]["output"]>;
    json_parser_retry_count?: Maybe<Scalars["Float"]["output"]>;
};
/** columns and relationships of "nft_points" */
type NftPoints = {
    amount: Scalars["numeric"]["output"];
    inserted_at: Scalars["timestamp"]["output"];
    owner_address: Scalars["String"]["output"];
    point_type: Scalars["String"]["output"];
    token_name: Scalars["String"]["output"];
    transaction_timestamp: Scalars["timestamp"]["output"];
    transaction_version: Scalars["bigint"]["output"];
};
/** aggregated selection of "nft_points" */
type NftPointsAggregate = {
    aggregate?: Maybe<NftPointsAggregateFields>;
    nodes: Array<NftPoints>;
};
/** aggregate fields of "nft_points" */
type NftPointsAggregateFields = {
    avg?: Maybe<NftPointsAvgFields>;
    count: Scalars["Int"]["output"];
    max?: Maybe<NftPointsMaxFields>;
    min?: Maybe<NftPointsMinFields>;
    stddev?: Maybe<NftPointsStddevFields>;
    stddev_pop?: Maybe<NftPointsStddevPopFields>;
    stddev_samp?: Maybe<NftPointsStddevSampFields>;
    sum?: Maybe<NftPointsSumFields>;
    var_pop?: Maybe<NftPointsVarPopFields>;
    var_samp?: Maybe<NftPointsVarSampFields>;
    variance?: Maybe<NftPointsVarianceFields>;
};
/** aggregate fields of "nft_points" */
type NftPointsAggregateFieldsCountArgs = {
    columns?: InputMaybe<Array<NftPointsSelectColumn>>;
    distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};
/** aggregate avg on columns */
type NftPointsAvgFields = {
    amount?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** Boolean expression to filter rows from the table "nft_points". All fields are combined with a logical 'AND'. */
type NftPointsBoolExp = {
    _and?: InputMaybe<Array<NftPointsBoolExp>>;
    _not?: InputMaybe<NftPointsBoolExp>;
    _or?: InputMaybe<Array<NftPointsBoolExp>>;
    amount?: InputMaybe<NumericComparisonExp>;
    inserted_at?: InputMaybe<TimestampComparisonExp>;
    owner_address?: InputMaybe<StringComparisonExp>;
    point_type?: InputMaybe<StringComparisonExp>;
    token_name?: InputMaybe<StringComparisonExp>;
    transaction_timestamp?: InputMaybe<TimestampComparisonExp>;
    transaction_version?: InputMaybe<BigintComparisonExp>;
};
/** unique or primary key constraints on table "nft_points" */
declare enum NftPointsConstraint {
    /** unique or primary key constraint on columns "transaction_version" */
    NftPointsPkey = "nft_points_pkey"
}
/** input type for incrementing numeric columns in table "nft_points" */
type NftPointsIncInput = {
    amount?: InputMaybe<Scalars["numeric"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** input type for inserting data into table "nft_points" */
type NftPointsInsertInput = {
    amount?: InputMaybe<Scalars["numeric"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    owner_address?: InputMaybe<Scalars["String"]["input"]>;
    point_type?: InputMaybe<Scalars["String"]["input"]>;
    token_name?: InputMaybe<Scalars["String"]["input"]>;
    transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** aggregate max on columns */
type NftPointsMaxFields = {
    amount?: Maybe<Scalars["numeric"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    owner_address?: Maybe<Scalars["String"]["output"]>;
    point_type?: Maybe<Scalars["String"]["output"]>;
    token_name?: Maybe<Scalars["String"]["output"]>;
    transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};
/** aggregate min on columns */
type NftPointsMinFields = {
    amount?: Maybe<Scalars["numeric"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    owner_address?: Maybe<Scalars["String"]["output"]>;
    point_type?: Maybe<Scalars["String"]["output"]>;
    token_name?: Maybe<Scalars["String"]["output"]>;
    transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};
/** response of any mutation on the table "nft_points" */
type NftPointsMutationResponse = {
    /** number of rows affected by the mutation */
    affected_rows: Scalars["Int"]["output"];
    /** data from the rows affected by the mutation */
    returning: Array<NftPoints>;
};
/** on_conflict condition type for table "nft_points" */
type NftPointsOnConflict = {
    constraint: NftPointsConstraint;
    update_columns?: Array<NftPointsUpdateColumn>;
    where?: InputMaybe<NftPointsBoolExp>;
};
/** Ordering options when selecting data from "nft_points". */
type NftPointsOrderBy = {
    amount?: InputMaybe<OrderBy>;
    inserted_at?: InputMaybe<OrderBy>;
    owner_address?: InputMaybe<OrderBy>;
    point_type?: InputMaybe<OrderBy>;
    token_name?: InputMaybe<OrderBy>;
    transaction_timestamp?: InputMaybe<OrderBy>;
    transaction_version?: InputMaybe<OrderBy>;
};
/** primary key columns input for table: nft_points */
type NftPointsPkColumnsInput = {
    transaction_version: Scalars["bigint"]["input"];
};
/** select columns of table "nft_points" */
declare enum NftPointsSelectColumn {
    /** column name */
    Amount = "amount",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    OwnerAddress = "owner_address",
    /** column name */
    PointType = "point_type",
    /** column name */
    TokenName = "token_name",
    /** column name */
    TransactionTimestamp = "transaction_timestamp",
    /** column name */
    TransactionVersion = "transaction_version"
}
/** input type for updating data in table "nft_points" */
type NftPointsSetInput = {
    amount?: InputMaybe<Scalars["numeric"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    owner_address?: InputMaybe<Scalars["String"]["input"]>;
    point_type?: InputMaybe<Scalars["String"]["input"]>;
    token_name?: InputMaybe<Scalars["String"]["input"]>;
    transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** aggregate stddev on columns */
type NftPointsStddevFields = {
    amount?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_pop on columns */
type NftPointsStddevPopFields = {
    amount?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_samp on columns */
type NftPointsStddevSampFields = {
    amount?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** Streaming cursor of the table "nft_points" */
type NftPointsStreamCursorInput = {
    /** Stream column input with initial value */
    initial_value: NftPointsStreamCursorValueInput;
    /** cursor ordering */
    ordering?: InputMaybe<CursorOrdering>;
};
/** Initial value of the column from where the streaming should start */
type NftPointsStreamCursorValueInput = {
    amount?: InputMaybe<Scalars["numeric"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    owner_address?: InputMaybe<Scalars["String"]["input"]>;
    point_type?: InputMaybe<Scalars["String"]["input"]>;
    token_name?: InputMaybe<Scalars["String"]["input"]>;
    transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** aggregate sum on columns */
type NftPointsSumFields = {
    amount?: Maybe<Scalars["numeric"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};
/** update columns of table "nft_points" */
declare enum NftPointsUpdateColumn {
    /** column name */
    Amount = "amount",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    OwnerAddress = "owner_address",
    /** column name */
    PointType = "point_type",
    /** column name */
    TokenName = "token_name",
    /** column name */
    TransactionTimestamp = "transaction_timestamp",
    /** column name */
    TransactionVersion = "transaction_version"
}
type NftPointsUpdates = {
    /** increments the numeric columns with given value of the filtered values */
    _inc?: InputMaybe<NftPointsIncInput>;
    /** sets the columns of the filtered rows to the given values */
    _set?: InputMaybe<NftPointsSetInput>;
    /** filter the rows which have to be updated */
    where: NftPointsBoolExp;
};
/** aggregate var_pop on columns */
type NftPointsVarPopFields = {
    amount?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate var_samp on columns */
type NftPointsVarSampFields = {
    amount?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate variance on columns */
type NftPointsVarianceFields = {
    amount?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** columns and relationships of "num_active_delegator_per_pool" */
type NumActiveDelegatorPerPool = {
    num_active_delegator?: Maybe<Scalars["bigint"]["output"]>;
    pool_address?: Maybe<Scalars["String"]["output"]>;
};
/** aggregated selection of "num_active_delegator_per_pool" */
type NumActiveDelegatorPerPoolAggregate = {
    aggregate?: Maybe<NumActiveDelegatorPerPoolAggregateFields>;
    nodes: Array<NumActiveDelegatorPerPool>;
};
/** aggregate fields of "num_active_delegator_per_pool" */
type NumActiveDelegatorPerPoolAggregateFields = {
    avg?: Maybe<NumActiveDelegatorPerPoolAvgFields>;
    count: Scalars["Int"]["output"];
    max?: Maybe<NumActiveDelegatorPerPoolMaxFields>;
    min?: Maybe<NumActiveDelegatorPerPoolMinFields>;
    stddev?: Maybe<NumActiveDelegatorPerPoolStddevFields>;
    stddev_pop?: Maybe<NumActiveDelegatorPerPoolStddevPopFields>;
    stddev_samp?: Maybe<NumActiveDelegatorPerPoolStddevSampFields>;
    sum?: Maybe<NumActiveDelegatorPerPoolSumFields>;
    var_pop?: Maybe<NumActiveDelegatorPerPoolVarPopFields>;
    var_samp?: Maybe<NumActiveDelegatorPerPoolVarSampFields>;
    variance?: Maybe<NumActiveDelegatorPerPoolVarianceFields>;
};
/** aggregate fields of "num_active_delegator_per_pool" */
type NumActiveDelegatorPerPoolAggregateFieldsCountArgs = {
    columns?: InputMaybe<Array<NumActiveDelegatorPerPoolSelectColumn>>;
    distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};
/** aggregate avg on columns */
type NumActiveDelegatorPerPoolAvgFields = {
    num_active_delegator?: Maybe<Scalars["Float"]["output"]>;
};
/** Boolean expression to filter rows from the table "num_active_delegator_per_pool". All fields are combined with a logical 'AND'. */
type NumActiveDelegatorPerPoolBoolExp = {
    _and?: InputMaybe<Array<NumActiveDelegatorPerPoolBoolExp>>;
    _not?: InputMaybe<NumActiveDelegatorPerPoolBoolExp>;
    _or?: InputMaybe<Array<NumActiveDelegatorPerPoolBoolExp>>;
    num_active_delegator?: InputMaybe<BigintComparisonExp>;
    pool_address?: InputMaybe<StringComparisonExp>;
};
/** aggregate max on columns */
type NumActiveDelegatorPerPoolMaxFields = {
    num_active_delegator?: Maybe<Scalars["bigint"]["output"]>;
    pool_address?: Maybe<Scalars["String"]["output"]>;
};
/** aggregate min on columns */
type NumActiveDelegatorPerPoolMinFields = {
    num_active_delegator?: Maybe<Scalars["bigint"]["output"]>;
    pool_address?: Maybe<Scalars["String"]["output"]>;
};
/** Ordering options when selecting data from "num_active_delegator_per_pool". */
type NumActiveDelegatorPerPoolOrderBy = {
    num_active_delegator?: InputMaybe<OrderBy>;
    pool_address?: InputMaybe<OrderBy>;
};
/** select columns of table "num_active_delegator_per_pool" */
declare enum NumActiveDelegatorPerPoolSelectColumn {
    /** column name */
    NumActiveDelegator = "num_active_delegator",
    /** column name */
    PoolAddress = "pool_address"
}
/** aggregate stddev on columns */
type NumActiveDelegatorPerPoolStddevFields = {
    num_active_delegator?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_pop on columns */
type NumActiveDelegatorPerPoolStddevPopFields = {
    num_active_delegator?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_samp on columns */
type NumActiveDelegatorPerPoolStddevSampFields = {
    num_active_delegator?: Maybe<Scalars["Float"]["output"]>;
};
/** Streaming cursor of the table "num_active_delegator_per_pool" */
type NumActiveDelegatorPerPoolStreamCursorInput = {
    /** Stream column input with initial value */
    initial_value: NumActiveDelegatorPerPoolStreamCursorValueInput;
    /** cursor ordering */
    ordering?: InputMaybe<CursorOrdering>;
};
/** Initial value of the column from where the streaming should start */
type NumActiveDelegatorPerPoolStreamCursorValueInput = {
    num_active_delegator?: InputMaybe<Scalars["bigint"]["input"]>;
    pool_address?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregate sum on columns */
type NumActiveDelegatorPerPoolSumFields = {
    num_active_delegator?: Maybe<Scalars["bigint"]["output"]>;
};
/** aggregate var_pop on columns */
type NumActiveDelegatorPerPoolVarPopFields = {
    num_active_delegator?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate var_samp on columns */
type NumActiveDelegatorPerPoolVarSampFields = {
    num_active_delegator?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate variance on columns */
type NumActiveDelegatorPerPoolVarianceFields = {
    num_active_delegator?: Maybe<Scalars["Float"]["output"]>;
};
/** Boolean expression to compare columns of type "numeric". All fields are combined with logical 'AND'. */
type NumericComparisonExp = {
    _eq?: InputMaybe<Scalars["numeric"]["input"]>;
    _gt?: InputMaybe<Scalars["numeric"]["input"]>;
    _gte?: InputMaybe<Scalars["numeric"]["input"]>;
    _in?: InputMaybe<Array<Scalars["numeric"]["input"]>>;
    _is_null?: InputMaybe<Scalars["Boolean"]["input"]>;
    _lt?: InputMaybe<Scalars["numeric"]["input"]>;
    _lte?: InputMaybe<Scalars["numeric"]["input"]>;
    _neq?: InputMaybe<Scalars["numeric"]["input"]>;
    _nin?: InputMaybe<Array<Scalars["numeric"]["input"]>>;
};
/** columns and relationships of "objects" */
type Objects = {
    allow_ungated_transfer: Scalars["Boolean"]["output"];
    guid_creation_num: Scalars["numeric"]["output"];
    inserted_at: Scalars["timestamp"]["output"];
    is_deleted: Scalars["Boolean"]["output"];
    object_address: Scalars["String"]["output"];
    owner_address: Scalars["String"]["output"];
    state_key_hash: Scalars["String"]["output"];
    transaction_version: Scalars["bigint"]["output"];
    untransferrable: Scalars["Boolean"]["output"];
    write_set_change_index: Scalars["bigint"]["output"];
};
/** aggregated selection of "objects" */
type ObjectsAggregate = {
    aggregate?: Maybe<ObjectsAggregateFields>;
    nodes: Array<Objects>;
};
/** aggregate fields of "objects" */
type ObjectsAggregateFields = {
    avg?: Maybe<ObjectsAvgFields>;
    count: Scalars["Int"]["output"];
    max?: Maybe<ObjectsMaxFields>;
    min?: Maybe<ObjectsMinFields>;
    stddev?: Maybe<ObjectsStddevFields>;
    stddev_pop?: Maybe<ObjectsStddevPopFields>;
    stddev_samp?: Maybe<ObjectsStddevSampFields>;
    sum?: Maybe<ObjectsSumFields>;
    var_pop?: Maybe<ObjectsVarPopFields>;
    var_samp?: Maybe<ObjectsVarSampFields>;
    variance?: Maybe<ObjectsVarianceFields>;
};
/** aggregate fields of "objects" */
type ObjectsAggregateFieldsCountArgs = {
    columns?: InputMaybe<Array<ObjectsSelectColumn>>;
    distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};
/** aggregate avg on columns */
type ObjectsAvgFields = {
    guid_creation_num?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};
/** Boolean expression to filter rows from the table "objects". All fields are combined with a logical 'AND'. */
type ObjectsBoolExp = {
    _and?: InputMaybe<Array<ObjectsBoolExp>>;
    _not?: InputMaybe<ObjectsBoolExp>;
    _or?: InputMaybe<Array<ObjectsBoolExp>>;
    allow_ungated_transfer?: InputMaybe<BooleanComparisonExp>;
    guid_creation_num?: InputMaybe<NumericComparisonExp>;
    inserted_at?: InputMaybe<TimestampComparisonExp>;
    is_deleted?: InputMaybe<BooleanComparisonExp>;
    object_address?: InputMaybe<StringComparisonExp>;
    owner_address?: InputMaybe<StringComparisonExp>;
    state_key_hash?: InputMaybe<StringComparisonExp>;
    transaction_version?: InputMaybe<BigintComparisonExp>;
    untransferrable?: InputMaybe<BooleanComparisonExp>;
    write_set_change_index?: InputMaybe<BigintComparisonExp>;
};
/** unique or primary key constraints on table "objects" */
declare enum ObjectsConstraint {
    /** unique or primary key constraint on columns "write_set_change_index", "transaction_version" */
    ObjectsPkey = "objects_pkey"
}
/** input type for incrementing numeric columns in table "objects" */
type ObjectsIncInput = {
    guid_creation_num?: InputMaybe<Scalars["numeric"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** input type for inserting data into table "objects" */
type ObjectsInsertInput = {
    allow_ungated_transfer?: InputMaybe<Scalars["Boolean"]["input"]>;
    guid_creation_num?: InputMaybe<Scalars["numeric"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    is_deleted?: InputMaybe<Scalars["Boolean"]["input"]>;
    object_address?: InputMaybe<Scalars["String"]["input"]>;
    owner_address?: InputMaybe<Scalars["String"]["input"]>;
    state_key_hash?: InputMaybe<Scalars["String"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    untransferrable?: InputMaybe<Scalars["Boolean"]["input"]>;
    write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** aggregate max on columns */
type ObjectsMaxFields = {
    guid_creation_num?: Maybe<Scalars["numeric"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    object_address?: Maybe<Scalars["String"]["output"]>;
    owner_address?: Maybe<Scalars["String"]["output"]>;
    state_key_hash?: Maybe<Scalars["String"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    write_set_change_index?: Maybe<Scalars["bigint"]["output"]>;
};
/** aggregate min on columns */
type ObjectsMinFields = {
    guid_creation_num?: Maybe<Scalars["numeric"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    object_address?: Maybe<Scalars["String"]["output"]>;
    owner_address?: Maybe<Scalars["String"]["output"]>;
    state_key_hash?: Maybe<Scalars["String"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    write_set_change_index?: Maybe<Scalars["bigint"]["output"]>;
};
/** response of any mutation on the table "objects" */
type ObjectsMutationResponse = {
    /** number of rows affected by the mutation */
    affected_rows: Scalars["Int"]["output"];
    /** data from the rows affected by the mutation */
    returning: Array<Objects>;
};
/** on_conflict condition type for table "objects" */
type ObjectsOnConflict = {
    constraint: ObjectsConstraint;
    update_columns?: Array<ObjectsUpdateColumn>;
    where?: InputMaybe<ObjectsBoolExp>;
};
/** Ordering options when selecting data from "objects". */
type ObjectsOrderBy = {
    allow_ungated_transfer?: InputMaybe<OrderBy>;
    guid_creation_num?: InputMaybe<OrderBy>;
    inserted_at?: InputMaybe<OrderBy>;
    is_deleted?: InputMaybe<OrderBy>;
    object_address?: InputMaybe<OrderBy>;
    owner_address?: InputMaybe<OrderBy>;
    state_key_hash?: InputMaybe<OrderBy>;
    transaction_version?: InputMaybe<OrderBy>;
    untransferrable?: InputMaybe<OrderBy>;
    write_set_change_index?: InputMaybe<OrderBy>;
};
/** primary key columns input for table: objects */
type ObjectsPkColumnsInput = {
    transaction_version: Scalars["bigint"]["input"];
    write_set_change_index: Scalars["bigint"]["input"];
};
/** select columns of table "objects" */
declare enum ObjectsSelectColumn {
    /** column name */
    AllowUngatedTransfer = "allow_ungated_transfer",
    /** column name */
    GuidCreationNum = "guid_creation_num",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    IsDeleted = "is_deleted",
    /** column name */
    ObjectAddress = "object_address",
    /** column name */
    OwnerAddress = "owner_address",
    /** column name */
    StateKeyHash = "state_key_hash",
    /** column name */
    TransactionVersion = "transaction_version",
    /** column name */
    Untransferrable = "untransferrable",
    /** column name */
    WriteSetChangeIndex = "write_set_change_index"
}
/** input type for updating data in table "objects" */
type ObjectsSetInput = {
    allow_ungated_transfer?: InputMaybe<Scalars["Boolean"]["input"]>;
    guid_creation_num?: InputMaybe<Scalars["numeric"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    is_deleted?: InputMaybe<Scalars["Boolean"]["input"]>;
    object_address?: InputMaybe<Scalars["String"]["input"]>;
    owner_address?: InputMaybe<Scalars["String"]["input"]>;
    state_key_hash?: InputMaybe<Scalars["String"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    untransferrable?: InputMaybe<Scalars["Boolean"]["input"]>;
    write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** aggregate stddev on columns */
type ObjectsStddevFields = {
    guid_creation_num?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_pop on columns */
type ObjectsStddevPopFields = {
    guid_creation_num?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_samp on columns */
type ObjectsStddevSampFields = {
    guid_creation_num?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};
/** Streaming cursor of the table "objects" */
type ObjectsStreamCursorInput = {
    /** Stream column input with initial value */
    initial_value: ObjectsStreamCursorValueInput;
    /** cursor ordering */
    ordering?: InputMaybe<CursorOrdering>;
};
/** Initial value of the column from where the streaming should start */
type ObjectsStreamCursorValueInput = {
    allow_ungated_transfer?: InputMaybe<Scalars["Boolean"]["input"]>;
    guid_creation_num?: InputMaybe<Scalars["numeric"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    is_deleted?: InputMaybe<Scalars["Boolean"]["input"]>;
    object_address?: InputMaybe<Scalars["String"]["input"]>;
    owner_address?: InputMaybe<Scalars["String"]["input"]>;
    state_key_hash?: InputMaybe<Scalars["String"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    untransferrable?: InputMaybe<Scalars["Boolean"]["input"]>;
    write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** aggregate sum on columns */
type ObjectsSumFields = {
    guid_creation_num?: Maybe<Scalars["numeric"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    write_set_change_index?: Maybe<Scalars["bigint"]["output"]>;
};
/** update columns of table "objects" */
declare enum ObjectsUpdateColumn {
    /** column name */
    AllowUngatedTransfer = "allow_ungated_transfer",
    /** column name */
    GuidCreationNum = "guid_creation_num",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    IsDeleted = "is_deleted",
    /** column name */
    ObjectAddress = "object_address",
    /** column name */
    OwnerAddress = "owner_address",
    /** column name */
    StateKeyHash = "state_key_hash",
    /** column name */
    TransactionVersion = "transaction_version",
    /** column name */
    Untransferrable = "untransferrable",
    /** column name */
    WriteSetChangeIndex = "write_set_change_index"
}
type ObjectsUpdates = {
    /** increments the numeric columns with given value of the filtered values */
    _inc?: InputMaybe<ObjectsIncInput>;
    /** sets the columns of the filtered rows to the given values */
    _set?: InputMaybe<ObjectsSetInput>;
    /** filter the rows which have to be updated */
    where: ObjectsBoolExp;
};
/** aggregate var_pop on columns */
type ObjectsVarPopFields = {
    guid_creation_num?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate var_samp on columns */
type ObjectsVarSampFields = {
    guid_creation_num?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate variance on columns */
type ObjectsVarianceFields = {
    guid_creation_num?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};
/** column ordering options */
declare enum OrderBy {
    /** in ascending order, nulls last */
    Asc = "asc",
    /** in ascending order, nulls first */
    AscNullsFirst = "asc_nulls_first",
    /** in ascending order, nulls last */
    AscNullsLast = "asc_nulls_last",
    /** in descending order, nulls first */
    Desc = "desc",
    /** in descending order, nulls first */
    DescNullsFirst = "desc_nulls_first",
    /** in descending order, nulls last */
    DescNullsLast = "desc_nulls_last"
}
/** columns and relationships of "processor_metadata.processor_status" */
type ProcessorMetadataProcessorStatus = {
    last_success_version: Scalars["bigint"]["output"];
    last_transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
    last_updated: Scalars["timestamp"]["output"];
    processor: Scalars["String"]["output"];
};
/** aggregated selection of "processor_metadata.processor_status" */
type ProcessorMetadataProcessorStatusAggregate = {
    aggregate?: Maybe<ProcessorMetadataProcessorStatusAggregateFields>;
    nodes: Array<ProcessorMetadataProcessorStatus>;
};
/** aggregate fields of "processor_metadata.processor_status" */
type ProcessorMetadataProcessorStatusAggregateFields = {
    avg?: Maybe<ProcessorMetadataProcessorStatusAvgFields>;
    count: Scalars["Int"]["output"];
    max?: Maybe<ProcessorMetadataProcessorStatusMaxFields>;
    min?: Maybe<ProcessorMetadataProcessorStatusMinFields>;
    stddev?: Maybe<ProcessorMetadataProcessorStatusStddevFields>;
    stddev_pop?: Maybe<ProcessorMetadataProcessorStatusStddevPopFields>;
    stddev_samp?: Maybe<ProcessorMetadataProcessorStatusStddevSampFields>;
    sum?: Maybe<ProcessorMetadataProcessorStatusSumFields>;
    var_pop?: Maybe<ProcessorMetadataProcessorStatusVarPopFields>;
    var_samp?: Maybe<ProcessorMetadataProcessorStatusVarSampFields>;
    variance?: Maybe<ProcessorMetadataProcessorStatusVarianceFields>;
};
/** aggregate fields of "processor_metadata.processor_status" */
type ProcessorMetadataProcessorStatusAggregateFieldsCountArgs = {
    columns?: InputMaybe<Array<ProcessorMetadataProcessorStatusSelectColumn>>;
    distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};
/** aggregate avg on columns */
type ProcessorMetadataProcessorStatusAvgFields = {
    last_success_version?: Maybe<Scalars["Float"]["output"]>;
};
/** Boolean expression to filter rows from the table "processor_metadata.processor_status". All fields are combined with a logical 'AND'. */
type ProcessorMetadataProcessorStatusBoolExp = {
    _and?: InputMaybe<Array<ProcessorMetadataProcessorStatusBoolExp>>;
    _not?: InputMaybe<ProcessorMetadataProcessorStatusBoolExp>;
    _or?: InputMaybe<Array<ProcessorMetadataProcessorStatusBoolExp>>;
    last_success_version?: InputMaybe<BigintComparisonExp>;
    last_transaction_timestamp?: InputMaybe<TimestampComparisonExp>;
    last_updated?: InputMaybe<TimestampComparisonExp>;
    processor?: InputMaybe<StringComparisonExp>;
};
/** unique or primary key constraints on table "processor_metadata.processor_status" */
declare enum ProcessorMetadataProcessorStatusConstraint {
    /** unique or primary key constraint on columns "processor" */
    ProcessorStatusPkey = "processor_status_pkey"
}
/** input type for incrementing numeric columns in table "processor_metadata.processor_status" */
type ProcessorMetadataProcessorStatusIncInput = {
    last_success_version?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** input type for inserting data into table "processor_metadata.processor_status" */
type ProcessorMetadataProcessorStatusInsertInput = {
    last_success_version?: InputMaybe<Scalars["bigint"]["input"]>;
    last_transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    last_updated?: InputMaybe<Scalars["timestamp"]["input"]>;
    processor?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregate max on columns */
type ProcessorMetadataProcessorStatusMaxFields = {
    last_success_version?: Maybe<Scalars["bigint"]["output"]>;
    last_transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
    last_updated?: Maybe<Scalars["timestamp"]["output"]>;
    processor?: Maybe<Scalars["String"]["output"]>;
};
/** aggregate min on columns */
type ProcessorMetadataProcessorStatusMinFields = {
    last_success_version?: Maybe<Scalars["bigint"]["output"]>;
    last_transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
    last_updated?: Maybe<Scalars["timestamp"]["output"]>;
    processor?: Maybe<Scalars["String"]["output"]>;
};
/** response of any mutation on the table "processor_metadata.processor_status" */
type ProcessorMetadataProcessorStatusMutationResponse = {
    /** number of rows affected by the mutation */
    affected_rows: Scalars["Int"]["output"];
    /** data from the rows affected by the mutation */
    returning: Array<ProcessorMetadataProcessorStatus>;
};
/** on_conflict condition type for table "processor_metadata.processor_status" */
type ProcessorMetadataProcessorStatusOnConflict = {
    constraint: ProcessorMetadataProcessorStatusConstraint;
    update_columns?: Array<ProcessorMetadataProcessorStatusUpdateColumn>;
    where?: InputMaybe<ProcessorMetadataProcessorStatusBoolExp>;
};
/** Ordering options when selecting data from "processor_metadata.processor_status". */
type ProcessorMetadataProcessorStatusOrderBy = {
    last_success_version?: InputMaybe<OrderBy>;
    last_transaction_timestamp?: InputMaybe<OrderBy>;
    last_updated?: InputMaybe<OrderBy>;
    processor?: InputMaybe<OrderBy>;
};
/** primary key columns input for table: processor_metadata.processor_status */
type ProcessorMetadataProcessorStatusPkColumnsInput = {
    processor: Scalars["String"]["input"];
};
/** select columns of table "processor_metadata.processor_status" */
declare enum ProcessorMetadataProcessorStatusSelectColumn {
    /** column name */
    LastSuccessVersion = "last_success_version",
    /** column name */
    LastTransactionTimestamp = "last_transaction_timestamp",
    /** column name */
    LastUpdated = "last_updated",
    /** column name */
    Processor = "processor"
}
/** input type for updating data in table "processor_metadata.processor_status" */
type ProcessorMetadataProcessorStatusSetInput = {
    last_success_version?: InputMaybe<Scalars["bigint"]["input"]>;
    last_transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    last_updated?: InputMaybe<Scalars["timestamp"]["input"]>;
    processor?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregate stddev on columns */
type ProcessorMetadataProcessorStatusStddevFields = {
    last_success_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_pop on columns */
type ProcessorMetadataProcessorStatusStddevPopFields = {
    last_success_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_samp on columns */
type ProcessorMetadataProcessorStatusStddevSampFields = {
    last_success_version?: Maybe<Scalars["Float"]["output"]>;
};
/** Streaming cursor of the table "processor_metadata_processor_status" */
type ProcessorMetadataProcessorStatusStreamCursorInput = {
    /** Stream column input with initial value */
    initial_value: ProcessorMetadataProcessorStatusStreamCursorValueInput;
    /** cursor ordering */
    ordering?: InputMaybe<CursorOrdering>;
};
/** Initial value of the column from where the streaming should start */
type ProcessorMetadataProcessorStatusStreamCursorValueInput = {
    last_success_version?: InputMaybe<Scalars["bigint"]["input"]>;
    last_transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    last_updated?: InputMaybe<Scalars["timestamp"]["input"]>;
    processor?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregate sum on columns */
type ProcessorMetadataProcessorStatusSumFields = {
    last_success_version?: Maybe<Scalars["bigint"]["output"]>;
};
/** update columns of table "processor_metadata.processor_status" */
declare enum ProcessorMetadataProcessorStatusUpdateColumn {
    /** column name */
    LastSuccessVersion = "last_success_version",
    /** column name */
    LastTransactionTimestamp = "last_transaction_timestamp",
    /** column name */
    LastUpdated = "last_updated",
    /** column name */
    Processor = "processor"
}
type ProcessorMetadataProcessorStatusUpdates = {
    /** increments the numeric columns with given value of the filtered values */
    _inc?: InputMaybe<ProcessorMetadataProcessorStatusIncInput>;
    /** sets the columns of the filtered rows to the given values */
    _set?: InputMaybe<ProcessorMetadataProcessorStatusSetInput>;
    /** filter the rows which have to be updated */
    where: ProcessorMetadataProcessorStatusBoolExp;
};
/** aggregate var_pop on columns */
type ProcessorMetadataProcessorStatusVarPopFields = {
    last_success_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate var_samp on columns */
type ProcessorMetadataProcessorStatusVarSampFields = {
    last_success_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate variance on columns */
type ProcessorMetadataProcessorStatusVarianceFields = {
    last_success_version?: Maybe<Scalars["Float"]["output"]>;
};
/** columns and relationships of "processor_status" */
type ProcessorStatus = {
    last_success_version: Scalars["bigint"]["output"];
    last_transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
    last_updated: Scalars["timestamp"]["output"];
    processor: Scalars["String"]["output"];
};
/** aggregated selection of "processor_status" */
type ProcessorStatusAggregate = {
    aggregate?: Maybe<ProcessorStatusAggregateFields>;
    nodes: Array<ProcessorStatus>;
};
/** aggregate fields of "processor_status" */
type ProcessorStatusAggregateFields = {
    avg?: Maybe<ProcessorStatusAvgFields>;
    count: Scalars["Int"]["output"];
    max?: Maybe<ProcessorStatusMaxFields>;
    min?: Maybe<ProcessorStatusMinFields>;
    stddev?: Maybe<ProcessorStatusStddevFields>;
    stddev_pop?: Maybe<ProcessorStatusStddevPopFields>;
    stddev_samp?: Maybe<ProcessorStatusStddevSampFields>;
    sum?: Maybe<ProcessorStatusSumFields>;
    var_pop?: Maybe<ProcessorStatusVarPopFields>;
    var_samp?: Maybe<ProcessorStatusVarSampFields>;
    variance?: Maybe<ProcessorStatusVarianceFields>;
};
/** aggregate fields of "processor_status" */
type ProcessorStatusAggregateFieldsCountArgs = {
    columns?: InputMaybe<Array<ProcessorStatusSelectColumn>>;
    distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};
/** aggregate avg on columns */
type ProcessorStatusAvgFields = {
    last_success_version?: Maybe<Scalars["Float"]["output"]>;
};
/** Boolean expression to filter rows from the table "processor_status". All fields are combined with a logical 'AND'. */
type ProcessorStatusBoolExp = {
    _and?: InputMaybe<Array<ProcessorStatusBoolExp>>;
    _not?: InputMaybe<ProcessorStatusBoolExp>;
    _or?: InputMaybe<Array<ProcessorStatusBoolExp>>;
    last_success_version?: InputMaybe<BigintComparisonExp>;
    last_transaction_timestamp?: InputMaybe<TimestampComparisonExp>;
    last_updated?: InputMaybe<TimestampComparisonExp>;
    processor?: InputMaybe<StringComparisonExp>;
};
/** unique or primary key constraints on table "processor_status" */
declare enum ProcessorStatusConstraint {
    /** unique or primary key constraint on columns "processor" */
    ProcessorStatusPkey = "processor_status_pkey",
    /** unique or primary key constraint on columns "processor" */
    ProcessorStatusPkey1 = "processor_status_pkey1"
}
/** input type for incrementing numeric columns in table "processor_status" */
type ProcessorStatusIncInput = {
    last_success_version?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** input type for inserting data into table "processor_status" */
type ProcessorStatusInsertInput = {
    last_success_version?: InputMaybe<Scalars["bigint"]["input"]>;
    last_transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    last_updated?: InputMaybe<Scalars["timestamp"]["input"]>;
    processor?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregate max on columns */
type ProcessorStatusMaxFields = {
    last_success_version?: Maybe<Scalars["bigint"]["output"]>;
    last_transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
    last_updated?: Maybe<Scalars["timestamp"]["output"]>;
    processor?: Maybe<Scalars["String"]["output"]>;
};
/** aggregate min on columns */
type ProcessorStatusMinFields = {
    last_success_version?: Maybe<Scalars["bigint"]["output"]>;
    last_transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
    last_updated?: Maybe<Scalars["timestamp"]["output"]>;
    processor?: Maybe<Scalars["String"]["output"]>;
};
/** response of any mutation on the table "processor_status" */
type ProcessorStatusMutationResponse = {
    /** number of rows affected by the mutation */
    affected_rows: Scalars["Int"]["output"];
    /** data from the rows affected by the mutation */
    returning: Array<ProcessorStatus>;
};
/** on_conflict condition type for table "processor_status" */
type ProcessorStatusOnConflict = {
    constraint: ProcessorStatusConstraint;
    update_columns?: Array<ProcessorStatusUpdateColumn>;
    where?: InputMaybe<ProcessorStatusBoolExp>;
};
/** Ordering options when selecting data from "processor_status". */
type ProcessorStatusOrderBy = {
    last_success_version?: InputMaybe<OrderBy>;
    last_transaction_timestamp?: InputMaybe<OrderBy>;
    last_updated?: InputMaybe<OrderBy>;
    processor?: InputMaybe<OrderBy>;
};
/** primary key columns input for table: processor_status */
type ProcessorStatusPkColumnsInput = {
    processor: Scalars["String"]["input"];
};
/** select columns of table "processor_status" */
declare enum ProcessorStatusSelectColumn {
    /** column name */
    LastSuccessVersion = "last_success_version",
    /** column name */
    LastTransactionTimestamp = "last_transaction_timestamp",
    /** column name */
    LastUpdated = "last_updated",
    /** column name */
    Processor = "processor"
}
/** input type for updating data in table "processor_status" */
type ProcessorStatusSetInput = {
    last_success_version?: InputMaybe<Scalars["bigint"]["input"]>;
    last_transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    last_updated?: InputMaybe<Scalars["timestamp"]["input"]>;
    processor?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregate stddev on columns */
type ProcessorStatusStddevFields = {
    last_success_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_pop on columns */
type ProcessorStatusStddevPopFields = {
    last_success_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_samp on columns */
type ProcessorStatusStddevSampFields = {
    last_success_version?: Maybe<Scalars["Float"]["output"]>;
};
/** Streaming cursor of the table "processor_status" */
type ProcessorStatusStreamCursorInput = {
    /** Stream column input with initial value */
    initial_value: ProcessorStatusStreamCursorValueInput;
    /** cursor ordering */
    ordering?: InputMaybe<CursorOrdering>;
};
/** Initial value of the column from where the streaming should start */
type ProcessorStatusStreamCursorValueInput = {
    last_success_version?: InputMaybe<Scalars["bigint"]["input"]>;
    last_transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    last_updated?: InputMaybe<Scalars["timestamp"]["input"]>;
    processor?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregate sum on columns */
type ProcessorStatusSumFields = {
    last_success_version?: Maybe<Scalars["bigint"]["output"]>;
};
/** update columns of table "processor_status" */
declare enum ProcessorStatusUpdateColumn {
    /** column name */
    LastSuccessVersion = "last_success_version",
    /** column name */
    LastTransactionTimestamp = "last_transaction_timestamp",
    /** column name */
    LastUpdated = "last_updated",
    /** column name */
    Processor = "processor"
}
type ProcessorStatusUpdates = {
    /** increments the numeric columns with given value of the filtered values */
    _inc?: InputMaybe<ProcessorStatusIncInput>;
    /** sets the columns of the filtered rows to the given values */
    _set?: InputMaybe<ProcessorStatusSetInput>;
    /** filter the rows which have to be updated */
    where: ProcessorStatusBoolExp;
};
/** aggregate var_pop on columns */
type ProcessorStatusVarPopFields = {
    last_success_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate var_samp on columns */
type ProcessorStatusVarSampFields = {
    last_success_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate variance on columns */
type ProcessorStatusVarianceFields = {
    last_success_version?: Maybe<Scalars["Float"]["output"]>;
};
/** columns and relationships of "proposal_votes" */
type ProposalVotes = {
    inserted_at: Scalars["timestamp"]["output"];
    num_votes: Scalars["numeric"]["output"];
    proposal_id: Scalars["bigint"]["output"];
    should_pass: Scalars["Boolean"]["output"];
    staking_pool_address: Scalars["String"]["output"];
    transaction_timestamp: Scalars["timestamp"]["output"];
    transaction_version: Scalars["bigint"]["output"];
    voter_address: Scalars["String"]["output"];
};
/** aggregated selection of "proposal_votes" */
type ProposalVotesAggregate = {
    aggregate?: Maybe<ProposalVotesAggregateFields>;
    nodes: Array<ProposalVotes>;
};
/** aggregate fields of "proposal_votes" */
type ProposalVotesAggregateFields = {
    avg?: Maybe<ProposalVotesAvgFields>;
    count: Scalars["Int"]["output"];
    max?: Maybe<ProposalVotesMaxFields>;
    min?: Maybe<ProposalVotesMinFields>;
    stddev?: Maybe<ProposalVotesStddevFields>;
    stddev_pop?: Maybe<ProposalVotesStddevPopFields>;
    stddev_samp?: Maybe<ProposalVotesStddevSampFields>;
    sum?: Maybe<ProposalVotesSumFields>;
    var_pop?: Maybe<ProposalVotesVarPopFields>;
    var_samp?: Maybe<ProposalVotesVarSampFields>;
    variance?: Maybe<ProposalVotesVarianceFields>;
};
/** aggregate fields of "proposal_votes" */
type ProposalVotesAggregateFieldsCountArgs = {
    columns?: InputMaybe<Array<ProposalVotesSelectColumn>>;
    distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};
/** aggregate avg on columns */
type ProposalVotesAvgFields = {
    num_votes?: Maybe<Scalars["Float"]["output"]>;
    proposal_id?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** Boolean expression to filter rows from the table "proposal_votes". All fields are combined with a logical 'AND'. */
type ProposalVotesBoolExp = {
    _and?: InputMaybe<Array<ProposalVotesBoolExp>>;
    _not?: InputMaybe<ProposalVotesBoolExp>;
    _or?: InputMaybe<Array<ProposalVotesBoolExp>>;
    inserted_at?: InputMaybe<TimestampComparisonExp>;
    num_votes?: InputMaybe<NumericComparisonExp>;
    proposal_id?: InputMaybe<BigintComparisonExp>;
    should_pass?: InputMaybe<BooleanComparisonExp>;
    staking_pool_address?: InputMaybe<StringComparisonExp>;
    transaction_timestamp?: InputMaybe<TimestampComparisonExp>;
    transaction_version?: InputMaybe<BigintComparisonExp>;
    voter_address?: InputMaybe<StringComparisonExp>;
};
/** unique or primary key constraints on table "proposal_votes" */
declare enum ProposalVotesConstraint {
    /** unique or primary key constraint on columns "voter_address", "transaction_version", "proposal_id" */
    ProposalVotesPkey = "proposal_votes_pkey"
}
/** input type for incrementing numeric columns in table "proposal_votes" */
type ProposalVotesIncInput = {
    num_votes?: InputMaybe<Scalars["numeric"]["input"]>;
    proposal_id?: InputMaybe<Scalars["bigint"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** input type for inserting data into table "proposal_votes" */
type ProposalVotesInsertInput = {
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    num_votes?: InputMaybe<Scalars["numeric"]["input"]>;
    proposal_id?: InputMaybe<Scalars["bigint"]["input"]>;
    should_pass?: InputMaybe<Scalars["Boolean"]["input"]>;
    staking_pool_address?: InputMaybe<Scalars["String"]["input"]>;
    transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    voter_address?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregate max on columns */
type ProposalVotesMaxFields = {
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    num_votes?: Maybe<Scalars["numeric"]["output"]>;
    proposal_id?: Maybe<Scalars["bigint"]["output"]>;
    staking_pool_address?: Maybe<Scalars["String"]["output"]>;
    transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    voter_address?: Maybe<Scalars["String"]["output"]>;
};
/** aggregate min on columns */
type ProposalVotesMinFields = {
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    num_votes?: Maybe<Scalars["numeric"]["output"]>;
    proposal_id?: Maybe<Scalars["bigint"]["output"]>;
    staking_pool_address?: Maybe<Scalars["String"]["output"]>;
    transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    voter_address?: Maybe<Scalars["String"]["output"]>;
};
/** response of any mutation on the table "proposal_votes" */
type ProposalVotesMutationResponse = {
    /** number of rows affected by the mutation */
    affected_rows: Scalars["Int"]["output"];
    /** data from the rows affected by the mutation */
    returning: Array<ProposalVotes>;
};
/** on_conflict condition type for table "proposal_votes" */
type ProposalVotesOnConflict = {
    constraint: ProposalVotesConstraint;
    update_columns?: Array<ProposalVotesUpdateColumn>;
    where?: InputMaybe<ProposalVotesBoolExp>;
};
/** Ordering options when selecting data from "proposal_votes". */
type ProposalVotesOrderBy = {
    inserted_at?: InputMaybe<OrderBy>;
    num_votes?: InputMaybe<OrderBy>;
    proposal_id?: InputMaybe<OrderBy>;
    should_pass?: InputMaybe<OrderBy>;
    staking_pool_address?: InputMaybe<OrderBy>;
    transaction_timestamp?: InputMaybe<OrderBy>;
    transaction_version?: InputMaybe<OrderBy>;
    voter_address?: InputMaybe<OrderBy>;
};
/** primary key columns input for table: proposal_votes */
type ProposalVotesPkColumnsInput = {
    proposal_id: Scalars["bigint"]["input"];
    transaction_version: Scalars["bigint"]["input"];
    voter_address: Scalars["String"]["input"];
};
/** select columns of table "proposal_votes" */
declare enum ProposalVotesSelectColumn {
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    NumVotes = "num_votes",
    /** column name */
    ProposalId = "proposal_id",
    /** column name */
    ShouldPass = "should_pass",
    /** column name */
    StakingPoolAddress = "staking_pool_address",
    /** column name */
    TransactionTimestamp = "transaction_timestamp",
    /** column name */
    TransactionVersion = "transaction_version",
    /** column name */
    VoterAddress = "voter_address"
}
/** input type for updating data in table "proposal_votes" */
type ProposalVotesSetInput = {
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    num_votes?: InputMaybe<Scalars["numeric"]["input"]>;
    proposal_id?: InputMaybe<Scalars["bigint"]["input"]>;
    should_pass?: InputMaybe<Scalars["Boolean"]["input"]>;
    staking_pool_address?: InputMaybe<Scalars["String"]["input"]>;
    transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    voter_address?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregate stddev on columns */
type ProposalVotesStddevFields = {
    num_votes?: Maybe<Scalars["Float"]["output"]>;
    proposal_id?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_pop on columns */
type ProposalVotesStddevPopFields = {
    num_votes?: Maybe<Scalars["Float"]["output"]>;
    proposal_id?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_samp on columns */
type ProposalVotesStddevSampFields = {
    num_votes?: Maybe<Scalars["Float"]["output"]>;
    proposal_id?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** Streaming cursor of the table "proposal_votes" */
type ProposalVotesStreamCursorInput = {
    /** Stream column input with initial value */
    initial_value: ProposalVotesStreamCursorValueInput;
    /** cursor ordering */
    ordering?: InputMaybe<CursorOrdering>;
};
/** Initial value of the column from where the streaming should start */
type ProposalVotesStreamCursorValueInput = {
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    num_votes?: InputMaybe<Scalars["numeric"]["input"]>;
    proposal_id?: InputMaybe<Scalars["bigint"]["input"]>;
    should_pass?: InputMaybe<Scalars["Boolean"]["input"]>;
    staking_pool_address?: InputMaybe<Scalars["String"]["input"]>;
    transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    voter_address?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregate sum on columns */
type ProposalVotesSumFields = {
    num_votes?: Maybe<Scalars["numeric"]["output"]>;
    proposal_id?: Maybe<Scalars["bigint"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};
/** update columns of table "proposal_votes" */
declare enum ProposalVotesUpdateColumn {
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    NumVotes = "num_votes",
    /** column name */
    ProposalId = "proposal_id",
    /** column name */
    ShouldPass = "should_pass",
    /** column name */
    StakingPoolAddress = "staking_pool_address",
    /** column name */
    TransactionTimestamp = "transaction_timestamp",
    /** column name */
    TransactionVersion = "transaction_version",
    /** column name */
    VoterAddress = "voter_address"
}
type ProposalVotesUpdates = {
    /** increments the numeric columns with given value of the filtered values */
    _inc?: InputMaybe<ProposalVotesIncInput>;
    /** sets the columns of the filtered rows to the given values */
    _set?: InputMaybe<ProposalVotesSetInput>;
    /** filter the rows which have to be updated */
    where: ProposalVotesBoolExp;
};
/** aggregate var_pop on columns */
type ProposalVotesVarPopFields = {
    num_votes?: Maybe<Scalars["Float"]["output"]>;
    proposal_id?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate var_samp on columns */
type ProposalVotesVarSampFields = {
    num_votes?: Maybe<Scalars["Float"]["output"]>;
    proposal_id?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate variance on columns */
type ProposalVotesVarianceFields = {
    num_votes?: Maybe<Scalars["Float"]["output"]>;
    proposal_id?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** columns and relationships of "public_key_auth_keys" */
type PublicKeyAuthKeys = {
    account_public_key?: Maybe<Scalars["String"]["output"]>;
    auth_key: Scalars["String"]["output"];
    is_public_key_used: Scalars["Boolean"]["output"];
    last_transaction_version: Scalars["bigint"]["output"];
    public_key: Scalars["String"]["output"];
    public_key_type: Scalars["String"]["output"];
    signature_type: Scalars["String"]["output"];
};
/** aggregated selection of "public_key_auth_keys" */
type PublicKeyAuthKeysAggregate = {
    aggregate?: Maybe<PublicKeyAuthKeysAggregateFields>;
    nodes: Array<PublicKeyAuthKeys>;
};
/** aggregate fields of "public_key_auth_keys" */
type PublicKeyAuthKeysAggregateFields = {
    avg?: Maybe<PublicKeyAuthKeysAvgFields>;
    count: Scalars["Int"]["output"];
    max?: Maybe<PublicKeyAuthKeysMaxFields>;
    min?: Maybe<PublicKeyAuthKeysMinFields>;
    stddev?: Maybe<PublicKeyAuthKeysStddevFields>;
    stddev_pop?: Maybe<PublicKeyAuthKeysStddevPopFields>;
    stddev_samp?: Maybe<PublicKeyAuthKeysStddevSampFields>;
    sum?: Maybe<PublicKeyAuthKeysSumFields>;
    var_pop?: Maybe<PublicKeyAuthKeysVarPopFields>;
    var_samp?: Maybe<PublicKeyAuthKeysVarSampFields>;
    variance?: Maybe<PublicKeyAuthKeysVarianceFields>;
};
/** aggregate fields of "public_key_auth_keys" */
type PublicKeyAuthKeysAggregateFieldsCountArgs = {
    columns?: InputMaybe<Array<PublicKeyAuthKeysSelectColumn>>;
    distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};
/** aggregate avg on columns */
type PublicKeyAuthKeysAvgFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** Boolean expression to filter rows from the table "public_key_auth_keys". All fields are combined with a logical 'AND'. */
type PublicKeyAuthKeysBoolExp = {
    _and?: InputMaybe<Array<PublicKeyAuthKeysBoolExp>>;
    _not?: InputMaybe<PublicKeyAuthKeysBoolExp>;
    _or?: InputMaybe<Array<PublicKeyAuthKeysBoolExp>>;
    account_public_key?: InputMaybe<StringComparisonExp>;
    auth_key?: InputMaybe<StringComparisonExp>;
    is_public_key_used?: InputMaybe<BooleanComparisonExp>;
    last_transaction_version?: InputMaybe<BigintComparisonExp>;
    public_key?: InputMaybe<StringComparisonExp>;
    public_key_type?: InputMaybe<StringComparisonExp>;
    signature_type?: InputMaybe<StringComparisonExp>;
};
/** unique or primary key constraints on table "public_key_auth_keys" */
declare enum PublicKeyAuthKeysConstraint {
    /** unique or primary key constraint on columns "public_key_type", "auth_key", "public_key" */
    PublicKeyAuthKeysPkey = "public_key_auth_keys_pkey"
}
/** input type for incrementing numeric columns in table "public_key_auth_keys" */
type PublicKeyAuthKeysIncInput = {
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** input type for inserting data into table "public_key_auth_keys" */
type PublicKeyAuthKeysInsertInput = {
    account_public_key?: InputMaybe<Scalars["String"]["input"]>;
    auth_key?: InputMaybe<Scalars["String"]["input"]>;
    is_public_key_used?: InputMaybe<Scalars["Boolean"]["input"]>;
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    public_key?: InputMaybe<Scalars["String"]["input"]>;
    public_key_type?: InputMaybe<Scalars["String"]["input"]>;
    signature_type?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregate max on columns */
type PublicKeyAuthKeysMaxFields = {
    account_public_key?: Maybe<Scalars["String"]["output"]>;
    auth_key?: Maybe<Scalars["String"]["output"]>;
    last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    public_key?: Maybe<Scalars["String"]["output"]>;
    public_key_type?: Maybe<Scalars["String"]["output"]>;
    signature_type?: Maybe<Scalars["String"]["output"]>;
};
/** aggregate min on columns */
type PublicKeyAuthKeysMinFields = {
    account_public_key?: Maybe<Scalars["String"]["output"]>;
    auth_key?: Maybe<Scalars["String"]["output"]>;
    last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    public_key?: Maybe<Scalars["String"]["output"]>;
    public_key_type?: Maybe<Scalars["String"]["output"]>;
    signature_type?: Maybe<Scalars["String"]["output"]>;
};
/** response of any mutation on the table "public_key_auth_keys" */
type PublicKeyAuthKeysMutationResponse = {
    /** number of rows affected by the mutation */
    affected_rows: Scalars["Int"]["output"];
    /** data from the rows affected by the mutation */
    returning: Array<PublicKeyAuthKeys>;
};
/** on_conflict condition type for table "public_key_auth_keys" */
type PublicKeyAuthKeysOnConflict = {
    constraint: PublicKeyAuthKeysConstraint;
    update_columns?: Array<PublicKeyAuthKeysUpdateColumn>;
    where?: InputMaybe<PublicKeyAuthKeysBoolExp>;
};
/** Ordering options when selecting data from "public_key_auth_keys". */
type PublicKeyAuthKeysOrderBy = {
    account_public_key?: InputMaybe<OrderBy>;
    auth_key?: InputMaybe<OrderBy>;
    is_public_key_used?: InputMaybe<OrderBy>;
    last_transaction_version?: InputMaybe<OrderBy>;
    public_key?: InputMaybe<OrderBy>;
    public_key_type?: InputMaybe<OrderBy>;
    signature_type?: InputMaybe<OrderBy>;
};
/** primary key columns input for table: public_key_auth_keys */
type PublicKeyAuthKeysPkColumnsInput = {
    auth_key: Scalars["String"]["input"];
    public_key: Scalars["String"]["input"];
    public_key_type: Scalars["String"]["input"];
};
/** select columns of table "public_key_auth_keys" */
declare enum PublicKeyAuthKeysSelectColumn {
    /** column name */
    AccountPublicKey = "account_public_key",
    /** column name */
    AuthKey = "auth_key",
    /** column name */
    IsPublicKeyUsed = "is_public_key_used",
    /** column name */
    LastTransactionVersion = "last_transaction_version",
    /** column name */
    PublicKey = "public_key",
    /** column name */
    PublicKeyType = "public_key_type",
    /** column name */
    SignatureType = "signature_type"
}
/** input type for updating data in table "public_key_auth_keys" */
type PublicKeyAuthKeysSetInput = {
    account_public_key?: InputMaybe<Scalars["String"]["input"]>;
    auth_key?: InputMaybe<Scalars["String"]["input"]>;
    is_public_key_used?: InputMaybe<Scalars["Boolean"]["input"]>;
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    public_key?: InputMaybe<Scalars["String"]["input"]>;
    public_key_type?: InputMaybe<Scalars["String"]["input"]>;
    signature_type?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregate stddev on columns */
type PublicKeyAuthKeysStddevFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_pop on columns */
type PublicKeyAuthKeysStddevPopFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_samp on columns */
type PublicKeyAuthKeysStddevSampFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** Streaming cursor of the table "public_key_auth_keys" */
type PublicKeyAuthKeysStreamCursorInput = {
    /** Stream column input with initial value */
    initial_value: PublicKeyAuthKeysStreamCursorValueInput;
    /** cursor ordering */
    ordering?: InputMaybe<CursorOrdering>;
};
/** Initial value of the column from where the streaming should start */
type PublicKeyAuthKeysStreamCursorValueInput = {
    account_public_key?: InputMaybe<Scalars["String"]["input"]>;
    auth_key?: InputMaybe<Scalars["String"]["input"]>;
    is_public_key_used?: InputMaybe<Scalars["Boolean"]["input"]>;
    last_transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    public_key?: InputMaybe<Scalars["String"]["input"]>;
    public_key_type?: InputMaybe<Scalars["String"]["input"]>;
    signature_type?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregate sum on columns */
type PublicKeyAuthKeysSumFields = {
    last_transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};
/** update columns of table "public_key_auth_keys" */
declare enum PublicKeyAuthKeysUpdateColumn {
    /** column name */
    AccountPublicKey = "account_public_key",
    /** column name */
    AuthKey = "auth_key",
    /** column name */
    IsPublicKeyUsed = "is_public_key_used",
    /** column name */
    LastTransactionVersion = "last_transaction_version",
    /** column name */
    PublicKey = "public_key",
    /** column name */
    PublicKeyType = "public_key_type",
    /** column name */
    SignatureType = "signature_type"
}
type PublicKeyAuthKeysUpdates = {
    /** increments the numeric columns with given value of the filtered values */
    _inc?: InputMaybe<PublicKeyAuthKeysIncInput>;
    /** sets the columns of the filtered rows to the given values */
    _set?: InputMaybe<PublicKeyAuthKeysSetInput>;
    /** filter the rows which have to be updated */
    where: PublicKeyAuthKeysBoolExp;
};
/** aggregate var_pop on columns */
type PublicKeyAuthKeysVarPopFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate var_samp on columns */
type PublicKeyAuthKeysVarSampFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate variance on columns */
type PublicKeyAuthKeysVarianceFields = {
    last_transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
type QueryRoot = {
    /** fetch data from the table: "account_transactions" */
    account_transactions: Array<AccountTransactions>;
    /** fetch aggregated fields from the table: "account_transactions" */
    account_transactions_aggregate: AccountTransactionsAggregate;
    /** fetch data from the table: "account_transactions" using primary key columns */
    account_transactions_by_pk?: Maybe<AccountTransactions>;
    /** fetch data from the table: "address_events_summary" */
    address_events_summary: Array<AddressEventsSummary>;
    /** fetch aggregated fields from the table: "address_events_summary" */
    address_events_summary_aggregate: AddressEventsSummaryAggregate;
    /** fetch data from the table: "address_version_from_events" */
    address_version_from_events: Array<AddressVersionFromEvents>;
    /** fetch aggregated fields from the table: "address_version_from_events" */
    address_version_from_events_aggregate: AddressVersionFromEventsAggregate;
    /** fetch data from the table: "address_version_from_move_resources" */
    address_version_from_move_resources: Array<AddressVersionFromMoveResources>;
    /** fetch aggregated fields from the table: "address_version_from_move_resources" */
    address_version_from_move_resources_aggregate: AddressVersionFromMoveResourcesAggregate;
    /** fetch data from the table: "ans_lookup" */
    ans_lookup: Array<AnsLookup>;
    /** fetch aggregated fields from the table: "ans_lookup" */
    ans_lookup_aggregate: AnsLookupAggregate;
    /** fetch data from the table: "ans_lookup" using primary key columns */
    ans_lookup_by_pk?: Maybe<AnsLookup>;
    /** fetch data from the table: "ans_lookup_v2" */
    ans_lookup_v2: Array<AnsLookupV2>;
    /** fetch aggregated fields from the table: "ans_lookup_v2" */
    ans_lookup_v2_aggregate: AnsLookupV2Aggregate;
    /** fetch data from the table: "ans_lookup_v2" using primary key columns */
    ans_lookup_v2_by_pk?: Maybe<AnsLookupV2>;
    /** fetch data from the table: "ans_primary_name" */
    ans_primary_name: Array<AnsPrimaryName>;
    /** fetch aggregated fields from the table: "ans_primary_name" */
    ans_primary_name_aggregate: AnsPrimaryNameAggregate;
    /** fetch data from the table: "ans_primary_name" using primary key columns */
    ans_primary_name_by_pk?: Maybe<AnsPrimaryName>;
    /** fetch data from the table: "ans_primary_name_v2" */
    ans_primary_name_v2: Array<AnsPrimaryNameV2>;
    /** fetch aggregated fields from the table: "ans_primary_name_v2" */
    ans_primary_name_v2_aggregate: AnsPrimaryNameV2Aggregate;
    /** fetch data from the table: "ans_primary_name_v2" using primary key columns */
    ans_primary_name_v2_by_pk?: Maybe<AnsPrimaryNameV2>;
    /** fetch data from the table: "auth_key_account_addresses" */
    auth_key_account_addresses: Array<AuthKeyAccountAddresses>;
    /** fetch aggregated fields from the table: "auth_key_account_addresses" */
    auth_key_account_addresses_aggregate: AuthKeyAccountAddressesAggregate;
    /** fetch data from the table: "auth_key_account_addresses" using primary key columns */
    auth_key_account_addresses_by_pk?: Maybe<AuthKeyAccountAddresses>;
    /** fetch data from the table: "block_metadata_transactions" */
    block_metadata_transactions: Array<BlockMetadataTransactions>;
    /** fetch aggregated fields from the table: "block_metadata_transactions" */
    block_metadata_transactions_aggregate: BlockMetadataTransactionsAggregate;
    /** fetch data from the table: "block_metadata_transactions" using primary key columns */
    block_metadata_transactions_by_pk?: Maybe<BlockMetadataTransactions>;
    /** fetch data from the table: "coin_activities" */
    coin_activities: Array<CoinActivities>;
    /** fetch aggregated fields from the table: "coin_activities" */
    coin_activities_aggregate: CoinActivitiesAggregate;
    /** fetch data from the table: "coin_activities" using primary key columns */
    coin_activities_by_pk?: Maybe<CoinActivities>;
    /** fetch data from the table: "coin_balances" */
    coin_balances: Array<CoinBalances>;
    /** fetch aggregated fields from the table: "coin_balances" */
    coin_balances_aggregate: CoinBalancesAggregate;
    /** fetch data from the table: "coin_balances" using primary key columns */
    coin_balances_by_pk?: Maybe<CoinBalances>;
    /** fetch data from the table: "coin_infos" */
    coin_infos: Array<CoinInfos>;
    /** fetch aggregated fields from the table: "coin_infos" */
    coin_infos_aggregate: CoinInfosAggregate;
    /** fetch data from the table: "coin_infos" using primary key columns */
    coin_infos_by_pk?: Maybe<CoinInfos>;
    /** fetch data from the table: "coin_supply" */
    coin_supply: Array<CoinSupply>;
    /** fetch aggregated fields from the table: "coin_supply" */
    coin_supply_aggregate: CoinSupplyAggregate;
    /** fetch data from the table: "coin_supply" using primary key columns */
    coin_supply_by_pk?: Maybe<CoinSupply>;
    /** fetch data from the table: "collection_datas" */
    collection_datas: Array<CollectionDatas>;
    /** fetch aggregated fields from the table: "collection_datas" */
    collection_datas_aggregate: CollectionDatasAggregate;
    /** fetch data from the table: "collection_datas" using primary key columns */
    collection_datas_by_pk?: Maybe<CollectionDatas>;
    /** fetch data from the table: "collections_v2" */
    collections_v2: Array<CollectionsV2>;
    /** fetch aggregated fields from the table: "collections_v2" */
    collections_v2_aggregate: CollectionsV2Aggregate;
    /** fetch data from the table: "collections_v2" using primary key columns */
    collections_v2_by_pk?: Maybe<CollectionsV2>;
    /** fetch data from the table: "current_ans_lookup" */
    current_ans_lookup: Array<CurrentAnsLookup>;
    /** fetch aggregated fields from the table: "current_ans_lookup" */
    current_ans_lookup_aggregate: CurrentAnsLookupAggregate;
    /** fetch data from the table: "current_ans_lookup" using primary key columns */
    current_ans_lookup_by_pk?: Maybe<CurrentAnsLookup>;
    /** fetch data from the table: "current_ans_lookup_v2" */
    current_ans_lookup_v2: Array<CurrentAnsLookupV2>;
    /** fetch aggregated fields from the table: "current_ans_lookup_v2" */
    current_ans_lookup_v2_aggregate: CurrentAnsLookupV2Aggregate;
    /** fetch data from the table: "current_ans_lookup_v2" using primary key columns */
    current_ans_lookup_v2_by_pk?: Maybe<CurrentAnsLookupV2>;
    /** fetch data from the table: "current_ans_primary_name" */
    current_ans_primary_name: Array<CurrentAnsPrimaryName>;
    /** fetch aggregated fields from the table: "current_ans_primary_name" */
    current_ans_primary_name_aggregate: CurrentAnsPrimaryNameAggregate;
    /** fetch data from the table: "current_ans_primary_name" using primary key columns */
    current_ans_primary_name_by_pk?: Maybe<CurrentAnsPrimaryName>;
    /** fetch data from the table: "current_ans_primary_name_v2" */
    current_ans_primary_name_v2: Array<CurrentAnsPrimaryNameV2>;
    /** fetch aggregated fields from the table: "current_ans_primary_name_v2" */
    current_ans_primary_name_v2_aggregate: CurrentAnsPrimaryNameV2Aggregate;
    /** fetch data from the table: "current_ans_primary_name_v2" using primary key columns */
    current_ans_primary_name_v2_by_pk?: Maybe<CurrentAnsPrimaryNameV2>;
    /** fetch data from the table: "current_cedra_names" */
    current_cedra_names: Array<CurrentCedraNames>;
    /** fetch aggregated fields from the table: "current_cedra_names" */
    current_cedra_names_aggregate: CurrentCedraNamesAggregate;
    /** fetch data from the table: "current_coin_balances" */
    current_coin_balances: Array<CurrentCoinBalances>;
    /** fetch aggregated fields from the table: "current_coin_balances" */
    current_coin_balances_aggregate: CurrentCoinBalancesAggregate;
    /** fetch data from the table: "current_coin_balances" using primary key columns */
    current_coin_balances_by_pk?: Maybe<CurrentCoinBalances>;
    /** fetch data from the table: "current_collection_datas" */
    current_collection_datas: Array<CurrentCollectionDatas>;
    /** fetch aggregated fields from the table: "current_collection_datas" */
    current_collection_datas_aggregate: CurrentCollectionDatasAggregate;
    /** fetch data from the table: "current_collection_datas" using primary key columns */
    current_collection_datas_by_pk?: Maybe<CurrentCollectionDatas>;
    /** fetch data from the table: "current_collection_ownership_v2_view" */
    current_collection_ownership_v2_view: Array<CurrentCollectionOwnershipV2View>;
    /** fetch aggregated fields from the table: "current_collection_ownership_v2_view" */
    current_collection_ownership_v2_view_aggregate: CurrentCollectionOwnershipV2ViewAggregate;
    /** fetch data from the table: "current_collection_ownership_view" */
    current_collection_ownership_view: Array<CurrentCollectionOwnershipView>;
    /** fetch aggregated fields from the table: "current_collection_ownership_view" */
    current_collection_ownership_view_aggregate: CurrentCollectionOwnershipViewAggregate;
    /** fetch data from the table: "current_collections_v2" */
    current_collections_v2: Array<CurrentCollectionsV2>;
    /** fetch aggregated fields from the table: "current_collections_v2" */
    current_collections_v2_aggregate: CurrentCollectionsV2Aggregate;
    /** fetch data from the table: "current_collections_v2" using primary key columns */
    current_collections_v2_by_pk?: Maybe<CurrentCollectionsV2>;
    /** fetch data from the table: "current_delegated_staking_pool_balances" */
    current_delegated_staking_pool_balances: Array<CurrentDelegatedStakingPoolBalances>;
    /** fetch aggregated fields from the table: "current_delegated_staking_pool_balances" */
    current_delegated_staking_pool_balances_aggregate: CurrentDelegatedStakingPoolBalancesAggregate;
    /** fetch data from the table: "current_delegated_staking_pool_balances" using primary key columns */
    current_delegated_staking_pool_balances_by_pk?: Maybe<CurrentDelegatedStakingPoolBalances>;
    /** fetch data from the table: "current_delegated_voter" */
    current_delegated_voter: Array<CurrentDelegatedVoter>;
    /** fetch aggregated fields from the table: "current_delegated_voter" */
    current_delegated_voter_aggregate: CurrentDelegatedVoterAggregate;
    /** fetch data from the table: "current_delegated_voter" using primary key columns */
    current_delegated_voter_by_pk?: Maybe<CurrentDelegatedVoter>;
    /** fetch data from the table: "current_delegator_balances" */
    current_delegator_balances: Array<CurrentDelegatorBalances>;
    /** fetch aggregated fields from the table: "current_delegator_balances" */
    current_delegator_balances_aggregate: CurrentDelegatorBalancesAggregate;
    /** fetch data from the table: "current_delegator_balances" using primary key columns */
    current_delegator_balances_by_pk?: Maybe<CurrentDelegatorBalances>;
    /** fetch data from the table: "current_fungible_asset_balances_legacy" */
    current_fungible_asset_balances: Array<CurrentFungibleAssetBalances>;
    /** fetch aggregated fields from the table: "current_fungible_asset_balances_legacy" */
    current_fungible_asset_balances_aggregate: CurrentFungibleAssetBalancesAggregate;
    /** fetch data from the table: "current_fungible_asset_balances_legacy" using primary key columns */
    current_fungible_asset_balances_by_pk?: Maybe<CurrentFungibleAssetBalances>;
    /** fetch data from the table: "current_fungible_asset_balances" */
    current_fungible_asset_balances_new: Array<CurrentFungibleAssetBalancesNew>;
    /** fetch aggregated fields from the table: "current_fungible_asset_balances" */
    current_fungible_asset_balances_new_aggregate: CurrentFungibleAssetBalancesNewAggregate;
    /** fetch data from the table: "current_fungible_asset_balances" using primary key columns */
    current_fungible_asset_balances_new_by_pk?: Maybe<CurrentFungibleAssetBalancesNew>;
    /** fetch data from the table: "current_objects" */
    current_objects: Array<CurrentObjects>;
    /** fetch aggregated fields from the table: "current_objects" */
    current_objects_aggregate: CurrentObjectsAggregate;
    /** fetch data from the table: "current_objects" using primary key columns */
    current_objects_by_pk?: Maybe<CurrentObjects>;
    /** fetch data from the table: "current_staking_pool_voter" */
    current_staking_pool_voter: Array<CurrentStakingPoolVoter>;
    /** fetch aggregated fields from the table: "current_staking_pool_voter" */
    current_staking_pool_voter_aggregate: CurrentStakingPoolVoterAggregate;
    /** fetch data from the table: "current_staking_pool_voter" using primary key columns */
    current_staking_pool_voter_by_pk?: Maybe<CurrentStakingPoolVoter>;
    /** fetch data from the table: "current_table_items" */
    current_table_items: Array<CurrentTableItems>;
    /** fetch aggregated fields from the table: "current_table_items" */
    current_table_items_aggregate: CurrentTableItemsAggregate;
    /** fetch data from the table: "current_table_items" using primary key columns */
    current_table_items_by_pk?: Maybe<CurrentTableItems>;
    /** fetch data from the table: "current_table_items_view" */
    current_table_items_view: Array<CurrentTableItemsView>;
    /** fetch aggregated fields from the table: "current_table_items_view" */
    current_table_items_view_aggregate: CurrentTableItemsViewAggregate;
    /** fetch data from the table: "current_token_datas" */
    current_token_datas: Array<CurrentTokenDatas>;
    /** fetch aggregated fields from the table: "current_token_datas" */
    current_token_datas_aggregate: CurrentTokenDatasAggregate;
    /** fetch data from the table: "current_token_datas" using primary key columns */
    current_token_datas_by_pk?: Maybe<CurrentTokenDatas>;
    /** fetch data from the table: "current_token_datas_v2" */
    current_token_datas_v2: Array<CurrentTokenDatasV2>;
    /** fetch aggregated fields from the table: "current_token_datas_v2" */
    current_token_datas_v2_aggregate: CurrentTokenDatasV2Aggregate;
    /** fetch data from the table: "current_token_datas_v2" using primary key columns */
    current_token_datas_v2_by_pk?: Maybe<CurrentTokenDatasV2>;
    /** fetch data from the table: "current_token_ownerships" */
    current_token_ownerships: Array<CurrentTokenOwnerships>;
    /** fetch aggregated fields from the table: "current_token_ownerships" */
    current_token_ownerships_aggregate: CurrentTokenOwnershipsAggregate;
    /** fetch data from the table: "current_token_ownerships" using primary key columns */
    current_token_ownerships_by_pk?: Maybe<CurrentTokenOwnerships>;
    /** fetch data from the table: "current_token_ownerships_v2" */
    current_token_ownerships_v2: Array<CurrentTokenOwnershipsV2>;
    /** fetch aggregated fields from the table: "current_token_ownerships_v2" */
    current_token_ownerships_v2_aggregate: CurrentTokenOwnershipsV2Aggregate;
    /** fetch data from the table: "current_token_ownerships_v2" using primary key columns */
    current_token_ownerships_v2_by_pk?: Maybe<CurrentTokenOwnershipsV2>;
    /** fetch data from the table: "current_token_pending_claims" */
    current_token_pending_claims: Array<CurrentTokenPendingClaims>;
    /** fetch aggregated fields from the table: "current_token_pending_claims" */
    current_token_pending_claims_aggregate: CurrentTokenPendingClaimsAggregate;
    /** fetch data from the table: "current_token_pending_claims" using primary key columns */
    current_token_pending_claims_by_pk?: Maybe<CurrentTokenPendingClaims>;
    /** fetch data from the table: "current_token_royalty_v1" */
    current_token_royalty_v1: Array<CurrentTokenRoyaltyV1>;
    /** fetch aggregated fields from the table: "current_token_royalty_v1" */
    current_token_royalty_v1_aggregate: CurrentTokenRoyaltyV1Aggregate;
    /** fetch data from the table: "current_token_royalty_v1" using primary key columns */
    current_token_royalty_v1_by_pk?: Maybe<CurrentTokenRoyaltyV1>;
    /** fetch data from the table: "current_token_v2_metadata" */
    current_token_v2_metadata: Array<CurrentTokenV2Metadata>;
    /** fetch aggregated fields from the table: "current_token_v2_metadata" */
    current_token_v2_metadata_aggregate: CurrentTokenV2MetadataAggregate;
    /** fetch data from the table: "current_token_v2_metadata" using primary key columns */
    current_token_v2_metadata_by_pk?: Maybe<CurrentTokenV2Metadata>;
    /** fetch data from the table: "delegated_staking_activities" */
    delegated_staking_activities: Array<DelegatedStakingActivities>;
    /** fetch aggregated fields from the table: "delegated_staking_activities" */
    delegated_staking_activities_aggregate: DelegatedStakingActivitiesAggregate;
    /** fetch data from the table: "delegated_staking_activities" using primary key columns */
    delegated_staking_activities_by_pk?: Maybe<DelegatedStakingActivities>;
    /** fetch data from the table: "delegated_staking_pool_balances" */
    delegated_staking_pool_balances: Array<DelegatedStakingPoolBalances>;
    /** fetch aggregated fields from the table: "delegated_staking_pool_balances" */
    delegated_staking_pool_balances_aggregate: DelegatedStakingPoolBalancesAggregate;
    /** fetch data from the table: "delegated_staking_pool_balances" using primary key columns */
    delegated_staking_pool_balances_by_pk?: Maybe<DelegatedStakingPoolBalances>;
    /** fetch data from the table: "delegated_staking_pools" */
    delegated_staking_pools: Array<DelegatedStakingPools>;
    /** fetch aggregated fields from the table: "delegated_staking_pools" */
    delegated_staking_pools_aggregate: DelegatedStakingPoolsAggregate;
    /** fetch data from the table: "delegated_staking_pools" using primary key columns */
    delegated_staking_pools_by_pk?: Maybe<DelegatedStakingPools>;
    /** fetch data from the table: "delegator_balances" */
    delegator_balances: Array<DelegatorBalances>;
    /** fetch aggregated fields from the table: "delegator_balances" */
    delegator_balances_aggregate: DelegatorBalancesAggregate;
    /** fetch data from the table: "delegator_balances" using primary key columns */
    delegator_balances_by_pk?: Maybe<DelegatorBalances>;
    /** fetch data from the table: "delegator_distinct_pool" */
    delegator_distinct_pool: Array<DelegatorDistinctPool>;
    /** fetch aggregated fields from the table: "delegator_distinct_pool" */
    delegator_distinct_pool_aggregate: DelegatorDistinctPoolAggregate;
    /** fetch data from the table: "event_size_info" */
    event_size_info: Array<EventSizeInfo>;
    /** fetch aggregated fields from the table: "event_size_info" */
    event_size_info_aggregate: EventSizeInfoAggregate;
    /** fetch data from the table: "event_size_info" using primary key columns */
    event_size_info_by_pk?: Maybe<EventSizeInfo>;
    /** fetch data from the table: "events" */
    events: Array<Events>;
    /** fetch aggregated fields from the table: "events" */
    events_aggregate: EventsAggregate;
    /** fetch data from the table: "events" using primary key columns */
    events_by_pk?: Maybe<Events>;
    /** fetch data from the table: "events_view" */
    events_view: Array<EventsView>;
    /** fetch aggregated fields from the table: "events_view" */
    events_view_aggregate: EventsViewAggregate;
    /** fetch data from the table: "fungible_asset_activities" */
    fungible_asset_activities: Array<FungibleAssetActivities>;
    /** fetch aggregated fields from the table: "fungible_asset_activities" */
    fungible_asset_activities_aggregate: FungibleAssetActivitiesAggregate;
    /** fetch data from the table: "fungible_asset_activities" using primary key columns */
    fungible_asset_activities_by_pk?: Maybe<FungibleAssetActivities>;
    /** fetch data from the table: "fungible_asset_balances" */
    fungible_asset_balances: Array<FungibleAssetBalances>;
    /** fetch aggregated fields from the table: "fungible_asset_balances" */
    fungible_asset_balances_aggregate: FungibleAssetBalancesAggregate;
    /** fetch data from the table: "fungible_asset_balances" using primary key columns */
    fungible_asset_balances_by_pk?: Maybe<FungibleAssetBalances>;
    /** fetch data from the table: "fungible_asset_metadata" */
    fungible_asset_metadata: Array<FungibleAssetMetadata>;
    /** fetch aggregated fields from the table: "fungible_asset_metadata" */
    fungible_asset_metadata_aggregate: FungibleAssetMetadataAggregate;
    /** fetch data from the table: "fungible_asset_metadata" using primary key columns */
    fungible_asset_metadata_by_pk?: Maybe<FungibleAssetMetadata>;
    /** fetch data from the table: "fungible_asset_to_coin_mappings" */
    fungible_asset_to_coin_mappings: Array<FungibleAssetToCoinMappings>;
    /** fetch aggregated fields from the table: "fungible_asset_to_coin_mappings" */
    fungible_asset_to_coin_mappings_aggregate: FungibleAssetToCoinMappingsAggregate;
    /** fetch data from the table: "fungible_asset_to_coin_mappings" using primary key columns */
    fungible_asset_to_coin_mappings_by_pk?: Maybe<FungibleAssetToCoinMappings>;
    /** fetch data from the table: "gas_fees" */
    gas_fees: Array<GasFees>;
    /** fetch aggregated fields from the table: "gas_fees" */
    gas_fees_aggregate: GasFeesAggregate;
    /** fetch data from the table: "gas_fees" using primary key columns */
    gas_fees_by_pk?: Maybe<GasFees>;
    /** fetch data from the table: "indexer_status" */
    indexer_status: Array<IndexerStatus>;
    /** fetch aggregated fields from the table: "indexer_status" */
    indexer_status_aggregate: IndexerStatusAggregate;
    /** fetch data from the table: "indexer_status" using primary key columns */
    indexer_status_by_pk?: Maybe<IndexerStatus>;
    /** fetch data from the table: "move_modules" */
    move_modules: Array<MoveModules>;
    /** fetch aggregated fields from the table: "move_modules" */
    move_modules_aggregate: MoveModulesAggregate;
    /** fetch data from the table: "move_modules" using primary key columns */
    move_modules_by_pk?: Maybe<MoveModules>;
    /** fetch data from the table: "move_resources" */
    move_resources: Array<MoveResources>;
    /** fetch aggregated fields from the table: "move_resources" */
    move_resources_aggregate: MoveResourcesAggregate;
    /** fetch data from the table: "move_resources" using primary key columns */
    move_resources_by_pk?: Maybe<MoveResources>;
    /** fetch data from the table: "move_resources_view" */
    move_resources_view: Array<MoveResourcesView>;
    /** fetch aggregated fields from the table: "move_resources_view" */
    move_resources_view_aggregate: MoveResourcesViewAggregate;
    /** fetch data from the table: "nft_metadata_crawler.parsed_asset_uris" */
    nft_metadata_crawler_parsed_asset_uris: Array<NftMetadataCrawlerParsedAssetUris>;
    /** fetch aggregated fields from the table: "nft_metadata_crawler.parsed_asset_uris" */
    nft_metadata_crawler_parsed_asset_uris_aggregate: NftMetadataCrawlerParsedAssetUrisAggregate;
    /** fetch data from the table: "nft_metadata_crawler.parsed_asset_uris" using primary key columns */
    nft_metadata_crawler_parsed_asset_uris_by_pk?: Maybe<NftMetadataCrawlerParsedAssetUris>;
    /** fetch data from the table: "nft_points" */
    nft_points: Array<NftPoints>;
    /** fetch aggregated fields from the table: "nft_points" */
    nft_points_aggregate: NftPointsAggregate;
    /** fetch data from the table: "nft_points" using primary key columns */
    nft_points_by_pk?: Maybe<NftPoints>;
    /** fetch data from the table: "num_active_delegator_per_pool" */
    num_active_delegator_per_pool: Array<NumActiveDelegatorPerPool>;
    /** fetch aggregated fields from the table: "num_active_delegator_per_pool" */
    num_active_delegator_per_pool_aggregate: NumActiveDelegatorPerPoolAggregate;
    /** fetch data from the table: "objects" */
    objects: Array<Objects>;
    /** fetch aggregated fields from the table: "objects" */
    objects_aggregate: ObjectsAggregate;
    /** fetch data from the table: "objects" using primary key columns */
    objects_by_pk?: Maybe<Objects>;
    /** fetch data from the table: "processor_metadata.processor_status" */
    processor_metadata_processor_status: Array<ProcessorMetadataProcessorStatus>;
    /** fetch aggregated fields from the table: "processor_metadata.processor_status" */
    processor_metadata_processor_status_aggregate: ProcessorMetadataProcessorStatusAggregate;
    /** fetch data from the table: "processor_metadata.processor_status" using primary key columns */
    processor_metadata_processor_status_by_pk?: Maybe<ProcessorMetadataProcessorStatus>;
    /** fetch data from the table: "processor_status" */
    processor_status: Array<ProcessorStatus>;
    /** fetch aggregated fields from the table: "processor_status" */
    processor_status_aggregate: ProcessorStatusAggregate;
    /** fetch data from the table: "processor_status" using primary key columns */
    processor_status_by_pk?: Maybe<ProcessorStatus>;
    /** fetch data from the table: "proposal_votes" */
    proposal_votes: Array<ProposalVotes>;
    /** fetch aggregated fields from the table: "proposal_votes" */
    proposal_votes_aggregate: ProposalVotesAggregate;
    /** fetch data from the table: "proposal_votes" using primary key columns */
    proposal_votes_by_pk?: Maybe<ProposalVotes>;
    /** fetch data from the table: "public_key_auth_keys" */
    public_key_auth_keys: Array<PublicKeyAuthKeys>;
    /** fetch aggregated fields from the table: "public_key_auth_keys" */
    public_key_auth_keys_aggregate: PublicKeyAuthKeysAggregate;
    /** fetch data from the table: "public_key_auth_keys" using primary key columns */
    public_key_auth_keys_by_pk?: Maybe<PublicKeyAuthKeys>;
    /** fetch data from the table: "signatures" */
    signatures: Array<Signatures>;
    /** fetch aggregated fields from the table: "signatures" */
    signatures_aggregate: SignaturesAggregate;
    /** fetch data from the table: "signatures" using primary key columns */
    signatures_by_pk?: Maybe<Signatures>;
    /** fetch data from the table: "spam_assets" */
    spam_assets: Array<SpamAssets>;
    /** fetch aggregated fields from the table: "spam_assets" */
    spam_assets_aggregate: SpamAssetsAggregate;
    /** fetch data from the table: "spam_assets" using primary key columns */
    spam_assets_by_pk?: Maybe<SpamAssets>;
    /** fetch data from the table: "table_items" */
    table_items: Array<TableItems>;
    /** fetch aggregated fields from the table: "table_items" */
    table_items_aggregate: TableItemsAggregate;
    /** fetch data from the table: "table_items" using primary key columns */
    table_items_by_pk?: Maybe<TableItems>;
    /** fetch data from the table: "table_items_view" */
    table_items_view: Array<TableItemsView>;
    /** fetch aggregated fields from the table: "table_items_view" */
    table_items_view_aggregate: TableItemsViewAggregate;
    /** fetch data from the table: "table_metadatas" */
    table_metadatas: Array<TableMetadatas>;
    /** fetch aggregated fields from the table: "table_metadatas" */
    table_metadatas_aggregate: TableMetadatasAggregate;
    /** fetch data from the table: "table_metadatas" using primary key columns */
    table_metadatas_by_pk?: Maybe<TableMetadatas>;
    /** fetch data from the table: "token_activities" */
    token_activities: Array<TokenActivities>;
    /** fetch aggregated fields from the table: "token_activities" */
    token_activities_aggregate: TokenActivitiesAggregate;
    /** fetch data from the table: "token_activities" using primary key columns */
    token_activities_by_pk?: Maybe<TokenActivities>;
    /** fetch data from the table: "token_activities_v2" */
    token_activities_v2: Array<TokenActivitiesV2>;
    /** fetch aggregated fields from the table: "token_activities_v2" */
    token_activities_v2_aggregate: TokenActivitiesV2Aggregate;
    /** fetch data from the table: "token_activities_v2" using primary key columns */
    token_activities_v2_by_pk?: Maybe<TokenActivitiesV2>;
    /** fetch data from the table: "token_datas" */
    token_datas: Array<TokenDatas>;
    /** fetch aggregated fields from the table: "token_datas" */
    token_datas_aggregate: TokenDatasAggregate;
    /** fetch data from the table: "token_datas" using primary key columns */
    token_datas_by_pk?: Maybe<TokenDatas>;
    /** fetch data from the table: "token_datas_v2" */
    token_datas_v2: Array<TokenDatasV2>;
    /** fetch aggregated fields from the table: "token_datas_v2" */
    token_datas_v2_aggregate: TokenDatasV2Aggregate;
    /** fetch data from the table: "token_datas_v2" using primary key columns */
    token_datas_v2_by_pk?: Maybe<TokenDatasV2>;
    /** fetch data from the table: "token_ownerships" */
    token_ownerships: Array<TokenOwnerships>;
    /** fetch aggregated fields from the table: "token_ownerships" */
    token_ownerships_aggregate: TokenOwnershipsAggregate;
    /** fetch data from the table: "token_ownerships" using primary key columns */
    token_ownerships_by_pk?: Maybe<TokenOwnerships>;
    /** fetch data from the table: "token_ownerships_v2" */
    token_ownerships_v2: Array<TokenOwnershipsV2>;
    /** fetch aggregated fields from the table: "token_ownerships_v2" */
    token_ownerships_v2_aggregate: TokenOwnershipsV2Aggregate;
    /** fetch data from the table: "token_ownerships_v2" using primary key columns */
    token_ownerships_v2_by_pk?: Maybe<TokenOwnershipsV2>;
    /** fetch data from the table: "tokens" */
    tokens: Array<Tokens>;
    /** fetch aggregated fields from the table: "tokens" */
    tokens_aggregate: TokensAggregate;
    /** fetch data from the table: "tokens" using primary key columns */
    tokens_by_pk?: Maybe<Tokens>;
    /** fetch data from the table: "transaction_size_info" */
    transaction_size_info: Array<TransactionSizeInfo>;
    /** fetch aggregated fields from the table: "transaction_size_info" */
    transaction_size_info_aggregate: TransactionSizeInfoAggregate;
    /** fetch data from the table: "transaction_size_info" using primary key columns */
    transaction_size_info_by_pk?: Maybe<TransactionSizeInfo>;
    /** fetch data from the table: "transactions_view" */
    transactions_view: Array<TransactionsView>;
    /** fetch aggregated fields from the table: "transactions_view" */
    transactions_view_aggregate: TransactionsViewAggregate;
    /** fetch data from the table: "user_transactions" */
    user_transactions: Array<UserTransactions>;
    /** fetch aggregated fields from the table: "user_transactions" */
    user_transactions_aggregate: UserTransactionsAggregate;
    /** fetch data from the table: "user_transactions" using primary key columns */
    user_transactions_by_pk?: Maybe<UserTransactions>;
};
type QueryRootAccountTransactionsArgs = {
    distinct_on?: InputMaybe<Array<AccountTransactionsSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<AccountTransactionsOrderBy>>;
    where?: InputMaybe<AccountTransactionsBoolExp>;
};
type QueryRootAccountTransactionsAggregateArgs = {
    distinct_on?: InputMaybe<Array<AccountTransactionsSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<AccountTransactionsOrderBy>>;
    where?: InputMaybe<AccountTransactionsBoolExp>;
};
type QueryRootAccountTransactionsByPkArgs = {
    account_address: Scalars["String"]["input"];
    transaction_version: Scalars["bigint"]["input"];
};
type QueryRootAddressEventsSummaryArgs = {
    distinct_on?: InputMaybe<Array<AddressEventsSummarySelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<AddressEventsSummaryOrderBy>>;
    where?: InputMaybe<AddressEventsSummaryBoolExp>;
};
type QueryRootAddressEventsSummaryAggregateArgs = {
    distinct_on?: InputMaybe<Array<AddressEventsSummarySelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<AddressEventsSummaryOrderBy>>;
    where?: InputMaybe<AddressEventsSummaryBoolExp>;
};
type QueryRootAddressVersionFromEventsArgs = {
    distinct_on?: InputMaybe<Array<AddressVersionFromEventsSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<AddressVersionFromEventsOrderBy>>;
    where?: InputMaybe<AddressVersionFromEventsBoolExp>;
};
type QueryRootAddressVersionFromEventsAggregateArgs = {
    distinct_on?: InputMaybe<Array<AddressVersionFromEventsSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<AddressVersionFromEventsOrderBy>>;
    where?: InputMaybe<AddressVersionFromEventsBoolExp>;
};
type QueryRootAddressVersionFromMoveResourcesArgs = {
    distinct_on?: InputMaybe<Array<AddressVersionFromMoveResourcesSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<AddressVersionFromMoveResourcesOrderBy>>;
    where?: InputMaybe<AddressVersionFromMoveResourcesBoolExp>;
};
type QueryRootAddressVersionFromMoveResourcesAggregateArgs = {
    distinct_on?: InputMaybe<Array<AddressVersionFromMoveResourcesSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<AddressVersionFromMoveResourcesOrderBy>>;
    where?: InputMaybe<AddressVersionFromMoveResourcesBoolExp>;
};
type QueryRootAnsLookupArgs = {
    distinct_on?: InputMaybe<Array<AnsLookupSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<AnsLookupOrderBy>>;
    where?: InputMaybe<AnsLookupBoolExp>;
};
type QueryRootAnsLookupAggregateArgs = {
    distinct_on?: InputMaybe<Array<AnsLookupSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<AnsLookupOrderBy>>;
    where?: InputMaybe<AnsLookupBoolExp>;
};
type QueryRootAnsLookupByPkArgs = {
    transaction_version: Scalars["bigint"]["input"];
    write_set_change_index: Scalars["bigint"]["input"];
};
type QueryRootAnsLookupV2Args = {
    distinct_on?: InputMaybe<Array<AnsLookupV2SelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<AnsLookupV2OrderBy>>;
    where?: InputMaybe<AnsLookupV2BoolExp>;
};
type QueryRootAnsLookupV2AggregateArgs = {
    distinct_on?: InputMaybe<Array<AnsLookupV2SelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<AnsLookupV2OrderBy>>;
    where?: InputMaybe<AnsLookupV2BoolExp>;
};
type QueryRootAnsLookupV2ByPkArgs = {
    transaction_version: Scalars["bigint"]["input"];
    write_set_change_index: Scalars["bigint"]["input"];
};
type QueryRootAnsPrimaryNameArgs = {
    distinct_on?: InputMaybe<Array<AnsPrimaryNameSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<AnsPrimaryNameOrderBy>>;
    where?: InputMaybe<AnsPrimaryNameBoolExp>;
};
type QueryRootAnsPrimaryNameAggregateArgs = {
    distinct_on?: InputMaybe<Array<AnsPrimaryNameSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<AnsPrimaryNameOrderBy>>;
    where?: InputMaybe<AnsPrimaryNameBoolExp>;
};
type QueryRootAnsPrimaryNameByPkArgs = {
    transaction_version: Scalars["bigint"]["input"];
    write_set_change_index: Scalars["bigint"]["input"];
};
type QueryRootAnsPrimaryNameV2Args = {
    distinct_on?: InputMaybe<Array<AnsPrimaryNameV2SelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<AnsPrimaryNameV2OrderBy>>;
    where?: InputMaybe<AnsPrimaryNameV2BoolExp>;
};
type QueryRootAnsPrimaryNameV2AggregateArgs = {
    distinct_on?: InputMaybe<Array<AnsPrimaryNameV2SelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<AnsPrimaryNameV2OrderBy>>;
    where?: InputMaybe<AnsPrimaryNameV2BoolExp>;
};
type QueryRootAnsPrimaryNameV2ByPkArgs = {
    transaction_version: Scalars["bigint"]["input"];
    write_set_change_index: Scalars["bigint"]["input"];
};
type QueryRootAuthKeyAccountAddressesArgs = {
    distinct_on?: InputMaybe<Array<AuthKeyAccountAddressesSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<AuthKeyAccountAddressesOrderBy>>;
    where?: InputMaybe<AuthKeyAccountAddressesBoolExp>;
};
type QueryRootAuthKeyAccountAddressesAggregateArgs = {
    distinct_on?: InputMaybe<Array<AuthKeyAccountAddressesSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<AuthKeyAccountAddressesOrderBy>>;
    where?: InputMaybe<AuthKeyAccountAddressesBoolExp>;
};
type QueryRootAuthKeyAccountAddressesByPkArgs = {
    account_address: Scalars["String"]["input"];
};
type QueryRootBlockMetadataTransactionsArgs = {
    distinct_on?: InputMaybe<Array<BlockMetadataTransactionsSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<BlockMetadataTransactionsOrderBy>>;
    where?: InputMaybe<BlockMetadataTransactionsBoolExp>;
};
type QueryRootBlockMetadataTransactionsAggregateArgs = {
    distinct_on?: InputMaybe<Array<BlockMetadataTransactionsSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<BlockMetadataTransactionsOrderBy>>;
    where?: InputMaybe<BlockMetadataTransactionsBoolExp>;
};
type QueryRootBlockMetadataTransactionsByPkArgs = {
    version: Scalars["bigint"]["input"];
};
type QueryRootCoinActivitiesArgs = {
    distinct_on?: InputMaybe<Array<CoinActivitiesSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CoinActivitiesOrderBy>>;
    where?: InputMaybe<CoinActivitiesBoolExp>;
};
type QueryRootCoinActivitiesAggregateArgs = {
    distinct_on?: InputMaybe<Array<CoinActivitiesSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CoinActivitiesOrderBy>>;
    where?: InputMaybe<CoinActivitiesBoolExp>;
};
type QueryRootCoinActivitiesByPkArgs = {
    event_account_address: Scalars["String"]["input"];
    event_creation_number: Scalars["bigint"]["input"];
    event_sequence_number: Scalars["bigint"]["input"];
    transaction_version: Scalars["bigint"]["input"];
};
type QueryRootCoinBalancesArgs = {
    distinct_on?: InputMaybe<Array<CoinBalancesSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CoinBalancesOrderBy>>;
    where?: InputMaybe<CoinBalancesBoolExp>;
};
type QueryRootCoinBalancesAggregateArgs = {
    distinct_on?: InputMaybe<Array<CoinBalancesSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CoinBalancesOrderBy>>;
    where?: InputMaybe<CoinBalancesBoolExp>;
};
type QueryRootCoinBalancesByPkArgs = {
    coin_type_hash: Scalars["String"]["input"];
    owner_address: Scalars["String"]["input"];
    transaction_version: Scalars["bigint"]["input"];
};
type QueryRootCoinInfosArgs = {
    distinct_on?: InputMaybe<Array<CoinInfosSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CoinInfosOrderBy>>;
    where?: InputMaybe<CoinInfosBoolExp>;
};
type QueryRootCoinInfosAggregateArgs = {
    distinct_on?: InputMaybe<Array<CoinInfosSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CoinInfosOrderBy>>;
    where?: InputMaybe<CoinInfosBoolExp>;
};
type QueryRootCoinInfosByPkArgs = {
    coin_type_hash: Scalars["String"]["input"];
};
type QueryRootCoinSupplyArgs = {
    distinct_on?: InputMaybe<Array<CoinSupplySelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CoinSupplyOrderBy>>;
    where?: InputMaybe<CoinSupplyBoolExp>;
};
type QueryRootCoinSupplyAggregateArgs = {
    distinct_on?: InputMaybe<Array<CoinSupplySelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CoinSupplyOrderBy>>;
    where?: InputMaybe<CoinSupplyBoolExp>;
};
type QueryRootCoinSupplyByPkArgs = {
    coin_type_hash: Scalars["String"]["input"];
    transaction_version: Scalars["bigint"]["input"];
};
type QueryRootCollectionDatasArgs = {
    distinct_on?: InputMaybe<Array<CollectionDatasSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CollectionDatasOrderBy>>;
    where?: InputMaybe<CollectionDatasBoolExp>;
};
type QueryRootCollectionDatasAggregateArgs = {
    distinct_on?: InputMaybe<Array<CollectionDatasSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CollectionDatasOrderBy>>;
    where?: InputMaybe<CollectionDatasBoolExp>;
};
type QueryRootCollectionDatasByPkArgs = {
    collection_data_id_hash: Scalars["String"]["input"];
    transaction_version: Scalars["bigint"]["input"];
};
type QueryRootCollectionsV2Args = {
    distinct_on?: InputMaybe<Array<CollectionsV2SelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CollectionsV2OrderBy>>;
    where?: InputMaybe<CollectionsV2BoolExp>;
};
type QueryRootCollectionsV2AggregateArgs = {
    distinct_on?: InputMaybe<Array<CollectionsV2SelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CollectionsV2OrderBy>>;
    where?: InputMaybe<CollectionsV2BoolExp>;
};
type QueryRootCollectionsV2ByPkArgs = {
    transaction_version: Scalars["bigint"]["input"];
    write_set_change_index: Scalars["bigint"]["input"];
};
type QueryRootCurrentAnsLookupArgs = {
    distinct_on?: InputMaybe<Array<CurrentAnsLookupSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentAnsLookupOrderBy>>;
    where?: InputMaybe<CurrentAnsLookupBoolExp>;
};
type QueryRootCurrentAnsLookupAggregateArgs = {
    distinct_on?: InputMaybe<Array<CurrentAnsLookupSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentAnsLookupOrderBy>>;
    where?: InputMaybe<CurrentAnsLookupBoolExp>;
};
type QueryRootCurrentAnsLookupByPkArgs = {
    domain: Scalars["String"]["input"];
    subdomain: Scalars["String"]["input"];
};
type QueryRootCurrentAnsLookupV2Args = {
    distinct_on?: InputMaybe<Array<CurrentAnsLookupV2SelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentAnsLookupV2OrderBy>>;
    where?: InputMaybe<CurrentAnsLookupV2BoolExp>;
};
type QueryRootCurrentAnsLookupV2AggregateArgs = {
    distinct_on?: InputMaybe<Array<CurrentAnsLookupV2SelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentAnsLookupV2OrderBy>>;
    where?: InputMaybe<CurrentAnsLookupV2BoolExp>;
};
type QueryRootCurrentAnsLookupV2ByPkArgs = {
    domain: Scalars["String"]["input"];
    subdomain: Scalars["String"]["input"];
    token_standard: Scalars["String"]["input"];
};
type QueryRootCurrentAnsPrimaryNameArgs = {
    distinct_on?: InputMaybe<Array<CurrentAnsPrimaryNameSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentAnsPrimaryNameOrderBy>>;
    where?: InputMaybe<CurrentAnsPrimaryNameBoolExp>;
};
type QueryRootCurrentAnsPrimaryNameAggregateArgs = {
    distinct_on?: InputMaybe<Array<CurrentAnsPrimaryNameSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentAnsPrimaryNameOrderBy>>;
    where?: InputMaybe<CurrentAnsPrimaryNameBoolExp>;
};
type QueryRootCurrentAnsPrimaryNameByPkArgs = {
    registered_address: Scalars["String"]["input"];
};
type QueryRootCurrentAnsPrimaryNameV2Args = {
    distinct_on?: InputMaybe<Array<CurrentAnsPrimaryNameV2SelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentAnsPrimaryNameV2OrderBy>>;
    where?: InputMaybe<CurrentAnsPrimaryNameV2BoolExp>;
};
type QueryRootCurrentAnsPrimaryNameV2AggregateArgs = {
    distinct_on?: InputMaybe<Array<CurrentAnsPrimaryNameV2SelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentAnsPrimaryNameV2OrderBy>>;
    where?: InputMaybe<CurrentAnsPrimaryNameV2BoolExp>;
};
type QueryRootCurrentAnsPrimaryNameV2ByPkArgs = {
    registered_address: Scalars["String"]["input"];
    token_standard: Scalars["String"]["input"];
};
type QueryRootCurrentCedraNamesArgs = {
    distinct_on?: InputMaybe<Array<CurrentCedraNamesSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentCedraNamesOrderBy>>;
    where?: InputMaybe<CurrentCedraNamesBoolExp>;
};
type QueryRootCurrentCedraNamesAggregateArgs = {
    distinct_on?: InputMaybe<Array<CurrentCedraNamesSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentCedraNamesOrderBy>>;
    where?: InputMaybe<CurrentCedraNamesBoolExp>;
};
type QueryRootCurrentCoinBalancesArgs = {
    distinct_on?: InputMaybe<Array<CurrentCoinBalancesSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentCoinBalancesOrderBy>>;
    where?: InputMaybe<CurrentCoinBalancesBoolExp>;
};
type QueryRootCurrentCoinBalancesAggregateArgs = {
    distinct_on?: InputMaybe<Array<CurrentCoinBalancesSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentCoinBalancesOrderBy>>;
    where?: InputMaybe<CurrentCoinBalancesBoolExp>;
};
type QueryRootCurrentCoinBalancesByPkArgs = {
    coin_type_hash: Scalars["String"]["input"];
    owner_address: Scalars["String"]["input"];
};
type QueryRootCurrentCollectionDatasArgs = {
    distinct_on?: InputMaybe<Array<CurrentCollectionDatasSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentCollectionDatasOrderBy>>;
    where?: InputMaybe<CurrentCollectionDatasBoolExp>;
};
type QueryRootCurrentCollectionDatasAggregateArgs = {
    distinct_on?: InputMaybe<Array<CurrentCollectionDatasSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentCollectionDatasOrderBy>>;
    where?: InputMaybe<CurrentCollectionDatasBoolExp>;
};
type QueryRootCurrentCollectionDatasByPkArgs = {
    collection_data_id_hash: Scalars["String"]["input"];
};
type QueryRootCurrentCollectionOwnershipV2ViewArgs = {
    distinct_on?: InputMaybe<Array<CurrentCollectionOwnershipV2ViewSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentCollectionOwnershipV2ViewOrderBy>>;
    where?: InputMaybe<CurrentCollectionOwnershipV2ViewBoolExp>;
};
type QueryRootCurrentCollectionOwnershipV2ViewAggregateArgs = {
    distinct_on?: InputMaybe<Array<CurrentCollectionOwnershipV2ViewSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentCollectionOwnershipV2ViewOrderBy>>;
    where?: InputMaybe<CurrentCollectionOwnershipV2ViewBoolExp>;
};
type QueryRootCurrentCollectionOwnershipViewArgs = {
    distinct_on?: InputMaybe<Array<CurrentCollectionOwnershipViewSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentCollectionOwnershipViewOrderBy>>;
    where?: InputMaybe<CurrentCollectionOwnershipViewBoolExp>;
};
type QueryRootCurrentCollectionOwnershipViewAggregateArgs = {
    distinct_on?: InputMaybe<Array<CurrentCollectionOwnershipViewSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentCollectionOwnershipViewOrderBy>>;
    where?: InputMaybe<CurrentCollectionOwnershipViewBoolExp>;
};
type QueryRootCurrentCollectionsV2Args = {
    distinct_on?: InputMaybe<Array<CurrentCollectionsV2SelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentCollectionsV2OrderBy>>;
    where?: InputMaybe<CurrentCollectionsV2BoolExp>;
};
type QueryRootCurrentCollectionsV2AggregateArgs = {
    distinct_on?: InputMaybe<Array<CurrentCollectionsV2SelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentCollectionsV2OrderBy>>;
    where?: InputMaybe<CurrentCollectionsV2BoolExp>;
};
type QueryRootCurrentCollectionsV2ByPkArgs = {
    collection_id: Scalars["String"]["input"];
};
type QueryRootCurrentDelegatedStakingPoolBalancesArgs = {
    distinct_on?: InputMaybe<Array<CurrentDelegatedStakingPoolBalancesSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentDelegatedStakingPoolBalancesOrderBy>>;
    where?: InputMaybe<CurrentDelegatedStakingPoolBalancesBoolExp>;
};
type QueryRootCurrentDelegatedStakingPoolBalancesAggregateArgs = {
    distinct_on?: InputMaybe<Array<CurrentDelegatedStakingPoolBalancesSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentDelegatedStakingPoolBalancesOrderBy>>;
    where?: InputMaybe<CurrentDelegatedStakingPoolBalancesBoolExp>;
};
type QueryRootCurrentDelegatedStakingPoolBalancesByPkArgs = {
    staking_pool_address: Scalars["String"]["input"];
};
type QueryRootCurrentDelegatedVoterArgs = {
    distinct_on?: InputMaybe<Array<CurrentDelegatedVoterSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentDelegatedVoterOrderBy>>;
    where?: InputMaybe<CurrentDelegatedVoterBoolExp>;
};
type QueryRootCurrentDelegatedVoterAggregateArgs = {
    distinct_on?: InputMaybe<Array<CurrentDelegatedVoterSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentDelegatedVoterOrderBy>>;
    where?: InputMaybe<CurrentDelegatedVoterBoolExp>;
};
type QueryRootCurrentDelegatedVoterByPkArgs = {
    delegation_pool_address: Scalars["String"]["input"];
    delegator_address: Scalars["String"]["input"];
};
type QueryRootCurrentDelegatorBalancesArgs = {
    distinct_on?: InputMaybe<Array<CurrentDelegatorBalancesSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentDelegatorBalancesOrderBy>>;
    where?: InputMaybe<CurrentDelegatorBalancesBoolExp>;
};
type QueryRootCurrentDelegatorBalancesAggregateArgs = {
    distinct_on?: InputMaybe<Array<CurrentDelegatorBalancesSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentDelegatorBalancesOrderBy>>;
    where?: InputMaybe<CurrentDelegatorBalancesBoolExp>;
};
type QueryRootCurrentDelegatorBalancesByPkArgs = {
    delegator_address: Scalars["String"]["input"];
    pool_address: Scalars["String"]["input"];
    pool_type: Scalars["String"]["input"];
    table_handle: Scalars["String"]["input"];
};
type QueryRootCurrentFungibleAssetBalancesArgs = {
    distinct_on?: InputMaybe<Array<CurrentFungibleAssetBalancesSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentFungibleAssetBalancesOrderBy>>;
    where?: InputMaybe<CurrentFungibleAssetBalancesBoolExp>;
};
type QueryRootCurrentFungibleAssetBalancesAggregateArgs = {
    distinct_on?: InputMaybe<Array<CurrentFungibleAssetBalancesSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentFungibleAssetBalancesOrderBy>>;
    where?: InputMaybe<CurrentFungibleAssetBalancesBoolExp>;
};
type QueryRootCurrentFungibleAssetBalancesByPkArgs = {
    storage_id: Scalars["String"]["input"];
};
type QueryRootCurrentFungibleAssetBalancesNewArgs = {
    distinct_on?: InputMaybe<Array<CurrentFungibleAssetBalancesNewSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentFungibleAssetBalancesNewOrderBy>>;
    where?: InputMaybe<CurrentFungibleAssetBalancesNewBoolExp>;
};
type QueryRootCurrentFungibleAssetBalancesNewAggregateArgs = {
    distinct_on?: InputMaybe<Array<CurrentFungibleAssetBalancesNewSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentFungibleAssetBalancesNewOrderBy>>;
    where?: InputMaybe<CurrentFungibleAssetBalancesNewBoolExp>;
};
type QueryRootCurrentFungibleAssetBalancesNewByPkArgs = {
    storage_id: Scalars["String"]["input"];
};
type QueryRootCurrentObjectsArgs = {
    distinct_on?: InputMaybe<Array<CurrentObjectsSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentObjectsOrderBy>>;
    where?: InputMaybe<CurrentObjectsBoolExp>;
};
type QueryRootCurrentObjectsAggregateArgs = {
    distinct_on?: InputMaybe<Array<CurrentObjectsSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentObjectsOrderBy>>;
    where?: InputMaybe<CurrentObjectsBoolExp>;
};
type QueryRootCurrentObjectsByPkArgs = {
    object_address: Scalars["String"]["input"];
};
type QueryRootCurrentStakingPoolVoterArgs = {
    distinct_on?: InputMaybe<Array<CurrentStakingPoolVoterSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentStakingPoolVoterOrderBy>>;
    where?: InputMaybe<CurrentStakingPoolVoterBoolExp>;
};
type QueryRootCurrentStakingPoolVoterAggregateArgs = {
    distinct_on?: InputMaybe<Array<CurrentStakingPoolVoterSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentStakingPoolVoterOrderBy>>;
    where?: InputMaybe<CurrentStakingPoolVoterBoolExp>;
};
type QueryRootCurrentStakingPoolVoterByPkArgs = {
    staking_pool_address: Scalars["String"]["input"];
};
type QueryRootCurrentTableItemsArgs = {
    distinct_on?: InputMaybe<Array<CurrentTableItemsSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentTableItemsOrderBy>>;
    where?: InputMaybe<CurrentTableItemsBoolExp>;
};
type QueryRootCurrentTableItemsAggregateArgs = {
    distinct_on?: InputMaybe<Array<CurrentTableItemsSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentTableItemsOrderBy>>;
    where?: InputMaybe<CurrentTableItemsBoolExp>;
};
type QueryRootCurrentTableItemsByPkArgs = {
    key_hash: Scalars["String"]["input"];
    table_handle: Scalars["String"]["input"];
};
type QueryRootCurrentTableItemsViewArgs = {
    distinct_on?: InputMaybe<Array<CurrentTableItemsViewSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentTableItemsViewOrderBy>>;
    where?: InputMaybe<CurrentTableItemsViewBoolExp>;
};
type QueryRootCurrentTableItemsViewAggregateArgs = {
    distinct_on?: InputMaybe<Array<CurrentTableItemsViewSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentTableItemsViewOrderBy>>;
    where?: InputMaybe<CurrentTableItemsViewBoolExp>;
};
type QueryRootCurrentTokenDatasArgs = {
    distinct_on?: InputMaybe<Array<CurrentTokenDatasSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentTokenDatasOrderBy>>;
    where?: InputMaybe<CurrentTokenDatasBoolExp>;
};
type QueryRootCurrentTokenDatasAggregateArgs = {
    distinct_on?: InputMaybe<Array<CurrentTokenDatasSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentTokenDatasOrderBy>>;
    where?: InputMaybe<CurrentTokenDatasBoolExp>;
};
type QueryRootCurrentTokenDatasByPkArgs = {
    token_data_id_hash: Scalars["String"]["input"];
};
type QueryRootCurrentTokenDatasV2Args = {
    distinct_on?: InputMaybe<Array<CurrentTokenDatasV2SelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentTokenDatasV2OrderBy>>;
    where?: InputMaybe<CurrentTokenDatasV2BoolExp>;
};
type QueryRootCurrentTokenDatasV2AggregateArgs = {
    distinct_on?: InputMaybe<Array<CurrentTokenDatasV2SelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentTokenDatasV2OrderBy>>;
    where?: InputMaybe<CurrentTokenDatasV2BoolExp>;
};
type QueryRootCurrentTokenDatasV2ByPkArgs = {
    token_data_id: Scalars["String"]["input"];
};
type QueryRootCurrentTokenOwnershipsArgs = {
    distinct_on?: InputMaybe<Array<CurrentTokenOwnershipsSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentTokenOwnershipsOrderBy>>;
    where?: InputMaybe<CurrentTokenOwnershipsBoolExp>;
};
type QueryRootCurrentTokenOwnershipsAggregateArgs = {
    distinct_on?: InputMaybe<Array<CurrentTokenOwnershipsSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentTokenOwnershipsOrderBy>>;
    where?: InputMaybe<CurrentTokenOwnershipsBoolExp>;
};
type QueryRootCurrentTokenOwnershipsByPkArgs = {
    owner_address: Scalars["String"]["input"];
    property_version: Scalars["numeric"]["input"];
    token_data_id_hash: Scalars["String"]["input"];
};
type QueryRootCurrentTokenOwnershipsV2Args = {
    distinct_on?: InputMaybe<Array<CurrentTokenOwnershipsV2SelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentTokenOwnershipsV2OrderBy>>;
    where?: InputMaybe<CurrentTokenOwnershipsV2BoolExp>;
};
type QueryRootCurrentTokenOwnershipsV2AggregateArgs = {
    distinct_on?: InputMaybe<Array<CurrentTokenOwnershipsV2SelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentTokenOwnershipsV2OrderBy>>;
    where?: InputMaybe<CurrentTokenOwnershipsV2BoolExp>;
};
type QueryRootCurrentTokenOwnershipsV2ByPkArgs = {
    owner_address: Scalars["String"]["input"];
    property_version_v1: Scalars["numeric"]["input"];
    storage_id: Scalars["String"]["input"];
    token_data_id: Scalars["String"]["input"];
};
type QueryRootCurrentTokenPendingClaimsArgs = {
    distinct_on?: InputMaybe<Array<CurrentTokenPendingClaimsSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentTokenPendingClaimsOrderBy>>;
    where?: InputMaybe<CurrentTokenPendingClaimsBoolExp>;
};
type QueryRootCurrentTokenPendingClaimsAggregateArgs = {
    distinct_on?: InputMaybe<Array<CurrentTokenPendingClaimsSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentTokenPendingClaimsOrderBy>>;
    where?: InputMaybe<CurrentTokenPendingClaimsBoolExp>;
};
type QueryRootCurrentTokenPendingClaimsByPkArgs = {
    from_address: Scalars["String"]["input"];
    property_version: Scalars["numeric"]["input"];
    to_address: Scalars["String"]["input"];
    token_data_id_hash: Scalars["String"]["input"];
};
type QueryRootCurrentTokenRoyaltyV1Args = {
    distinct_on?: InputMaybe<Array<CurrentTokenRoyaltyV1SelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentTokenRoyaltyV1OrderBy>>;
    where?: InputMaybe<CurrentTokenRoyaltyV1BoolExp>;
};
type QueryRootCurrentTokenRoyaltyV1AggregateArgs = {
    distinct_on?: InputMaybe<Array<CurrentTokenRoyaltyV1SelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentTokenRoyaltyV1OrderBy>>;
    where?: InputMaybe<CurrentTokenRoyaltyV1BoolExp>;
};
type QueryRootCurrentTokenRoyaltyV1ByPkArgs = {
    token_data_id: Scalars["String"]["input"];
};
type QueryRootCurrentTokenV2MetadataArgs = {
    distinct_on?: InputMaybe<Array<CurrentTokenV2MetadataSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentTokenV2MetadataOrderBy>>;
    where?: InputMaybe<CurrentTokenV2MetadataBoolExp>;
};
type QueryRootCurrentTokenV2MetadataAggregateArgs = {
    distinct_on?: InputMaybe<Array<CurrentTokenV2MetadataSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentTokenV2MetadataOrderBy>>;
    where?: InputMaybe<CurrentTokenV2MetadataBoolExp>;
};
type QueryRootCurrentTokenV2MetadataByPkArgs = {
    object_address: Scalars["String"]["input"];
    resource_type: Scalars["String"]["input"];
};
type QueryRootDelegatedStakingActivitiesArgs = {
    distinct_on?: InputMaybe<Array<DelegatedStakingActivitiesSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<DelegatedStakingActivitiesOrderBy>>;
    where?: InputMaybe<DelegatedStakingActivitiesBoolExp>;
};
type QueryRootDelegatedStakingActivitiesAggregateArgs = {
    distinct_on?: InputMaybe<Array<DelegatedStakingActivitiesSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<DelegatedStakingActivitiesOrderBy>>;
    where?: InputMaybe<DelegatedStakingActivitiesBoolExp>;
};
type QueryRootDelegatedStakingActivitiesByPkArgs = {
    event_index: Scalars["bigint"]["input"];
    transaction_version: Scalars["bigint"]["input"];
};
type QueryRootDelegatedStakingPoolBalancesArgs = {
    distinct_on?: InputMaybe<Array<DelegatedStakingPoolBalancesSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<DelegatedStakingPoolBalancesOrderBy>>;
    where?: InputMaybe<DelegatedStakingPoolBalancesBoolExp>;
};
type QueryRootDelegatedStakingPoolBalancesAggregateArgs = {
    distinct_on?: InputMaybe<Array<DelegatedStakingPoolBalancesSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<DelegatedStakingPoolBalancesOrderBy>>;
    where?: InputMaybe<DelegatedStakingPoolBalancesBoolExp>;
};
type QueryRootDelegatedStakingPoolBalancesByPkArgs = {
    staking_pool_address: Scalars["String"]["input"];
    transaction_version: Scalars["bigint"]["input"];
};
type QueryRootDelegatedStakingPoolsArgs = {
    distinct_on?: InputMaybe<Array<DelegatedStakingPoolsSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<DelegatedStakingPoolsOrderBy>>;
    where?: InputMaybe<DelegatedStakingPoolsBoolExp>;
};
type QueryRootDelegatedStakingPoolsAggregateArgs = {
    distinct_on?: InputMaybe<Array<DelegatedStakingPoolsSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<DelegatedStakingPoolsOrderBy>>;
    where?: InputMaybe<DelegatedStakingPoolsBoolExp>;
};
type QueryRootDelegatedStakingPoolsByPkArgs = {
    staking_pool_address: Scalars["String"]["input"];
};
type QueryRootDelegatorBalancesArgs = {
    distinct_on?: InputMaybe<Array<DelegatorBalancesSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<DelegatorBalancesOrderBy>>;
    where?: InputMaybe<DelegatorBalancesBoolExp>;
};
type QueryRootDelegatorBalancesAggregateArgs = {
    distinct_on?: InputMaybe<Array<DelegatorBalancesSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<DelegatorBalancesOrderBy>>;
    where?: InputMaybe<DelegatorBalancesBoolExp>;
};
type QueryRootDelegatorBalancesByPkArgs = {
    transaction_version: Scalars["bigint"]["input"];
    write_set_change_index: Scalars["bigint"]["input"];
};
type QueryRootDelegatorDistinctPoolArgs = {
    distinct_on?: InputMaybe<Array<DelegatorDistinctPoolSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<DelegatorDistinctPoolOrderBy>>;
    where?: InputMaybe<DelegatorDistinctPoolBoolExp>;
};
type QueryRootDelegatorDistinctPoolAggregateArgs = {
    distinct_on?: InputMaybe<Array<DelegatorDistinctPoolSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<DelegatorDistinctPoolOrderBy>>;
    where?: InputMaybe<DelegatorDistinctPoolBoolExp>;
};
type QueryRootEventSizeInfoArgs = {
    distinct_on?: InputMaybe<Array<EventSizeInfoSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<EventSizeInfoOrderBy>>;
    where?: InputMaybe<EventSizeInfoBoolExp>;
};
type QueryRootEventSizeInfoAggregateArgs = {
    distinct_on?: InputMaybe<Array<EventSizeInfoSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<EventSizeInfoOrderBy>>;
    where?: InputMaybe<EventSizeInfoBoolExp>;
};
type QueryRootEventSizeInfoByPkArgs = {
    index: Scalars["bigint"]["input"];
    transaction_version: Scalars["bigint"]["input"];
};
type QueryRootEventsArgs = {
    distinct_on?: InputMaybe<Array<EventsSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<EventsOrderBy>>;
    where?: InputMaybe<EventsBoolExp>;
};
type QueryRootEventsAggregateArgs = {
    distinct_on?: InputMaybe<Array<EventsSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<EventsOrderBy>>;
    where?: InputMaybe<EventsBoolExp>;
};
type QueryRootEventsByPkArgs = {
    event_index: Scalars["bigint"]["input"];
    transaction_version: Scalars["bigint"]["input"];
};
type QueryRootEventsViewArgs = {
    distinct_on?: InputMaybe<Array<EventsViewSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<EventsViewOrderBy>>;
    where?: InputMaybe<EventsViewBoolExp>;
};
type QueryRootEventsViewAggregateArgs = {
    distinct_on?: InputMaybe<Array<EventsViewSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<EventsViewOrderBy>>;
    where?: InputMaybe<EventsViewBoolExp>;
};
type QueryRootFungibleAssetActivitiesArgs = {
    distinct_on?: InputMaybe<Array<FungibleAssetActivitiesSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<FungibleAssetActivitiesOrderBy>>;
    where?: InputMaybe<FungibleAssetActivitiesBoolExp>;
};
type QueryRootFungibleAssetActivitiesAggregateArgs = {
    distinct_on?: InputMaybe<Array<FungibleAssetActivitiesSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<FungibleAssetActivitiesOrderBy>>;
    where?: InputMaybe<FungibleAssetActivitiesBoolExp>;
};
type QueryRootFungibleAssetActivitiesByPkArgs = {
    event_index: Scalars["bigint"]["input"];
    transaction_version: Scalars["bigint"]["input"];
};
type QueryRootFungibleAssetBalancesArgs = {
    distinct_on?: InputMaybe<Array<FungibleAssetBalancesSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<FungibleAssetBalancesOrderBy>>;
    where?: InputMaybe<FungibleAssetBalancesBoolExp>;
};
type QueryRootFungibleAssetBalancesAggregateArgs = {
    distinct_on?: InputMaybe<Array<FungibleAssetBalancesSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<FungibleAssetBalancesOrderBy>>;
    where?: InputMaybe<FungibleAssetBalancesBoolExp>;
};
type QueryRootFungibleAssetBalancesByPkArgs = {
    transaction_version: Scalars["bigint"]["input"];
    write_set_change_index: Scalars["bigint"]["input"];
};
type QueryRootFungibleAssetMetadataArgs = {
    distinct_on?: InputMaybe<Array<FungibleAssetMetadataSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<FungibleAssetMetadataOrderBy>>;
    where?: InputMaybe<FungibleAssetMetadataBoolExp>;
};
type QueryRootFungibleAssetMetadataAggregateArgs = {
    distinct_on?: InputMaybe<Array<FungibleAssetMetadataSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<FungibleAssetMetadataOrderBy>>;
    where?: InputMaybe<FungibleAssetMetadataBoolExp>;
};
type QueryRootFungibleAssetMetadataByPkArgs = {
    asset_type: Scalars["String"]["input"];
};
type QueryRootFungibleAssetToCoinMappingsArgs = {
    distinct_on?: InputMaybe<Array<FungibleAssetToCoinMappingsSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<FungibleAssetToCoinMappingsOrderBy>>;
    where?: InputMaybe<FungibleAssetToCoinMappingsBoolExp>;
};
type QueryRootFungibleAssetToCoinMappingsAggregateArgs = {
    distinct_on?: InputMaybe<Array<FungibleAssetToCoinMappingsSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<FungibleAssetToCoinMappingsOrderBy>>;
    where?: InputMaybe<FungibleAssetToCoinMappingsBoolExp>;
};
type QueryRootFungibleAssetToCoinMappingsByPkArgs = {
    fungible_asset_metadata_address: Scalars["String"]["input"];
};
type QueryRootGasFeesArgs = {
    distinct_on?: InputMaybe<Array<GasFeesSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<GasFeesOrderBy>>;
    where?: InputMaybe<GasFeesBoolExp>;
};
type QueryRootGasFeesAggregateArgs = {
    distinct_on?: InputMaybe<Array<GasFeesSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<GasFeesOrderBy>>;
    where?: InputMaybe<GasFeesBoolExp>;
};
type QueryRootGasFeesByPkArgs = {
    transaction_version: Scalars["bigint"]["input"];
};
type QueryRootIndexerStatusArgs = {
    distinct_on?: InputMaybe<Array<IndexerStatusSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<IndexerStatusOrderBy>>;
    where?: InputMaybe<IndexerStatusBoolExp>;
};
type QueryRootIndexerStatusAggregateArgs = {
    distinct_on?: InputMaybe<Array<IndexerStatusSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<IndexerStatusOrderBy>>;
    where?: InputMaybe<IndexerStatusBoolExp>;
};
type QueryRootIndexerStatusByPkArgs = {
    db: Scalars["String"]["input"];
};
type QueryRootMoveModulesArgs = {
    distinct_on?: InputMaybe<Array<MoveModulesSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<MoveModulesOrderBy>>;
    where?: InputMaybe<MoveModulesBoolExp>;
};
type QueryRootMoveModulesAggregateArgs = {
    distinct_on?: InputMaybe<Array<MoveModulesSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<MoveModulesOrderBy>>;
    where?: InputMaybe<MoveModulesBoolExp>;
};
type QueryRootMoveModulesByPkArgs = {
    transaction_version: Scalars["bigint"]["input"];
    write_set_change_index: Scalars["bigint"]["input"];
};
type QueryRootMoveResourcesArgs = {
    distinct_on?: InputMaybe<Array<MoveResourcesSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<MoveResourcesOrderBy>>;
    where?: InputMaybe<MoveResourcesBoolExp>;
};
type QueryRootMoveResourcesAggregateArgs = {
    distinct_on?: InputMaybe<Array<MoveResourcesSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<MoveResourcesOrderBy>>;
    where?: InputMaybe<MoveResourcesBoolExp>;
};
type QueryRootMoveResourcesByPkArgs = {
    transaction_version: Scalars["bigint"]["input"];
    write_set_change_index: Scalars["bigint"]["input"];
};
type QueryRootMoveResourcesViewArgs = {
    distinct_on?: InputMaybe<Array<MoveResourcesViewSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<MoveResourcesViewOrderBy>>;
    where?: InputMaybe<MoveResourcesViewBoolExp>;
};
type QueryRootMoveResourcesViewAggregateArgs = {
    distinct_on?: InputMaybe<Array<MoveResourcesViewSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<MoveResourcesViewOrderBy>>;
    where?: InputMaybe<MoveResourcesViewBoolExp>;
};
type QueryRootNftMetadataCrawlerParsedAssetUrisArgs = {
    distinct_on?: InputMaybe<Array<NftMetadataCrawlerParsedAssetUrisSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<NftMetadataCrawlerParsedAssetUrisOrderBy>>;
    where?: InputMaybe<NftMetadataCrawlerParsedAssetUrisBoolExp>;
};
type QueryRootNftMetadataCrawlerParsedAssetUrisAggregateArgs = {
    distinct_on?: InputMaybe<Array<NftMetadataCrawlerParsedAssetUrisSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<NftMetadataCrawlerParsedAssetUrisOrderBy>>;
    where?: InputMaybe<NftMetadataCrawlerParsedAssetUrisBoolExp>;
};
type QueryRootNftMetadataCrawlerParsedAssetUrisByPkArgs = {
    asset_uri: Scalars["String"]["input"];
};
type QueryRootNftPointsArgs = {
    distinct_on?: InputMaybe<Array<NftPointsSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<NftPointsOrderBy>>;
    where?: InputMaybe<NftPointsBoolExp>;
};
type QueryRootNftPointsAggregateArgs = {
    distinct_on?: InputMaybe<Array<NftPointsSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<NftPointsOrderBy>>;
    where?: InputMaybe<NftPointsBoolExp>;
};
type QueryRootNftPointsByPkArgs = {
    transaction_version: Scalars["bigint"]["input"];
};
type QueryRootNumActiveDelegatorPerPoolArgs = {
    distinct_on?: InputMaybe<Array<NumActiveDelegatorPerPoolSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<NumActiveDelegatorPerPoolOrderBy>>;
    where?: InputMaybe<NumActiveDelegatorPerPoolBoolExp>;
};
type QueryRootNumActiveDelegatorPerPoolAggregateArgs = {
    distinct_on?: InputMaybe<Array<NumActiveDelegatorPerPoolSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<NumActiveDelegatorPerPoolOrderBy>>;
    where?: InputMaybe<NumActiveDelegatorPerPoolBoolExp>;
};
type QueryRootObjectsArgs = {
    distinct_on?: InputMaybe<Array<ObjectsSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<ObjectsOrderBy>>;
    where?: InputMaybe<ObjectsBoolExp>;
};
type QueryRootObjectsAggregateArgs = {
    distinct_on?: InputMaybe<Array<ObjectsSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<ObjectsOrderBy>>;
    where?: InputMaybe<ObjectsBoolExp>;
};
type QueryRootObjectsByPkArgs = {
    transaction_version: Scalars["bigint"]["input"];
    write_set_change_index: Scalars["bigint"]["input"];
};
type QueryRootProcessorMetadataProcessorStatusArgs = {
    distinct_on?: InputMaybe<Array<ProcessorMetadataProcessorStatusSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<ProcessorMetadataProcessorStatusOrderBy>>;
    where?: InputMaybe<ProcessorMetadataProcessorStatusBoolExp>;
};
type QueryRootProcessorMetadataProcessorStatusAggregateArgs = {
    distinct_on?: InputMaybe<Array<ProcessorMetadataProcessorStatusSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<ProcessorMetadataProcessorStatusOrderBy>>;
    where?: InputMaybe<ProcessorMetadataProcessorStatusBoolExp>;
};
type QueryRootProcessorMetadataProcessorStatusByPkArgs = {
    processor: Scalars["String"]["input"];
};
type QueryRootProcessorStatusArgs = {
    distinct_on?: InputMaybe<Array<ProcessorStatusSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<ProcessorStatusOrderBy>>;
    where?: InputMaybe<ProcessorStatusBoolExp>;
};
type QueryRootProcessorStatusAggregateArgs = {
    distinct_on?: InputMaybe<Array<ProcessorStatusSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<ProcessorStatusOrderBy>>;
    where?: InputMaybe<ProcessorStatusBoolExp>;
};
type QueryRootProcessorStatusByPkArgs = {
    processor: Scalars["String"]["input"];
};
type QueryRootProposalVotesArgs = {
    distinct_on?: InputMaybe<Array<ProposalVotesSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<ProposalVotesOrderBy>>;
    where?: InputMaybe<ProposalVotesBoolExp>;
};
type QueryRootProposalVotesAggregateArgs = {
    distinct_on?: InputMaybe<Array<ProposalVotesSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<ProposalVotesOrderBy>>;
    where?: InputMaybe<ProposalVotesBoolExp>;
};
type QueryRootProposalVotesByPkArgs = {
    proposal_id: Scalars["bigint"]["input"];
    transaction_version: Scalars["bigint"]["input"];
    voter_address: Scalars["String"]["input"];
};
type QueryRootPublicKeyAuthKeysArgs = {
    distinct_on?: InputMaybe<Array<PublicKeyAuthKeysSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<PublicKeyAuthKeysOrderBy>>;
    where?: InputMaybe<PublicKeyAuthKeysBoolExp>;
};
type QueryRootPublicKeyAuthKeysAggregateArgs = {
    distinct_on?: InputMaybe<Array<PublicKeyAuthKeysSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<PublicKeyAuthKeysOrderBy>>;
    where?: InputMaybe<PublicKeyAuthKeysBoolExp>;
};
type QueryRootPublicKeyAuthKeysByPkArgs = {
    auth_key: Scalars["String"]["input"];
    public_key: Scalars["String"]["input"];
    public_key_type: Scalars["String"]["input"];
};
type QueryRootSignaturesArgs = {
    distinct_on?: InputMaybe<Array<SignaturesSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<SignaturesOrderBy>>;
    where?: InputMaybe<SignaturesBoolExp>;
};
type QueryRootSignaturesAggregateArgs = {
    distinct_on?: InputMaybe<Array<SignaturesSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<SignaturesOrderBy>>;
    where?: InputMaybe<SignaturesBoolExp>;
};
type QueryRootSignaturesByPkArgs = {
    is_sender_primary: Scalars["Boolean"]["input"];
    multi_agent_index: Scalars["bigint"]["input"];
    multi_sig_index: Scalars["bigint"]["input"];
    transaction_version: Scalars["bigint"]["input"];
};
type QueryRootSpamAssetsArgs = {
    distinct_on?: InputMaybe<Array<SpamAssetsSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<SpamAssetsOrderBy>>;
    where?: InputMaybe<SpamAssetsBoolExp>;
};
type QueryRootSpamAssetsAggregateArgs = {
    distinct_on?: InputMaybe<Array<SpamAssetsSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<SpamAssetsOrderBy>>;
    where?: InputMaybe<SpamAssetsBoolExp>;
};
type QueryRootSpamAssetsByPkArgs = {
    asset: Scalars["String"]["input"];
};
type QueryRootTableItemsArgs = {
    distinct_on?: InputMaybe<Array<TableItemsSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<TableItemsOrderBy>>;
    where?: InputMaybe<TableItemsBoolExp>;
};
type QueryRootTableItemsAggregateArgs = {
    distinct_on?: InputMaybe<Array<TableItemsSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<TableItemsOrderBy>>;
    where?: InputMaybe<TableItemsBoolExp>;
};
type QueryRootTableItemsByPkArgs = {
    transaction_version: Scalars["bigint"]["input"];
    write_set_change_index: Scalars["bigint"]["input"];
};
type QueryRootTableItemsViewArgs = {
    distinct_on?: InputMaybe<Array<TableItemsViewSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<TableItemsViewOrderBy>>;
    where?: InputMaybe<TableItemsViewBoolExp>;
};
type QueryRootTableItemsViewAggregateArgs = {
    distinct_on?: InputMaybe<Array<TableItemsViewSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<TableItemsViewOrderBy>>;
    where?: InputMaybe<TableItemsViewBoolExp>;
};
type QueryRootTableMetadatasArgs = {
    distinct_on?: InputMaybe<Array<TableMetadatasSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<TableMetadatasOrderBy>>;
    where?: InputMaybe<TableMetadatasBoolExp>;
};
type QueryRootTableMetadatasAggregateArgs = {
    distinct_on?: InputMaybe<Array<TableMetadatasSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<TableMetadatasOrderBy>>;
    where?: InputMaybe<TableMetadatasBoolExp>;
};
type QueryRootTableMetadatasByPkArgs = {
    handle: Scalars["String"]["input"];
};
type QueryRootTokenActivitiesArgs = {
    distinct_on?: InputMaybe<Array<TokenActivitiesSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<TokenActivitiesOrderBy>>;
    where?: InputMaybe<TokenActivitiesBoolExp>;
};
type QueryRootTokenActivitiesAggregateArgs = {
    distinct_on?: InputMaybe<Array<TokenActivitiesSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<TokenActivitiesOrderBy>>;
    where?: InputMaybe<TokenActivitiesBoolExp>;
};
type QueryRootTokenActivitiesByPkArgs = {
    event_account_address: Scalars["String"]["input"];
    event_creation_number: Scalars["bigint"]["input"];
    event_sequence_number: Scalars["bigint"]["input"];
    transaction_version: Scalars["bigint"]["input"];
};
type QueryRootTokenActivitiesV2Args = {
    distinct_on?: InputMaybe<Array<TokenActivitiesV2SelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<TokenActivitiesV2OrderBy>>;
    where?: InputMaybe<TokenActivitiesV2BoolExp>;
};
type QueryRootTokenActivitiesV2AggregateArgs = {
    distinct_on?: InputMaybe<Array<TokenActivitiesV2SelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<TokenActivitiesV2OrderBy>>;
    where?: InputMaybe<TokenActivitiesV2BoolExp>;
};
type QueryRootTokenActivitiesV2ByPkArgs = {
    event_index: Scalars["bigint"]["input"];
    transaction_version: Scalars["bigint"]["input"];
};
type QueryRootTokenDatasArgs = {
    distinct_on?: InputMaybe<Array<TokenDatasSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<TokenDatasOrderBy>>;
    where?: InputMaybe<TokenDatasBoolExp>;
};
type QueryRootTokenDatasAggregateArgs = {
    distinct_on?: InputMaybe<Array<TokenDatasSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<TokenDatasOrderBy>>;
    where?: InputMaybe<TokenDatasBoolExp>;
};
type QueryRootTokenDatasByPkArgs = {
    token_data_id_hash: Scalars["String"]["input"];
    transaction_version: Scalars["bigint"]["input"];
};
type QueryRootTokenDatasV2Args = {
    distinct_on?: InputMaybe<Array<TokenDatasV2SelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<TokenDatasV2OrderBy>>;
    where?: InputMaybe<TokenDatasV2BoolExp>;
};
type QueryRootTokenDatasV2AggregateArgs = {
    distinct_on?: InputMaybe<Array<TokenDatasV2SelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<TokenDatasV2OrderBy>>;
    where?: InputMaybe<TokenDatasV2BoolExp>;
};
type QueryRootTokenDatasV2ByPkArgs = {
    transaction_version: Scalars["bigint"]["input"];
    write_set_change_index: Scalars["bigint"]["input"];
};
type QueryRootTokenOwnershipsArgs = {
    distinct_on?: InputMaybe<Array<TokenOwnershipsSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<TokenOwnershipsOrderBy>>;
    where?: InputMaybe<TokenOwnershipsBoolExp>;
};
type QueryRootTokenOwnershipsAggregateArgs = {
    distinct_on?: InputMaybe<Array<TokenOwnershipsSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<TokenOwnershipsOrderBy>>;
    where?: InputMaybe<TokenOwnershipsBoolExp>;
};
type QueryRootTokenOwnershipsByPkArgs = {
    property_version: Scalars["numeric"]["input"];
    table_handle: Scalars["String"]["input"];
    token_data_id_hash: Scalars["String"]["input"];
    transaction_version: Scalars["bigint"]["input"];
};
type QueryRootTokenOwnershipsV2Args = {
    distinct_on?: InputMaybe<Array<TokenOwnershipsV2SelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<TokenOwnershipsV2OrderBy>>;
    where?: InputMaybe<TokenOwnershipsV2BoolExp>;
};
type QueryRootTokenOwnershipsV2AggregateArgs = {
    distinct_on?: InputMaybe<Array<TokenOwnershipsV2SelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<TokenOwnershipsV2OrderBy>>;
    where?: InputMaybe<TokenOwnershipsV2BoolExp>;
};
type QueryRootTokenOwnershipsV2ByPkArgs = {
    transaction_version: Scalars["bigint"]["input"];
    write_set_change_index: Scalars["bigint"]["input"];
};
type QueryRootTokensArgs = {
    distinct_on?: InputMaybe<Array<TokensSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<TokensOrderBy>>;
    where?: InputMaybe<TokensBoolExp>;
};
type QueryRootTokensAggregateArgs = {
    distinct_on?: InputMaybe<Array<TokensSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<TokensOrderBy>>;
    where?: InputMaybe<TokensBoolExp>;
};
type QueryRootTokensByPkArgs = {
    property_version: Scalars["numeric"]["input"];
    token_data_id_hash: Scalars["String"]["input"];
    transaction_version: Scalars["bigint"]["input"];
};
type QueryRootTransactionSizeInfoArgs = {
    distinct_on?: InputMaybe<Array<TransactionSizeInfoSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<TransactionSizeInfoOrderBy>>;
    where?: InputMaybe<TransactionSizeInfoBoolExp>;
};
type QueryRootTransactionSizeInfoAggregateArgs = {
    distinct_on?: InputMaybe<Array<TransactionSizeInfoSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<TransactionSizeInfoOrderBy>>;
    where?: InputMaybe<TransactionSizeInfoBoolExp>;
};
type QueryRootTransactionSizeInfoByPkArgs = {
    transaction_version: Scalars["bigint"]["input"];
};
type QueryRootTransactionsViewArgs = {
    distinct_on?: InputMaybe<Array<TransactionsViewSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<TransactionsViewOrderBy>>;
    where?: InputMaybe<TransactionsViewBoolExp>;
};
type QueryRootTransactionsViewAggregateArgs = {
    distinct_on?: InputMaybe<Array<TransactionsViewSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<TransactionsViewOrderBy>>;
    where?: InputMaybe<TransactionsViewBoolExp>;
};
type QueryRootUserTransactionsArgs = {
    distinct_on?: InputMaybe<Array<UserTransactionsSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<UserTransactionsOrderBy>>;
    where?: InputMaybe<UserTransactionsBoolExp>;
};
type QueryRootUserTransactionsAggregateArgs = {
    distinct_on?: InputMaybe<Array<UserTransactionsSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<UserTransactionsOrderBy>>;
    where?: InputMaybe<UserTransactionsBoolExp>;
};
type QueryRootUserTransactionsByPkArgs = {
    version: Scalars["bigint"]["input"];
};
/** columns and relationships of "signatures" */
type Signatures = {
    any_signature_type?: Maybe<Scalars["String"]["output"]>;
    inserted_at: Scalars["timestamp"]["output"];
    is_sender_primary: Scalars["Boolean"]["output"];
    multi_agent_index: Scalars["bigint"]["output"];
    multi_sig_index: Scalars["bigint"]["output"];
    public_key: Scalars["String"]["output"];
    public_key_indices: Scalars["jsonb"]["output"];
    public_key_type?: Maybe<Scalars["String"]["output"]>;
    signature: Scalars["String"]["output"];
    signer: Scalars["String"]["output"];
    threshold: Scalars["bigint"]["output"];
    transaction_block_height: Scalars["bigint"]["output"];
    transaction_version: Scalars["bigint"]["output"];
    type: Scalars["String"]["output"];
};
/** columns and relationships of "signatures" */
type SignaturesPublicKeyIndicesArgs = {
    path?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregated selection of "signatures" */
type SignaturesAggregate = {
    aggregate?: Maybe<SignaturesAggregateFields>;
    nodes: Array<Signatures>;
};
/** aggregate fields of "signatures" */
type SignaturesAggregateFields = {
    avg?: Maybe<SignaturesAvgFields>;
    count: Scalars["Int"]["output"];
    max?: Maybe<SignaturesMaxFields>;
    min?: Maybe<SignaturesMinFields>;
    stddev?: Maybe<SignaturesStddevFields>;
    stddev_pop?: Maybe<SignaturesStddevPopFields>;
    stddev_samp?: Maybe<SignaturesStddevSampFields>;
    sum?: Maybe<SignaturesSumFields>;
    var_pop?: Maybe<SignaturesVarPopFields>;
    var_samp?: Maybe<SignaturesVarSampFields>;
    variance?: Maybe<SignaturesVarianceFields>;
};
/** aggregate fields of "signatures" */
type SignaturesAggregateFieldsCountArgs = {
    columns?: InputMaybe<Array<SignaturesSelectColumn>>;
    distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};
/** append existing jsonb value of filtered columns with new jsonb value */
type SignaturesAppendInput = {
    public_key_indices?: InputMaybe<Scalars["jsonb"]["input"]>;
};
/** aggregate avg on columns */
type SignaturesAvgFields = {
    multi_agent_index?: Maybe<Scalars["Float"]["output"]>;
    multi_sig_index?: Maybe<Scalars["Float"]["output"]>;
    threshold?: Maybe<Scalars["Float"]["output"]>;
    transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** Boolean expression to filter rows from the table "signatures". All fields are combined with a logical 'AND'. */
type SignaturesBoolExp = {
    _and?: InputMaybe<Array<SignaturesBoolExp>>;
    _not?: InputMaybe<SignaturesBoolExp>;
    _or?: InputMaybe<Array<SignaturesBoolExp>>;
    any_signature_type?: InputMaybe<StringComparisonExp>;
    inserted_at?: InputMaybe<TimestampComparisonExp>;
    is_sender_primary?: InputMaybe<BooleanComparisonExp>;
    multi_agent_index?: InputMaybe<BigintComparisonExp>;
    multi_sig_index?: InputMaybe<BigintComparisonExp>;
    public_key?: InputMaybe<StringComparisonExp>;
    public_key_indices?: InputMaybe<JsonbComparisonExp>;
    public_key_type?: InputMaybe<StringComparisonExp>;
    signature?: InputMaybe<StringComparisonExp>;
    signer?: InputMaybe<StringComparisonExp>;
    threshold?: InputMaybe<BigintComparisonExp>;
    transaction_block_height?: InputMaybe<BigintComparisonExp>;
    transaction_version?: InputMaybe<BigintComparisonExp>;
    type?: InputMaybe<StringComparisonExp>;
};
/** unique or primary key constraints on table "signatures" */
declare enum SignaturesConstraint {
    /** unique or primary key constraint on columns "multi_agent_index", "is_sender_primary", "transaction_version", "multi_sig_index" */
    SignaturesPkey = "signatures_pkey"
}
/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
type SignaturesDeleteAtPathInput = {
    public_key_indices?: InputMaybe<Array<Scalars["String"]["input"]>>;
};
/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
type SignaturesDeleteElemInput = {
    public_key_indices?: InputMaybe<Scalars["Int"]["input"]>;
};
/** delete key/value pair or string element. key/value pairs are matched based on their key value */
type SignaturesDeleteKeyInput = {
    public_key_indices?: InputMaybe<Scalars["String"]["input"]>;
};
/** input type for incrementing numeric columns in table "signatures" */
type SignaturesIncInput = {
    multi_agent_index?: InputMaybe<Scalars["bigint"]["input"]>;
    multi_sig_index?: InputMaybe<Scalars["bigint"]["input"]>;
    threshold?: InputMaybe<Scalars["bigint"]["input"]>;
    transaction_block_height?: InputMaybe<Scalars["bigint"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** input type for inserting data into table "signatures" */
type SignaturesInsertInput = {
    any_signature_type?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    is_sender_primary?: InputMaybe<Scalars["Boolean"]["input"]>;
    multi_agent_index?: InputMaybe<Scalars["bigint"]["input"]>;
    multi_sig_index?: InputMaybe<Scalars["bigint"]["input"]>;
    public_key?: InputMaybe<Scalars["String"]["input"]>;
    public_key_indices?: InputMaybe<Scalars["jsonb"]["input"]>;
    public_key_type?: InputMaybe<Scalars["String"]["input"]>;
    signature?: InputMaybe<Scalars["String"]["input"]>;
    signer?: InputMaybe<Scalars["String"]["input"]>;
    threshold?: InputMaybe<Scalars["bigint"]["input"]>;
    transaction_block_height?: InputMaybe<Scalars["bigint"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    type?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregate max on columns */
type SignaturesMaxFields = {
    any_signature_type?: Maybe<Scalars["String"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    multi_agent_index?: Maybe<Scalars["bigint"]["output"]>;
    multi_sig_index?: Maybe<Scalars["bigint"]["output"]>;
    public_key?: Maybe<Scalars["String"]["output"]>;
    public_key_type?: Maybe<Scalars["String"]["output"]>;
    signature?: Maybe<Scalars["String"]["output"]>;
    signer?: Maybe<Scalars["String"]["output"]>;
    threshold?: Maybe<Scalars["bigint"]["output"]>;
    transaction_block_height?: Maybe<Scalars["bigint"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    type?: Maybe<Scalars["String"]["output"]>;
};
/** aggregate min on columns */
type SignaturesMinFields = {
    any_signature_type?: Maybe<Scalars["String"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    multi_agent_index?: Maybe<Scalars["bigint"]["output"]>;
    multi_sig_index?: Maybe<Scalars["bigint"]["output"]>;
    public_key?: Maybe<Scalars["String"]["output"]>;
    public_key_type?: Maybe<Scalars["String"]["output"]>;
    signature?: Maybe<Scalars["String"]["output"]>;
    signer?: Maybe<Scalars["String"]["output"]>;
    threshold?: Maybe<Scalars["bigint"]["output"]>;
    transaction_block_height?: Maybe<Scalars["bigint"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    type?: Maybe<Scalars["String"]["output"]>;
};
/** response of any mutation on the table "signatures" */
type SignaturesMutationResponse = {
    /** number of rows affected by the mutation */
    affected_rows: Scalars["Int"]["output"];
    /** data from the rows affected by the mutation */
    returning: Array<Signatures>;
};
/** on_conflict condition type for table "signatures" */
type SignaturesOnConflict = {
    constraint: SignaturesConstraint;
    update_columns?: Array<SignaturesUpdateColumn>;
    where?: InputMaybe<SignaturesBoolExp>;
};
/** Ordering options when selecting data from "signatures". */
type SignaturesOrderBy = {
    any_signature_type?: InputMaybe<OrderBy>;
    inserted_at?: InputMaybe<OrderBy>;
    is_sender_primary?: InputMaybe<OrderBy>;
    multi_agent_index?: InputMaybe<OrderBy>;
    multi_sig_index?: InputMaybe<OrderBy>;
    public_key?: InputMaybe<OrderBy>;
    public_key_indices?: InputMaybe<OrderBy>;
    public_key_type?: InputMaybe<OrderBy>;
    signature?: InputMaybe<OrderBy>;
    signer?: InputMaybe<OrderBy>;
    threshold?: InputMaybe<OrderBy>;
    transaction_block_height?: InputMaybe<OrderBy>;
    transaction_version?: InputMaybe<OrderBy>;
    type?: InputMaybe<OrderBy>;
};
/** primary key columns input for table: signatures */
type SignaturesPkColumnsInput = {
    is_sender_primary: Scalars["Boolean"]["input"];
    multi_agent_index: Scalars["bigint"]["input"];
    multi_sig_index: Scalars["bigint"]["input"];
    transaction_version: Scalars["bigint"]["input"];
};
/** prepend existing jsonb value of filtered columns with new jsonb value */
type SignaturesPrependInput = {
    public_key_indices?: InputMaybe<Scalars["jsonb"]["input"]>;
};
/** select columns of table "signatures" */
declare enum SignaturesSelectColumn {
    /** column name */
    AnySignatureType = "any_signature_type",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    IsSenderPrimary = "is_sender_primary",
    /** column name */
    MultiAgentIndex = "multi_agent_index",
    /** column name */
    MultiSigIndex = "multi_sig_index",
    /** column name */
    PublicKey = "public_key",
    /** column name */
    PublicKeyIndices = "public_key_indices",
    /** column name */
    PublicKeyType = "public_key_type",
    /** column name */
    Signature = "signature",
    /** column name */
    Signer = "signer",
    /** column name */
    Threshold = "threshold",
    /** column name */
    TransactionBlockHeight = "transaction_block_height",
    /** column name */
    TransactionVersion = "transaction_version",
    /** column name */
    Type = "type"
}
/** input type for updating data in table "signatures" */
type SignaturesSetInput = {
    any_signature_type?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    is_sender_primary?: InputMaybe<Scalars["Boolean"]["input"]>;
    multi_agent_index?: InputMaybe<Scalars["bigint"]["input"]>;
    multi_sig_index?: InputMaybe<Scalars["bigint"]["input"]>;
    public_key?: InputMaybe<Scalars["String"]["input"]>;
    public_key_indices?: InputMaybe<Scalars["jsonb"]["input"]>;
    public_key_type?: InputMaybe<Scalars["String"]["input"]>;
    signature?: InputMaybe<Scalars["String"]["input"]>;
    signer?: InputMaybe<Scalars["String"]["input"]>;
    threshold?: InputMaybe<Scalars["bigint"]["input"]>;
    transaction_block_height?: InputMaybe<Scalars["bigint"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    type?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregate stddev on columns */
type SignaturesStddevFields = {
    multi_agent_index?: Maybe<Scalars["Float"]["output"]>;
    multi_sig_index?: Maybe<Scalars["Float"]["output"]>;
    threshold?: Maybe<Scalars["Float"]["output"]>;
    transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_pop on columns */
type SignaturesStddevPopFields = {
    multi_agent_index?: Maybe<Scalars["Float"]["output"]>;
    multi_sig_index?: Maybe<Scalars["Float"]["output"]>;
    threshold?: Maybe<Scalars["Float"]["output"]>;
    transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_samp on columns */
type SignaturesStddevSampFields = {
    multi_agent_index?: Maybe<Scalars["Float"]["output"]>;
    multi_sig_index?: Maybe<Scalars["Float"]["output"]>;
    threshold?: Maybe<Scalars["Float"]["output"]>;
    transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** Streaming cursor of the table "signatures" */
type SignaturesStreamCursorInput = {
    /** Stream column input with initial value */
    initial_value: SignaturesStreamCursorValueInput;
    /** cursor ordering */
    ordering?: InputMaybe<CursorOrdering>;
};
/** Initial value of the column from where the streaming should start */
type SignaturesStreamCursorValueInput = {
    any_signature_type?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    is_sender_primary?: InputMaybe<Scalars["Boolean"]["input"]>;
    multi_agent_index?: InputMaybe<Scalars["bigint"]["input"]>;
    multi_sig_index?: InputMaybe<Scalars["bigint"]["input"]>;
    public_key?: InputMaybe<Scalars["String"]["input"]>;
    public_key_indices?: InputMaybe<Scalars["jsonb"]["input"]>;
    public_key_type?: InputMaybe<Scalars["String"]["input"]>;
    signature?: InputMaybe<Scalars["String"]["input"]>;
    signer?: InputMaybe<Scalars["String"]["input"]>;
    threshold?: InputMaybe<Scalars["bigint"]["input"]>;
    transaction_block_height?: InputMaybe<Scalars["bigint"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    type?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregate sum on columns */
type SignaturesSumFields = {
    multi_agent_index?: Maybe<Scalars["bigint"]["output"]>;
    multi_sig_index?: Maybe<Scalars["bigint"]["output"]>;
    threshold?: Maybe<Scalars["bigint"]["output"]>;
    transaction_block_height?: Maybe<Scalars["bigint"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};
/** update columns of table "signatures" */
declare enum SignaturesUpdateColumn {
    /** column name */
    AnySignatureType = "any_signature_type",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    IsSenderPrimary = "is_sender_primary",
    /** column name */
    MultiAgentIndex = "multi_agent_index",
    /** column name */
    MultiSigIndex = "multi_sig_index",
    /** column name */
    PublicKey = "public_key",
    /** column name */
    PublicKeyIndices = "public_key_indices",
    /** column name */
    PublicKeyType = "public_key_type",
    /** column name */
    Signature = "signature",
    /** column name */
    Signer = "signer",
    /** column name */
    Threshold = "threshold",
    /** column name */
    TransactionBlockHeight = "transaction_block_height",
    /** column name */
    TransactionVersion = "transaction_version",
    /** column name */
    Type = "type"
}
type SignaturesUpdates = {
    /** append existing jsonb value of filtered columns with new jsonb value */
    _append?: InputMaybe<SignaturesAppendInput>;
    /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
    _delete_at_path?: InputMaybe<SignaturesDeleteAtPathInput>;
    /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
    _delete_elem?: InputMaybe<SignaturesDeleteElemInput>;
    /** delete key/value pair or string element. key/value pairs are matched based on their key value */
    _delete_key?: InputMaybe<SignaturesDeleteKeyInput>;
    /** increments the numeric columns with given value of the filtered values */
    _inc?: InputMaybe<SignaturesIncInput>;
    /** prepend existing jsonb value of filtered columns with new jsonb value */
    _prepend?: InputMaybe<SignaturesPrependInput>;
    /** sets the columns of the filtered rows to the given values */
    _set?: InputMaybe<SignaturesSetInput>;
    /** filter the rows which have to be updated */
    where: SignaturesBoolExp;
};
/** aggregate var_pop on columns */
type SignaturesVarPopFields = {
    multi_agent_index?: Maybe<Scalars["Float"]["output"]>;
    multi_sig_index?: Maybe<Scalars["Float"]["output"]>;
    threshold?: Maybe<Scalars["Float"]["output"]>;
    transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate var_samp on columns */
type SignaturesVarSampFields = {
    multi_agent_index?: Maybe<Scalars["Float"]["output"]>;
    multi_sig_index?: Maybe<Scalars["Float"]["output"]>;
    threshold?: Maybe<Scalars["Float"]["output"]>;
    transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate variance on columns */
type SignaturesVarianceFields = {
    multi_agent_index?: Maybe<Scalars["Float"]["output"]>;
    multi_sig_index?: Maybe<Scalars["Float"]["output"]>;
    threshold?: Maybe<Scalars["Float"]["output"]>;
    transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** columns and relationships of "spam_assets" */
type SpamAssets = {
    asset: Scalars["String"]["output"];
    is_spam: Scalars["Boolean"]["output"];
    last_updated: Scalars["timestamp"]["output"];
};
/** aggregated selection of "spam_assets" */
type SpamAssetsAggregate = {
    aggregate?: Maybe<SpamAssetsAggregateFields>;
    nodes: Array<SpamAssets>;
};
/** aggregate fields of "spam_assets" */
type SpamAssetsAggregateFields = {
    count: Scalars["Int"]["output"];
    max?: Maybe<SpamAssetsMaxFields>;
    min?: Maybe<SpamAssetsMinFields>;
};
/** aggregate fields of "spam_assets" */
type SpamAssetsAggregateFieldsCountArgs = {
    columns?: InputMaybe<Array<SpamAssetsSelectColumn>>;
    distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};
/** Boolean expression to filter rows from the table "spam_assets". All fields are combined with a logical 'AND'. */
type SpamAssetsBoolExp = {
    _and?: InputMaybe<Array<SpamAssetsBoolExp>>;
    _not?: InputMaybe<SpamAssetsBoolExp>;
    _or?: InputMaybe<Array<SpamAssetsBoolExp>>;
    asset?: InputMaybe<StringComparisonExp>;
    is_spam?: InputMaybe<BooleanComparisonExp>;
    last_updated?: InputMaybe<TimestampComparisonExp>;
};
/** unique or primary key constraints on table "spam_assets" */
declare enum SpamAssetsConstraint {
    /** unique or primary key constraint on columns "asset" */
    SpamAssetsPkey = "spam_assets_pkey"
}
/** input type for inserting data into table "spam_assets" */
type SpamAssetsInsertInput = {
    asset?: InputMaybe<Scalars["String"]["input"]>;
    is_spam?: InputMaybe<Scalars["Boolean"]["input"]>;
    last_updated?: InputMaybe<Scalars["timestamp"]["input"]>;
};
/** aggregate max on columns */
type SpamAssetsMaxFields = {
    asset?: Maybe<Scalars["String"]["output"]>;
    last_updated?: Maybe<Scalars["timestamp"]["output"]>;
};
/** aggregate min on columns */
type SpamAssetsMinFields = {
    asset?: Maybe<Scalars["String"]["output"]>;
    last_updated?: Maybe<Scalars["timestamp"]["output"]>;
};
/** response of any mutation on the table "spam_assets" */
type SpamAssetsMutationResponse = {
    /** number of rows affected by the mutation */
    affected_rows: Scalars["Int"]["output"];
    /** data from the rows affected by the mutation */
    returning: Array<SpamAssets>;
};
/** on_conflict condition type for table "spam_assets" */
type SpamAssetsOnConflict = {
    constraint: SpamAssetsConstraint;
    update_columns?: Array<SpamAssetsUpdateColumn>;
    where?: InputMaybe<SpamAssetsBoolExp>;
};
/** Ordering options when selecting data from "spam_assets". */
type SpamAssetsOrderBy = {
    asset?: InputMaybe<OrderBy>;
    is_spam?: InputMaybe<OrderBy>;
    last_updated?: InputMaybe<OrderBy>;
};
/** primary key columns input for table: spam_assets */
type SpamAssetsPkColumnsInput = {
    asset: Scalars["String"]["input"];
};
/** select columns of table "spam_assets" */
declare enum SpamAssetsSelectColumn {
    /** column name */
    Asset = "asset",
    /** column name */
    IsSpam = "is_spam",
    /** column name */
    LastUpdated = "last_updated"
}
/** input type for updating data in table "spam_assets" */
type SpamAssetsSetInput = {
    asset?: InputMaybe<Scalars["String"]["input"]>;
    is_spam?: InputMaybe<Scalars["Boolean"]["input"]>;
    last_updated?: InputMaybe<Scalars["timestamp"]["input"]>;
};
/** Streaming cursor of the table "spam_assets" */
type SpamAssetsStreamCursorInput = {
    /** Stream column input with initial value */
    initial_value: SpamAssetsStreamCursorValueInput;
    /** cursor ordering */
    ordering?: InputMaybe<CursorOrdering>;
};
/** Initial value of the column from where the streaming should start */
type SpamAssetsStreamCursorValueInput = {
    asset?: InputMaybe<Scalars["String"]["input"]>;
    is_spam?: InputMaybe<Scalars["Boolean"]["input"]>;
    last_updated?: InputMaybe<Scalars["timestamp"]["input"]>;
};
/** update columns of table "spam_assets" */
declare enum SpamAssetsUpdateColumn {
    /** column name */
    Asset = "asset",
    /** column name */
    IsSpam = "is_spam",
    /** column name */
    LastUpdated = "last_updated"
}
type SpamAssetsUpdates = {
    /** sets the columns of the filtered rows to the given values */
    _set?: InputMaybe<SpamAssetsSetInput>;
    /** filter the rows which have to be updated */
    where: SpamAssetsBoolExp;
};
type SubscriptionRoot = {
    /** fetch data from the table: "account_transactions" */
    account_transactions: Array<AccountTransactions>;
    /** fetch aggregated fields from the table: "account_transactions" */
    account_transactions_aggregate: AccountTransactionsAggregate;
    /** fetch data from the table: "account_transactions" using primary key columns */
    account_transactions_by_pk?: Maybe<AccountTransactions>;
    /** fetch data from the table in a streaming manner: "account_transactions" */
    account_transactions_stream: Array<AccountTransactions>;
    /** fetch data from the table: "address_events_summary" */
    address_events_summary: Array<AddressEventsSummary>;
    /** fetch aggregated fields from the table: "address_events_summary" */
    address_events_summary_aggregate: AddressEventsSummaryAggregate;
    /** fetch data from the table in a streaming manner: "address_events_summary" */
    address_events_summary_stream: Array<AddressEventsSummary>;
    /** fetch data from the table: "address_version_from_events" */
    address_version_from_events: Array<AddressVersionFromEvents>;
    /** fetch aggregated fields from the table: "address_version_from_events" */
    address_version_from_events_aggregate: AddressVersionFromEventsAggregate;
    /** fetch data from the table in a streaming manner: "address_version_from_events" */
    address_version_from_events_stream: Array<AddressVersionFromEvents>;
    /** fetch data from the table: "address_version_from_move_resources" */
    address_version_from_move_resources: Array<AddressVersionFromMoveResources>;
    /** fetch aggregated fields from the table: "address_version_from_move_resources" */
    address_version_from_move_resources_aggregate: AddressVersionFromMoveResourcesAggregate;
    /** fetch data from the table in a streaming manner: "address_version_from_move_resources" */
    address_version_from_move_resources_stream: Array<AddressVersionFromMoveResources>;
    /** fetch data from the table: "ans_lookup" */
    ans_lookup: Array<AnsLookup>;
    /** fetch aggregated fields from the table: "ans_lookup" */
    ans_lookup_aggregate: AnsLookupAggregate;
    /** fetch data from the table: "ans_lookup" using primary key columns */
    ans_lookup_by_pk?: Maybe<AnsLookup>;
    /** fetch data from the table in a streaming manner: "ans_lookup" */
    ans_lookup_stream: Array<AnsLookup>;
    /** fetch data from the table: "ans_lookup_v2" */
    ans_lookup_v2: Array<AnsLookupV2>;
    /** fetch aggregated fields from the table: "ans_lookup_v2" */
    ans_lookup_v2_aggregate: AnsLookupV2Aggregate;
    /** fetch data from the table: "ans_lookup_v2" using primary key columns */
    ans_lookup_v2_by_pk?: Maybe<AnsLookupV2>;
    /** fetch data from the table in a streaming manner: "ans_lookup_v2" */
    ans_lookup_v2_stream: Array<AnsLookupV2>;
    /** fetch data from the table: "ans_primary_name" */
    ans_primary_name: Array<AnsPrimaryName>;
    /** fetch aggregated fields from the table: "ans_primary_name" */
    ans_primary_name_aggregate: AnsPrimaryNameAggregate;
    /** fetch data from the table: "ans_primary_name" using primary key columns */
    ans_primary_name_by_pk?: Maybe<AnsPrimaryName>;
    /** fetch data from the table in a streaming manner: "ans_primary_name" */
    ans_primary_name_stream: Array<AnsPrimaryName>;
    /** fetch data from the table: "ans_primary_name_v2" */
    ans_primary_name_v2: Array<AnsPrimaryNameV2>;
    /** fetch aggregated fields from the table: "ans_primary_name_v2" */
    ans_primary_name_v2_aggregate: AnsPrimaryNameV2Aggregate;
    /** fetch data from the table: "ans_primary_name_v2" using primary key columns */
    ans_primary_name_v2_by_pk?: Maybe<AnsPrimaryNameV2>;
    /** fetch data from the table in a streaming manner: "ans_primary_name_v2" */
    ans_primary_name_v2_stream: Array<AnsPrimaryNameV2>;
    /** fetch data from the table: "auth_key_account_addresses" */
    auth_key_account_addresses: Array<AuthKeyAccountAddresses>;
    /** fetch aggregated fields from the table: "auth_key_account_addresses" */
    auth_key_account_addresses_aggregate: AuthKeyAccountAddressesAggregate;
    /** fetch data from the table: "auth_key_account_addresses" using primary key columns */
    auth_key_account_addresses_by_pk?: Maybe<AuthKeyAccountAddresses>;
    /** fetch data from the table in a streaming manner: "auth_key_account_addresses" */
    auth_key_account_addresses_stream: Array<AuthKeyAccountAddresses>;
    /** fetch data from the table: "block_metadata_transactions" */
    block_metadata_transactions: Array<BlockMetadataTransactions>;
    /** fetch aggregated fields from the table: "block_metadata_transactions" */
    block_metadata_transactions_aggregate: BlockMetadataTransactionsAggregate;
    /** fetch data from the table: "block_metadata_transactions" using primary key columns */
    block_metadata_transactions_by_pk?: Maybe<BlockMetadataTransactions>;
    /** fetch data from the table in a streaming manner: "block_metadata_transactions" */
    block_metadata_transactions_stream: Array<BlockMetadataTransactions>;
    /** fetch data from the table: "coin_activities" */
    coin_activities: Array<CoinActivities>;
    /** fetch aggregated fields from the table: "coin_activities" */
    coin_activities_aggregate: CoinActivitiesAggregate;
    /** fetch data from the table: "coin_activities" using primary key columns */
    coin_activities_by_pk?: Maybe<CoinActivities>;
    /** fetch data from the table in a streaming manner: "coin_activities" */
    coin_activities_stream: Array<CoinActivities>;
    /** fetch data from the table: "coin_balances" */
    coin_balances: Array<CoinBalances>;
    /** fetch aggregated fields from the table: "coin_balances" */
    coin_balances_aggregate: CoinBalancesAggregate;
    /** fetch data from the table: "coin_balances" using primary key columns */
    coin_balances_by_pk?: Maybe<CoinBalances>;
    /** fetch data from the table in a streaming manner: "coin_balances" */
    coin_balances_stream: Array<CoinBalances>;
    /** fetch data from the table: "coin_infos" */
    coin_infos: Array<CoinInfos>;
    /** fetch aggregated fields from the table: "coin_infos" */
    coin_infos_aggregate: CoinInfosAggregate;
    /** fetch data from the table: "coin_infos" using primary key columns */
    coin_infos_by_pk?: Maybe<CoinInfos>;
    /** fetch data from the table in a streaming manner: "coin_infos" */
    coin_infos_stream: Array<CoinInfos>;
    /** fetch data from the table: "coin_supply" */
    coin_supply: Array<CoinSupply>;
    /** fetch aggregated fields from the table: "coin_supply" */
    coin_supply_aggregate: CoinSupplyAggregate;
    /** fetch data from the table: "coin_supply" using primary key columns */
    coin_supply_by_pk?: Maybe<CoinSupply>;
    /** fetch data from the table in a streaming manner: "coin_supply" */
    coin_supply_stream: Array<CoinSupply>;
    /** fetch data from the table: "collection_datas" */
    collection_datas: Array<CollectionDatas>;
    /** fetch aggregated fields from the table: "collection_datas" */
    collection_datas_aggregate: CollectionDatasAggregate;
    /** fetch data from the table: "collection_datas" using primary key columns */
    collection_datas_by_pk?: Maybe<CollectionDatas>;
    /** fetch data from the table in a streaming manner: "collection_datas" */
    collection_datas_stream: Array<CollectionDatas>;
    /** fetch data from the table: "collections_v2" */
    collections_v2: Array<CollectionsV2>;
    /** fetch aggregated fields from the table: "collections_v2" */
    collections_v2_aggregate: CollectionsV2Aggregate;
    /** fetch data from the table: "collections_v2" using primary key columns */
    collections_v2_by_pk?: Maybe<CollectionsV2>;
    /** fetch data from the table in a streaming manner: "collections_v2" */
    collections_v2_stream: Array<CollectionsV2>;
    /** fetch data from the table: "current_ans_lookup" */
    current_ans_lookup: Array<CurrentAnsLookup>;
    /** fetch aggregated fields from the table: "current_ans_lookup" */
    current_ans_lookup_aggregate: CurrentAnsLookupAggregate;
    /** fetch data from the table: "current_ans_lookup" using primary key columns */
    current_ans_lookup_by_pk?: Maybe<CurrentAnsLookup>;
    /** fetch data from the table in a streaming manner: "current_ans_lookup" */
    current_ans_lookup_stream: Array<CurrentAnsLookup>;
    /** fetch data from the table: "current_ans_lookup_v2" */
    current_ans_lookup_v2: Array<CurrentAnsLookupV2>;
    /** fetch aggregated fields from the table: "current_ans_lookup_v2" */
    current_ans_lookup_v2_aggregate: CurrentAnsLookupV2Aggregate;
    /** fetch data from the table: "current_ans_lookup_v2" using primary key columns */
    current_ans_lookup_v2_by_pk?: Maybe<CurrentAnsLookupV2>;
    /** fetch data from the table in a streaming manner: "current_ans_lookup_v2" */
    current_ans_lookup_v2_stream: Array<CurrentAnsLookupV2>;
    /** fetch data from the table: "current_ans_primary_name" */
    current_ans_primary_name: Array<CurrentAnsPrimaryName>;
    /** fetch aggregated fields from the table: "current_ans_primary_name" */
    current_ans_primary_name_aggregate: CurrentAnsPrimaryNameAggregate;
    /** fetch data from the table: "current_ans_primary_name" using primary key columns */
    current_ans_primary_name_by_pk?: Maybe<CurrentAnsPrimaryName>;
    /** fetch data from the table in a streaming manner: "current_ans_primary_name" */
    current_ans_primary_name_stream: Array<CurrentAnsPrimaryName>;
    /** fetch data from the table: "current_ans_primary_name_v2" */
    current_ans_primary_name_v2: Array<CurrentAnsPrimaryNameV2>;
    /** fetch aggregated fields from the table: "current_ans_primary_name_v2" */
    current_ans_primary_name_v2_aggregate: CurrentAnsPrimaryNameV2Aggregate;
    /** fetch data from the table: "current_ans_primary_name_v2" using primary key columns */
    current_ans_primary_name_v2_by_pk?: Maybe<CurrentAnsPrimaryNameV2>;
    /** fetch data from the table in a streaming manner: "current_ans_primary_name_v2" */
    current_ans_primary_name_v2_stream: Array<CurrentAnsPrimaryNameV2>;
    /** fetch data from the table: "current_cedra_names" */
    current_cedra_names: Array<CurrentCedraNames>;
    /** fetch aggregated fields from the table: "current_cedra_names" */
    current_cedra_names_aggregate: CurrentCedraNamesAggregate;
    /** fetch data from the table in a streaming manner: "current_cedra_names" */
    current_cedra_names_stream: Array<CurrentCedraNames>;
    /** fetch data from the table: "current_coin_balances" */
    current_coin_balances: Array<CurrentCoinBalances>;
    /** fetch aggregated fields from the table: "current_coin_balances" */
    current_coin_balances_aggregate: CurrentCoinBalancesAggregate;
    /** fetch data from the table: "current_coin_balances" using primary key columns */
    current_coin_balances_by_pk?: Maybe<CurrentCoinBalances>;
    /** fetch data from the table in a streaming manner: "current_coin_balances" */
    current_coin_balances_stream: Array<CurrentCoinBalances>;
    /** fetch data from the table: "current_collection_datas" */
    current_collection_datas: Array<CurrentCollectionDatas>;
    /** fetch aggregated fields from the table: "current_collection_datas" */
    current_collection_datas_aggregate: CurrentCollectionDatasAggregate;
    /** fetch data from the table: "current_collection_datas" using primary key columns */
    current_collection_datas_by_pk?: Maybe<CurrentCollectionDatas>;
    /** fetch data from the table in a streaming manner: "current_collection_datas" */
    current_collection_datas_stream: Array<CurrentCollectionDatas>;
    /** fetch data from the table: "current_collection_ownership_v2_view" */
    current_collection_ownership_v2_view: Array<CurrentCollectionOwnershipV2View>;
    /** fetch aggregated fields from the table: "current_collection_ownership_v2_view" */
    current_collection_ownership_v2_view_aggregate: CurrentCollectionOwnershipV2ViewAggregate;
    /** fetch data from the table in a streaming manner: "current_collection_ownership_v2_view" */
    current_collection_ownership_v2_view_stream: Array<CurrentCollectionOwnershipV2View>;
    /** fetch data from the table: "current_collection_ownership_view" */
    current_collection_ownership_view: Array<CurrentCollectionOwnershipView>;
    /** fetch aggregated fields from the table: "current_collection_ownership_view" */
    current_collection_ownership_view_aggregate: CurrentCollectionOwnershipViewAggregate;
    /** fetch data from the table in a streaming manner: "current_collection_ownership_view" */
    current_collection_ownership_view_stream: Array<CurrentCollectionOwnershipView>;
    /** fetch data from the table: "current_collections_v2" */
    current_collections_v2: Array<CurrentCollectionsV2>;
    /** fetch aggregated fields from the table: "current_collections_v2" */
    current_collections_v2_aggregate: CurrentCollectionsV2Aggregate;
    /** fetch data from the table: "current_collections_v2" using primary key columns */
    current_collections_v2_by_pk?: Maybe<CurrentCollectionsV2>;
    /** fetch data from the table in a streaming manner: "current_collections_v2" */
    current_collections_v2_stream: Array<CurrentCollectionsV2>;
    /** fetch data from the table: "current_delegated_staking_pool_balances" */
    current_delegated_staking_pool_balances: Array<CurrentDelegatedStakingPoolBalances>;
    /** fetch aggregated fields from the table: "current_delegated_staking_pool_balances" */
    current_delegated_staking_pool_balances_aggregate: CurrentDelegatedStakingPoolBalancesAggregate;
    /** fetch data from the table: "current_delegated_staking_pool_balances" using primary key columns */
    current_delegated_staking_pool_balances_by_pk?: Maybe<CurrentDelegatedStakingPoolBalances>;
    /** fetch data from the table in a streaming manner: "current_delegated_staking_pool_balances" */
    current_delegated_staking_pool_balances_stream: Array<CurrentDelegatedStakingPoolBalances>;
    /** fetch data from the table: "current_delegated_voter" */
    current_delegated_voter: Array<CurrentDelegatedVoter>;
    /** fetch aggregated fields from the table: "current_delegated_voter" */
    current_delegated_voter_aggregate: CurrentDelegatedVoterAggregate;
    /** fetch data from the table: "current_delegated_voter" using primary key columns */
    current_delegated_voter_by_pk?: Maybe<CurrentDelegatedVoter>;
    /** fetch data from the table in a streaming manner: "current_delegated_voter" */
    current_delegated_voter_stream: Array<CurrentDelegatedVoter>;
    /** fetch data from the table: "current_delegator_balances" */
    current_delegator_balances: Array<CurrentDelegatorBalances>;
    /** fetch aggregated fields from the table: "current_delegator_balances" */
    current_delegator_balances_aggregate: CurrentDelegatorBalancesAggregate;
    /** fetch data from the table: "current_delegator_balances" using primary key columns */
    current_delegator_balances_by_pk?: Maybe<CurrentDelegatorBalances>;
    /** fetch data from the table in a streaming manner: "current_delegator_balances" */
    current_delegator_balances_stream: Array<CurrentDelegatorBalances>;
    /** fetch data from the table: "current_fungible_asset_balances_legacy" */
    current_fungible_asset_balances: Array<CurrentFungibleAssetBalances>;
    /** fetch aggregated fields from the table: "current_fungible_asset_balances_legacy" */
    current_fungible_asset_balances_aggregate: CurrentFungibleAssetBalancesAggregate;
    /** fetch data from the table: "current_fungible_asset_balances_legacy" using primary key columns */
    current_fungible_asset_balances_by_pk?: Maybe<CurrentFungibleAssetBalances>;
    /** fetch data from the table: "current_fungible_asset_balances" */
    current_fungible_asset_balances_new: Array<CurrentFungibleAssetBalancesNew>;
    /** fetch aggregated fields from the table: "current_fungible_asset_balances" */
    current_fungible_asset_balances_new_aggregate: CurrentFungibleAssetBalancesNewAggregate;
    /** fetch data from the table: "current_fungible_asset_balances" using primary key columns */
    current_fungible_asset_balances_new_by_pk?: Maybe<CurrentFungibleAssetBalancesNew>;
    /** fetch data from the table in a streaming manner: "current_fungible_asset_balances" */
    current_fungible_asset_balances_new_stream: Array<CurrentFungibleAssetBalancesNew>;
    /** fetch data from the table in a streaming manner: "current_fungible_asset_balances_legacy" */
    current_fungible_asset_balances_stream: Array<CurrentFungibleAssetBalances>;
    /** fetch data from the table: "current_objects" */
    current_objects: Array<CurrentObjects>;
    /** fetch aggregated fields from the table: "current_objects" */
    current_objects_aggregate: CurrentObjectsAggregate;
    /** fetch data from the table: "current_objects" using primary key columns */
    current_objects_by_pk?: Maybe<CurrentObjects>;
    /** fetch data from the table in a streaming manner: "current_objects" */
    current_objects_stream: Array<CurrentObjects>;
    /** fetch data from the table: "current_staking_pool_voter" */
    current_staking_pool_voter: Array<CurrentStakingPoolVoter>;
    /** fetch aggregated fields from the table: "current_staking_pool_voter" */
    current_staking_pool_voter_aggregate: CurrentStakingPoolVoterAggregate;
    /** fetch data from the table: "current_staking_pool_voter" using primary key columns */
    current_staking_pool_voter_by_pk?: Maybe<CurrentStakingPoolVoter>;
    /** fetch data from the table in a streaming manner: "current_staking_pool_voter" */
    current_staking_pool_voter_stream: Array<CurrentStakingPoolVoter>;
    /** fetch data from the table: "current_table_items" */
    current_table_items: Array<CurrentTableItems>;
    /** fetch aggregated fields from the table: "current_table_items" */
    current_table_items_aggregate: CurrentTableItemsAggregate;
    /** fetch data from the table: "current_table_items" using primary key columns */
    current_table_items_by_pk?: Maybe<CurrentTableItems>;
    /** fetch data from the table in a streaming manner: "current_table_items" */
    current_table_items_stream: Array<CurrentTableItems>;
    /** fetch data from the table: "current_table_items_view" */
    current_table_items_view: Array<CurrentTableItemsView>;
    /** fetch aggregated fields from the table: "current_table_items_view" */
    current_table_items_view_aggregate: CurrentTableItemsViewAggregate;
    /** fetch data from the table in a streaming manner: "current_table_items_view" */
    current_table_items_view_stream: Array<CurrentTableItemsView>;
    /** fetch data from the table: "current_token_datas" */
    current_token_datas: Array<CurrentTokenDatas>;
    /** fetch aggregated fields from the table: "current_token_datas" */
    current_token_datas_aggregate: CurrentTokenDatasAggregate;
    /** fetch data from the table: "current_token_datas" using primary key columns */
    current_token_datas_by_pk?: Maybe<CurrentTokenDatas>;
    /** fetch data from the table in a streaming manner: "current_token_datas" */
    current_token_datas_stream: Array<CurrentTokenDatas>;
    /** fetch data from the table: "current_token_datas_v2" */
    current_token_datas_v2: Array<CurrentTokenDatasV2>;
    /** fetch aggregated fields from the table: "current_token_datas_v2" */
    current_token_datas_v2_aggregate: CurrentTokenDatasV2Aggregate;
    /** fetch data from the table: "current_token_datas_v2" using primary key columns */
    current_token_datas_v2_by_pk?: Maybe<CurrentTokenDatasV2>;
    /** fetch data from the table in a streaming manner: "current_token_datas_v2" */
    current_token_datas_v2_stream: Array<CurrentTokenDatasV2>;
    /** fetch data from the table: "current_token_ownerships" */
    current_token_ownerships: Array<CurrentTokenOwnerships>;
    /** fetch aggregated fields from the table: "current_token_ownerships" */
    current_token_ownerships_aggregate: CurrentTokenOwnershipsAggregate;
    /** fetch data from the table: "current_token_ownerships" using primary key columns */
    current_token_ownerships_by_pk?: Maybe<CurrentTokenOwnerships>;
    /** fetch data from the table in a streaming manner: "current_token_ownerships" */
    current_token_ownerships_stream: Array<CurrentTokenOwnerships>;
    /** fetch data from the table: "current_token_ownerships_v2" */
    current_token_ownerships_v2: Array<CurrentTokenOwnershipsV2>;
    /** fetch aggregated fields from the table: "current_token_ownerships_v2" */
    current_token_ownerships_v2_aggregate: CurrentTokenOwnershipsV2Aggregate;
    /** fetch data from the table: "current_token_ownerships_v2" using primary key columns */
    current_token_ownerships_v2_by_pk?: Maybe<CurrentTokenOwnershipsV2>;
    /** fetch data from the table in a streaming manner: "current_token_ownerships_v2" */
    current_token_ownerships_v2_stream: Array<CurrentTokenOwnershipsV2>;
    /** fetch data from the table: "current_token_pending_claims" */
    current_token_pending_claims: Array<CurrentTokenPendingClaims>;
    /** fetch aggregated fields from the table: "current_token_pending_claims" */
    current_token_pending_claims_aggregate: CurrentTokenPendingClaimsAggregate;
    /** fetch data from the table: "current_token_pending_claims" using primary key columns */
    current_token_pending_claims_by_pk?: Maybe<CurrentTokenPendingClaims>;
    /** fetch data from the table in a streaming manner: "current_token_pending_claims" */
    current_token_pending_claims_stream: Array<CurrentTokenPendingClaims>;
    /** fetch data from the table: "current_token_royalty_v1" */
    current_token_royalty_v1: Array<CurrentTokenRoyaltyV1>;
    /** fetch aggregated fields from the table: "current_token_royalty_v1" */
    current_token_royalty_v1_aggregate: CurrentTokenRoyaltyV1Aggregate;
    /** fetch data from the table: "current_token_royalty_v1" using primary key columns */
    current_token_royalty_v1_by_pk?: Maybe<CurrentTokenRoyaltyV1>;
    /** fetch data from the table in a streaming manner: "current_token_royalty_v1" */
    current_token_royalty_v1_stream: Array<CurrentTokenRoyaltyV1>;
    /** fetch data from the table: "current_token_v2_metadata" */
    current_token_v2_metadata: Array<CurrentTokenV2Metadata>;
    /** fetch aggregated fields from the table: "current_token_v2_metadata" */
    current_token_v2_metadata_aggregate: CurrentTokenV2MetadataAggregate;
    /** fetch data from the table: "current_token_v2_metadata" using primary key columns */
    current_token_v2_metadata_by_pk?: Maybe<CurrentTokenV2Metadata>;
    /** fetch data from the table in a streaming manner: "current_token_v2_metadata" */
    current_token_v2_metadata_stream: Array<CurrentTokenV2Metadata>;
    /** fetch data from the table: "delegated_staking_activities" */
    delegated_staking_activities: Array<DelegatedStakingActivities>;
    /** fetch aggregated fields from the table: "delegated_staking_activities" */
    delegated_staking_activities_aggregate: DelegatedStakingActivitiesAggregate;
    /** fetch data from the table: "delegated_staking_activities" using primary key columns */
    delegated_staking_activities_by_pk?: Maybe<DelegatedStakingActivities>;
    /** fetch data from the table in a streaming manner: "delegated_staking_activities" */
    delegated_staking_activities_stream: Array<DelegatedStakingActivities>;
    /** fetch data from the table: "delegated_staking_pool_balances" */
    delegated_staking_pool_balances: Array<DelegatedStakingPoolBalances>;
    /** fetch aggregated fields from the table: "delegated_staking_pool_balances" */
    delegated_staking_pool_balances_aggregate: DelegatedStakingPoolBalancesAggregate;
    /** fetch data from the table: "delegated_staking_pool_balances" using primary key columns */
    delegated_staking_pool_balances_by_pk?: Maybe<DelegatedStakingPoolBalances>;
    /** fetch data from the table in a streaming manner: "delegated_staking_pool_balances" */
    delegated_staking_pool_balances_stream: Array<DelegatedStakingPoolBalances>;
    /** fetch data from the table: "delegated_staking_pools" */
    delegated_staking_pools: Array<DelegatedStakingPools>;
    /** fetch aggregated fields from the table: "delegated_staking_pools" */
    delegated_staking_pools_aggregate: DelegatedStakingPoolsAggregate;
    /** fetch data from the table: "delegated_staking_pools" using primary key columns */
    delegated_staking_pools_by_pk?: Maybe<DelegatedStakingPools>;
    /** fetch data from the table in a streaming manner: "delegated_staking_pools" */
    delegated_staking_pools_stream: Array<DelegatedStakingPools>;
    /** fetch data from the table: "delegator_balances" */
    delegator_balances: Array<DelegatorBalances>;
    /** fetch aggregated fields from the table: "delegator_balances" */
    delegator_balances_aggregate: DelegatorBalancesAggregate;
    /** fetch data from the table: "delegator_balances" using primary key columns */
    delegator_balances_by_pk?: Maybe<DelegatorBalances>;
    /** fetch data from the table in a streaming manner: "delegator_balances" */
    delegator_balances_stream: Array<DelegatorBalances>;
    /** fetch data from the table: "delegator_distinct_pool" */
    delegator_distinct_pool: Array<DelegatorDistinctPool>;
    /** fetch aggregated fields from the table: "delegator_distinct_pool" */
    delegator_distinct_pool_aggregate: DelegatorDistinctPoolAggregate;
    /** fetch data from the table in a streaming manner: "delegator_distinct_pool" */
    delegator_distinct_pool_stream: Array<DelegatorDistinctPool>;
    /** fetch data from the table: "event_size_info" */
    event_size_info: Array<EventSizeInfo>;
    /** fetch aggregated fields from the table: "event_size_info" */
    event_size_info_aggregate: EventSizeInfoAggregate;
    /** fetch data from the table: "event_size_info" using primary key columns */
    event_size_info_by_pk?: Maybe<EventSizeInfo>;
    /** fetch data from the table in a streaming manner: "event_size_info" */
    event_size_info_stream: Array<EventSizeInfo>;
    /** fetch data from the table: "events" */
    events: Array<Events>;
    /** fetch aggregated fields from the table: "events" */
    events_aggregate: EventsAggregate;
    /** fetch data from the table: "events" using primary key columns */
    events_by_pk?: Maybe<Events>;
    /** fetch data from the table in a streaming manner: "events" */
    events_stream: Array<Events>;
    /** fetch data from the table: "events_view" */
    events_view: Array<EventsView>;
    /** fetch aggregated fields from the table: "events_view" */
    events_view_aggregate: EventsViewAggregate;
    /** fetch data from the table in a streaming manner: "events_view" */
    events_view_stream: Array<EventsView>;
    /** fetch data from the table: "fungible_asset_activities" */
    fungible_asset_activities: Array<FungibleAssetActivities>;
    /** fetch aggregated fields from the table: "fungible_asset_activities" */
    fungible_asset_activities_aggregate: FungibleAssetActivitiesAggregate;
    /** fetch data from the table: "fungible_asset_activities" using primary key columns */
    fungible_asset_activities_by_pk?: Maybe<FungibleAssetActivities>;
    /** fetch data from the table in a streaming manner: "fungible_asset_activities" */
    fungible_asset_activities_stream: Array<FungibleAssetActivities>;
    /** fetch data from the table: "fungible_asset_balances" */
    fungible_asset_balances: Array<FungibleAssetBalances>;
    /** fetch aggregated fields from the table: "fungible_asset_balances" */
    fungible_asset_balances_aggregate: FungibleAssetBalancesAggregate;
    /** fetch data from the table: "fungible_asset_balances" using primary key columns */
    fungible_asset_balances_by_pk?: Maybe<FungibleAssetBalances>;
    /** fetch data from the table in a streaming manner: "fungible_asset_balances" */
    fungible_asset_balances_stream: Array<FungibleAssetBalances>;
    /** fetch data from the table: "fungible_asset_metadata" */
    fungible_asset_metadata: Array<FungibleAssetMetadata>;
    /** fetch aggregated fields from the table: "fungible_asset_metadata" */
    fungible_asset_metadata_aggregate: FungibleAssetMetadataAggregate;
    /** fetch data from the table: "fungible_asset_metadata" using primary key columns */
    fungible_asset_metadata_by_pk?: Maybe<FungibleAssetMetadata>;
    /** fetch data from the table in a streaming manner: "fungible_asset_metadata" */
    fungible_asset_metadata_stream: Array<FungibleAssetMetadata>;
    /** fetch data from the table: "fungible_asset_to_coin_mappings" */
    fungible_asset_to_coin_mappings: Array<FungibleAssetToCoinMappings>;
    /** fetch aggregated fields from the table: "fungible_asset_to_coin_mappings" */
    fungible_asset_to_coin_mappings_aggregate: FungibleAssetToCoinMappingsAggregate;
    /** fetch data from the table: "fungible_asset_to_coin_mappings" using primary key columns */
    fungible_asset_to_coin_mappings_by_pk?: Maybe<FungibleAssetToCoinMappings>;
    /** fetch data from the table in a streaming manner: "fungible_asset_to_coin_mappings" */
    fungible_asset_to_coin_mappings_stream: Array<FungibleAssetToCoinMappings>;
    /** fetch data from the table: "gas_fees" */
    gas_fees: Array<GasFees>;
    /** fetch aggregated fields from the table: "gas_fees" */
    gas_fees_aggregate: GasFeesAggregate;
    /** fetch data from the table: "gas_fees" using primary key columns */
    gas_fees_by_pk?: Maybe<GasFees>;
    /** fetch data from the table in a streaming manner: "gas_fees" */
    gas_fees_stream: Array<GasFees>;
    /** fetch data from the table: "indexer_status" */
    indexer_status: Array<IndexerStatus>;
    /** fetch aggregated fields from the table: "indexer_status" */
    indexer_status_aggregate: IndexerStatusAggregate;
    /** fetch data from the table: "indexer_status" using primary key columns */
    indexer_status_by_pk?: Maybe<IndexerStatus>;
    /** fetch data from the table in a streaming manner: "indexer_status" */
    indexer_status_stream: Array<IndexerStatus>;
    /** fetch data from the table: "move_modules" */
    move_modules: Array<MoveModules>;
    /** fetch aggregated fields from the table: "move_modules" */
    move_modules_aggregate: MoveModulesAggregate;
    /** fetch data from the table: "move_modules" using primary key columns */
    move_modules_by_pk?: Maybe<MoveModules>;
    /** fetch data from the table in a streaming manner: "move_modules" */
    move_modules_stream: Array<MoveModules>;
    /** fetch data from the table: "move_resources" */
    move_resources: Array<MoveResources>;
    /** fetch aggregated fields from the table: "move_resources" */
    move_resources_aggregate: MoveResourcesAggregate;
    /** fetch data from the table: "move_resources" using primary key columns */
    move_resources_by_pk?: Maybe<MoveResources>;
    /** fetch data from the table in a streaming manner: "move_resources" */
    move_resources_stream: Array<MoveResources>;
    /** fetch data from the table: "move_resources_view" */
    move_resources_view: Array<MoveResourcesView>;
    /** fetch aggregated fields from the table: "move_resources_view" */
    move_resources_view_aggregate: MoveResourcesViewAggregate;
    /** fetch data from the table in a streaming manner: "move_resources_view" */
    move_resources_view_stream: Array<MoveResourcesView>;
    /** fetch data from the table: "nft_metadata_crawler.parsed_asset_uris" */
    nft_metadata_crawler_parsed_asset_uris: Array<NftMetadataCrawlerParsedAssetUris>;
    /** fetch aggregated fields from the table: "nft_metadata_crawler.parsed_asset_uris" */
    nft_metadata_crawler_parsed_asset_uris_aggregate: NftMetadataCrawlerParsedAssetUrisAggregate;
    /** fetch data from the table: "nft_metadata_crawler.parsed_asset_uris" using primary key columns */
    nft_metadata_crawler_parsed_asset_uris_by_pk?: Maybe<NftMetadataCrawlerParsedAssetUris>;
    /** fetch data from the table in a streaming manner: "nft_metadata_crawler.parsed_asset_uris" */
    nft_metadata_crawler_parsed_asset_uris_stream: Array<NftMetadataCrawlerParsedAssetUris>;
    /** fetch data from the table: "nft_points" */
    nft_points: Array<NftPoints>;
    /** fetch aggregated fields from the table: "nft_points" */
    nft_points_aggregate: NftPointsAggregate;
    /** fetch data from the table: "nft_points" using primary key columns */
    nft_points_by_pk?: Maybe<NftPoints>;
    /** fetch data from the table in a streaming manner: "nft_points" */
    nft_points_stream: Array<NftPoints>;
    /** fetch data from the table: "num_active_delegator_per_pool" */
    num_active_delegator_per_pool: Array<NumActiveDelegatorPerPool>;
    /** fetch aggregated fields from the table: "num_active_delegator_per_pool" */
    num_active_delegator_per_pool_aggregate: NumActiveDelegatorPerPoolAggregate;
    /** fetch data from the table in a streaming manner: "num_active_delegator_per_pool" */
    num_active_delegator_per_pool_stream: Array<NumActiveDelegatorPerPool>;
    /** fetch data from the table: "objects" */
    objects: Array<Objects>;
    /** fetch aggregated fields from the table: "objects" */
    objects_aggregate: ObjectsAggregate;
    /** fetch data from the table: "objects" using primary key columns */
    objects_by_pk?: Maybe<Objects>;
    /** fetch data from the table in a streaming manner: "objects" */
    objects_stream: Array<Objects>;
    /** fetch data from the table: "processor_metadata.processor_status" */
    processor_metadata_processor_status: Array<ProcessorMetadataProcessorStatus>;
    /** fetch aggregated fields from the table: "processor_metadata.processor_status" */
    processor_metadata_processor_status_aggregate: ProcessorMetadataProcessorStatusAggregate;
    /** fetch data from the table: "processor_metadata.processor_status" using primary key columns */
    processor_metadata_processor_status_by_pk?: Maybe<ProcessorMetadataProcessorStatus>;
    /** fetch data from the table in a streaming manner: "processor_metadata.processor_status" */
    processor_metadata_processor_status_stream: Array<ProcessorMetadataProcessorStatus>;
    /** fetch data from the table: "processor_status" */
    processor_status: Array<ProcessorStatus>;
    /** fetch aggregated fields from the table: "processor_status" */
    processor_status_aggregate: ProcessorStatusAggregate;
    /** fetch data from the table: "processor_status" using primary key columns */
    processor_status_by_pk?: Maybe<ProcessorStatus>;
    /** fetch data from the table in a streaming manner: "processor_status" */
    processor_status_stream: Array<ProcessorStatus>;
    /** fetch data from the table: "proposal_votes" */
    proposal_votes: Array<ProposalVotes>;
    /** fetch aggregated fields from the table: "proposal_votes" */
    proposal_votes_aggregate: ProposalVotesAggregate;
    /** fetch data from the table: "proposal_votes" using primary key columns */
    proposal_votes_by_pk?: Maybe<ProposalVotes>;
    /** fetch data from the table in a streaming manner: "proposal_votes" */
    proposal_votes_stream: Array<ProposalVotes>;
    /** fetch data from the table: "public_key_auth_keys" */
    public_key_auth_keys: Array<PublicKeyAuthKeys>;
    /** fetch aggregated fields from the table: "public_key_auth_keys" */
    public_key_auth_keys_aggregate: PublicKeyAuthKeysAggregate;
    /** fetch data from the table: "public_key_auth_keys" using primary key columns */
    public_key_auth_keys_by_pk?: Maybe<PublicKeyAuthKeys>;
    /** fetch data from the table in a streaming manner: "public_key_auth_keys" */
    public_key_auth_keys_stream: Array<PublicKeyAuthKeys>;
    /** fetch data from the table: "signatures" */
    signatures: Array<Signatures>;
    /** fetch aggregated fields from the table: "signatures" */
    signatures_aggregate: SignaturesAggregate;
    /** fetch data from the table: "signatures" using primary key columns */
    signatures_by_pk?: Maybe<Signatures>;
    /** fetch data from the table in a streaming manner: "signatures" */
    signatures_stream: Array<Signatures>;
    /** fetch data from the table: "spam_assets" */
    spam_assets: Array<SpamAssets>;
    /** fetch aggregated fields from the table: "spam_assets" */
    spam_assets_aggregate: SpamAssetsAggregate;
    /** fetch data from the table: "spam_assets" using primary key columns */
    spam_assets_by_pk?: Maybe<SpamAssets>;
    /** fetch data from the table in a streaming manner: "spam_assets" */
    spam_assets_stream: Array<SpamAssets>;
    /** fetch data from the table: "table_items" */
    table_items: Array<TableItems>;
    /** fetch aggregated fields from the table: "table_items" */
    table_items_aggregate: TableItemsAggregate;
    /** fetch data from the table: "table_items" using primary key columns */
    table_items_by_pk?: Maybe<TableItems>;
    /** fetch data from the table in a streaming manner: "table_items" */
    table_items_stream: Array<TableItems>;
    /** fetch data from the table: "table_items_view" */
    table_items_view: Array<TableItemsView>;
    /** fetch aggregated fields from the table: "table_items_view" */
    table_items_view_aggregate: TableItemsViewAggregate;
    /** fetch data from the table in a streaming manner: "table_items_view" */
    table_items_view_stream: Array<TableItemsView>;
    /** fetch data from the table: "table_metadatas" */
    table_metadatas: Array<TableMetadatas>;
    /** fetch aggregated fields from the table: "table_metadatas" */
    table_metadatas_aggregate: TableMetadatasAggregate;
    /** fetch data from the table: "table_metadatas" using primary key columns */
    table_metadatas_by_pk?: Maybe<TableMetadatas>;
    /** fetch data from the table in a streaming manner: "table_metadatas" */
    table_metadatas_stream: Array<TableMetadatas>;
    /** fetch data from the table: "token_activities" */
    token_activities: Array<TokenActivities>;
    /** fetch aggregated fields from the table: "token_activities" */
    token_activities_aggregate: TokenActivitiesAggregate;
    /** fetch data from the table: "token_activities" using primary key columns */
    token_activities_by_pk?: Maybe<TokenActivities>;
    /** fetch data from the table in a streaming manner: "token_activities" */
    token_activities_stream: Array<TokenActivities>;
    /** fetch data from the table: "token_activities_v2" */
    token_activities_v2: Array<TokenActivitiesV2>;
    /** fetch aggregated fields from the table: "token_activities_v2" */
    token_activities_v2_aggregate: TokenActivitiesV2Aggregate;
    /** fetch data from the table: "token_activities_v2" using primary key columns */
    token_activities_v2_by_pk?: Maybe<TokenActivitiesV2>;
    /** fetch data from the table in a streaming manner: "token_activities_v2" */
    token_activities_v2_stream: Array<TokenActivitiesV2>;
    /** fetch data from the table: "token_datas" */
    token_datas: Array<TokenDatas>;
    /** fetch aggregated fields from the table: "token_datas" */
    token_datas_aggregate: TokenDatasAggregate;
    /** fetch data from the table: "token_datas" using primary key columns */
    token_datas_by_pk?: Maybe<TokenDatas>;
    /** fetch data from the table in a streaming manner: "token_datas" */
    token_datas_stream: Array<TokenDatas>;
    /** fetch data from the table: "token_datas_v2" */
    token_datas_v2: Array<TokenDatasV2>;
    /** fetch aggregated fields from the table: "token_datas_v2" */
    token_datas_v2_aggregate: TokenDatasV2Aggregate;
    /** fetch data from the table: "token_datas_v2" using primary key columns */
    token_datas_v2_by_pk?: Maybe<TokenDatasV2>;
    /** fetch data from the table in a streaming manner: "token_datas_v2" */
    token_datas_v2_stream: Array<TokenDatasV2>;
    /** fetch data from the table: "token_ownerships" */
    token_ownerships: Array<TokenOwnerships>;
    /** fetch aggregated fields from the table: "token_ownerships" */
    token_ownerships_aggregate: TokenOwnershipsAggregate;
    /** fetch data from the table: "token_ownerships" using primary key columns */
    token_ownerships_by_pk?: Maybe<TokenOwnerships>;
    /** fetch data from the table in a streaming manner: "token_ownerships" */
    token_ownerships_stream: Array<TokenOwnerships>;
    /** fetch data from the table: "token_ownerships_v2" */
    token_ownerships_v2: Array<TokenOwnershipsV2>;
    /** fetch aggregated fields from the table: "token_ownerships_v2" */
    token_ownerships_v2_aggregate: TokenOwnershipsV2Aggregate;
    /** fetch data from the table: "token_ownerships_v2" using primary key columns */
    token_ownerships_v2_by_pk?: Maybe<TokenOwnershipsV2>;
    /** fetch data from the table in a streaming manner: "token_ownerships_v2" */
    token_ownerships_v2_stream: Array<TokenOwnershipsV2>;
    /** fetch data from the table: "tokens" */
    tokens: Array<Tokens>;
    /** fetch aggregated fields from the table: "tokens" */
    tokens_aggregate: TokensAggregate;
    /** fetch data from the table: "tokens" using primary key columns */
    tokens_by_pk?: Maybe<Tokens>;
    /** fetch data from the table in a streaming manner: "tokens" */
    tokens_stream: Array<Tokens>;
    /** fetch data from the table: "transaction_size_info" */
    transaction_size_info: Array<TransactionSizeInfo>;
    /** fetch aggregated fields from the table: "transaction_size_info" */
    transaction_size_info_aggregate: TransactionSizeInfoAggregate;
    /** fetch data from the table: "transaction_size_info" using primary key columns */
    transaction_size_info_by_pk?: Maybe<TransactionSizeInfo>;
    /** fetch data from the table in a streaming manner: "transaction_size_info" */
    transaction_size_info_stream: Array<TransactionSizeInfo>;
    /** fetch data from the table: "transactions_view" */
    transactions_view: Array<TransactionsView>;
    /** fetch aggregated fields from the table: "transactions_view" */
    transactions_view_aggregate: TransactionsViewAggregate;
    /** fetch data from the table in a streaming manner: "transactions_view" */
    transactions_view_stream: Array<TransactionsView>;
    /** fetch data from the table: "user_transactions" */
    user_transactions: Array<UserTransactions>;
    /** fetch aggregated fields from the table: "user_transactions" */
    user_transactions_aggregate: UserTransactionsAggregate;
    /** fetch data from the table: "user_transactions" using primary key columns */
    user_transactions_by_pk?: Maybe<UserTransactions>;
    /** fetch data from the table in a streaming manner: "user_transactions" */
    user_transactions_stream: Array<UserTransactions>;
};
type SubscriptionRootAccountTransactionsArgs = {
    distinct_on?: InputMaybe<Array<AccountTransactionsSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<AccountTransactionsOrderBy>>;
    where?: InputMaybe<AccountTransactionsBoolExp>;
};
type SubscriptionRootAccountTransactionsAggregateArgs = {
    distinct_on?: InputMaybe<Array<AccountTransactionsSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<AccountTransactionsOrderBy>>;
    where?: InputMaybe<AccountTransactionsBoolExp>;
};
type SubscriptionRootAccountTransactionsByPkArgs = {
    account_address: Scalars["String"]["input"];
    transaction_version: Scalars["bigint"]["input"];
};
type SubscriptionRootAccountTransactionsStreamArgs = {
    batch_size: Scalars["Int"]["input"];
    cursor: Array<InputMaybe<AccountTransactionsStreamCursorInput>>;
    where?: InputMaybe<AccountTransactionsBoolExp>;
};
type SubscriptionRootAddressEventsSummaryArgs = {
    distinct_on?: InputMaybe<Array<AddressEventsSummarySelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<AddressEventsSummaryOrderBy>>;
    where?: InputMaybe<AddressEventsSummaryBoolExp>;
};
type SubscriptionRootAddressEventsSummaryAggregateArgs = {
    distinct_on?: InputMaybe<Array<AddressEventsSummarySelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<AddressEventsSummaryOrderBy>>;
    where?: InputMaybe<AddressEventsSummaryBoolExp>;
};
type SubscriptionRootAddressEventsSummaryStreamArgs = {
    batch_size: Scalars["Int"]["input"];
    cursor: Array<InputMaybe<AddressEventsSummaryStreamCursorInput>>;
    where?: InputMaybe<AddressEventsSummaryBoolExp>;
};
type SubscriptionRootAddressVersionFromEventsArgs = {
    distinct_on?: InputMaybe<Array<AddressVersionFromEventsSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<AddressVersionFromEventsOrderBy>>;
    where?: InputMaybe<AddressVersionFromEventsBoolExp>;
};
type SubscriptionRootAddressVersionFromEventsAggregateArgs = {
    distinct_on?: InputMaybe<Array<AddressVersionFromEventsSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<AddressVersionFromEventsOrderBy>>;
    where?: InputMaybe<AddressVersionFromEventsBoolExp>;
};
type SubscriptionRootAddressVersionFromEventsStreamArgs = {
    batch_size: Scalars["Int"]["input"];
    cursor: Array<InputMaybe<AddressVersionFromEventsStreamCursorInput>>;
    where?: InputMaybe<AddressVersionFromEventsBoolExp>;
};
type SubscriptionRootAddressVersionFromMoveResourcesArgs = {
    distinct_on?: InputMaybe<Array<AddressVersionFromMoveResourcesSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<AddressVersionFromMoveResourcesOrderBy>>;
    where?: InputMaybe<AddressVersionFromMoveResourcesBoolExp>;
};
type SubscriptionRootAddressVersionFromMoveResourcesAggregateArgs = {
    distinct_on?: InputMaybe<Array<AddressVersionFromMoveResourcesSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<AddressVersionFromMoveResourcesOrderBy>>;
    where?: InputMaybe<AddressVersionFromMoveResourcesBoolExp>;
};
type SubscriptionRootAddressVersionFromMoveResourcesStreamArgs = {
    batch_size: Scalars["Int"]["input"];
    cursor: Array<InputMaybe<AddressVersionFromMoveResourcesStreamCursorInput>>;
    where?: InputMaybe<AddressVersionFromMoveResourcesBoolExp>;
};
type SubscriptionRootAnsLookupArgs = {
    distinct_on?: InputMaybe<Array<AnsLookupSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<AnsLookupOrderBy>>;
    where?: InputMaybe<AnsLookupBoolExp>;
};
type SubscriptionRootAnsLookupAggregateArgs = {
    distinct_on?: InputMaybe<Array<AnsLookupSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<AnsLookupOrderBy>>;
    where?: InputMaybe<AnsLookupBoolExp>;
};
type SubscriptionRootAnsLookupByPkArgs = {
    transaction_version: Scalars["bigint"]["input"];
    write_set_change_index: Scalars["bigint"]["input"];
};
type SubscriptionRootAnsLookupStreamArgs = {
    batch_size: Scalars["Int"]["input"];
    cursor: Array<InputMaybe<AnsLookupStreamCursorInput>>;
    where?: InputMaybe<AnsLookupBoolExp>;
};
type SubscriptionRootAnsLookupV2Args = {
    distinct_on?: InputMaybe<Array<AnsLookupV2SelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<AnsLookupV2OrderBy>>;
    where?: InputMaybe<AnsLookupV2BoolExp>;
};
type SubscriptionRootAnsLookupV2AggregateArgs = {
    distinct_on?: InputMaybe<Array<AnsLookupV2SelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<AnsLookupV2OrderBy>>;
    where?: InputMaybe<AnsLookupV2BoolExp>;
};
type SubscriptionRootAnsLookupV2ByPkArgs = {
    transaction_version: Scalars["bigint"]["input"];
    write_set_change_index: Scalars["bigint"]["input"];
};
type SubscriptionRootAnsLookupV2StreamArgs = {
    batch_size: Scalars["Int"]["input"];
    cursor: Array<InputMaybe<AnsLookupV2StreamCursorInput>>;
    where?: InputMaybe<AnsLookupV2BoolExp>;
};
type SubscriptionRootAnsPrimaryNameArgs = {
    distinct_on?: InputMaybe<Array<AnsPrimaryNameSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<AnsPrimaryNameOrderBy>>;
    where?: InputMaybe<AnsPrimaryNameBoolExp>;
};
type SubscriptionRootAnsPrimaryNameAggregateArgs = {
    distinct_on?: InputMaybe<Array<AnsPrimaryNameSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<AnsPrimaryNameOrderBy>>;
    where?: InputMaybe<AnsPrimaryNameBoolExp>;
};
type SubscriptionRootAnsPrimaryNameByPkArgs = {
    transaction_version: Scalars["bigint"]["input"];
    write_set_change_index: Scalars["bigint"]["input"];
};
type SubscriptionRootAnsPrimaryNameStreamArgs = {
    batch_size: Scalars["Int"]["input"];
    cursor: Array<InputMaybe<AnsPrimaryNameStreamCursorInput>>;
    where?: InputMaybe<AnsPrimaryNameBoolExp>;
};
type SubscriptionRootAnsPrimaryNameV2Args = {
    distinct_on?: InputMaybe<Array<AnsPrimaryNameV2SelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<AnsPrimaryNameV2OrderBy>>;
    where?: InputMaybe<AnsPrimaryNameV2BoolExp>;
};
type SubscriptionRootAnsPrimaryNameV2AggregateArgs = {
    distinct_on?: InputMaybe<Array<AnsPrimaryNameV2SelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<AnsPrimaryNameV2OrderBy>>;
    where?: InputMaybe<AnsPrimaryNameV2BoolExp>;
};
type SubscriptionRootAnsPrimaryNameV2ByPkArgs = {
    transaction_version: Scalars["bigint"]["input"];
    write_set_change_index: Scalars["bigint"]["input"];
};
type SubscriptionRootAnsPrimaryNameV2StreamArgs = {
    batch_size: Scalars["Int"]["input"];
    cursor: Array<InputMaybe<AnsPrimaryNameV2StreamCursorInput>>;
    where?: InputMaybe<AnsPrimaryNameV2BoolExp>;
};
type SubscriptionRootAuthKeyAccountAddressesArgs = {
    distinct_on?: InputMaybe<Array<AuthKeyAccountAddressesSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<AuthKeyAccountAddressesOrderBy>>;
    where?: InputMaybe<AuthKeyAccountAddressesBoolExp>;
};
type SubscriptionRootAuthKeyAccountAddressesAggregateArgs = {
    distinct_on?: InputMaybe<Array<AuthKeyAccountAddressesSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<AuthKeyAccountAddressesOrderBy>>;
    where?: InputMaybe<AuthKeyAccountAddressesBoolExp>;
};
type SubscriptionRootAuthKeyAccountAddressesByPkArgs = {
    account_address: Scalars["String"]["input"];
};
type SubscriptionRootAuthKeyAccountAddressesStreamArgs = {
    batch_size: Scalars["Int"]["input"];
    cursor: Array<InputMaybe<AuthKeyAccountAddressesStreamCursorInput>>;
    where?: InputMaybe<AuthKeyAccountAddressesBoolExp>;
};
type SubscriptionRootBlockMetadataTransactionsArgs = {
    distinct_on?: InputMaybe<Array<BlockMetadataTransactionsSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<BlockMetadataTransactionsOrderBy>>;
    where?: InputMaybe<BlockMetadataTransactionsBoolExp>;
};
type SubscriptionRootBlockMetadataTransactionsAggregateArgs = {
    distinct_on?: InputMaybe<Array<BlockMetadataTransactionsSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<BlockMetadataTransactionsOrderBy>>;
    where?: InputMaybe<BlockMetadataTransactionsBoolExp>;
};
type SubscriptionRootBlockMetadataTransactionsByPkArgs = {
    version: Scalars["bigint"]["input"];
};
type SubscriptionRootBlockMetadataTransactionsStreamArgs = {
    batch_size: Scalars["Int"]["input"];
    cursor: Array<InputMaybe<BlockMetadataTransactionsStreamCursorInput>>;
    where?: InputMaybe<BlockMetadataTransactionsBoolExp>;
};
type SubscriptionRootCoinActivitiesArgs = {
    distinct_on?: InputMaybe<Array<CoinActivitiesSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CoinActivitiesOrderBy>>;
    where?: InputMaybe<CoinActivitiesBoolExp>;
};
type SubscriptionRootCoinActivitiesAggregateArgs = {
    distinct_on?: InputMaybe<Array<CoinActivitiesSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CoinActivitiesOrderBy>>;
    where?: InputMaybe<CoinActivitiesBoolExp>;
};
type SubscriptionRootCoinActivitiesByPkArgs = {
    event_account_address: Scalars["String"]["input"];
    event_creation_number: Scalars["bigint"]["input"];
    event_sequence_number: Scalars["bigint"]["input"];
    transaction_version: Scalars["bigint"]["input"];
};
type SubscriptionRootCoinActivitiesStreamArgs = {
    batch_size: Scalars["Int"]["input"];
    cursor: Array<InputMaybe<CoinActivitiesStreamCursorInput>>;
    where?: InputMaybe<CoinActivitiesBoolExp>;
};
type SubscriptionRootCoinBalancesArgs = {
    distinct_on?: InputMaybe<Array<CoinBalancesSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CoinBalancesOrderBy>>;
    where?: InputMaybe<CoinBalancesBoolExp>;
};
type SubscriptionRootCoinBalancesAggregateArgs = {
    distinct_on?: InputMaybe<Array<CoinBalancesSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CoinBalancesOrderBy>>;
    where?: InputMaybe<CoinBalancesBoolExp>;
};
type SubscriptionRootCoinBalancesByPkArgs = {
    coin_type_hash: Scalars["String"]["input"];
    owner_address: Scalars["String"]["input"];
    transaction_version: Scalars["bigint"]["input"];
};
type SubscriptionRootCoinBalancesStreamArgs = {
    batch_size: Scalars["Int"]["input"];
    cursor: Array<InputMaybe<CoinBalancesStreamCursorInput>>;
    where?: InputMaybe<CoinBalancesBoolExp>;
};
type SubscriptionRootCoinInfosArgs = {
    distinct_on?: InputMaybe<Array<CoinInfosSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CoinInfosOrderBy>>;
    where?: InputMaybe<CoinInfosBoolExp>;
};
type SubscriptionRootCoinInfosAggregateArgs = {
    distinct_on?: InputMaybe<Array<CoinInfosSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CoinInfosOrderBy>>;
    where?: InputMaybe<CoinInfosBoolExp>;
};
type SubscriptionRootCoinInfosByPkArgs = {
    coin_type_hash: Scalars["String"]["input"];
};
type SubscriptionRootCoinInfosStreamArgs = {
    batch_size: Scalars["Int"]["input"];
    cursor: Array<InputMaybe<CoinInfosStreamCursorInput>>;
    where?: InputMaybe<CoinInfosBoolExp>;
};
type SubscriptionRootCoinSupplyArgs = {
    distinct_on?: InputMaybe<Array<CoinSupplySelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CoinSupplyOrderBy>>;
    where?: InputMaybe<CoinSupplyBoolExp>;
};
type SubscriptionRootCoinSupplyAggregateArgs = {
    distinct_on?: InputMaybe<Array<CoinSupplySelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CoinSupplyOrderBy>>;
    where?: InputMaybe<CoinSupplyBoolExp>;
};
type SubscriptionRootCoinSupplyByPkArgs = {
    coin_type_hash: Scalars["String"]["input"];
    transaction_version: Scalars["bigint"]["input"];
};
type SubscriptionRootCoinSupplyStreamArgs = {
    batch_size: Scalars["Int"]["input"];
    cursor: Array<InputMaybe<CoinSupplyStreamCursorInput>>;
    where?: InputMaybe<CoinSupplyBoolExp>;
};
type SubscriptionRootCollectionDatasArgs = {
    distinct_on?: InputMaybe<Array<CollectionDatasSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CollectionDatasOrderBy>>;
    where?: InputMaybe<CollectionDatasBoolExp>;
};
type SubscriptionRootCollectionDatasAggregateArgs = {
    distinct_on?: InputMaybe<Array<CollectionDatasSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CollectionDatasOrderBy>>;
    where?: InputMaybe<CollectionDatasBoolExp>;
};
type SubscriptionRootCollectionDatasByPkArgs = {
    collection_data_id_hash: Scalars["String"]["input"];
    transaction_version: Scalars["bigint"]["input"];
};
type SubscriptionRootCollectionDatasStreamArgs = {
    batch_size: Scalars["Int"]["input"];
    cursor: Array<InputMaybe<CollectionDatasStreamCursorInput>>;
    where?: InputMaybe<CollectionDatasBoolExp>;
};
type SubscriptionRootCollectionsV2Args = {
    distinct_on?: InputMaybe<Array<CollectionsV2SelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CollectionsV2OrderBy>>;
    where?: InputMaybe<CollectionsV2BoolExp>;
};
type SubscriptionRootCollectionsV2AggregateArgs = {
    distinct_on?: InputMaybe<Array<CollectionsV2SelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CollectionsV2OrderBy>>;
    where?: InputMaybe<CollectionsV2BoolExp>;
};
type SubscriptionRootCollectionsV2ByPkArgs = {
    transaction_version: Scalars["bigint"]["input"];
    write_set_change_index: Scalars["bigint"]["input"];
};
type SubscriptionRootCollectionsV2StreamArgs = {
    batch_size: Scalars["Int"]["input"];
    cursor: Array<InputMaybe<CollectionsV2StreamCursorInput>>;
    where?: InputMaybe<CollectionsV2BoolExp>;
};
type SubscriptionRootCurrentAnsLookupArgs = {
    distinct_on?: InputMaybe<Array<CurrentAnsLookupSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentAnsLookupOrderBy>>;
    where?: InputMaybe<CurrentAnsLookupBoolExp>;
};
type SubscriptionRootCurrentAnsLookupAggregateArgs = {
    distinct_on?: InputMaybe<Array<CurrentAnsLookupSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentAnsLookupOrderBy>>;
    where?: InputMaybe<CurrentAnsLookupBoolExp>;
};
type SubscriptionRootCurrentAnsLookupByPkArgs = {
    domain: Scalars["String"]["input"];
    subdomain: Scalars["String"]["input"];
};
type SubscriptionRootCurrentAnsLookupStreamArgs = {
    batch_size: Scalars["Int"]["input"];
    cursor: Array<InputMaybe<CurrentAnsLookupStreamCursorInput>>;
    where?: InputMaybe<CurrentAnsLookupBoolExp>;
};
type SubscriptionRootCurrentAnsLookupV2Args = {
    distinct_on?: InputMaybe<Array<CurrentAnsLookupV2SelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentAnsLookupV2OrderBy>>;
    where?: InputMaybe<CurrentAnsLookupV2BoolExp>;
};
type SubscriptionRootCurrentAnsLookupV2AggregateArgs = {
    distinct_on?: InputMaybe<Array<CurrentAnsLookupV2SelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentAnsLookupV2OrderBy>>;
    where?: InputMaybe<CurrentAnsLookupV2BoolExp>;
};
type SubscriptionRootCurrentAnsLookupV2ByPkArgs = {
    domain: Scalars["String"]["input"];
    subdomain: Scalars["String"]["input"];
    token_standard: Scalars["String"]["input"];
};
type SubscriptionRootCurrentAnsLookupV2StreamArgs = {
    batch_size: Scalars["Int"]["input"];
    cursor: Array<InputMaybe<CurrentAnsLookupV2StreamCursorInput>>;
    where?: InputMaybe<CurrentAnsLookupV2BoolExp>;
};
type SubscriptionRootCurrentAnsPrimaryNameArgs = {
    distinct_on?: InputMaybe<Array<CurrentAnsPrimaryNameSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentAnsPrimaryNameOrderBy>>;
    where?: InputMaybe<CurrentAnsPrimaryNameBoolExp>;
};
type SubscriptionRootCurrentAnsPrimaryNameAggregateArgs = {
    distinct_on?: InputMaybe<Array<CurrentAnsPrimaryNameSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentAnsPrimaryNameOrderBy>>;
    where?: InputMaybe<CurrentAnsPrimaryNameBoolExp>;
};
type SubscriptionRootCurrentAnsPrimaryNameByPkArgs = {
    registered_address: Scalars["String"]["input"];
};
type SubscriptionRootCurrentAnsPrimaryNameStreamArgs = {
    batch_size: Scalars["Int"]["input"];
    cursor: Array<InputMaybe<CurrentAnsPrimaryNameStreamCursorInput>>;
    where?: InputMaybe<CurrentAnsPrimaryNameBoolExp>;
};
type SubscriptionRootCurrentAnsPrimaryNameV2Args = {
    distinct_on?: InputMaybe<Array<CurrentAnsPrimaryNameV2SelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentAnsPrimaryNameV2OrderBy>>;
    where?: InputMaybe<CurrentAnsPrimaryNameV2BoolExp>;
};
type SubscriptionRootCurrentAnsPrimaryNameV2AggregateArgs = {
    distinct_on?: InputMaybe<Array<CurrentAnsPrimaryNameV2SelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentAnsPrimaryNameV2OrderBy>>;
    where?: InputMaybe<CurrentAnsPrimaryNameV2BoolExp>;
};
type SubscriptionRootCurrentAnsPrimaryNameV2ByPkArgs = {
    registered_address: Scalars["String"]["input"];
    token_standard: Scalars["String"]["input"];
};
type SubscriptionRootCurrentAnsPrimaryNameV2StreamArgs = {
    batch_size: Scalars["Int"]["input"];
    cursor: Array<InputMaybe<CurrentAnsPrimaryNameV2StreamCursorInput>>;
    where?: InputMaybe<CurrentAnsPrimaryNameV2BoolExp>;
};
type SubscriptionRootCurrentCedraNamesArgs = {
    distinct_on?: InputMaybe<Array<CurrentCedraNamesSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentCedraNamesOrderBy>>;
    where?: InputMaybe<CurrentCedraNamesBoolExp>;
};
type SubscriptionRootCurrentCedraNamesAggregateArgs = {
    distinct_on?: InputMaybe<Array<CurrentCedraNamesSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentCedraNamesOrderBy>>;
    where?: InputMaybe<CurrentCedraNamesBoolExp>;
};
type SubscriptionRootCurrentCedraNamesStreamArgs = {
    batch_size: Scalars["Int"]["input"];
    cursor: Array<InputMaybe<CurrentCedraNamesStreamCursorInput>>;
    where?: InputMaybe<CurrentCedraNamesBoolExp>;
};
type SubscriptionRootCurrentCoinBalancesArgs = {
    distinct_on?: InputMaybe<Array<CurrentCoinBalancesSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentCoinBalancesOrderBy>>;
    where?: InputMaybe<CurrentCoinBalancesBoolExp>;
};
type SubscriptionRootCurrentCoinBalancesAggregateArgs = {
    distinct_on?: InputMaybe<Array<CurrentCoinBalancesSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentCoinBalancesOrderBy>>;
    where?: InputMaybe<CurrentCoinBalancesBoolExp>;
};
type SubscriptionRootCurrentCoinBalancesByPkArgs = {
    coin_type_hash: Scalars["String"]["input"];
    owner_address: Scalars["String"]["input"];
};
type SubscriptionRootCurrentCoinBalancesStreamArgs = {
    batch_size: Scalars["Int"]["input"];
    cursor: Array<InputMaybe<CurrentCoinBalancesStreamCursorInput>>;
    where?: InputMaybe<CurrentCoinBalancesBoolExp>;
};
type SubscriptionRootCurrentCollectionDatasArgs = {
    distinct_on?: InputMaybe<Array<CurrentCollectionDatasSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentCollectionDatasOrderBy>>;
    where?: InputMaybe<CurrentCollectionDatasBoolExp>;
};
type SubscriptionRootCurrentCollectionDatasAggregateArgs = {
    distinct_on?: InputMaybe<Array<CurrentCollectionDatasSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentCollectionDatasOrderBy>>;
    where?: InputMaybe<CurrentCollectionDatasBoolExp>;
};
type SubscriptionRootCurrentCollectionDatasByPkArgs = {
    collection_data_id_hash: Scalars["String"]["input"];
};
type SubscriptionRootCurrentCollectionDatasStreamArgs = {
    batch_size: Scalars["Int"]["input"];
    cursor: Array<InputMaybe<CurrentCollectionDatasStreamCursorInput>>;
    where?: InputMaybe<CurrentCollectionDatasBoolExp>;
};
type SubscriptionRootCurrentCollectionOwnershipV2ViewArgs = {
    distinct_on?: InputMaybe<Array<CurrentCollectionOwnershipV2ViewSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentCollectionOwnershipV2ViewOrderBy>>;
    where?: InputMaybe<CurrentCollectionOwnershipV2ViewBoolExp>;
};
type SubscriptionRootCurrentCollectionOwnershipV2ViewAggregateArgs = {
    distinct_on?: InputMaybe<Array<CurrentCollectionOwnershipV2ViewSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentCollectionOwnershipV2ViewOrderBy>>;
    where?: InputMaybe<CurrentCollectionOwnershipV2ViewBoolExp>;
};
type SubscriptionRootCurrentCollectionOwnershipV2ViewStreamArgs = {
    batch_size: Scalars["Int"]["input"];
    cursor: Array<InputMaybe<CurrentCollectionOwnershipV2ViewStreamCursorInput>>;
    where?: InputMaybe<CurrentCollectionOwnershipV2ViewBoolExp>;
};
type SubscriptionRootCurrentCollectionOwnershipViewArgs = {
    distinct_on?: InputMaybe<Array<CurrentCollectionOwnershipViewSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentCollectionOwnershipViewOrderBy>>;
    where?: InputMaybe<CurrentCollectionOwnershipViewBoolExp>;
};
type SubscriptionRootCurrentCollectionOwnershipViewAggregateArgs = {
    distinct_on?: InputMaybe<Array<CurrentCollectionOwnershipViewSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentCollectionOwnershipViewOrderBy>>;
    where?: InputMaybe<CurrentCollectionOwnershipViewBoolExp>;
};
type SubscriptionRootCurrentCollectionOwnershipViewStreamArgs = {
    batch_size: Scalars["Int"]["input"];
    cursor: Array<InputMaybe<CurrentCollectionOwnershipViewStreamCursorInput>>;
    where?: InputMaybe<CurrentCollectionOwnershipViewBoolExp>;
};
type SubscriptionRootCurrentCollectionsV2Args = {
    distinct_on?: InputMaybe<Array<CurrentCollectionsV2SelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentCollectionsV2OrderBy>>;
    where?: InputMaybe<CurrentCollectionsV2BoolExp>;
};
type SubscriptionRootCurrentCollectionsV2AggregateArgs = {
    distinct_on?: InputMaybe<Array<CurrentCollectionsV2SelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentCollectionsV2OrderBy>>;
    where?: InputMaybe<CurrentCollectionsV2BoolExp>;
};
type SubscriptionRootCurrentCollectionsV2ByPkArgs = {
    collection_id: Scalars["String"]["input"];
};
type SubscriptionRootCurrentCollectionsV2StreamArgs = {
    batch_size: Scalars["Int"]["input"];
    cursor: Array<InputMaybe<CurrentCollectionsV2StreamCursorInput>>;
    where?: InputMaybe<CurrentCollectionsV2BoolExp>;
};
type SubscriptionRootCurrentDelegatedStakingPoolBalancesArgs = {
    distinct_on?: InputMaybe<Array<CurrentDelegatedStakingPoolBalancesSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentDelegatedStakingPoolBalancesOrderBy>>;
    where?: InputMaybe<CurrentDelegatedStakingPoolBalancesBoolExp>;
};
type SubscriptionRootCurrentDelegatedStakingPoolBalancesAggregateArgs = {
    distinct_on?: InputMaybe<Array<CurrentDelegatedStakingPoolBalancesSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentDelegatedStakingPoolBalancesOrderBy>>;
    where?: InputMaybe<CurrentDelegatedStakingPoolBalancesBoolExp>;
};
type SubscriptionRootCurrentDelegatedStakingPoolBalancesByPkArgs = {
    staking_pool_address: Scalars["String"]["input"];
};
type SubscriptionRootCurrentDelegatedStakingPoolBalancesStreamArgs = {
    batch_size: Scalars["Int"]["input"];
    cursor: Array<InputMaybe<CurrentDelegatedStakingPoolBalancesStreamCursorInput>>;
    where?: InputMaybe<CurrentDelegatedStakingPoolBalancesBoolExp>;
};
type SubscriptionRootCurrentDelegatedVoterArgs = {
    distinct_on?: InputMaybe<Array<CurrentDelegatedVoterSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentDelegatedVoterOrderBy>>;
    where?: InputMaybe<CurrentDelegatedVoterBoolExp>;
};
type SubscriptionRootCurrentDelegatedVoterAggregateArgs = {
    distinct_on?: InputMaybe<Array<CurrentDelegatedVoterSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentDelegatedVoterOrderBy>>;
    where?: InputMaybe<CurrentDelegatedVoterBoolExp>;
};
type SubscriptionRootCurrentDelegatedVoterByPkArgs = {
    delegation_pool_address: Scalars["String"]["input"];
    delegator_address: Scalars["String"]["input"];
};
type SubscriptionRootCurrentDelegatedVoterStreamArgs = {
    batch_size: Scalars["Int"]["input"];
    cursor: Array<InputMaybe<CurrentDelegatedVoterStreamCursorInput>>;
    where?: InputMaybe<CurrentDelegatedVoterBoolExp>;
};
type SubscriptionRootCurrentDelegatorBalancesArgs = {
    distinct_on?: InputMaybe<Array<CurrentDelegatorBalancesSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentDelegatorBalancesOrderBy>>;
    where?: InputMaybe<CurrentDelegatorBalancesBoolExp>;
};
type SubscriptionRootCurrentDelegatorBalancesAggregateArgs = {
    distinct_on?: InputMaybe<Array<CurrentDelegatorBalancesSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentDelegatorBalancesOrderBy>>;
    where?: InputMaybe<CurrentDelegatorBalancesBoolExp>;
};
type SubscriptionRootCurrentDelegatorBalancesByPkArgs = {
    delegator_address: Scalars["String"]["input"];
    pool_address: Scalars["String"]["input"];
    pool_type: Scalars["String"]["input"];
    table_handle: Scalars["String"]["input"];
};
type SubscriptionRootCurrentDelegatorBalancesStreamArgs = {
    batch_size: Scalars["Int"]["input"];
    cursor: Array<InputMaybe<CurrentDelegatorBalancesStreamCursorInput>>;
    where?: InputMaybe<CurrentDelegatorBalancesBoolExp>;
};
type SubscriptionRootCurrentFungibleAssetBalancesArgs = {
    distinct_on?: InputMaybe<Array<CurrentFungibleAssetBalancesSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentFungibleAssetBalancesOrderBy>>;
    where?: InputMaybe<CurrentFungibleAssetBalancesBoolExp>;
};
type SubscriptionRootCurrentFungibleAssetBalancesAggregateArgs = {
    distinct_on?: InputMaybe<Array<CurrentFungibleAssetBalancesSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentFungibleAssetBalancesOrderBy>>;
    where?: InputMaybe<CurrentFungibleAssetBalancesBoolExp>;
};
type SubscriptionRootCurrentFungibleAssetBalancesByPkArgs = {
    storage_id: Scalars["String"]["input"];
};
type SubscriptionRootCurrentFungibleAssetBalancesNewArgs = {
    distinct_on?: InputMaybe<Array<CurrentFungibleAssetBalancesNewSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentFungibleAssetBalancesNewOrderBy>>;
    where?: InputMaybe<CurrentFungibleAssetBalancesNewBoolExp>;
};
type SubscriptionRootCurrentFungibleAssetBalancesNewAggregateArgs = {
    distinct_on?: InputMaybe<Array<CurrentFungibleAssetBalancesNewSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentFungibleAssetBalancesNewOrderBy>>;
    where?: InputMaybe<CurrentFungibleAssetBalancesNewBoolExp>;
};
type SubscriptionRootCurrentFungibleAssetBalancesNewByPkArgs = {
    storage_id: Scalars["String"]["input"];
};
type SubscriptionRootCurrentFungibleAssetBalancesNewStreamArgs = {
    batch_size: Scalars["Int"]["input"];
    cursor: Array<InputMaybe<CurrentFungibleAssetBalancesNewStreamCursorInput>>;
    where?: InputMaybe<CurrentFungibleAssetBalancesNewBoolExp>;
};
type SubscriptionRootCurrentFungibleAssetBalancesStreamArgs = {
    batch_size: Scalars["Int"]["input"];
    cursor: Array<InputMaybe<CurrentFungibleAssetBalancesStreamCursorInput>>;
    where?: InputMaybe<CurrentFungibleAssetBalancesBoolExp>;
};
type SubscriptionRootCurrentObjectsArgs = {
    distinct_on?: InputMaybe<Array<CurrentObjectsSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentObjectsOrderBy>>;
    where?: InputMaybe<CurrentObjectsBoolExp>;
};
type SubscriptionRootCurrentObjectsAggregateArgs = {
    distinct_on?: InputMaybe<Array<CurrentObjectsSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentObjectsOrderBy>>;
    where?: InputMaybe<CurrentObjectsBoolExp>;
};
type SubscriptionRootCurrentObjectsByPkArgs = {
    object_address: Scalars["String"]["input"];
};
type SubscriptionRootCurrentObjectsStreamArgs = {
    batch_size: Scalars["Int"]["input"];
    cursor: Array<InputMaybe<CurrentObjectsStreamCursorInput>>;
    where?: InputMaybe<CurrentObjectsBoolExp>;
};
type SubscriptionRootCurrentStakingPoolVoterArgs = {
    distinct_on?: InputMaybe<Array<CurrentStakingPoolVoterSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentStakingPoolVoterOrderBy>>;
    where?: InputMaybe<CurrentStakingPoolVoterBoolExp>;
};
type SubscriptionRootCurrentStakingPoolVoterAggregateArgs = {
    distinct_on?: InputMaybe<Array<CurrentStakingPoolVoterSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentStakingPoolVoterOrderBy>>;
    where?: InputMaybe<CurrentStakingPoolVoterBoolExp>;
};
type SubscriptionRootCurrentStakingPoolVoterByPkArgs = {
    staking_pool_address: Scalars["String"]["input"];
};
type SubscriptionRootCurrentStakingPoolVoterStreamArgs = {
    batch_size: Scalars["Int"]["input"];
    cursor: Array<InputMaybe<CurrentStakingPoolVoterStreamCursorInput>>;
    where?: InputMaybe<CurrentStakingPoolVoterBoolExp>;
};
type SubscriptionRootCurrentTableItemsArgs = {
    distinct_on?: InputMaybe<Array<CurrentTableItemsSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentTableItemsOrderBy>>;
    where?: InputMaybe<CurrentTableItemsBoolExp>;
};
type SubscriptionRootCurrentTableItemsAggregateArgs = {
    distinct_on?: InputMaybe<Array<CurrentTableItemsSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentTableItemsOrderBy>>;
    where?: InputMaybe<CurrentTableItemsBoolExp>;
};
type SubscriptionRootCurrentTableItemsByPkArgs = {
    key_hash: Scalars["String"]["input"];
    table_handle: Scalars["String"]["input"];
};
type SubscriptionRootCurrentTableItemsStreamArgs = {
    batch_size: Scalars["Int"]["input"];
    cursor: Array<InputMaybe<CurrentTableItemsStreamCursorInput>>;
    where?: InputMaybe<CurrentTableItemsBoolExp>;
};
type SubscriptionRootCurrentTableItemsViewArgs = {
    distinct_on?: InputMaybe<Array<CurrentTableItemsViewSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentTableItemsViewOrderBy>>;
    where?: InputMaybe<CurrentTableItemsViewBoolExp>;
};
type SubscriptionRootCurrentTableItemsViewAggregateArgs = {
    distinct_on?: InputMaybe<Array<CurrentTableItemsViewSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentTableItemsViewOrderBy>>;
    where?: InputMaybe<CurrentTableItemsViewBoolExp>;
};
type SubscriptionRootCurrentTableItemsViewStreamArgs = {
    batch_size: Scalars["Int"]["input"];
    cursor: Array<InputMaybe<CurrentTableItemsViewStreamCursorInput>>;
    where?: InputMaybe<CurrentTableItemsViewBoolExp>;
};
type SubscriptionRootCurrentTokenDatasArgs = {
    distinct_on?: InputMaybe<Array<CurrentTokenDatasSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentTokenDatasOrderBy>>;
    where?: InputMaybe<CurrentTokenDatasBoolExp>;
};
type SubscriptionRootCurrentTokenDatasAggregateArgs = {
    distinct_on?: InputMaybe<Array<CurrentTokenDatasSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentTokenDatasOrderBy>>;
    where?: InputMaybe<CurrentTokenDatasBoolExp>;
};
type SubscriptionRootCurrentTokenDatasByPkArgs = {
    token_data_id_hash: Scalars["String"]["input"];
};
type SubscriptionRootCurrentTokenDatasStreamArgs = {
    batch_size: Scalars["Int"]["input"];
    cursor: Array<InputMaybe<CurrentTokenDatasStreamCursorInput>>;
    where?: InputMaybe<CurrentTokenDatasBoolExp>;
};
type SubscriptionRootCurrentTokenDatasV2Args = {
    distinct_on?: InputMaybe<Array<CurrentTokenDatasV2SelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentTokenDatasV2OrderBy>>;
    where?: InputMaybe<CurrentTokenDatasV2BoolExp>;
};
type SubscriptionRootCurrentTokenDatasV2AggregateArgs = {
    distinct_on?: InputMaybe<Array<CurrentTokenDatasV2SelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentTokenDatasV2OrderBy>>;
    where?: InputMaybe<CurrentTokenDatasV2BoolExp>;
};
type SubscriptionRootCurrentTokenDatasV2ByPkArgs = {
    token_data_id: Scalars["String"]["input"];
};
type SubscriptionRootCurrentTokenDatasV2StreamArgs = {
    batch_size: Scalars["Int"]["input"];
    cursor: Array<InputMaybe<CurrentTokenDatasV2StreamCursorInput>>;
    where?: InputMaybe<CurrentTokenDatasV2BoolExp>;
};
type SubscriptionRootCurrentTokenOwnershipsArgs = {
    distinct_on?: InputMaybe<Array<CurrentTokenOwnershipsSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentTokenOwnershipsOrderBy>>;
    where?: InputMaybe<CurrentTokenOwnershipsBoolExp>;
};
type SubscriptionRootCurrentTokenOwnershipsAggregateArgs = {
    distinct_on?: InputMaybe<Array<CurrentTokenOwnershipsSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentTokenOwnershipsOrderBy>>;
    where?: InputMaybe<CurrentTokenOwnershipsBoolExp>;
};
type SubscriptionRootCurrentTokenOwnershipsByPkArgs = {
    owner_address: Scalars["String"]["input"];
    property_version: Scalars["numeric"]["input"];
    token_data_id_hash: Scalars["String"]["input"];
};
type SubscriptionRootCurrentTokenOwnershipsStreamArgs = {
    batch_size: Scalars["Int"]["input"];
    cursor: Array<InputMaybe<CurrentTokenOwnershipsStreamCursorInput>>;
    where?: InputMaybe<CurrentTokenOwnershipsBoolExp>;
};
type SubscriptionRootCurrentTokenOwnershipsV2Args = {
    distinct_on?: InputMaybe<Array<CurrentTokenOwnershipsV2SelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentTokenOwnershipsV2OrderBy>>;
    where?: InputMaybe<CurrentTokenOwnershipsV2BoolExp>;
};
type SubscriptionRootCurrentTokenOwnershipsV2AggregateArgs = {
    distinct_on?: InputMaybe<Array<CurrentTokenOwnershipsV2SelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentTokenOwnershipsV2OrderBy>>;
    where?: InputMaybe<CurrentTokenOwnershipsV2BoolExp>;
};
type SubscriptionRootCurrentTokenOwnershipsV2ByPkArgs = {
    owner_address: Scalars["String"]["input"];
    property_version_v1: Scalars["numeric"]["input"];
    storage_id: Scalars["String"]["input"];
    token_data_id: Scalars["String"]["input"];
};
type SubscriptionRootCurrentTokenOwnershipsV2StreamArgs = {
    batch_size: Scalars["Int"]["input"];
    cursor: Array<InputMaybe<CurrentTokenOwnershipsV2StreamCursorInput>>;
    where?: InputMaybe<CurrentTokenOwnershipsV2BoolExp>;
};
type SubscriptionRootCurrentTokenPendingClaimsArgs = {
    distinct_on?: InputMaybe<Array<CurrentTokenPendingClaimsSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentTokenPendingClaimsOrderBy>>;
    where?: InputMaybe<CurrentTokenPendingClaimsBoolExp>;
};
type SubscriptionRootCurrentTokenPendingClaimsAggregateArgs = {
    distinct_on?: InputMaybe<Array<CurrentTokenPendingClaimsSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentTokenPendingClaimsOrderBy>>;
    where?: InputMaybe<CurrentTokenPendingClaimsBoolExp>;
};
type SubscriptionRootCurrentTokenPendingClaimsByPkArgs = {
    from_address: Scalars["String"]["input"];
    property_version: Scalars["numeric"]["input"];
    to_address: Scalars["String"]["input"];
    token_data_id_hash: Scalars["String"]["input"];
};
type SubscriptionRootCurrentTokenPendingClaimsStreamArgs = {
    batch_size: Scalars["Int"]["input"];
    cursor: Array<InputMaybe<CurrentTokenPendingClaimsStreamCursorInput>>;
    where?: InputMaybe<CurrentTokenPendingClaimsBoolExp>;
};
type SubscriptionRootCurrentTokenRoyaltyV1Args = {
    distinct_on?: InputMaybe<Array<CurrentTokenRoyaltyV1SelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentTokenRoyaltyV1OrderBy>>;
    where?: InputMaybe<CurrentTokenRoyaltyV1BoolExp>;
};
type SubscriptionRootCurrentTokenRoyaltyV1AggregateArgs = {
    distinct_on?: InputMaybe<Array<CurrentTokenRoyaltyV1SelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentTokenRoyaltyV1OrderBy>>;
    where?: InputMaybe<CurrentTokenRoyaltyV1BoolExp>;
};
type SubscriptionRootCurrentTokenRoyaltyV1ByPkArgs = {
    token_data_id: Scalars["String"]["input"];
};
type SubscriptionRootCurrentTokenRoyaltyV1StreamArgs = {
    batch_size: Scalars["Int"]["input"];
    cursor: Array<InputMaybe<CurrentTokenRoyaltyV1StreamCursorInput>>;
    where?: InputMaybe<CurrentTokenRoyaltyV1BoolExp>;
};
type SubscriptionRootCurrentTokenV2MetadataArgs = {
    distinct_on?: InputMaybe<Array<CurrentTokenV2MetadataSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentTokenV2MetadataOrderBy>>;
    where?: InputMaybe<CurrentTokenV2MetadataBoolExp>;
};
type SubscriptionRootCurrentTokenV2MetadataAggregateArgs = {
    distinct_on?: InputMaybe<Array<CurrentTokenV2MetadataSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentTokenV2MetadataOrderBy>>;
    where?: InputMaybe<CurrentTokenV2MetadataBoolExp>;
};
type SubscriptionRootCurrentTokenV2MetadataByPkArgs = {
    object_address: Scalars["String"]["input"];
    resource_type: Scalars["String"]["input"];
};
type SubscriptionRootCurrentTokenV2MetadataStreamArgs = {
    batch_size: Scalars["Int"]["input"];
    cursor: Array<InputMaybe<CurrentTokenV2MetadataStreamCursorInput>>;
    where?: InputMaybe<CurrentTokenV2MetadataBoolExp>;
};
type SubscriptionRootDelegatedStakingActivitiesArgs = {
    distinct_on?: InputMaybe<Array<DelegatedStakingActivitiesSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<DelegatedStakingActivitiesOrderBy>>;
    where?: InputMaybe<DelegatedStakingActivitiesBoolExp>;
};
type SubscriptionRootDelegatedStakingActivitiesAggregateArgs = {
    distinct_on?: InputMaybe<Array<DelegatedStakingActivitiesSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<DelegatedStakingActivitiesOrderBy>>;
    where?: InputMaybe<DelegatedStakingActivitiesBoolExp>;
};
type SubscriptionRootDelegatedStakingActivitiesByPkArgs = {
    event_index: Scalars["bigint"]["input"];
    transaction_version: Scalars["bigint"]["input"];
};
type SubscriptionRootDelegatedStakingActivitiesStreamArgs = {
    batch_size: Scalars["Int"]["input"];
    cursor: Array<InputMaybe<DelegatedStakingActivitiesStreamCursorInput>>;
    where?: InputMaybe<DelegatedStakingActivitiesBoolExp>;
};
type SubscriptionRootDelegatedStakingPoolBalancesArgs = {
    distinct_on?: InputMaybe<Array<DelegatedStakingPoolBalancesSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<DelegatedStakingPoolBalancesOrderBy>>;
    where?: InputMaybe<DelegatedStakingPoolBalancesBoolExp>;
};
type SubscriptionRootDelegatedStakingPoolBalancesAggregateArgs = {
    distinct_on?: InputMaybe<Array<DelegatedStakingPoolBalancesSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<DelegatedStakingPoolBalancesOrderBy>>;
    where?: InputMaybe<DelegatedStakingPoolBalancesBoolExp>;
};
type SubscriptionRootDelegatedStakingPoolBalancesByPkArgs = {
    staking_pool_address: Scalars["String"]["input"];
    transaction_version: Scalars["bigint"]["input"];
};
type SubscriptionRootDelegatedStakingPoolBalancesStreamArgs = {
    batch_size: Scalars["Int"]["input"];
    cursor: Array<InputMaybe<DelegatedStakingPoolBalancesStreamCursorInput>>;
    where?: InputMaybe<DelegatedStakingPoolBalancesBoolExp>;
};
type SubscriptionRootDelegatedStakingPoolsArgs = {
    distinct_on?: InputMaybe<Array<DelegatedStakingPoolsSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<DelegatedStakingPoolsOrderBy>>;
    where?: InputMaybe<DelegatedStakingPoolsBoolExp>;
};
type SubscriptionRootDelegatedStakingPoolsAggregateArgs = {
    distinct_on?: InputMaybe<Array<DelegatedStakingPoolsSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<DelegatedStakingPoolsOrderBy>>;
    where?: InputMaybe<DelegatedStakingPoolsBoolExp>;
};
type SubscriptionRootDelegatedStakingPoolsByPkArgs = {
    staking_pool_address: Scalars["String"]["input"];
};
type SubscriptionRootDelegatedStakingPoolsStreamArgs = {
    batch_size: Scalars["Int"]["input"];
    cursor: Array<InputMaybe<DelegatedStakingPoolsStreamCursorInput>>;
    where?: InputMaybe<DelegatedStakingPoolsBoolExp>;
};
type SubscriptionRootDelegatorBalancesArgs = {
    distinct_on?: InputMaybe<Array<DelegatorBalancesSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<DelegatorBalancesOrderBy>>;
    where?: InputMaybe<DelegatorBalancesBoolExp>;
};
type SubscriptionRootDelegatorBalancesAggregateArgs = {
    distinct_on?: InputMaybe<Array<DelegatorBalancesSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<DelegatorBalancesOrderBy>>;
    where?: InputMaybe<DelegatorBalancesBoolExp>;
};
type SubscriptionRootDelegatorBalancesByPkArgs = {
    transaction_version: Scalars["bigint"]["input"];
    write_set_change_index: Scalars["bigint"]["input"];
};
type SubscriptionRootDelegatorBalancesStreamArgs = {
    batch_size: Scalars["Int"]["input"];
    cursor: Array<InputMaybe<DelegatorBalancesStreamCursorInput>>;
    where?: InputMaybe<DelegatorBalancesBoolExp>;
};
type SubscriptionRootDelegatorDistinctPoolArgs = {
    distinct_on?: InputMaybe<Array<DelegatorDistinctPoolSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<DelegatorDistinctPoolOrderBy>>;
    where?: InputMaybe<DelegatorDistinctPoolBoolExp>;
};
type SubscriptionRootDelegatorDistinctPoolAggregateArgs = {
    distinct_on?: InputMaybe<Array<DelegatorDistinctPoolSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<DelegatorDistinctPoolOrderBy>>;
    where?: InputMaybe<DelegatorDistinctPoolBoolExp>;
};
type SubscriptionRootDelegatorDistinctPoolStreamArgs = {
    batch_size: Scalars["Int"]["input"];
    cursor: Array<InputMaybe<DelegatorDistinctPoolStreamCursorInput>>;
    where?: InputMaybe<DelegatorDistinctPoolBoolExp>;
};
type SubscriptionRootEventSizeInfoArgs = {
    distinct_on?: InputMaybe<Array<EventSizeInfoSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<EventSizeInfoOrderBy>>;
    where?: InputMaybe<EventSizeInfoBoolExp>;
};
type SubscriptionRootEventSizeInfoAggregateArgs = {
    distinct_on?: InputMaybe<Array<EventSizeInfoSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<EventSizeInfoOrderBy>>;
    where?: InputMaybe<EventSizeInfoBoolExp>;
};
type SubscriptionRootEventSizeInfoByPkArgs = {
    index: Scalars["bigint"]["input"];
    transaction_version: Scalars["bigint"]["input"];
};
type SubscriptionRootEventSizeInfoStreamArgs = {
    batch_size: Scalars["Int"]["input"];
    cursor: Array<InputMaybe<EventSizeInfoStreamCursorInput>>;
    where?: InputMaybe<EventSizeInfoBoolExp>;
};
type SubscriptionRootEventsArgs = {
    distinct_on?: InputMaybe<Array<EventsSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<EventsOrderBy>>;
    where?: InputMaybe<EventsBoolExp>;
};
type SubscriptionRootEventsAggregateArgs = {
    distinct_on?: InputMaybe<Array<EventsSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<EventsOrderBy>>;
    where?: InputMaybe<EventsBoolExp>;
};
type SubscriptionRootEventsByPkArgs = {
    event_index: Scalars["bigint"]["input"];
    transaction_version: Scalars["bigint"]["input"];
};
type SubscriptionRootEventsStreamArgs = {
    batch_size: Scalars["Int"]["input"];
    cursor: Array<InputMaybe<EventsStreamCursorInput>>;
    where?: InputMaybe<EventsBoolExp>;
};
type SubscriptionRootEventsViewArgs = {
    distinct_on?: InputMaybe<Array<EventsViewSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<EventsViewOrderBy>>;
    where?: InputMaybe<EventsViewBoolExp>;
};
type SubscriptionRootEventsViewAggregateArgs = {
    distinct_on?: InputMaybe<Array<EventsViewSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<EventsViewOrderBy>>;
    where?: InputMaybe<EventsViewBoolExp>;
};
type SubscriptionRootEventsViewStreamArgs = {
    batch_size: Scalars["Int"]["input"];
    cursor: Array<InputMaybe<EventsViewStreamCursorInput>>;
    where?: InputMaybe<EventsViewBoolExp>;
};
type SubscriptionRootFungibleAssetActivitiesArgs = {
    distinct_on?: InputMaybe<Array<FungibleAssetActivitiesSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<FungibleAssetActivitiesOrderBy>>;
    where?: InputMaybe<FungibleAssetActivitiesBoolExp>;
};
type SubscriptionRootFungibleAssetActivitiesAggregateArgs = {
    distinct_on?: InputMaybe<Array<FungibleAssetActivitiesSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<FungibleAssetActivitiesOrderBy>>;
    where?: InputMaybe<FungibleAssetActivitiesBoolExp>;
};
type SubscriptionRootFungibleAssetActivitiesByPkArgs = {
    event_index: Scalars["bigint"]["input"];
    transaction_version: Scalars["bigint"]["input"];
};
type SubscriptionRootFungibleAssetActivitiesStreamArgs = {
    batch_size: Scalars["Int"]["input"];
    cursor: Array<InputMaybe<FungibleAssetActivitiesStreamCursorInput>>;
    where?: InputMaybe<FungibleAssetActivitiesBoolExp>;
};
type SubscriptionRootFungibleAssetBalancesArgs = {
    distinct_on?: InputMaybe<Array<FungibleAssetBalancesSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<FungibleAssetBalancesOrderBy>>;
    where?: InputMaybe<FungibleAssetBalancesBoolExp>;
};
type SubscriptionRootFungibleAssetBalancesAggregateArgs = {
    distinct_on?: InputMaybe<Array<FungibleAssetBalancesSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<FungibleAssetBalancesOrderBy>>;
    where?: InputMaybe<FungibleAssetBalancesBoolExp>;
};
type SubscriptionRootFungibleAssetBalancesByPkArgs = {
    transaction_version: Scalars["bigint"]["input"];
    write_set_change_index: Scalars["bigint"]["input"];
};
type SubscriptionRootFungibleAssetBalancesStreamArgs = {
    batch_size: Scalars["Int"]["input"];
    cursor: Array<InputMaybe<FungibleAssetBalancesStreamCursorInput>>;
    where?: InputMaybe<FungibleAssetBalancesBoolExp>;
};
type SubscriptionRootFungibleAssetMetadataArgs = {
    distinct_on?: InputMaybe<Array<FungibleAssetMetadataSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<FungibleAssetMetadataOrderBy>>;
    where?: InputMaybe<FungibleAssetMetadataBoolExp>;
};
type SubscriptionRootFungibleAssetMetadataAggregateArgs = {
    distinct_on?: InputMaybe<Array<FungibleAssetMetadataSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<FungibleAssetMetadataOrderBy>>;
    where?: InputMaybe<FungibleAssetMetadataBoolExp>;
};
type SubscriptionRootFungibleAssetMetadataByPkArgs = {
    asset_type: Scalars["String"]["input"];
};
type SubscriptionRootFungibleAssetMetadataStreamArgs = {
    batch_size: Scalars["Int"]["input"];
    cursor: Array<InputMaybe<FungibleAssetMetadataStreamCursorInput>>;
    where?: InputMaybe<FungibleAssetMetadataBoolExp>;
};
type SubscriptionRootFungibleAssetToCoinMappingsArgs = {
    distinct_on?: InputMaybe<Array<FungibleAssetToCoinMappingsSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<FungibleAssetToCoinMappingsOrderBy>>;
    where?: InputMaybe<FungibleAssetToCoinMappingsBoolExp>;
};
type SubscriptionRootFungibleAssetToCoinMappingsAggregateArgs = {
    distinct_on?: InputMaybe<Array<FungibleAssetToCoinMappingsSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<FungibleAssetToCoinMappingsOrderBy>>;
    where?: InputMaybe<FungibleAssetToCoinMappingsBoolExp>;
};
type SubscriptionRootFungibleAssetToCoinMappingsByPkArgs = {
    fungible_asset_metadata_address: Scalars["String"]["input"];
};
type SubscriptionRootFungibleAssetToCoinMappingsStreamArgs = {
    batch_size: Scalars["Int"]["input"];
    cursor: Array<InputMaybe<FungibleAssetToCoinMappingsStreamCursorInput>>;
    where?: InputMaybe<FungibleAssetToCoinMappingsBoolExp>;
};
type SubscriptionRootGasFeesArgs = {
    distinct_on?: InputMaybe<Array<GasFeesSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<GasFeesOrderBy>>;
    where?: InputMaybe<GasFeesBoolExp>;
};
type SubscriptionRootGasFeesAggregateArgs = {
    distinct_on?: InputMaybe<Array<GasFeesSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<GasFeesOrderBy>>;
    where?: InputMaybe<GasFeesBoolExp>;
};
type SubscriptionRootGasFeesByPkArgs = {
    transaction_version: Scalars["bigint"]["input"];
};
type SubscriptionRootGasFeesStreamArgs = {
    batch_size: Scalars["Int"]["input"];
    cursor: Array<InputMaybe<GasFeesStreamCursorInput>>;
    where?: InputMaybe<GasFeesBoolExp>;
};
type SubscriptionRootIndexerStatusArgs = {
    distinct_on?: InputMaybe<Array<IndexerStatusSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<IndexerStatusOrderBy>>;
    where?: InputMaybe<IndexerStatusBoolExp>;
};
type SubscriptionRootIndexerStatusAggregateArgs = {
    distinct_on?: InputMaybe<Array<IndexerStatusSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<IndexerStatusOrderBy>>;
    where?: InputMaybe<IndexerStatusBoolExp>;
};
type SubscriptionRootIndexerStatusByPkArgs = {
    db: Scalars["String"]["input"];
};
type SubscriptionRootIndexerStatusStreamArgs = {
    batch_size: Scalars["Int"]["input"];
    cursor: Array<InputMaybe<IndexerStatusStreamCursorInput>>;
    where?: InputMaybe<IndexerStatusBoolExp>;
};
type SubscriptionRootMoveModulesArgs = {
    distinct_on?: InputMaybe<Array<MoveModulesSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<MoveModulesOrderBy>>;
    where?: InputMaybe<MoveModulesBoolExp>;
};
type SubscriptionRootMoveModulesAggregateArgs = {
    distinct_on?: InputMaybe<Array<MoveModulesSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<MoveModulesOrderBy>>;
    where?: InputMaybe<MoveModulesBoolExp>;
};
type SubscriptionRootMoveModulesByPkArgs = {
    transaction_version: Scalars["bigint"]["input"];
    write_set_change_index: Scalars["bigint"]["input"];
};
type SubscriptionRootMoveModulesStreamArgs = {
    batch_size: Scalars["Int"]["input"];
    cursor: Array<InputMaybe<MoveModulesStreamCursorInput>>;
    where?: InputMaybe<MoveModulesBoolExp>;
};
type SubscriptionRootMoveResourcesArgs = {
    distinct_on?: InputMaybe<Array<MoveResourcesSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<MoveResourcesOrderBy>>;
    where?: InputMaybe<MoveResourcesBoolExp>;
};
type SubscriptionRootMoveResourcesAggregateArgs = {
    distinct_on?: InputMaybe<Array<MoveResourcesSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<MoveResourcesOrderBy>>;
    where?: InputMaybe<MoveResourcesBoolExp>;
};
type SubscriptionRootMoveResourcesByPkArgs = {
    transaction_version: Scalars["bigint"]["input"];
    write_set_change_index: Scalars["bigint"]["input"];
};
type SubscriptionRootMoveResourcesStreamArgs = {
    batch_size: Scalars["Int"]["input"];
    cursor: Array<InputMaybe<MoveResourcesStreamCursorInput>>;
    where?: InputMaybe<MoveResourcesBoolExp>;
};
type SubscriptionRootMoveResourcesViewArgs = {
    distinct_on?: InputMaybe<Array<MoveResourcesViewSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<MoveResourcesViewOrderBy>>;
    where?: InputMaybe<MoveResourcesViewBoolExp>;
};
type SubscriptionRootMoveResourcesViewAggregateArgs = {
    distinct_on?: InputMaybe<Array<MoveResourcesViewSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<MoveResourcesViewOrderBy>>;
    where?: InputMaybe<MoveResourcesViewBoolExp>;
};
type SubscriptionRootMoveResourcesViewStreamArgs = {
    batch_size: Scalars["Int"]["input"];
    cursor: Array<InputMaybe<MoveResourcesViewStreamCursorInput>>;
    where?: InputMaybe<MoveResourcesViewBoolExp>;
};
type SubscriptionRootNftMetadataCrawlerParsedAssetUrisArgs = {
    distinct_on?: InputMaybe<Array<NftMetadataCrawlerParsedAssetUrisSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<NftMetadataCrawlerParsedAssetUrisOrderBy>>;
    where?: InputMaybe<NftMetadataCrawlerParsedAssetUrisBoolExp>;
};
type SubscriptionRootNftMetadataCrawlerParsedAssetUrisAggregateArgs = {
    distinct_on?: InputMaybe<Array<NftMetadataCrawlerParsedAssetUrisSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<NftMetadataCrawlerParsedAssetUrisOrderBy>>;
    where?: InputMaybe<NftMetadataCrawlerParsedAssetUrisBoolExp>;
};
type SubscriptionRootNftMetadataCrawlerParsedAssetUrisByPkArgs = {
    asset_uri: Scalars["String"]["input"];
};
type SubscriptionRootNftMetadataCrawlerParsedAssetUrisStreamArgs = {
    batch_size: Scalars["Int"]["input"];
    cursor: Array<InputMaybe<NftMetadataCrawlerParsedAssetUrisStreamCursorInput>>;
    where?: InputMaybe<NftMetadataCrawlerParsedAssetUrisBoolExp>;
};
type SubscriptionRootNftPointsArgs = {
    distinct_on?: InputMaybe<Array<NftPointsSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<NftPointsOrderBy>>;
    where?: InputMaybe<NftPointsBoolExp>;
};
type SubscriptionRootNftPointsAggregateArgs = {
    distinct_on?: InputMaybe<Array<NftPointsSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<NftPointsOrderBy>>;
    where?: InputMaybe<NftPointsBoolExp>;
};
type SubscriptionRootNftPointsByPkArgs = {
    transaction_version: Scalars["bigint"]["input"];
};
type SubscriptionRootNftPointsStreamArgs = {
    batch_size: Scalars["Int"]["input"];
    cursor: Array<InputMaybe<NftPointsStreamCursorInput>>;
    where?: InputMaybe<NftPointsBoolExp>;
};
type SubscriptionRootNumActiveDelegatorPerPoolArgs = {
    distinct_on?: InputMaybe<Array<NumActiveDelegatorPerPoolSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<NumActiveDelegatorPerPoolOrderBy>>;
    where?: InputMaybe<NumActiveDelegatorPerPoolBoolExp>;
};
type SubscriptionRootNumActiveDelegatorPerPoolAggregateArgs = {
    distinct_on?: InputMaybe<Array<NumActiveDelegatorPerPoolSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<NumActiveDelegatorPerPoolOrderBy>>;
    where?: InputMaybe<NumActiveDelegatorPerPoolBoolExp>;
};
type SubscriptionRootNumActiveDelegatorPerPoolStreamArgs = {
    batch_size: Scalars["Int"]["input"];
    cursor: Array<InputMaybe<NumActiveDelegatorPerPoolStreamCursorInput>>;
    where?: InputMaybe<NumActiveDelegatorPerPoolBoolExp>;
};
type SubscriptionRootObjectsArgs = {
    distinct_on?: InputMaybe<Array<ObjectsSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<ObjectsOrderBy>>;
    where?: InputMaybe<ObjectsBoolExp>;
};
type SubscriptionRootObjectsAggregateArgs = {
    distinct_on?: InputMaybe<Array<ObjectsSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<ObjectsOrderBy>>;
    where?: InputMaybe<ObjectsBoolExp>;
};
type SubscriptionRootObjectsByPkArgs = {
    transaction_version: Scalars["bigint"]["input"];
    write_set_change_index: Scalars["bigint"]["input"];
};
type SubscriptionRootObjectsStreamArgs = {
    batch_size: Scalars["Int"]["input"];
    cursor: Array<InputMaybe<ObjectsStreamCursorInput>>;
    where?: InputMaybe<ObjectsBoolExp>;
};
type SubscriptionRootProcessorMetadataProcessorStatusArgs = {
    distinct_on?: InputMaybe<Array<ProcessorMetadataProcessorStatusSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<ProcessorMetadataProcessorStatusOrderBy>>;
    where?: InputMaybe<ProcessorMetadataProcessorStatusBoolExp>;
};
type SubscriptionRootProcessorMetadataProcessorStatusAggregateArgs = {
    distinct_on?: InputMaybe<Array<ProcessorMetadataProcessorStatusSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<ProcessorMetadataProcessorStatusOrderBy>>;
    where?: InputMaybe<ProcessorMetadataProcessorStatusBoolExp>;
};
type SubscriptionRootProcessorMetadataProcessorStatusByPkArgs = {
    processor: Scalars["String"]["input"];
};
type SubscriptionRootProcessorMetadataProcessorStatusStreamArgs = {
    batch_size: Scalars["Int"]["input"];
    cursor: Array<InputMaybe<ProcessorMetadataProcessorStatusStreamCursorInput>>;
    where?: InputMaybe<ProcessorMetadataProcessorStatusBoolExp>;
};
type SubscriptionRootProcessorStatusArgs = {
    distinct_on?: InputMaybe<Array<ProcessorStatusSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<ProcessorStatusOrderBy>>;
    where?: InputMaybe<ProcessorStatusBoolExp>;
};
type SubscriptionRootProcessorStatusAggregateArgs = {
    distinct_on?: InputMaybe<Array<ProcessorStatusSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<ProcessorStatusOrderBy>>;
    where?: InputMaybe<ProcessorStatusBoolExp>;
};
type SubscriptionRootProcessorStatusByPkArgs = {
    processor: Scalars["String"]["input"];
};
type SubscriptionRootProcessorStatusStreamArgs = {
    batch_size: Scalars["Int"]["input"];
    cursor: Array<InputMaybe<ProcessorStatusStreamCursorInput>>;
    where?: InputMaybe<ProcessorStatusBoolExp>;
};
type SubscriptionRootProposalVotesArgs = {
    distinct_on?: InputMaybe<Array<ProposalVotesSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<ProposalVotesOrderBy>>;
    where?: InputMaybe<ProposalVotesBoolExp>;
};
type SubscriptionRootProposalVotesAggregateArgs = {
    distinct_on?: InputMaybe<Array<ProposalVotesSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<ProposalVotesOrderBy>>;
    where?: InputMaybe<ProposalVotesBoolExp>;
};
type SubscriptionRootProposalVotesByPkArgs = {
    proposal_id: Scalars["bigint"]["input"];
    transaction_version: Scalars["bigint"]["input"];
    voter_address: Scalars["String"]["input"];
};
type SubscriptionRootProposalVotesStreamArgs = {
    batch_size: Scalars["Int"]["input"];
    cursor: Array<InputMaybe<ProposalVotesStreamCursorInput>>;
    where?: InputMaybe<ProposalVotesBoolExp>;
};
type SubscriptionRootPublicKeyAuthKeysArgs = {
    distinct_on?: InputMaybe<Array<PublicKeyAuthKeysSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<PublicKeyAuthKeysOrderBy>>;
    where?: InputMaybe<PublicKeyAuthKeysBoolExp>;
};
type SubscriptionRootPublicKeyAuthKeysAggregateArgs = {
    distinct_on?: InputMaybe<Array<PublicKeyAuthKeysSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<PublicKeyAuthKeysOrderBy>>;
    where?: InputMaybe<PublicKeyAuthKeysBoolExp>;
};
type SubscriptionRootPublicKeyAuthKeysByPkArgs = {
    auth_key: Scalars["String"]["input"];
    public_key: Scalars["String"]["input"];
    public_key_type: Scalars["String"]["input"];
};
type SubscriptionRootPublicKeyAuthKeysStreamArgs = {
    batch_size: Scalars["Int"]["input"];
    cursor: Array<InputMaybe<PublicKeyAuthKeysStreamCursorInput>>;
    where?: InputMaybe<PublicKeyAuthKeysBoolExp>;
};
type SubscriptionRootSignaturesArgs = {
    distinct_on?: InputMaybe<Array<SignaturesSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<SignaturesOrderBy>>;
    where?: InputMaybe<SignaturesBoolExp>;
};
type SubscriptionRootSignaturesAggregateArgs = {
    distinct_on?: InputMaybe<Array<SignaturesSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<SignaturesOrderBy>>;
    where?: InputMaybe<SignaturesBoolExp>;
};
type SubscriptionRootSignaturesByPkArgs = {
    is_sender_primary: Scalars["Boolean"]["input"];
    multi_agent_index: Scalars["bigint"]["input"];
    multi_sig_index: Scalars["bigint"]["input"];
    transaction_version: Scalars["bigint"]["input"];
};
type SubscriptionRootSignaturesStreamArgs = {
    batch_size: Scalars["Int"]["input"];
    cursor: Array<InputMaybe<SignaturesStreamCursorInput>>;
    where?: InputMaybe<SignaturesBoolExp>;
};
type SubscriptionRootSpamAssetsArgs = {
    distinct_on?: InputMaybe<Array<SpamAssetsSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<SpamAssetsOrderBy>>;
    where?: InputMaybe<SpamAssetsBoolExp>;
};
type SubscriptionRootSpamAssetsAggregateArgs = {
    distinct_on?: InputMaybe<Array<SpamAssetsSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<SpamAssetsOrderBy>>;
    where?: InputMaybe<SpamAssetsBoolExp>;
};
type SubscriptionRootSpamAssetsByPkArgs = {
    asset: Scalars["String"]["input"];
};
type SubscriptionRootSpamAssetsStreamArgs = {
    batch_size: Scalars["Int"]["input"];
    cursor: Array<InputMaybe<SpamAssetsStreamCursorInput>>;
    where?: InputMaybe<SpamAssetsBoolExp>;
};
type SubscriptionRootTableItemsArgs = {
    distinct_on?: InputMaybe<Array<TableItemsSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<TableItemsOrderBy>>;
    where?: InputMaybe<TableItemsBoolExp>;
};
type SubscriptionRootTableItemsAggregateArgs = {
    distinct_on?: InputMaybe<Array<TableItemsSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<TableItemsOrderBy>>;
    where?: InputMaybe<TableItemsBoolExp>;
};
type SubscriptionRootTableItemsByPkArgs = {
    transaction_version: Scalars["bigint"]["input"];
    write_set_change_index: Scalars["bigint"]["input"];
};
type SubscriptionRootTableItemsStreamArgs = {
    batch_size: Scalars["Int"]["input"];
    cursor: Array<InputMaybe<TableItemsStreamCursorInput>>;
    where?: InputMaybe<TableItemsBoolExp>;
};
type SubscriptionRootTableItemsViewArgs = {
    distinct_on?: InputMaybe<Array<TableItemsViewSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<TableItemsViewOrderBy>>;
    where?: InputMaybe<TableItemsViewBoolExp>;
};
type SubscriptionRootTableItemsViewAggregateArgs = {
    distinct_on?: InputMaybe<Array<TableItemsViewSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<TableItemsViewOrderBy>>;
    where?: InputMaybe<TableItemsViewBoolExp>;
};
type SubscriptionRootTableItemsViewStreamArgs = {
    batch_size: Scalars["Int"]["input"];
    cursor: Array<InputMaybe<TableItemsViewStreamCursorInput>>;
    where?: InputMaybe<TableItemsViewBoolExp>;
};
type SubscriptionRootTableMetadatasArgs = {
    distinct_on?: InputMaybe<Array<TableMetadatasSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<TableMetadatasOrderBy>>;
    where?: InputMaybe<TableMetadatasBoolExp>;
};
type SubscriptionRootTableMetadatasAggregateArgs = {
    distinct_on?: InputMaybe<Array<TableMetadatasSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<TableMetadatasOrderBy>>;
    where?: InputMaybe<TableMetadatasBoolExp>;
};
type SubscriptionRootTableMetadatasByPkArgs = {
    handle: Scalars["String"]["input"];
};
type SubscriptionRootTableMetadatasStreamArgs = {
    batch_size: Scalars["Int"]["input"];
    cursor: Array<InputMaybe<TableMetadatasStreamCursorInput>>;
    where?: InputMaybe<TableMetadatasBoolExp>;
};
type SubscriptionRootTokenActivitiesArgs = {
    distinct_on?: InputMaybe<Array<TokenActivitiesSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<TokenActivitiesOrderBy>>;
    where?: InputMaybe<TokenActivitiesBoolExp>;
};
type SubscriptionRootTokenActivitiesAggregateArgs = {
    distinct_on?: InputMaybe<Array<TokenActivitiesSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<TokenActivitiesOrderBy>>;
    where?: InputMaybe<TokenActivitiesBoolExp>;
};
type SubscriptionRootTokenActivitiesByPkArgs = {
    event_account_address: Scalars["String"]["input"];
    event_creation_number: Scalars["bigint"]["input"];
    event_sequence_number: Scalars["bigint"]["input"];
    transaction_version: Scalars["bigint"]["input"];
};
type SubscriptionRootTokenActivitiesStreamArgs = {
    batch_size: Scalars["Int"]["input"];
    cursor: Array<InputMaybe<TokenActivitiesStreamCursorInput>>;
    where?: InputMaybe<TokenActivitiesBoolExp>;
};
type SubscriptionRootTokenActivitiesV2Args = {
    distinct_on?: InputMaybe<Array<TokenActivitiesV2SelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<TokenActivitiesV2OrderBy>>;
    where?: InputMaybe<TokenActivitiesV2BoolExp>;
};
type SubscriptionRootTokenActivitiesV2AggregateArgs = {
    distinct_on?: InputMaybe<Array<TokenActivitiesV2SelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<TokenActivitiesV2OrderBy>>;
    where?: InputMaybe<TokenActivitiesV2BoolExp>;
};
type SubscriptionRootTokenActivitiesV2ByPkArgs = {
    event_index: Scalars["bigint"]["input"];
    transaction_version: Scalars["bigint"]["input"];
};
type SubscriptionRootTokenActivitiesV2StreamArgs = {
    batch_size: Scalars["Int"]["input"];
    cursor: Array<InputMaybe<TokenActivitiesV2StreamCursorInput>>;
    where?: InputMaybe<TokenActivitiesV2BoolExp>;
};
type SubscriptionRootTokenDatasArgs = {
    distinct_on?: InputMaybe<Array<TokenDatasSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<TokenDatasOrderBy>>;
    where?: InputMaybe<TokenDatasBoolExp>;
};
type SubscriptionRootTokenDatasAggregateArgs = {
    distinct_on?: InputMaybe<Array<TokenDatasSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<TokenDatasOrderBy>>;
    where?: InputMaybe<TokenDatasBoolExp>;
};
type SubscriptionRootTokenDatasByPkArgs = {
    token_data_id_hash: Scalars["String"]["input"];
    transaction_version: Scalars["bigint"]["input"];
};
type SubscriptionRootTokenDatasStreamArgs = {
    batch_size: Scalars["Int"]["input"];
    cursor: Array<InputMaybe<TokenDatasStreamCursorInput>>;
    where?: InputMaybe<TokenDatasBoolExp>;
};
type SubscriptionRootTokenDatasV2Args = {
    distinct_on?: InputMaybe<Array<TokenDatasV2SelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<TokenDatasV2OrderBy>>;
    where?: InputMaybe<TokenDatasV2BoolExp>;
};
type SubscriptionRootTokenDatasV2AggregateArgs = {
    distinct_on?: InputMaybe<Array<TokenDatasV2SelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<TokenDatasV2OrderBy>>;
    where?: InputMaybe<TokenDatasV2BoolExp>;
};
type SubscriptionRootTokenDatasV2ByPkArgs = {
    transaction_version: Scalars["bigint"]["input"];
    write_set_change_index: Scalars["bigint"]["input"];
};
type SubscriptionRootTokenDatasV2StreamArgs = {
    batch_size: Scalars["Int"]["input"];
    cursor: Array<InputMaybe<TokenDatasV2StreamCursorInput>>;
    where?: InputMaybe<TokenDatasV2BoolExp>;
};
type SubscriptionRootTokenOwnershipsArgs = {
    distinct_on?: InputMaybe<Array<TokenOwnershipsSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<TokenOwnershipsOrderBy>>;
    where?: InputMaybe<TokenOwnershipsBoolExp>;
};
type SubscriptionRootTokenOwnershipsAggregateArgs = {
    distinct_on?: InputMaybe<Array<TokenOwnershipsSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<TokenOwnershipsOrderBy>>;
    where?: InputMaybe<TokenOwnershipsBoolExp>;
};
type SubscriptionRootTokenOwnershipsByPkArgs = {
    property_version: Scalars["numeric"]["input"];
    table_handle: Scalars["String"]["input"];
    token_data_id_hash: Scalars["String"]["input"];
    transaction_version: Scalars["bigint"]["input"];
};
type SubscriptionRootTokenOwnershipsStreamArgs = {
    batch_size: Scalars["Int"]["input"];
    cursor: Array<InputMaybe<TokenOwnershipsStreamCursorInput>>;
    where?: InputMaybe<TokenOwnershipsBoolExp>;
};
type SubscriptionRootTokenOwnershipsV2Args = {
    distinct_on?: InputMaybe<Array<TokenOwnershipsV2SelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<TokenOwnershipsV2OrderBy>>;
    where?: InputMaybe<TokenOwnershipsV2BoolExp>;
};
type SubscriptionRootTokenOwnershipsV2AggregateArgs = {
    distinct_on?: InputMaybe<Array<TokenOwnershipsV2SelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<TokenOwnershipsV2OrderBy>>;
    where?: InputMaybe<TokenOwnershipsV2BoolExp>;
};
type SubscriptionRootTokenOwnershipsV2ByPkArgs = {
    transaction_version: Scalars["bigint"]["input"];
    write_set_change_index: Scalars["bigint"]["input"];
};
type SubscriptionRootTokenOwnershipsV2StreamArgs = {
    batch_size: Scalars["Int"]["input"];
    cursor: Array<InputMaybe<TokenOwnershipsV2StreamCursorInput>>;
    where?: InputMaybe<TokenOwnershipsV2BoolExp>;
};
type SubscriptionRootTokensArgs = {
    distinct_on?: InputMaybe<Array<TokensSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<TokensOrderBy>>;
    where?: InputMaybe<TokensBoolExp>;
};
type SubscriptionRootTokensAggregateArgs = {
    distinct_on?: InputMaybe<Array<TokensSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<TokensOrderBy>>;
    where?: InputMaybe<TokensBoolExp>;
};
type SubscriptionRootTokensByPkArgs = {
    property_version: Scalars["numeric"]["input"];
    token_data_id_hash: Scalars["String"]["input"];
    transaction_version: Scalars["bigint"]["input"];
};
type SubscriptionRootTokensStreamArgs = {
    batch_size: Scalars["Int"]["input"];
    cursor: Array<InputMaybe<TokensStreamCursorInput>>;
    where?: InputMaybe<TokensBoolExp>;
};
type SubscriptionRootTransactionSizeInfoArgs = {
    distinct_on?: InputMaybe<Array<TransactionSizeInfoSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<TransactionSizeInfoOrderBy>>;
    where?: InputMaybe<TransactionSizeInfoBoolExp>;
};
type SubscriptionRootTransactionSizeInfoAggregateArgs = {
    distinct_on?: InputMaybe<Array<TransactionSizeInfoSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<TransactionSizeInfoOrderBy>>;
    where?: InputMaybe<TransactionSizeInfoBoolExp>;
};
type SubscriptionRootTransactionSizeInfoByPkArgs = {
    transaction_version: Scalars["bigint"]["input"];
};
type SubscriptionRootTransactionSizeInfoStreamArgs = {
    batch_size: Scalars["Int"]["input"];
    cursor: Array<InputMaybe<TransactionSizeInfoStreamCursorInput>>;
    where?: InputMaybe<TransactionSizeInfoBoolExp>;
};
type SubscriptionRootTransactionsViewArgs = {
    distinct_on?: InputMaybe<Array<TransactionsViewSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<TransactionsViewOrderBy>>;
    where?: InputMaybe<TransactionsViewBoolExp>;
};
type SubscriptionRootTransactionsViewAggregateArgs = {
    distinct_on?: InputMaybe<Array<TransactionsViewSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<TransactionsViewOrderBy>>;
    where?: InputMaybe<TransactionsViewBoolExp>;
};
type SubscriptionRootTransactionsViewStreamArgs = {
    batch_size: Scalars["Int"]["input"];
    cursor: Array<InputMaybe<TransactionsViewStreamCursorInput>>;
    where?: InputMaybe<TransactionsViewBoolExp>;
};
type SubscriptionRootUserTransactionsArgs = {
    distinct_on?: InputMaybe<Array<UserTransactionsSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<UserTransactionsOrderBy>>;
    where?: InputMaybe<UserTransactionsBoolExp>;
};
type SubscriptionRootUserTransactionsAggregateArgs = {
    distinct_on?: InputMaybe<Array<UserTransactionsSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<UserTransactionsOrderBy>>;
    where?: InputMaybe<UserTransactionsBoolExp>;
};
type SubscriptionRootUserTransactionsByPkArgs = {
    version: Scalars["bigint"]["input"];
};
type SubscriptionRootUserTransactionsStreamArgs = {
    batch_size: Scalars["Int"]["input"];
    cursor: Array<InputMaybe<UserTransactionsStreamCursorInput>>;
    where?: InputMaybe<UserTransactionsBoolExp>;
};
/** columns and relationships of "table_items" */
type TableItems = {
    decoded_key: Scalars["jsonb"]["output"];
    decoded_value?: Maybe<Scalars["jsonb"]["output"]>;
    inserted_at: Scalars["timestamp"]["output"];
    is_deleted: Scalars["Boolean"]["output"];
    key: Scalars["String"]["output"];
    table_handle: Scalars["String"]["output"];
    transaction_block_height: Scalars["bigint"]["output"];
    transaction_version: Scalars["bigint"]["output"];
    write_set_change_index: Scalars["bigint"]["output"];
};
/** columns and relationships of "table_items" */
type TableItemsDecodedKeyArgs = {
    path?: InputMaybe<Scalars["String"]["input"]>;
};
/** columns and relationships of "table_items" */
type TableItemsDecodedValueArgs = {
    path?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregated selection of "table_items" */
type TableItemsAggregate = {
    aggregate?: Maybe<TableItemsAggregateFields>;
    nodes: Array<TableItems>;
};
/** aggregate fields of "table_items" */
type TableItemsAggregateFields = {
    avg?: Maybe<TableItemsAvgFields>;
    count: Scalars["Int"]["output"];
    max?: Maybe<TableItemsMaxFields>;
    min?: Maybe<TableItemsMinFields>;
    stddev?: Maybe<TableItemsStddevFields>;
    stddev_pop?: Maybe<TableItemsStddevPopFields>;
    stddev_samp?: Maybe<TableItemsStddevSampFields>;
    sum?: Maybe<TableItemsSumFields>;
    var_pop?: Maybe<TableItemsVarPopFields>;
    var_samp?: Maybe<TableItemsVarSampFields>;
    variance?: Maybe<TableItemsVarianceFields>;
};
/** aggregate fields of "table_items" */
type TableItemsAggregateFieldsCountArgs = {
    columns?: InputMaybe<Array<TableItemsSelectColumn>>;
    distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};
/** append existing jsonb value of filtered columns with new jsonb value */
type TableItemsAppendInput = {
    decoded_key?: InputMaybe<Scalars["jsonb"]["input"]>;
    decoded_value?: InputMaybe<Scalars["jsonb"]["input"]>;
};
/** aggregate avg on columns */
type TableItemsAvgFields = {
    transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};
/** Boolean expression to filter rows from the table "table_items". All fields are combined with a logical 'AND'. */
type TableItemsBoolExp = {
    _and?: InputMaybe<Array<TableItemsBoolExp>>;
    _not?: InputMaybe<TableItemsBoolExp>;
    _or?: InputMaybe<Array<TableItemsBoolExp>>;
    decoded_key?: InputMaybe<JsonbComparisonExp>;
    decoded_value?: InputMaybe<JsonbComparisonExp>;
    inserted_at?: InputMaybe<TimestampComparisonExp>;
    is_deleted?: InputMaybe<BooleanComparisonExp>;
    key?: InputMaybe<StringComparisonExp>;
    table_handle?: InputMaybe<StringComparisonExp>;
    transaction_block_height?: InputMaybe<BigintComparisonExp>;
    transaction_version?: InputMaybe<BigintComparisonExp>;
    write_set_change_index?: InputMaybe<BigintComparisonExp>;
};
/** unique or primary key constraints on table "table_items" */
declare enum TableItemsConstraint {
    /** unique or primary key constraint on columns "write_set_change_index", "transaction_version" */
    TableItemsPkey = "table_items_pkey"
}
/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
type TableItemsDeleteAtPathInput = {
    decoded_key?: InputMaybe<Array<Scalars["String"]["input"]>>;
    decoded_value?: InputMaybe<Array<Scalars["String"]["input"]>>;
};
/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
type TableItemsDeleteElemInput = {
    decoded_key?: InputMaybe<Scalars["Int"]["input"]>;
    decoded_value?: InputMaybe<Scalars["Int"]["input"]>;
};
/** delete key/value pair or string element. key/value pairs are matched based on their key value */
type TableItemsDeleteKeyInput = {
    decoded_key?: InputMaybe<Scalars["String"]["input"]>;
    decoded_value?: InputMaybe<Scalars["String"]["input"]>;
};
/** input type for incrementing numeric columns in table "table_items" */
type TableItemsIncInput = {
    transaction_block_height?: InputMaybe<Scalars["bigint"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** input type for inserting data into table "table_items" */
type TableItemsInsertInput = {
    decoded_key?: InputMaybe<Scalars["jsonb"]["input"]>;
    decoded_value?: InputMaybe<Scalars["jsonb"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    is_deleted?: InputMaybe<Scalars["Boolean"]["input"]>;
    key?: InputMaybe<Scalars["String"]["input"]>;
    table_handle?: InputMaybe<Scalars["String"]["input"]>;
    transaction_block_height?: InputMaybe<Scalars["bigint"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** aggregate max on columns */
type TableItemsMaxFields = {
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    key?: Maybe<Scalars["String"]["output"]>;
    table_handle?: Maybe<Scalars["String"]["output"]>;
    transaction_block_height?: Maybe<Scalars["bigint"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    write_set_change_index?: Maybe<Scalars["bigint"]["output"]>;
};
/** aggregate min on columns */
type TableItemsMinFields = {
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    key?: Maybe<Scalars["String"]["output"]>;
    table_handle?: Maybe<Scalars["String"]["output"]>;
    transaction_block_height?: Maybe<Scalars["bigint"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    write_set_change_index?: Maybe<Scalars["bigint"]["output"]>;
};
/** response of any mutation on the table "table_items" */
type TableItemsMutationResponse = {
    /** number of rows affected by the mutation */
    affected_rows: Scalars["Int"]["output"];
    /** data from the rows affected by the mutation */
    returning: Array<TableItems>;
};
/** on_conflict condition type for table "table_items" */
type TableItemsOnConflict = {
    constraint: TableItemsConstraint;
    update_columns?: Array<TableItemsUpdateColumn>;
    where?: InputMaybe<TableItemsBoolExp>;
};
/** Ordering options when selecting data from "table_items". */
type TableItemsOrderBy = {
    decoded_key?: InputMaybe<OrderBy>;
    decoded_value?: InputMaybe<OrderBy>;
    inserted_at?: InputMaybe<OrderBy>;
    is_deleted?: InputMaybe<OrderBy>;
    key?: InputMaybe<OrderBy>;
    table_handle?: InputMaybe<OrderBy>;
    transaction_block_height?: InputMaybe<OrderBy>;
    transaction_version?: InputMaybe<OrderBy>;
    write_set_change_index?: InputMaybe<OrderBy>;
};
/** primary key columns input for table: table_items */
type TableItemsPkColumnsInput = {
    transaction_version: Scalars["bigint"]["input"];
    write_set_change_index: Scalars["bigint"]["input"];
};
/** prepend existing jsonb value of filtered columns with new jsonb value */
type TableItemsPrependInput = {
    decoded_key?: InputMaybe<Scalars["jsonb"]["input"]>;
    decoded_value?: InputMaybe<Scalars["jsonb"]["input"]>;
};
/** select columns of table "table_items" */
declare enum TableItemsSelectColumn {
    /** column name */
    DecodedKey = "decoded_key",
    /** column name */
    DecodedValue = "decoded_value",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    IsDeleted = "is_deleted",
    /** column name */
    Key = "key",
    /** column name */
    TableHandle = "table_handle",
    /** column name */
    TransactionBlockHeight = "transaction_block_height",
    /** column name */
    TransactionVersion = "transaction_version",
    /** column name */
    WriteSetChangeIndex = "write_set_change_index"
}
/** input type for updating data in table "table_items" */
type TableItemsSetInput = {
    decoded_key?: InputMaybe<Scalars["jsonb"]["input"]>;
    decoded_value?: InputMaybe<Scalars["jsonb"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    is_deleted?: InputMaybe<Scalars["Boolean"]["input"]>;
    key?: InputMaybe<Scalars["String"]["input"]>;
    table_handle?: InputMaybe<Scalars["String"]["input"]>;
    transaction_block_height?: InputMaybe<Scalars["bigint"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** aggregate stddev on columns */
type TableItemsStddevFields = {
    transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_pop on columns */
type TableItemsStddevPopFields = {
    transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_samp on columns */
type TableItemsStddevSampFields = {
    transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};
/** Streaming cursor of the table "table_items" */
type TableItemsStreamCursorInput = {
    /** Stream column input with initial value */
    initial_value: TableItemsStreamCursorValueInput;
    /** cursor ordering */
    ordering?: InputMaybe<CursorOrdering>;
};
/** Initial value of the column from where the streaming should start */
type TableItemsStreamCursorValueInput = {
    decoded_key?: InputMaybe<Scalars["jsonb"]["input"]>;
    decoded_value?: InputMaybe<Scalars["jsonb"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    is_deleted?: InputMaybe<Scalars["Boolean"]["input"]>;
    key?: InputMaybe<Scalars["String"]["input"]>;
    table_handle?: InputMaybe<Scalars["String"]["input"]>;
    transaction_block_height?: InputMaybe<Scalars["bigint"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** aggregate sum on columns */
type TableItemsSumFields = {
    transaction_block_height?: Maybe<Scalars["bigint"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    write_set_change_index?: Maybe<Scalars["bigint"]["output"]>;
};
/** update columns of table "table_items" */
declare enum TableItemsUpdateColumn {
    /** column name */
    DecodedKey = "decoded_key",
    /** column name */
    DecodedValue = "decoded_value",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    IsDeleted = "is_deleted",
    /** column name */
    Key = "key",
    /** column name */
    TableHandle = "table_handle",
    /** column name */
    TransactionBlockHeight = "transaction_block_height",
    /** column name */
    TransactionVersion = "transaction_version",
    /** column name */
    WriteSetChangeIndex = "write_set_change_index"
}
type TableItemsUpdates = {
    /** append existing jsonb value of filtered columns with new jsonb value */
    _append?: InputMaybe<TableItemsAppendInput>;
    /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
    _delete_at_path?: InputMaybe<TableItemsDeleteAtPathInput>;
    /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
    _delete_elem?: InputMaybe<TableItemsDeleteElemInput>;
    /** delete key/value pair or string element. key/value pairs are matched based on their key value */
    _delete_key?: InputMaybe<TableItemsDeleteKeyInput>;
    /** increments the numeric columns with given value of the filtered values */
    _inc?: InputMaybe<TableItemsIncInput>;
    /** prepend existing jsonb value of filtered columns with new jsonb value */
    _prepend?: InputMaybe<TableItemsPrependInput>;
    /** sets the columns of the filtered rows to the given values */
    _set?: InputMaybe<TableItemsSetInput>;
    /** filter the rows which have to be updated */
    where: TableItemsBoolExp;
};
/** aggregate var_pop on columns */
type TableItemsVarPopFields = {
    transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate var_samp on columns */
type TableItemsVarSampFields = {
    transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate variance on columns */
type TableItemsVarianceFields = {
    transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};
/** columns and relationships of "table_items_view" */
type TableItemsView = {
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    is_deleted?: Maybe<Scalars["Boolean"]["output"]>;
    json_decoded_key?: Maybe<Scalars["String"]["output"]>;
    json_decoded_value?: Maybe<Scalars["String"]["output"]>;
    key?: Maybe<Scalars["String"]["output"]>;
    table_handle?: Maybe<Scalars["String"]["output"]>;
    transaction_block_height?: Maybe<Scalars["bigint"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    write_set_change_index?: Maybe<Scalars["bigint"]["output"]>;
};
/** aggregated selection of "table_items_view" */
type TableItemsViewAggregate = {
    aggregate?: Maybe<TableItemsViewAggregateFields>;
    nodes: Array<TableItemsView>;
};
/** aggregate fields of "table_items_view" */
type TableItemsViewAggregateFields = {
    avg?: Maybe<TableItemsViewAvgFields>;
    count: Scalars["Int"]["output"];
    max?: Maybe<TableItemsViewMaxFields>;
    min?: Maybe<TableItemsViewMinFields>;
    stddev?: Maybe<TableItemsViewStddevFields>;
    stddev_pop?: Maybe<TableItemsViewStddevPopFields>;
    stddev_samp?: Maybe<TableItemsViewStddevSampFields>;
    sum?: Maybe<TableItemsViewSumFields>;
    var_pop?: Maybe<TableItemsViewVarPopFields>;
    var_samp?: Maybe<TableItemsViewVarSampFields>;
    variance?: Maybe<TableItemsViewVarianceFields>;
};
/** aggregate fields of "table_items_view" */
type TableItemsViewAggregateFieldsCountArgs = {
    columns?: InputMaybe<Array<TableItemsViewSelectColumn>>;
    distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};
/** aggregate avg on columns */
type TableItemsViewAvgFields = {
    transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};
/** Boolean expression to filter rows from the table "table_items_view". All fields are combined with a logical 'AND'. */
type TableItemsViewBoolExp = {
    _and?: InputMaybe<Array<TableItemsViewBoolExp>>;
    _not?: InputMaybe<TableItemsViewBoolExp>;
    _or?: InputMaybe<Array<TableItemsViewBoolExp>>;
    inserted_at?: InputMaybe<TimestampComparisonExp>;
    is_deleted?: InputMaybe<BooleanComparisonExp>;
    json_decoded_key?: InputMaybe<StringComparisonExp>;
    json_decoded_value?: InputMaybe<StringComparisonExp>;
    key?: InputMaybe<StringComparisonExp>;
    table_handle?: InputMaybe<StringComparisonExp>;
    transaction_block_height?: InputMaybe<BigintComparisonExp>;
    transaction_version?: InputMaybe<BigintComparisonExp>;
    write_set_change_index?: InputMaybe<BigintComparisonExp>;
};
/** input type for incrementing numeric columns in table "table_items_view" */
type TableItemsViewIncInput = {
    transaction_block_height?: InputMaybe<Scalars["bigint"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** input type for inserting data into table "table_items_view" */
type TableItemsViewInsertInput = {
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    is_deleted?: InputMaybe<Scalars["Boolean"]["input"]>;
    json_decoded_key?: InputMaybe<Scalars["String"]["input"]>;
    json_decoded_value?: InputMaybe<Scalars["String"]["input"]>;
    key?: InputMaybe<Scalars["String"]["input"]>;
    table_handle?: InputMaybe<Scalars["String"]["input"]>;
    transaction_block_height?: InputMaybe<Scalars["bigint"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** aggregate max on columns */
type TableItemsViewMaxFields = {
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    json_decoded_key?: Maybe<Scalars["String"]["output"]>;
    json_decoded_value?: Maybe<Scalars["String"]["output"]>;
    key?: Maybe<Scalars["String"]["output"]>;
    table_handle?: Maybe<Scalars["String"]["output"]>;
    transaction_block_height?: Maybe<Scalars["bigint"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    write_set_change_index?: Maybe<Scalars["bigint"]["output"]>;
};
/** aggregate min on columns */
type TableItemsViewMinFields = {
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    json_decoded_key?: Maybe<Scalars["String"]["output"]>;
    json_decoded_value?: Maybe<Scalars["String"]["output"]>;
    key?: Maybe<Scalars["String"]["output"]>;
    table_handle?: Maybe<Scalars["String"]["output"]>;
    transaction_block_height?: Maybe<Scalars["bigint"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    write_set_change_index?: Maybe<Scalars["bigint"]["output"]>;
};
/** response of any mutation on the table "table_items_view" */
type TableItemsViewMutationResponse = {
    /** number of rows affected by the mutation */
    affected_rows: Scalars["Int"]["output"];
    /** data from the rows affected by the mutation */
    returning: Array<TableItemsView>;
};
/** Ordering options when selecting data from "table_items_view". */
type TableItemsViewOrderBy = {
    inserted_at?: InputMaybe<OrderBy>;
    is_deleted?: InputMaybe<OrderBy>;
    json_decoded_key?: InputMaybe<OrderBy>;
    json_decoded_value?: InputMaybe<OrderBy>;
    key?: InputMaybe<OrderBy>;
    table_handle?: InputMaybe<OrderBy>;
    transaction_block_height?: InputMaybe<OrderBy>;
    transaction_version?: InputMaybe<OrderBy>;
    write_set_change_index?: InputMaybe<OrderBy>;
};
/** select columns of table "table_items_view" */
declare enum TableItemsViewSelectColumn {
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    IsDeleted = "is_deleted",
    /** column name */
    JsonDecodedKey = "json_decoded_key",
    /** column name */
    JsonDecodedValue = "json_decoded_value",
    /** column name */
    Key = "key",
    /** column name */
    TableHandle = "table_handle",
    /** column name */
    TransactionBlockHeight = "transaction_block_height",
    /** column name */
    TransactionVersion = "transaction_version",
    /** column name */
    WriteSetChangeIndex = "write_set_change_index"
}
/** input type for updating data in table "table_items_view" */
type TableItemsViewSetInput = {
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    is_deleted?: InputMaybe<Scalars["Boolean"]["input"]>;
    json_decoded_key?: InputMaybe<Scalars["String"]["input"]>;
    json_decoded_value?: InputMaybe<Scalars["String"]["input"]>;
    key?: InputMaybe<Scalars["String"]["input"]>;
    table_handle?: InputMaybe<Scalars["String"]["input"]>;
    transaction_block_height?: InputMaybe<Scalars["bigint"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** aggregate stddev on columns */
type TableItemsViewStddevFields = {
    transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_pop on columns */
type TableItemsViewStddevPopFields = {
    transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_samp on columns */
type TableItemsViewStddevSampFields = {
    transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};
/** Streaming cursor of the table "table_items_view" */
type TableItemsViewStreamCursorInput = {
    /** Stream column input with initial value */
    initial_value: TableItemsViewStreamCursorValueInput;
    /** cursor ordering */
    ordering?: InputMaybe<CursorOrdering>;
};
/** Initial value of the column from where the streaming should start */
type TableItemsViewStreamCursorValueInput = {
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    is_deleted?: InputMaybe<Scalars["Boolean"]["input"]>;
    json_decoded_key?: InputMaybe<Scalars["String"]["input"]>;
    json_decoded_value?: InputMaybe<Scalars["String"]["input"]>;
    key?: InputMaybe<Scalars["String"]["input"]>;
    table_handle?: InputMaybe<Scalars["String"]["input"]>;
    transaction_block_height?: InputMaybe<Scalars["bigint"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** aggregate sum on columns */
type TableItemsViewSumFields = {
    transaction_block_height?: Maybe<Scalars["bigint"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    write_set_change_index?: Maybe<Scalars["bigint"]["output"]>;
};
type TableItemsViewUpdates = {
    /** increments the numeric columns with given value of the filtered values */
    _inc?: InputMaybe<TableItemsViewIncInput>;
    /** sets the columns of the filtered rows to the given values */
    _set?: InputMaybe<TableItemsViewSetInput>;
    /** filter the rows which have to be updated */
    where: TableItemsViewBoolExp;
};
/** aggregate var_pop on columns */
type TableItemsViewVarPopFields = {
    transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate var_samp on columns */
type TableItemsViewVarSampFields = {
    transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate variance on columns */
type TableItemsViewVarianceFields = {
    transaction_block_height?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};
/** columns and relationships of "table_metadatas" */
type TableMetadatas = {
    handle: Scalars["String"]["output"];
    inserted_at: Scalars["timestamp"]["output"];
    key_type: Scalars["String"]["output"];
    value_type: Scalars["String"]["output"];
};
/** aggregated selection of "table_metadatas" */
type TableMetadatasAggregate = {
    aggregate?: Maybe<TableMetadatasAggregateFields>;
    nodes: Array<TableMetadatas>;
};
/** aggregate fields of "table_metadatas" */
type TableMetadatasAggregateFields = {
    count: Scalars["Int"]["output"];
    max?: Maybe<TableMetadatasMaxFields>;
    min?: Maybe<TableMetadatasMinFields>;
};
/** aggregate fields of "table_metadatas" */
type TableMetadatasAggregateFieldsCountArgs = {
    columns?: InputMaybe<Array<TableMetadatasSelectColumn>>;
    distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};
/** Boolean expression to filter rows from the table "table_metadatas". All fields are combined with a logical 'AND'. */
type TableMetadatasBoolExp = {
    _and?: InputMaybe<Array<TableMetadatasBoolExp>>;
    _not?: InputMaybe<TableMetadatasBoolExp>;
    _or?: InputMaybe<Array<TableMetadatasBoolExp>>;
    handle?: InputMaybe<StringComparisonExp>;
    inserted_at?: InputMaybe<TimestampComparisonExp>;
    key_type?: InputMaybe<StringComparisonExp>;
    value_type?: InputMaybe<StringComparisonExp>;
};
/** unique or primary key constraints on table "table_metadatas" */
declare enum TableMetadatasConstraint {
    /** unique or primary key constraint on columns "handle" */
    TableMetadatasPkey = "table_metadatas_pkey"
}
/** input type for inserting data into table "table_metadatas" */
type TableMetadatasInsertInput = {
    handle?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    key_type?: InputMaybe<Scalars["String"]["input"]>;
    value_type?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregate max on columns */
type TableMetadatasMaxFields = {
    handle?: Maybe<Scalars["String"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    key_type?: Maybe<Scalars["String"]["output"]>;
    value_type?: Maybe<Scalars["String"]["output"]>;
};
/** aggregate min on columns */
type TableMetadatasMinFields = {
    handle?: Maybe<Scalars["String"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    key_type?: Maybe<Scalars["String"]["output"]>;
    value_type?: Maybe<Scalars["String"]["output"]>;
};
/** response of any mutation on the table "table_metadatas" */
type TableMetadatasMutationResponse = {
    /** number of rows affected by the mutation */
    affected_rows: Scalars["Int"]["output"];
    /** data from the rows affected by the mutation */
    returning: Array<TableMetadatas>;
};
/** on_conflict condition type for table "table_metadatas" */
type TableMetadatasOnConflict = {
    constraint: TableMetadatasConstraint;
    update_columns?: Array<TableMetadatasUpdateColumn>;
    where?: InputMaybe<TableMetadatasBoolExp>;
};
/** Ordering options when selecting data from "table_metadatas". */
type TableMetadatasOrderBy = {
    handle?: InputMaybe<OrderBy>;
    inserted_at?: InputMaybe<OrderBy>;
    key_type?: InputMaybe<OrderBy>;
    value_type?: InputMaybe<OrderBy>;
};
/** primary key columns input for table: table_metadatas */
type TableMetadatasPkColumnsInput = {
    handle: Scalars["String"]["input"];
};
/** select columns of table "table_metadatas" */
declare enum TableMetadatasSelectColumn {
    /** column name */
    Handle = "handle",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    KeyType = "key_type",
    /** column name */
    ValueType = "value_type"
}
/** input type for updating data in table "table_metadatas" */
type TableMetadatasSetInput = {
    handle?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    key_type?: InputMaybe<Scalars["String"]["input"]>;
    value_type?: InputMaybe<Scalars["String"]["input"]>;
};
/** Streaming cursor of the table "table_metadatas" */
type TableMetadatasStreamCursorInput = {
    /** Stream column input with initial value */
    initial_value: TableMetadatasStreamCursorValueInput;
    /** cursor ordering */
    ordering?: InputMaybe<CursorOrdering>;
};
/** Initial value of the column from where the streaming should start */
type TableMetadatasStreamCursorValueInput = {
    handle?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    key_type?: InputMaybe<Scalars["String"]["input"]>;
    value_type?: InputMaybe<Scalars["String"]["input"]>;
};
/** update columns of table "table_metadatas" */
declare enum TableMetadatasUpdateColumn {
    /** column name */
    Handle = "handle",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    KeyType = "key_type",
    /** column name */
    ValueType = "value_type"
}
type TableMetadatasUpdates = {
    /** sets the columns of the filtered rows to the given values */
    _set?: InputMaybe<TableMetadatasSetInput>;
    /** filter the rows which have to be updated */
    where: TableMetadatasBoolExp;
};
/** Boolean expression to compare columns of type "timestamp". All fields are combined with logical 'AND'. */
type TimestampComparisonExp = {
    _eq?: InputMaybe<Scalars["timestamp"]["input"]>;
    _gt?: InputMaybe<Scalars["timestamp"]["input"]>;
    _gte?: InputMaybe<Scalars["timestamp"]["input"]>;
    _in?: InputMaybe<Array<Scalars["timestamp"]["input"]>>;
    _is_null?: InputMaybe<Scalars["Boolean"]["input"]>;
    _lt?: InputMaybe<Scalars["timestamp"]["input"]>;
    _lte?: InputMaybe<Scalars["timestamp"]["input"]>;
    _neq?: InputMaybe<Scalars["timestamp"]["input"]>;
    _nin?: InputMaybe<Array<Scalars["timestamp"]["input"]>>;
};
/** columns and relationships of "token_activities" */
type TokenActivities = {
    coin_amount?: Maybe<Scalars["numeric"]["output"]>;
    coin_type?: Maybe<Scalars["String"]["output"]>;
    collection_data_id_hash: Scalars["String"]["output"];
    collection_name: Scalars["String"]["output"];
    creator_address: Scalars["String"]["output"];
    event_account_address: Scalars["String"]["output"];
    event_creation_number: Scalars["bigint"]["output"];
    event_index?: Maybe<Scalars["bigint"]["output"]>;
    event_sequence_number: Scalars["bigint"]["output"];
    from_address?: Maybe<Scalars["String"]["output"]>;
    inserted_at: Scalars["timestamp"]["output"];
    name: Scalars["String"]["output"];
    property_version: Scalars["numeric"]["output"];
    to_address?: Maybe<Scalars["String"]["output"]>;
    token_amount: Scalars["numeric"]["output"];
    token_data_id_hash: Scalars["String"]["output"];
    transaction_timestamp: Scalars["timestamp"]["output"];
    transaction_version: Scalars["bigint"]["output"];
    transfer_type: Scalars["String"]["output"];
};
/** aggregated selection of "token_activities" */
type TokenActivitiesAggregate = {
    aggregate?: Maybe<TokenActivitiesAggregateFields>;
    nodes: Array<TokenActivities>;
};
/** aggregate fields of "token_activities" */
type TokenActivitiesAggregateFields = {
    avg?: Maybe<TokenActivitiesAvgFields>;
    count: Scalars["Int"]["output"];
    max?: Maybe<TokenActivitiesMaxFields>;
    min?: Maybe<TokenActivitiesMinFields>;
    stddev?: Maybe<TokenActivitiesStddevFields>;
    stddev_pop?: Maybe<TokenActivitiesStddevPopFields>;
    stddev_samp?: Maybe<TokenActivitiesStddevSampFields>;
    sum?: Maybe<TokenActivitiesSumFields>;
    var_pop?: Maybe<TokenActivitiesVarPopFields>;
    var_samp?: Maybe<TokenActivitiesVarSampFields>;
    variance?: Maybe<TokenActivitiesVarianceFields>;
};
/** aggregate fields of "token_activities" */
type TokenActivitiesAggregateFieldsCountArgs = {
    columns?: InputMaybe<Array<TokenActivitiesSelectColumn>>;
    distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};
/** aggregate avg on columns */
type TokenActivitiesAvgFields = {
    coin_amount?: Maybe<Scalars["Float"]["output"]>;
    event_creation_number?: Maybe<Scalars["Float"]["output"]>;
    event_index?: Maybe<Scalars["Float"]["output"]>;
    event_sequence_number?: Maybe<Scalars["Float"]["output"]>;
    property_version?: Maybe<Scalars["Float"]["output"]>;
    token_amount?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** Boolean expression to filter rows from the table "token_activities". All fields are combined with a logical 'AND'. */
type TokenActivitiesBoolExp = {
    _and?: InputMaybe<Array<TokenActivitiesBoolExp>>;
    _not?: InputMaybe<TokenActivitiesBoolExp>;
    _or?: InputMaybe<Array<TokenActivitiesBoolExp>>;
    coin_amount?: InputMaybe<NumericComparisonExp>;
    coin_type?: InputMaybe<StringComparisonExp>;
    collection_data_id_hash?: InputMaybe<StringComparisonExp>;
    collection_name?: InputMaybe<StringComparisonExp>;
    creator_address?: InputMaybe<StringComparisonExp>;
    event_account_address?: InputMaybe<StringComparisonExp>;
    event_creation_number?: InputMaybe<BigintComparisonExp>;
    event_index?: InputMaybe<BigintComparisonExp>;
    event_sequence_number?: InputMaybe<BigintComparisonExp>;
    from_address?: InputMaybe<StringComparisonExp>;
    inserted_at?: InputMaybe<TimestampComparisonExp>;
    name?: InputMaybe<StringComparisonExp>;
    property_version?: InputMaybe<NumericComparisonExp>;
    to_address?: InputMaybe<StringComparisonExp>;
    token_amount?: InputMaybe<NumericComparisonExp>;
    token_data_id_hash?: InputMaybe<StringComparisonExp>;
    transaction_timestamp?: InputMaybe<TimestampComparisonExp>;
    transaction_version?: InputMaybe<BigintComparisonExp>;
    transfer_type?: InputMaybe<StringComparisonExp>;
};
/** unique or primary key constraints on table "token_activities" */
declare enum TokenActivitiesConstraint {
    /** unique or primary key constraint on columns "event_sequence_number", "event_creation_number", "transaction_version", "event_account_address" */
    TokenActivitiesPkey = "token_activities_pkey"
}
/** input type for incrementing numeric columns in table "token_activities" */
type TokenActivitiesIncInput = {
    coin_amount?: InputMaybe<Scalars["numeric"]["input"]>;
    event_creation_number?: InputMaybe<Scalars["bigint"]["input"]>;
    event_index?: InputMaybe<Scalars["bigint"]["input"]>;
    event_sequence_number?: InputMaybe<Scalars["bigint"]["input"]>;
    property_version?: InputMaybe<Scalars["numeric"]["input"]>;
    token_amount?: InputMaybe<Scalars["numeric"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** input type for inserting data into table "token_activities" */
type TokenActivitiesInsertInput = {
    coin_amount?: InputMaybe<Scalars["numeric"]["input"]>;
    coin_type?: InputMaybe<Scalars["String"]["input"]>;
    collection_data_id_hash?: InputMaybe<Scalars["String"]["input"]>;
    collection_name?: InputMaybe<Scalars["String"]["input"]>;
    creator_address?: InputMaybe<Scalars["String"]["input"]>;
    event_account_address?: InputMaybe<Scalars["String"]["input"]>;
    event_creation_number?: InputMaybe<Scalars["bigint"]["input"]>;
    event_index?: InputMaybe<Scalars["bigint"]["input"]>;
    event_sequence_number?: InputMaybe<Scalars["bigint"]["input"]>;
    from_address?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    name?: InputMaybe<Scalars["String"]["input"]>;
    property_version?: InputMaybe<Scalars["numeric"]["input"]>;
    to_address?: InputMaybe<Scalars["String"]["input"]>;
    token_amount?: InputMaybe<Scalars["numeric"]["input"]>;
    token_data_id_hash?: InputMaybe<Scalars["String"]["input"]>;
    transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    transfer_type?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregate max on columns */
type TokenActivitiesMaxFields = {
    coin_amount?: Maybe<Scalars["numeric"]["output"]>;
    coin_type?: Maybe<Scalars["String"]["output"]>;
    collection_data_id_hash?: Maybe<Scalars["String"]["output"]>;
    collection_name?: Maybe<Scalars["String"]["output"]>;
    creator_address?: Maybe<Scalars["String"]["output"]>;
    event_account_address?: Maybe<Scalars["String"]["output"]>;
    event_creation_number?: Maybe<Scalars["bigint"]["output"]>;
    event_index?: Maybe<Scalars["bigint"]["output"]>;
    event_sequence_number?: Maybe<Scalars["bigint"]["output"]>;
    from_address?: Maybe<Scalars["String"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    name?: Maybe<Scalars["String"]["output"]>;
    property_version?: Maybe<Scalars["numeric"]["output"]>;
    to_address?: Maybe<Scalars["String"]["output"]>;
    token_amount?: Maybe<Scalars["numeric"]["output"]>;
    token_data_id_hash?: Maybe<Scalars["String"]["output"]>;
    transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    transfer_type?: Maybe<Scalars["String"]["output"]>;
};
/** aggregate min on columns */
type TokenActivitiesMinFields = {
    coin_amount?: Maybe<Scalars["numeric"]["output"]>;
    coin_type?: Maybe<Scalars["String"]["output"]>;
    collection_data_id_hash?: Maybe<Scalars["String"]["output"]>;
    collection_name?: Maybe<Scalars["String"]["output"]>;
    creator_address?: Maybe<Scalars["String"]["output"]>;
    event_account_address?: Maybe<Scalars["String"]["output"]>;
    event_creation_number?: Maybe<Scalars["bigint"]["output"]>;
    event_index?: Maybe<Scalars["bigint"]["output"]>;
    event_sequence_number?: Maybe<Scalars["bigint"]["output"]>;
    from_address?: Maybe<Scalars["String"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    name?: Maybe<Scalars["String"]["output"]>;
    property_version?: Maybe<Scalars["numeric"]["output"]>;
    to_address?: Maybe<Scalars["String"]["output"]>;
    token_amount?: Maybe<Scalars["numeric"]["output"]>;
    token_data_id_hash?: Maybe<Scalars["String"]["output"]>;
    transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    transfer_type?: Maybe<Scalars["String"]["output"]>;
};
/** response of any mutation on the table "token_activities" */
type TokenActivitiesMutationResponse = {
    /** number of rows affected by the mutation */
    affected_rows: Scalars["Int"]["output"];
    /** data from the rows affected by the mutation */
    returning: Array<TokenActivities>;
};
/** on_conflict condition type for table "token_activities" */
type TokenActivitiesOnConflict = {
    constraint: TokenActivitiesConstraint;
    update_columns?: Array<TokenActivitiesUpdateColumn>;
    where?: InputMaybe<TokenActivitiesBoolExp>;
};
/** Ordering options when selecting data from "token_activities". */
type TokenActivitiesOrderBy = {
    coin_amount?: InputMaybe<OrderBy>;
    coin_type?: InputMaybe<OrderBy>;
    collection_data_id_hash?: InputMaybe<OrderBy>;
    collection_name?: InputMaybe<OrderBy>;
    creator_address?: InputMaybe<OrderBy>;
    event_account_address?: InputMaybe<OrderBy>;
    event_creation_number?: InputMaybe<OrderBy>;
    event_index?: InputMaybe<OrderBy>;
    event_sequence_number?: InputMaybe<OrderBy>;
    from_address?: InputMaybe<OrderBy>;
    inserted_at?: InputMaybe<OrderBy>;
    name?: InputMaybe<OrderBy>;
    property_version?: InputMaybe<OrderBy>;
    to_address?: InputMaybe<OrderBy>;
    token_amount?: InputMaybe<OrderBy>;
    token_data_id_hash?: InputMaybe<OrderBy>;
    transaction_timestamp?: InputMaybe<OrderBy>;
    transaction_version?: InputMaybe<OrderBy>;
    transfer_type?: InputMaybe<OrderBy>;
};
/** primary key columns input for table: token_activities */
type TokenActivitiesPkColumnsInput = {
    event_account_address: Scalars["String"]["input"];
    event_creation_number: Scalars["bigint"]["input"];
    event_sequence_number: Scalars["bigint"]["input"];
    transaction_version: Scalars["bigint"]["input"];
};
/** select columns of table "token_activities" */
declare enum TokenActivitiesSelectColumn {
    /** column name */
    CoinAmount = "coin_amount",
    /** column name */
    CoinType = "coin_type",
    /** column name */
    CollectionDataIdHash = "collection_data_id_hash",
    /** column name */
    CollectionName = "collection_name",
    /** column name */
    CreatorAddress = "creator_address",
    /** column name */
    EventAccountAddress = "event_account_address",
    /** column name */
    EventCreationNumber = "event_creation_number",
    /** column name */
    EventIndex = "event_index",
    /** column name */
    EventSequenceNumber = "event_sequence_number",
    /** column name */
    FromAddress = "from_address",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    Name = "name",
    /** column name */
    PropertyVersion = "property_version",
    /** column name */
    ToAddress = "to_address",
    /** column name */
    TokenAmount = "token_amount",
    /** column name */
    TokenDataIdHash = "token_data_id_hash",
    /** column name */
    TransactionTimestamp = "transaction_timestamp",
    /** column name */
    TransactionVersion = "transaction_version",
    /** column name */
    TransferType = "transfer_type"
}
/** input type for updating data in table "token_activities" */
type TokenActivitiesSetInput = {
    coin_amount?: InputMaybe<Scalars["numeric"]["input"]>;
    coin_type?: InputMaybe<Scalars["String"]["input"]>;
    collection_data_id_hash?: InputMaybe<Scalars["String"]["input"]>;
    collection_name?: InputMaybe<Scalars["String"]["input"]>;
    creator_address?: InputMaybe<Scalars["String"]["input"]>;
    event_account_address?: InputMaybe<Scalars["String"]["input"]>;
    event_creation_number?: InputMaybe<Scalars["bigint"]["input"]>;
    event_index?: InputMaybe<Scalars["bigint"]["input"]>;
    event_sequence_number?: InputMaybe<Scalars["bigint"]["input"]>;
    from_address?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    name?: InputMaybe<Scalars["String"]["input"]>;
    property_version?: InputMaybe<Scalars["numeric"]["input"]>;
    to_address?: InputMaybe<Scalars["String"]["input"]>;
    token_amount?: InputMaybe<Scalars["numeric"]["input"]>;
    token_data_id_hash?: InputMaybe<Scalars["String"]["input"]>;
    transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    transfer_type?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregate stddev on columns */
type TokenActivitiesStddevFields = {
    coin_amount?: Maybe<Scalars["Float"]["output"]>;
    event_creation_number?: Maybe<Scalars["Float"]["output"]>;
    event_index?: Maybe<Scalars["Float"]["output"]>;
    event_sequence_number?: Maybe<Scalars["Float"]["output"]>;
    property_version?: Maybe<Scalars["Float"]["output"]>;
    token_amount?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_pop on columns */
type TokenActivitiesStddevPopFields = {
    coin_amount?: Maybe<Scalars["Float"]["output"]>;
    event_creation_number?: Maybe<Scalars["Float"]["output"]>;
    event_index?: Maybe<Scalars["Float"]["output"]>;
    event_sequence_number?: Maybe<Scalars["Float"]["output"]>;
    property_version?: Maybe<Scalars["Float"]["output"]>;
    token_amount?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_samp on columns */
type TokenActivitiesStddevSampFields = {
    coin_amount?: Maybe<Scalars["Float"]["output"]>;
    event_creation_number?: Maybe<Scalars["Float"]["output"]>;
    event_index?: Maybe<Scalars["Float"]["output"]>;
    event_sequence_number?: Maybe<Scalars["Float"]["output"]>;
    property_version?: Maybe<Scalars["Float"]["output"]>;
    token_amount?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** Streaming cursor of the table "token_activities" */
type TokenActivitiesStreamCursorInput = {
    /** Stream column input with initial value */
    initial_value: TokenActivitiesStreamCursorValueInput;
    /** cursor ordering */
    ordering?: InputMaybe<CursorOrdering>;
};
/** Initial value of the column from where the streaming should start */
type TokenActivitiesStreamCursorValueInput = {
    coin_amount?: InputMaybe<Scalars["numeric"]["input"]>;
    coin_type?: InputMaybe<Scalars["String"]["input"]>;
    collection_data_id_hash?: InputMaybe<Scalars["String"]["input"]>;
    collection_name?: InputMaybe<Scalars["String"]["input"]>;
    creator_address?: InputMaybe<Scalars["String"]["input"]>;
    event_account_address?: InputMaybe<Scalars["String"]["input"]>;
    event_creation_number?: InputMaybe<Scalars["bigint"]["input"]>;
    event_index?: InputMaybe<Scalars["bigint"]["input"]>;
    event_sequence_number?: InputMaybe<Scalars["bigint"]["input"]>;
    from_address?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    name?: InputMaybe<Scalars["String"]["input"]>;
    property_version?: InputMaybe<Scalars["numeric"]["input"]>;
    to_address?: InputMaybe<Scalars["String"]["input"]>;
    token_amount?: InputMaybe<Scalars["numeric"]["input"]>;
    token_data_id_hash?: InputMaybe<Scalars["String"]["input"]>;
    transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    transfer_type?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregate sum on columns */
type TokenActivitiesSumFields = {
    coin_amount?: Maybe<Scalars["numeric"]["output"]>;
    event_creation_number?: Maybe<Scalars["bigint"]["output"]>;
    event_index?: Maybe<Scalars["bigint"]["output"]>;
    event_sequence_number?: Maybe<Scalars["bigint"]["output"]>;
    property_version?: Maybe<Scalars["numeric"]["output"]>;
    token_amount?: Maybe<Scalars["numeric"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};
/** update columns of table "token_activities" */
declare enum TokenActivitiesUpdateColumn {
    /** column name */
    CoinAmount = "coin_amount",
    /** column name */
    CoinType = "coin_type",
    /** column name */
    CollectionDataIdHash = "collection_data_id_hash",
    /** column name */
    CollectionName = "collection_name",
    /** column name */
    CreatorAddress = "creator_address",
    /** column name */
    EventAccountAddress = "event_account_address",
    /** column name */
    EventCreationNumber = "event_creation_number",
    /** column name */
    EventIndex = "event_index",
    /** column name */
    EventSequenceNumber = "event_sequence_number",
    /** column name */
    FromAddress = "from_address",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    Name = "name",
    /** column name */
    PropertyVersion = "property_version",
    /** column name */
    ToAddress = "to_address",
    /** column name */
    TokenAmount = "token_amount",
    /** column name */
    TokenDataIdHash = "token_data_id_hash",
    /** column name */
    TransactionTimestamp = "transaction_timestamp",
    /** column name */
    TransactionVersion = "transaction_version",
    /** column name */
    TransferType = "transfer_type"
}
type TokenActivitiesUpdates = {
    /** increments the numeric columns with given value of the filtered values */
    _inc?: InputMaybe<TokenActivitiesIncInput>;
    /** sets the columns of the filtered rows to the given values */
    _set?: InputMaybe<TokenActivitiesSetInput>;
    /** filter the rows which have to be updated */
    where: TokenActivitiesBoolExp;
};
/** columns and relationships of "token_activities_v2" */
type TokenActivitiesV2 = {
    after_value?: Maybe<Scalars["String"]["output"]>;
    before_value?: Maybe<Scalars["String"]["output"]>;
    /** An array relationship */
    cedra_names_from: Array<CurrentCedraNames>;
    /** An aggregate relationship */
    cedra_names_from_aggregate: CurrentCedraNamesAggregate;
    /** An array relationship */
    cedra_names_to: Array<CurrentCedraNames>;
    /** An aggregate relationship */
    cedra_names_to_aggregate: CurrentCedraNamesAggregate;
    /** An object relationship */
    current_token_data?: Maybe<CurrentTokenDatasV2>;
    entry_function_id_str?: Maybe<Scalars["String"]["output"]>;
    event_account_address: Scalars["String"]["output"];
    event_index: Scalars["bigint"]["output"];
    from_address?: Maybe<Scalars["String"]["output"]>;
    inserted_at: Scalars["timestamp"]["output"];
    is_fungible_v2?: Maybe<Scalars["Boolean"]["output"]>;
    property_version_v1: Scalars["numeric"]["output"];
    to_address?: Maybe<Scalars["String"]["output"]>;
    token_amount: Scalars["numeric"]["output"];
    token_data_id: Scalars["String"]["output"];
    token_standard: Scalars["String"]["output"];
    transaction_timestamp: Scalars["timestamp"]["output"];
    transaction_version: Scalars["bigint"]["output"];
    type: Scalars["String"]["output"];
};
/** columns and relationships of "token_activities_v2" */
type TokenActivitiesV2CedraNamesFromArgs = {
    distinct_on?: InputMaybe<Array<CurrentCedraNamesSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentCedraNamesOrderBy>>;
    where?: InputMaybe<CurrentCedraNamesBoolExp>;
};
/** columns and relationships of "token_activities_v2" */
type TokenActivitiesV2CedraNamesFromAggregateArgs = {
    distinct_on?: InputMaybe<Array<CurrentCedraNamesSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentCedraNamesOrderBy>>;
    where?: InputMaybe<CurrentCedraNamesBoolExp>;
};
/** columns and relationships of "token_activities_v2" */
type TokenActivitiesV2CedraNamesToArgs = {
    distinct_on?: InputMaybe<Array<CurrentCedraNamesSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentCedraNamesOrderBy>>;
    where?: InputMaybe<CurrentCedraNamesBoolExp>;
};
/** columns and relationships of "token_activities_v2" */
type TokenActivitiesV2CedraNamesToAggregateArgs = {
    distinct_on?: InputMaybe<Array<CurrentCedraNamesSelectColumn>>;
    limit?: InputMaybe<Scalars["Int"]["input"]>;
    offset?: InputMaybe<Scalars["Int"]["input"]>;
    order_by?: InputMaybe<Array<CurrentCedraNamesOrderBy>>;
    where?: InputMaybe<CurrentCedraNamesBoolExp>;
};
/** aggregated selection of "token_activities_v2" */
type TokenActivitiesV2Aggregate = {
    aggregate?: Maybe<TokenActivitiesV2AggregateFields>;
    nodes: Array<TokenActivitiesV2>;
};
type TokenActivitiesV2AggregateBoolExp = {
    bool_and?: InputMaybe<TokenActivitiesV2AggregateBoolExpBoolAnd>;
    bool_or?: InputMaybe<TokenActivitiesV2AggregateBoolExpBoolOr>;
    count?: InputMaybe<TokenActivitiesV2AggregateBoolExpCount>;
};
type TokenActivitiesV2AggregateBoolExpBoolAnd = {
    arguments: TokenActivitiesV2SelectColumnTokenActivitiesV2AggregateBoolExpBoolAndArgumentsColumns;
    distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
    filter?: InputMaybe<TokenActivitiesV2BoolExp>;
    predicate: BooleanComparisonExp;
};
type TokenActivitiesV2AggregateBoolExpBoolOr = {
    arguments: TokenActivitiesV2SelectColumnTokenActivitiesV2AggregateBoolExpBoolOrArgumentsColumns;
    distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
    filter?: InputMaybe<TokenActivitiesV2BoolExp>;
    predicate: BooleanComparisonExp;
};
type TokenActivitiesV2AggregateBoolExpCount = {
    arguments?: InputMaybe<Array<TokenActivitiesV2SelectColumn>>;
    distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
    filter?: InputMaybe<TokenActivitiesV2BoolExp>;
    predicate: IntComparisonExp;
};
/** aggregate fields of "token_activities_v2" */
type TokenActivitiesV2AggregateFields = {
    avg?: Maybe<TokenActivitiesV2AvgFields>;
    count: Scalars["Int"]["output"];
    max?: Maybe<TokenActivitiesV2MaxFields>;
    min?: Maybe<TokenActivitiesV2MinFields>;
    stddev?: Maybe<TokenActivitiesV2StddevFields>;
    stddev_pop?: Maybe<TokenActivitiesV2StddevPopFields>;
    stddev_samp?: Maybe<TokenActivitiesV2StddevSampFields>;
    sum?: Maybe<TokenActivitiesV2SumFields>;
    var_pop?: Maybe<TokenActivitiesV2VarPopFields>;
    var_samp?: Maybe<TokenActivitiesV2VarSampFields>;
    variance?: Maybe<TokenActivitiesV2VarianceFields>;
};
/** aggregate fields of "token_activities_v2" */
type TokenActivitiesV2AggregateFieldsCountArgs = {
    columns?: InputMaybe<Array<TokenActivitiesV2SelectColumn>>;
    distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};
/** order by aggregate values of table "token_activities_v2" */
type TokenActivitiesV2AggregateOrderBy = {
    avg?: InputMaybe<TokenActivitiesV2AvgOrderBy>;
    count?: InputMaybe<OrderBy>;
    max?: InputMaybe<TokenActivitiesV2MaxOrderBy>;
    min?: InputMaybe<TokenActivitiesV2MinOrderBy>;
    stddev?: InputMaybe<TokenActivitiesV2StddevOrderBy>;
    stddev_pop?: InputMaybe<TokenActivitiesV2StddevPopOrderBy>;
    stddev_samp?: InputMaybe<TokenActivitiesV2StddevSampOrderBy>;
    sum?: InputMaybe<TokenActivitiesV2SumOrderBy>;
    var_pop?: InputMaybe<TokenActivitiesV2VarPopOrderBy>;
    var_samp?: InputMaybe<TokenActivitiesV2VarSampOrderBy>;
    variance?: InputMaybe<TokenActivitiesV2VarianceOrderBy>;
};
/** input type for inserting array relation for remote table "token_activities_v2" */
type TokenActivitiesV2ArrRelInsertInput = {
    data: Array<TokenActivitiesV2InsertInput>;
    /** upsert condition */
    on_conflict?: InputMaybe<TokenActivitiesV2OnConflict>;
};
/** aggregate avg on columns */
type TokenActivitiesV2AvgFields = {
    event_index?: Maybe<Scalars["Float"]["output"]>;
    property_version_v1?: Maybe<Scalars["Float"]["output"]>;
    token_amount?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** order by avg() on columns of table "token_activities_v2" */
type TokenActivitiesV2AvgOrderBy = {
    event_index?: InputMaybe<OrderBy>;
    property_version_v1?: InputMaybe<OrderBy>;
    token_amount?: InputMaybe<OrderBy>;
    transaction_version?: InputMaybe<OrderBy>;
};
/** Boolean expression to filter rows from the table "token_activities_v2". All fields are combined with a logical 'AND'. */
type TokenActivitiesV2BoolExp = {
    _and?: InputMaybe<Array<TokenActivitiesV2BoolExp>>;
    _not?: InputMaybe<TokenActivitiesV2BoolExp>;
    _or?: InputMaybe<Array<TokenActivitiesV2BoolExp>>;
    after_value?: InputMaybe<StringComparisonExp>;
    before_value?: InputMaybe<StringComparisonExp>;
    cedra_names_from?: InputMaybe<CurrentCedraNamesBoolExp>;
    cedra_names_from_aggregate?: InputMaybe<CurrentCedraNamesAggregateBoolExp>;
    cedra_names_to?: InputMaybe<CurrentCedraNamesBoolExp>;
    cedra_names_to_aggregate?: InputMaybe<CurrentCedraNamesAggregateBoolExp>;
    current_token_data?: InputMaybe<CurrentTokenDatasV2BoolExp>;
    entry_function_id_str?: InputMaybe<StringComparisonExp>;
    event_account_address?: InputMaybe<StringComparisonExp>;
    event_index?: InputMaybe<BigintComparisonExp>;
    from_address?: InputMaybe<StringComparisonExp>;
    inserted_at?: InputMaybe<TimestampComparisonExp>;
    is_fungible_v2?: InputMaybe<BooleanComparisonExp>;
    property_version_v1?: InputMaybe<NumericComparisonExp>;
    to_address?: InputMaybe<StringComparisonExp>;
    token_amount?: InputMaybe<NumericComparisonExp>;
    token_data_id?: InputMaybe<StringComparisonExp>;
    token_standard?: InputMaybe<StringComparisonExp>;
    transaction_timestamp?: InputMaybe<TimestampComparisonExp>;
    transaction_version?: InputMaybe<BigintComparisonExp>;
    type?: InputMaybe<StringComparisonExp>;
};
/** unique or primary key constraints on table "token_activities_v2" */
declare enum TokenActivitiesV2Constraint {
    /** unique or primary key constraint on columns "event_index", "transaction_version" */
    TokenActivitiesV2Pkey = "token_activities_v2_pkey"
}
/** input type for incrementing numeric columns in table "token_activities_v2" */
type TokenActivitiesV2IncInput = {
    event_index?: InputMaybe<Scalars["bigint"]["input"]>;
    property_version_v1?: InputMaybe<Scalars["numeric"]["input"]>;
    token_amount?: InputMaybe<Scalars["numeric"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** input type for inserting data into table "token_activities_v2" */
type TokenActivitiesV2InsertInput = {
    after_value?: InputMaybe<Scalars["String"]["input"]>;
    before_value?: InputMaybe<Scalars["String"]["input"]>;
    cedra_names_from?: InputMaybe<CurrentCedraNamesArrRelInsertInput>;
    cedra_names_to?: InputMaybe<CurrentCedraNamesArrRelInsertInput>;
    current_token_data?: InputMaybe<CurrentTokenDatasV2ObjRelInsertInput>;
    entry_function_id_str?: InputMaybe<Scalars["String"]["input"]>;
    event_account_address?: InputMaybe<Scalars["String"]["input"]>;
    event_index?: InputMaybe<Scalars["bigint"]["input"]>;
    from_address?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    is_fungible_v2?: InputMaybe<Scalars["Boolean"]["input"]>;
    property_version_v1?: InputMaybe<Scalars["numeric"]["input"]>;
    to_address?: InputMaybe<Scalars["String"]["input"]>;
    token_amount?: InputMaybe<Scalars["numeric"]["input"]>;
    token_data_id?: InputMaybe<Scalars["String"]["input"]>;
    token_standard?: InputMaybe<Scalars["String"]["input"]>;
    transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    type?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregate max on columns */
type TokenActivitiesV2MaxFields = {
    after_value?: Maybe<Scalars["String"]["output"]>;
    before_value?: Maybe<Scalars["String"]["output"]>;
    entry_function_id_str?: Maybe<Scalars["String"]["output"]>;
    event_account_address?: Maybe<Scalars["String"]["output"]>;
    event_index?: Maybe<Scalars["bigint"]["output"]>;
    from_address?: Maybe<Scalars["String"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    property_version_v1?: Maybe<Scalars["numeric"]["output"]>;
    to_address?: Maybe<Scalars["String"]["output"]>;
    token_amount?: Maybe<Scalars["numeric"]["output"]>;
    token_data_id?: Maybe<Scalars["String"]["output"]>;
    token_standard?: Maybe<Scalars["String"]["output"]>;
    transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    type?: Maybe<Scalars["String"]["output"]>;
};
/** order by max() on columns of table "token_activities_v2" */
type TokenActivitiesV2MaxOrderBy = {
    after_value?: InputMaybe<OrderBy>;
    before_value?: InputMaybe<OrderBy>;
    entry_function_id_str?: InputMaybe<OrderBy>;
    event_account_address?: InputMaybe<OrderBy>;
    event_index?: InputMaybe<OrderBy>;
    from_address?: InputMaybe<OrderBy>;
    inserted_at?: InputMaybe<OrderBy>;
    property_version_v1?: InputMaybe<OrderBy>;
    to_address?: InputMaybe<OrderBy>;
    token_amount?: InputMaybe<OrderBy>;
    token_data_id?: InputMaybe<OrderBy>;
    token_standard?: InputMaybe<OrderBy>;
    transaction_timestamp?: InputMaybe<OrderBy>;
    transaction_version?: InputMaybe<OrderBy>;
    type?: InputMaybe<OrderBy>;
};
/** aggregate min on columns */
type TokenActivitiesV2MinFields = {
    after_value?: Maybe<Scalars["String"]["output"]>;
    before_value?: Maybe<Scalars["String"]["output"]>;
    entry_function_id_str?: Maybe<Scalars["String"]["output"]>;
    event_account_address?: Maybe<Scalars["String"]["output"]>;
    event_index?: Maybe<Scalars["bigint"]["output"]>;
    from_address?: Maybe<Scalars["String"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    property_version_v1?: Maybe<Scalars["numeric"]["output"]>;
    to_address?: Maybe<Scalars["String"]["output"]>;
    token_amount?: Maybe<Scalars["numeric"]["output"]>;
    token_data_id?: Maybe<Scalars["String"]["output"]>;
    token_standard?: Maybe<Scalars["String"]["output"]>;
    transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    type?: Maybe<Scalars["String"]["output"]>;
};
/** order by min() on columns of table "token_activities_v2" */
type TokenActivitiesV2MinOrderBy = {
    after_value?: InputMaybe<OrderBy>;
    before_value?: InputMaybe<OrderBy>;
    entry_function_id_str?: InputMaybe<OrderBy>;
    event_account_address?: InputMaybe<OrderBy>;
    event_index?: InputMaybe<OrderBy>;
    from_address?: InputMaybe<OrderBy>;
    inserted_at?: InputMaybe<OrderBy>;
    property_version_v1?: InputMaybe<OrderBy>;
    to_address?: InputMaybe<OrderBy>;
    token_amount?: InputMaybe<OrderBy>;
    token_data_id?: InputMaybe<OrderBy>;
    token_standard?: InputMaybe<OrderBy>;
    transaction_timestamp?: InputMaybe<OrderBy>;
    transaction_version?: InputMaybe<OrderBy>;
    type?: InputMaybe<OrderBy>;
};
/** response of any mutation on the table "token_activities_v2" */
type TokenActivitiesV2MutationResponse = {
    /** number of rows affected by the mutation */
    affected_rows: Scalars["Int"]["output"];
    /** data from the rows affected by the mutation */
    returning: Array<TokenActivitiesV2>;
};
/** on_conflict condition type for table "token_activities_v2" */
type TokenActivitiesV2OnConflict = {
    constraint: TokenActivitiesV2Constraint;
    update_columns?: Array<TokenActivitiesV2UpdateColumn>;
    where?: InputMaybe<TokenActivitiesV2BoolExp>;
};
/** Ordering options when selecting data from "token_activities_v2". */
type TokenActivitiesV2OrderBy = {
    after_value?: InputMaybe<OrderBy>;
    before_value?: InputMaybe<OrderBy>;
    cedra_names_from_aggregate?: InputMaybe<CurrentCedraNamesAggregateOrderBy>;
    cedra_names_to_aggregate?: InputMaybe<CurrentCedraNamesAggregateOrderBy>;
    current_token_data?: InputMaybe<CurrentTokenDatasV2OrderBy>;
    entry_function_id_str?: InputMaybe<OrderBy>;
    event_account_address?: InputMaybe<OrderBy>;
    event_index?: InputMaybe<OrderBy>;
    from_address?: InputMaybe<OrderBy>;
    inserted_at?: InputMaybe<OrderBy>;
    is_fungible_v2?: InputMaybe<OrderBy>;
    property_version_v1?: InputMaybe<OrderBy>;
    to_address?: InputMaybe<OrderBy>;
    token_amount?: InputMaybe<OrderBy>;
    token_data_id?: InputMaybe<OrderBy>;
    token_standard?: InputMaybe<OrderBy>;
    transaction_timestamp?: InputMaybe<OrderBy>;
    transaction_version?: InputMaybe<OrderBy>;
    type?: InputMaybe<OrderBy>;
};
/** primary key columns input for table: token_activities_v2 */
type TokenActivitiesV2PkColumnsInput = {
    event_index: Scalars["bigint"]["input"];
    transaction_version: Scalars["bigint"]["input"];
};
/** select columns of table "token_activities_v2" */
declare enum TokenActivitiesV2SelectColumn {
    /** column name */
    AfterValue = "after_value",
    /** column name */
    BeforeValue = "before_value",
    /** column name */
    EntryFunctionIdStr = "entry_function_id_str",
    /** column name */
    EventAccountAddress = "event_account_address",
    /** column name */
    EventIndex = "event_index",
    /** column name */
    FromAddress = "from_address",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    IsFungibleV2 = "is_fungible_v2",
    /** column name */
    PropertyVersionV1 = "property_version_v1",
    /** column name */
    ToAddress = "to_address",
    /** column name */
    TokenAmount = "token_amount",
    /** column name */
    TokenDataId = "token_data_id",
    /** column name */
    TokenStandard = "token_standard",
    /** column name */
    TransactionTimestamp = "transaction_timestamp",
    /** column name */
    TransactionVersion = "transaction_version",
    /** column name */
    Type = "type"
}
/** select "token_activities_v2_aggregate_bool_exp_bool_and_arguments_columns" columns of table "token_activities_v2" */
declare enum TokenActivitiesV2SelectColumnTokenActivitiesV2AggregateBoolExpBoolAndArgumentsColumns {
    /** column name */
    IsFungibleV2 = "is_fungible_v2"
}
/** select "token_activities_v2_aggregate_bool_exp_bool_or_arguments_columns" columns of table "token_activities_v2" */
declare enum TokenActivitiesV2SelectColumnTokenActivitiesV2AggregateBoolExpBoolOrArgumentsColumns {
    /** column name */
    IsFungibleV2 = "is_fungible_v2"
}
/** input type for updating data in table "token_activities_v2" */
type TokenActivitiesV2SetInput = {
    after_value?: InputMaybe<Scalars["String"]["input"]>;
    before_value?: InputMaybe<Scalars["String"]["input"]>;
    entry_function_id_str?: InputMaybe<Scalars["String"]["input"]>;
    event_account_address?: InputMaybe<Scalars["String"]["input"]>;
    event_index?: InputMaybe<Scalars["bigint"]["input"]>;
    from_address?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    is_fungible_v2?: InputMaybe<Scalars["Boolean"]["input"]>;
    property_version_v1?: InputMaybe<Scalars["numeric"]["input"]>;
    to_address?: InputMaybe<Scalars["String"]["input"]>;
    token_amount?: InputMaybe<Scalars["numeric"]["input"]>;
    token_data_id?: InputMaybe<Scalars["String"]["input"]>;
    token_standard?: InputMaybe<Scalars["String"]["input"]>;
    transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    type?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregate stddev on columns */
type TokenActivitiesV2StddevFields = {
    event_index?: Maybe<Scalars["Float"]["output"]>;
    property_version_v1?: Maybe<Scalars["Float"]["output"]>;
    token_amount?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** order by stddev() on columns of table "token_activities_v2" */
type TokenActivitiesV2StddevOrderBy = {
    event_index?: InputMaybe<OrderBy>;
    property_version_v1?: InputMaybe<OrderBy>;
    token_amount?: InputMaybe<OrderBy>;
    transaction_version?: InputMaybe<OrderBy>;
};
/** aggregate stddev_pop on columns */
type TokenActivitiesV2StddevPopFields = {
    event_index?: Maybe<Scalars["Float"]["output"]>;
    property_version_v1?: Maybe<Scalars["Float"]["output"]>;
    token_amount?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** order by stddev_pop() on columns of table "token_activities_v2" */
type TokenActivitiesV2StddevPopOrderBy = {
    event_index?: InputMaybe<OrderBy>;
    property_version_v1?: InputMaybe<OrderBy>;
    token_amount?: InputMaybe<OrderBy>;
    transaction_version?: InputMaybe<OrderBy>;
};
/** aggregate stddev_samp on columns */
type TokenActivitiesV2StddevSampFields = {
    event_index?: Maybe<Scalars["Float"]["output"]>;
    property_version_v1?: Maybe<Scalars["Float"]["output"]>;
    token_amount?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** order by stddev_samp() on columns of table "token_activities_v2" */
type TokenActivitiesV2StddevSampOrderBy = {
    event_index?: InputMaybe<OrderBy>;
    property_version_v1?: InputMaybe<OrderBy>;
    token_amount?: InputMaybe<OrderBy>;
    transaction_version?: InputMaybe<OrderBy>;
};
/** Streaming cursor of the table "token_activities_v2" */
type TokenActivitiesV2StreamCursorInput = {
    /** Stream column input with initial value */
    initial_value: TokenActivitiesV2StreamCursorValueInput;
    /** cursor ordering */
    ordering?: InputMaybe<CursorOrdering>;
};
/** Initial value of the column from where the streaming should start */
type TokenActivitiesV2StreamCursorValueInput = {
    after_value?: InputMaybe<Scalars["String"]["input"]>;
    before_value?: InputMaybe<Scalars["String"]["input"]>;
    entry_function_id_str?: InputMaybe<Scalars["String"]["input"]>;
    event_account_address?: InputMaybe<Scalars["String"]["input"]>;
    event_index?: InputMaybe<Scalars["bigint"]["input"]>;
    from_address?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    is_fungible_v2?: InputMaybe<Scalars["Boolean"]["input"]>;
    property_version_v1?: InputMaybe<Scalars["numeric"]["input"]>;
    to_address?: InputMaybe<Scalars["String"]["input"]>;
    token_amount?: InputMaybe<Scalars["numeric"]["input"]>;
    token_data_id?: InputMaybe<Scalars["String"]["input"]>;
    token_standard?: InputMaybe<Scalars["String"]["input"]>;
    transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    type?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregate sum on columns */
type TokenActivitiesV2SumFields = {
    event_index?: Maybe<Scalars["bigint"]["output"]>;
    property_version_v1?: Maybe<Scalars["numeric"]["output"]>;
    token_amount?: Maybe<Scalars["numeric"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};
/** order by sum() on columns of table "token_activities_v2" */
type TokenActivitiesV2SumOrderBy = {
    event_index?: InputMaybe<OrderBy>;
    property_version_v1?: InputMaybe<OrderBy>;
    token_amount?: InputMaybe<OrderBy>;
    transaction_version?: InputMaybe<OrderBy>;
};
/** update columns of table "token_activities_v2" */
declare enum TokenActivitiesV2UpdateColumn {
    /** column name */
    AfterValue = "after_value",
    /** column name */
    BeforeValue = "before_value",
    /** column name */
    EntryFunctionIdStr = "entry_function_id_str",
    /** column name */
    EventAccountAddress = "event_account_address",
    /** column name */
    EventIndex = "event_index",
    /** column name */
    FromAddress = "from_address",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    IsFungibleV2 = "is_fungible_v2",
    /** column name */
    PropertyVersionV1 = "property_version_v1",
    /** column name */
    ToAddress = "to_address",
    /** column name */
    TokenAmount = "token_amount",
    /** column name */
    TokenDataId = "token_data_id",
    /** column name */
    TokenStandard = "token_standard",
    /** column name */
    TransactionTimestamp = "transaction_timestamp",
    /** column name */
    TransactionVersion = "transaction_version",
    /** column name */
    Type = "type"
}
type TokenActivitiesV2Updates = {
    /** increments the numeric columns with given value of the filtered values */
    _inc?: InputMaybe<TokenActivitiesV2IncInput>;
    /** sets the columns of the filtered rows to the given values */
    _set?: InputMaybe<TokenActivitiesV2SetInput>;
    /** filter the rows which have to be updated */
    where: TokenActivitiesV2BoolExp;
};
/** aggregate var_pop on columns */
type TokenActivitiesV2VarPopFields = {
    event_index?: Maybe<Scalars["Float"]["output"]>;
    property_version_v1?: Maybe<Scalars["Float"]["output"]>;
    token_amount?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** order by var_pop() on columns of table "token_activities_v2" */
type TokenActivitiesV2VarPopOrderBy = {
    event_index?: InputMaybe<OrderBy>;
    property_version_v1?: InputMaybe<OrderBy>;
    token_amount?: InputMaybe<OrderBy>;
    transaction_version?: InputMaybe<OrderBy>;
};
/** aggregate var_samp on columns */
type TokenActivitiesV2VarSampFields = {
    event_index?: Maybe<Scalars["Float"]["output"]>;
    property_version_v1?: Maybe<Scalars["Float"]["output"]>;
    token_amount?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** order by var_samp() on columns of table "token_activities_v2" */
type TokenActivitiesV2VarSampOrderBy = {
    event_index?: InputMaybe<OrderBy>;
    property_version_v1?: InputMaybe<OrderBy>;
    token_amount?: InputMaybe<OrderBy>;
    transaction_version?: InputMaybe<OrderBy>;
};
/** aggregate variance on columns */
type TokenActivitiesV2VarianceFields = {
    event_index?: Maybe<Scalars["Float"]["output"]>;
    property_version_v1?: Maybe<Scalars["Float"]["output"]>;
    token_amount?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** order by variance() on columns of table "token_activities_v2" */
type TokenActivitiesV2VarianceOrderBy = {
    event_index?: InputMaybe<OrderBy>;
    property_version_v1?: InputMaybe<OrderBy>;
    token_amount?: InputMaybe<OrderBy>;
    transaction_version?: InputMaybe<OrderBy>;
};
/** aggregate var_pop on columns */
type TokenActivitiesVarPopFields = {
    coin_amount?: Maybe<Scalars["Float"]["output"]>;
    event_creation_number?: Maybe<Scalars["Float"]["output"]>;
    event_index?: Maybe<Scalars["Float"]["output"]>;
    event_sequence_number?: Maybe<Scalars["Float"]["output"]>;
    property_version?: Maybe<Scalars["Float"]["output"]>;
    token_amount?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate var_samp on columns */
type TokenActivitiesVarSampFields = {
    coin_amount?: Maybe<Scalars["Float"]["output"]>;
    event_creation_number?: Maybe<Scalars["Float"]["output"]>;
    event_index?: Maybe<Scalars["Float"]["output"]>;
    event_sequence_number?: Maybe<Scalars["Float"]["output"]>;
    property_version?: Maybe<Scalars["Float"]["output"]>;
    token_amount?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate variance on columns */
type TokenActivitiesVarianceFields = {
    coin_amount?: Maybe<Scalars["Float"]["output"]>;
    event_creation_number?: Maybe<Scalars["Float"]["output"]>;
    event_index?: Maybe<Scalars["Float"]["output"]>;
    event_sequence_number?: Maybe<Scalars["Float"]["output"]>;
    property_version?: Maybe<Scalars["Float"]["output"]>;
    token_amount?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** columns and relationships of "token_datas" */
type TokenDatas = {
    collection_data_id_hash: Scalars["String"]["output"];
    collection_name: Scalars["String"]["output"];
    creator_address: Scalars["String"]["output"];
    default_properties: Scalars["jsonb"]["output"];
    description: Scalars["String"]["output"];
    description_mutable: Scalars["Boolean"]["output"];
    inserted_at: Scalars["timestamp"]["output"];
    largest_property_version: Scalars["numeric"]["output"];
    maximum: Scalars["numeric"]["output"];
    maximum_mutable: Scalars["Boolean"]["output"];
    metadata_uri: Scalars["String"]["output"];
    name: Scalars["String"]["output"];
    payee_address: Scalars["String"]["output"];
    properties_mutable: Scalars["Boolean"]["output"];
    royalty_mutable: Scalars["Boolean"]["output"];
    royalty_points_denominator: Scalars["numeric"]["output"];
    royalty_points_numerator: Scalars["numeric"]["output"];
    supply: Scalars["numeric"]["output"];
    token_data_id_hash: Scalars["String"]["output"];
    transaction_timestamp: Scalars["timestamp"]["output"];
    transaction_version: Scalars["bigint"]["output"];
    uri_mutable: Scalars["Boolean"]["output"];
};
/** columns and relationships of "token_datas" */
type TokenDatasDefaultPropertiesArgs = {
    path?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregated selection of "token_datas" */
type TokenDatasAggregate = {
    aggregate?: Maybe<TokenDatasAggregateFields>;
    nodes: Array<TokenDatas>;
};
/** aggregate fields of "token_datas" */
type TokenDatasAggregateFields = {
    avg?: Maybe<TokenDatasAvgFields>;
    count: Scalars["Int"]["output"];
    max?: Maybe<TokenDatasMaxFields>;
    min?: Maybe<TokenDatasMinFields>;
    stddev?: Maybe<TokenDatasStddevFields>;
    stddev_pop?: Maybe<TokenDatasStddevPopFields>;
    stddev_samp?: Maybe<TokenDatasStddevSampFields>;
    sum?: Maybe<TokenDatasSumFields>;
    var_pop?: Maybe<TokenDatasVarPopFields>;
    var_samp?: Maybe<TokenDatasVarSampFields>;
    variance?: Maybe<TokenDatasVarianceFields>;
};
/** aggregate fields of "token_datas" */
type TokenDatasAggregateFieldsCountArgs = {
    columns?: InputMaybe<Array<TokenDatasSelectColumn>>;
    distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};
/** append existing jsonb value of filtered columns with new jsonb value */
type TokenDatasAppendInput = {
    default_properties?: InputMaybe<Scalars["jsonb"]["input"]>;
};
/** aggregate avg on columns */
type TokenDatasAvgFields = {
    largest_property_version?: Maybe<Scalars["Float"]["output"]>;
    maximum?: Maybe<Scalars["Float"]["output"]>;
    royalty_points_denominator?: Maybe<Scalars["Float"]["output"]>;
    royalty_points_numerator?: Maybe<Scalars["Float"]["output"]>;
    supply?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** Boolean expression to filter rows from the table "token_datas". All fields are combined with a logical 'AND'. */
type TokenDatasBoolExp = {
    _and?: InputMaybe<Array<TokenDatasBoolExp>>;
    _not?: InputMaybe<TokenDatasBoolExp>;
    _or?: InputMaybe<Array<TokenDatasBoolExp>>;
    collection_data_id_hash?: InputMaybe<StringComparisonExp>;
    collection_name?: InputMaybe<StringComparisonExp>;
    creator_address?: InputMaybe<StringComparisonExp>;
    default_properties?: InputMaybe<JsonbComparisonExp>;
    description?: InputMaybe<StringComparisonExp>;
    description_mutable?: InputMaybe<BooleanComparisonExp>;
    inserted_at?: InputMaybe<TimestampComparisonExp>;
    largest_property_version?: InputMaybe<NumericComparisonExp>;
    maximum?: InputMaybe<NumericComparisonExp>;
    maximum_mutable?: InputMaybe<BooleanComparisonExp>;
    metadata_uri?: InputMaybe<StringComparisonExp>;
    name?: InputMaybe<StringComparisonExp>;
    payee_address?: InputMaybe<StringComparisonExp>;
    properties_mutable?: InputMaybe<BooleanComparisonExp>;
    royalty_mutable?: InputMaybe<BooleanComparisonExp>;
    royalty_points_denominator?: InputMaybe<NumericComparisonExp>;
    royalty_points_numerator?: InputMaybe<NumericComparisonExp>;
    supply?: InputMaybe<NumericComparisonExp>;
    token_data_id_hash?: InputMaybe<StringComparisonExp>;
    transaction_timestamp?: InputMaybe<TimestampComparisonExp>;
    transaction_version?: InputMaybe<BigintComparisonExp>;
    uri_mutable?: InputMaybe<BooleanComparisonExp>;
};
/** unique or primary key constraints on table "token_datas" */
declare enum TokenDatasConstraint {
    /** unique or primary key constraint on columns "token_data_id_hash", "transaction_version" */
    TokenDatasPkey = "token_datas_pkey"
}
/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
type TokenDatasDeleteAtPathInput = {
    default_properties?: InputMaybe<Array<Scalars["String"]["input"]>>;
};
/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
type TokenDatasDeleteElemInput = {
    default_properties?: InputMaybe<Scalars["Int"]["input"]>;
};
/** delete key/value pair or string element. key/value pairs are matched based on their key value */
type TokenDatasDeleteKeyInput = {
    default_properties?: InputMaybe<Scalars["String"]["input"]>;
};
/** input type for incrementing numeric columns in table "token_datas" */
type TokenDatasIncInput = {
    largest_property_version?: InputMaybe<Scalars["numeric"]["input"]>;
    maximum?: InputMaybe<Scalars["numeric"]["input"]>;
    royalty_points_denominator?: InputMaybe<Scalars["numeric"]["input"]>;
    royalty_points_numerator?: InputMaybe<Scalars["numeric"]["input"]>;
    supply?: InputMaybe<Scalars["numeric"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** input type for inserting data into table "token_datas" */
type TokenDatasInsertInput = {
    collection_data_id_hash?: InputMaybe<Scalars["String"]["input"]>;
    collection_name?: InputMaybe<Scalars["String"]["input"]>;
    creator_address?: InputMaybe<Scalars["String"]["input"]>;
    default_properties?: InputMaybe<Scalars["jsonb"]["input"]>;
    description?: InputMaybe<Scalars["String"]["input"]>;
    description_mutable?: InputMaybe<Scalars["Boolean"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    largest_property_version?: InputMaybe<Scalars["numeric"]["input"]>;
    maximum?: InputMaybe<Scalars["numeric"]["input"]>;
    maximum_mutable?: InputMaybe<Scalars["Boolean"]["input"]>;
    metadata_uri?: InputMaybe<Scalars["String"]["input"]>;
    name?: InputMaybe<Scalars["String"]["input"]>;
    payee_address?: InputMaybe<Scalars["String"]["input"]>;
    properties_mutable?: InputMaybe<Scalars["Boolean"]["input"]>;
    royalty_mutable?: InputMaybe<Scalars["Boolean"]["input"]>;
    royalty_points_denominator?: InputMaybe<Scalars["numeric"]["input"]>;
    royalty_points_numerator?: InputMaybe<Scalars["numeric"]["input"]>;
    supply?: InputMaybe<Scalars["numeric"]["input"]>;
    token_data_id_hash?: InputMaybe<Scalars["String"]["input"]>;
    transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    uri_mutable?: InputMaybe<Scalars["Boolean"]["input"]>;
};
/** aggregate max on columns */
type TokenDatasMaxFields = {
    collection_data_id_hash?: Maybe<Scalars["String"]["output"]>;
    collection_name?: Maybe<Scalars["String"]["output"]>;
    creator_address?: Maybe<Scalars["String"]["output"]>;
    description?: Maybe<Scalars["String"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    largest_property_version?: Maybe<Scalars["numeric"]["output"]>;
    maximum?: Maybe<Scalars["numeric"]["output"]>;
    metadata_uri?: Maybe<Scalars["String"]["output"]>;
    name?: Maybe<Scalars["String"]["output"]>;
    payee_address?: Maybe<Scalars["String"]["output"]>;
    royalty_points_denominator?: Maybe<Scalars["numeric"]["output"]>;
    royalty_points_numerator?: Maybe<Scalars["numeric"]["output"]>;
    supply?: Maybe<Scalars["numeric"]["output"]>;
    token_data_id_hash?: Maybe<Scalars["String"]["output"]>;
    transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};
/** aggregate min on columns */
type TokenDatasMinFields = {
    collection_data_id_hash?: Maybe<Scalars["String"]["output"]>;
    collection_name?: Maybe<Scalars["String"]["output"]>;
    creator_address?: Maybe<Scalars["String"]["output"]>;
    description?: Maybe<Scalars["String"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    largest_property_version?: Maybe<Scalars["numeric"]["output"]>;
    maximum?: Maybe<Scalars["numeric"]["output"]>;
    metadata_uri?: Maybe<Scalars["String"]["output"]>;
    name?: Maybe<Scalars["String"]["output"]>;
    payee_address?: Maybe<Scalars["String"]["output"]>;
    royalty_points_denominator?: Maybe<Scalars["numeric"]["output"]>;
    royalty_points_numerator?: Maybe<Scalars["numeric"]["output"]>;
    supply?: Maybe<Scalars["numeric"]["output"]>;
    token_data_id_hash?: Maybe<Scalars["String"]["output"]>;
    transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};
/** response of any mutation on the table "token_datas" */
type TokenDatasMutationResponse = {
    /** number of rows affected by the mutation */
    affected_rows: Scalars["Int"]["output"];
    /** data from the rows affected by the mutation */
    returning: Array<TokenDatas>;
};
/** on_conflict condition type for table "token_datas" */
type TokenDatasOnConflict = {
    constraint: TokenDatasConstraint;
    update_columns?: Array<TokenDatasUpdateColumn>;
    where?: InputMaybe<TokenDatasBoolExp>;
};
/** Ordering options when selecting data from "token_datas". */
type TokenDatasOrderBy = {
    collection_data_id_hash?: InputMaybe<OrderBy>;
    collection_name?: InputMaybe<OrderBy>;
    creator_address?: InputMaybe<OrderBy>;
    default_properties?: InputMaybe<OrderBy>;
    description?: InputMaybe<OrderBy>;
    description_mutable?: InputMaybe<OrderBy>;
    inserted_at?: InputMaybe<OrderBy>;
    largest_property_version?: InputMaybe<OrderBy>;
    maximum?: InputMaybe<OrderBy>;
    maximum_mutable?: InputMaybe<OrderBy>;
    metadata_uri?: InputMaybe<OrderBy>;
    name?: InputMaybe<OrderBy>;
    payee_address?: InputMaybe<OrderBy>;
    properties_mutable?: InputMaybe<OrderBy>;
    royalty_mutable?: InputMaybe<OrderBy>;
    royalty_points_denominator?: InputMaybe<OrderBy>;
    royalty_points_numerator?: InputMaybe<OrderBy>;
    supply?: InputMaybe<OrderBy>;
    token_data_id_hash?: InputMaybe<OrderBy>;
    transaction_timestamp?: InputMaybe<OrderBy>;
    transaction_version?: InputMaybe<OrderBy>;
    uri_mutable?: InputMaybe<OrderBy>;
};
/** primary key columns input for table: token_datas */
type TokenDatasPkColumnsInput = {
    token_data_id_hash: Scalars["String"]["input"];
    transaction_version: Scalars["bigint"]["input"];
};
/** prepend existing jsonb value of filtered columns with new jsonb value */
type TokenDatasPrependInput = {
    default_properties?: InputMaybe<Scalars["jsonb"]["input"]>;
};
/** select columns of table "token_datas" */
declare enum TokenDatasSelectColumn {
    /** column name */
    CollectionDataIdHash = "collection_data_id_hash",
    /** column name */
    CollectionName = "collection_name",
    /** column name */
    CreatorAddress = "creator_address",
    /** column name */
    DefaultProperties = "default_properties",
    /** column name */
    Description = "description",
    /** column name */
    DescriptionMutable = "description_mutable",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    LargestPropertyVersion = "largest_property_version",
    /** column name */
    Maximum = "maximum",
    /** column name */
    MaximumMutable = "maximum_mutable",
    /** column name */
    MetadataUri = "metadata_uri",
    /** column name */
    Name = "name",
    /** column name */
    PayeeAddress = "payee_address",
    /** column name */
    PropertiesMutable = "properties_mutable",
    /** column name */
    RoyaltyMutable = "royalty_mutable",
    /** column name */
    RoyaltyPointsDenominator = "royalty_points_denominator",
    /** column name */
    RoyaltyPointsNumerator = "royalty_points_numerator",
    /** column name */
    Supply = "supply",
    /** column name */
    TokenDataIdHash = "token_data_id_hash",
    /** column name */
    TransactionTimestamp = "transaction_timestamp",
    /** column name */
    TransactionVersion = "transaction_version",
    /** column name */
    UriMutable = "uri_mutable"
}
/** input type for updating data in table "token_datas" */
type TokenDatasSetInput = {
    collection_data_id_hash?: InputMaybe<Scalars["String"]["input"]>;
    collection_name?: InputMaybe<Scalars["String"]["input"]>;
    creator_address?: InputMaybe<Scalars["String"]["input"]>;
    default_properties?: InputMaybe<Scalars["jsonb"]["input"]>;
    description?: InputMaybe<Scalars["String"]["input"]>;
    description_mutable?: InputMaybe<Scalars["Boolean"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    largest_property_version?: InputMaybe<Scalars["numeric"]["input"]>;
    maximum?: InputMaybe<Scalars["numeric"]["input"]>;
    maximum_mutable?: InputMaybe<Scalars["Boolean"]["input"]>;
    metadata_uri?: InputMaybe<Scalars["String"]["input"]>;
    name?: InputMaybe<Scalars["String"]["input"]>;
    payee_address?: InputMaybe<Scalars["String"]["input"]>;
    properties_mutable?: InputMaybe<Scalars["Boolean"]["input"]>;
    royalty_mutable?: InputMaybe<Scalars["Boolean"]["input"]>;
    royalty_points_denominator?: InputMaybe<Scalars["numeric"]["input"]>;
    royalty_points_numerator?: InputMaybe<Scalars["numeric"]["input"]>;
    supply?: InputMaybe<Scalars["numeric"]["input"]>;
    token_data_id_hash?: InputMaybe<Scalars["String"]["input"]>;
    transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    uri_mutable?: InputMaybe<Scalars["Boolean"]["input"]>;
};
/** aggregate stddev on columns */
type TokenDatasStddevFields = {
    largest_property_version?: Maybe<Scalars["Float"]["output"]>;
    maximum?: Maybe<Scalars["Float"]["output"]>;
    royalty_points_denominator?: Maybe<Scalars["Float"]["output"]>;
    royalty_points_numerator?: Maybe<Scalars["Float"]["output"]>;
    supply?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_pop on columns */
type TokenDatasStddevPopFields = {
    largest_property_version?: Maybe<Scalars["Float"]["output"]>;
    maximum?: Maybe<Scalars["Float"]["output"]>;
    royalty_points_denominator?: Maybe<Scalars["Float"]["output"]>;
    royalty_points_numerator?: Maybe<Scalars["Float"]["output"]>;
    supply?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_samp on columns */
type TokenDatasStddevSampFields = {
    largest_property_version?: Maybe<Scalars["Float"]["output"]>;
    maximum?: Maybe<Scalars["Float"]["output"]>;
    royalty_points_denominator?: Maybe<Scalars["Float"]["output"]>;
    royalty_points_numerator?: Maybe<Scalars["Float"]["output"]>;
    supply?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** Streaming cursor of the table "token_datas" */
type TokenDatasStreamCursorInput = {
    /** Stream column input with initial value */
    initial_value: TokenDatasStreamCursorValueInput;
    /** cursor ordering */
    ordering?: InputMaybe<CursorOrdering>;
};
/** Initial value of the column from where the streaming should start */
type TokenDatasStreamCursorValueInput = {
    collection_data_id_hash?: InputMaybe<Scalars["String"]["input"]>;
    collection_name?: InputMaybe<Scalars["String"]["input"]>;
    creator_address?: InputMaybe<Scalars["String"]["input"]>;
    default_properties?: InputMaybe<Scalars["jsonb"]["input"]>;
    description?: InputMaybe<Scalars["String"]["input"]>;
    description_mutable?: InputMaybe<Scalars["Boolean"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    largest_property_version?: InputMaybe<Scalars["numeric"]["input"]>;
    maximum?: InputMaybe<Scalars["numeric"]["input"]>;
    maximum_mutable?: InputMaybe<Scalars["Boolean"]["input"]>;
    metadata_uri?: InputMaybe<Scalars["String"]["input"]>;
    name?: InputMaybe<Scalars["String"]["input"]>;
    payee_address?: InputMaybe<Scalars["String"]["input"]>;
    properties_mutable?: InputMaybe<Scalars["Boolean"]["input"]>;
    royalty_mutable?: InputMaybe<Scalars["Boolean"]["input"]>;
    royalty_points_denominator?: InputMaybe<Scalars["numeric"]["input"]>;
    royalty_points_numerator?: InputMaybe<Scalars["numeric"]["input"]>;
    supply?: InputMaybe<Scalars["numeric"]["input"]>;
    token_data_id_hash?: InputMaybe<Scalars["String"]["input"]>;
    transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    uri_mutable?: InputMaybe<Scalars["Boolean"]["input"]>;
};
/** aggregate sum on columns */
type TokenDatasSumFields = {
    largest_property_version?: Maybe<Scalars["numeric"]["output"]>;
    maximum?: Maybe<Scalars["numeric"]["output"]>;
    royalty_points_denominator?: Maybe<Scalars["numeric"]["output"]>;
    royalty_points_numerator?: Maybe<Scalars["numeric"]["output"]>;
    supply?: Maybe<Scalars["numeric"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};
/** update columns of table "token_datas" */
declare enum TokenDatasUpdateColumn {
    /** column name */
    CollectionDataIdHash = "collection_data_id_hash",
    /** column name */
    CollectionName = "collection_name",
    /** column name */
    CreatorAddress = "creator_address",
    /** column name */
    DefaultProperties = "default_properties",
    /** column name */
    Description = "description",
    /** column name */
    DescriptionMutable = "description_mutable",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    LargestPropertyVersion = "largest_property_version",
    /** column name */
    Maximum = "maximum",
    /** column name */
    MaximumMutable = "maximum_mutable",
    /** column name */
    MetadataUri = "metadata_uri",
    /** column name */
    Name = "name",
    /** column name */
    PayeeAddress = "payee_address",
    /** column name */
    PropertiesMutable = "properties_mutable",
    /** column name */
    RoyaltyMutable = "royalty_mutable",
    /** column name */
    RoyaltyPointsDenominator = "royalty_points_denominator",
    /** column name */
    RoyaltyPointsNumerator = "royalty_points_numerator",
    /** column name */
    Supply = "supply",
    /** column name */
    TokenDataIdHash = "token_data_id_hash",
    /** column name */
    TransactionTimestamp = "transaction_timestamp",
    /** column name */
    TransactionVersion = "transaction_version",
    /** column name */
    UriMutable = "uri_mutable"
}
type TokenDatasUpdates = {
    /** append existing jsonb value of filtered columns with new jsonb value */
    _append?: InputMaybe<TokenDatasAppendInput>;
    /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
    _delete_at_path?: InputMaybe<TokenDatasDeleteAtPathInput>;
    /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
    _delete_elem?: InputMaybe<TokenDatasDeleteElemInput>;
    /** delete key/value pair or string element. key/value pairs are matched based on their key value */
    _delete_key?: InputMaybe<TokenDatasDeleteKeyInput>;
    /** increments the numeric columns with given value of the filtered values */
    _inc?: InputMaybe<TokenDatasIncInput>;
    /** prepend existing jsonb value of filtered columns with new jsonb value */
    _prepend?: InputMaybe<TokenDatasPrependInput>;
    /** sets the columns of the filtered rows to the given values */
    _set?: InputMaybe<TokenDatasSetInput>;
    /** filter the rows which have to be updated */
    where: TokenDatasBoolExp;
};
/** columns and relationships of "token_datas_v2" */
type TokenDatasV2 = {
    collection_id: Scalars["String"]["output"];
    decimals?: Maybe<Scalars["bigint"]["output"]>;
    description: Scalars["String"]["output"];
    inserted_at: Scalars["timestamp"]["output"];
    is_deleted_v2?: Maybe<Scalars["Boolean"]["output"]>;
    is_fungible_v2?: Maybe<Scalars["Boolean"]["output"]>;
    largest_property_version_v1?: Maybe<Scalars["numeric"]["output"]>;
    maximum?: Maybe<Scalars["numeric"]["output"]>;
    supply?: Maybe<Scalars["numeric"]["output"]>;
    token_data_id: Scalars["String"]["output"];
    token_name: Scalars["String"]["output"];
    token_properties: Scalars["jsonb"]["output"];
    token_standard: Scalars["String"]["output"];
    token_uri: Scalars["String"]["output"];
    transaction_timestamp: Scalars["timestamp"]["output"];
    transaction_version: Scalars["bigint"]["output"];
    write_set_change_index: Scalars["bigint"]["output"];
};
/** columns and relationships of "token_datas_v2" */
type TokenDatasV2TokenPropertiesArgs = {
    path?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregated selection of "token_datas_v2" */
type TokenDatasV2Aggregate = {
    aggregate?: Maybe<TokenDatasV2AggregateFields>;
    nodes: Array<TokenDatasV2>;
};
/** aggregate fields of "token_datas_v2" */
type TokenDatasV2AggregateFields = {
    avg?: Maybe<TokenDatasV2AvgFields>;
    count: Scalars["Int"]["output"];
    max?: Maybe<TokenDatasV2MaxFields>;
    min?: Maybe<TokenDatasV2MinFields>;
    stddev?: Maybe<TokenDatasV2StddevFields>;
    stddev_pop?: Maybe<TokenDatasV2StddevPopFields>;
    stddev_samp?: Maybe<TokenDatasV2StddevSampFields>;
    sum?: Maybe<TokenDatasV2SumFields>;
    var_pop?: Maybe<TokenDatasV2VarPopFields>;
    var_samp?: Maybe<TokenDatasV2VarSampFields>;
    variance?: Maybe<TokenDatasV2VarianceFields>;
};
/** aggregate fields of "token_datas_v2" */
type TokenDatasV2AggregateFieldsCountArgs = {
    columns?: InputMaybe<Array<TokenDatasV2SelectColumn>>;
    distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};
/** append existing jsonb value of filtered columns with new jsonb value */
type TokenDatasV2AppendInput = {
    token_properties?: InputMaybe<Scalars["jsonb"]["input"]>;
};
/** aggregate avg on columns */
type TokenDatasV2AvgFields = {
    decimals?: Maybe<Scalars["Float"]["output"]>;
    largest_property_version_v1?: Maybe<Scalars["Float"]["output"]>;
    maximum?: Maybe<Scalars["Float"]["output"]>;
    supply?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};
/** Boolean expression to filter rows from the table "token_datas_v2". All fields are combined with a logical 'AND'. */
type TokenDatasV2BoolExp = {
    _and?: InputMaybe<Array<TokenDatasV2BoolExp>>;
    _not?: InputMaybe<TokenDatasV2BoolExp>;
    _or?: InputMaybe<Array<TokenDatasV2BoolExp>>;
    collection_id?: InputMaybe<StringComparisonExp>;
    decimals?: InputMaybe<BigintComparisonExp>;
    description?: InputMaybe<StringComparisonExp>;
    inserted_at?: InputMaybe<TimestampComparisonExp>;
    is_deleted_v2?: InputMaybe<BooleanComparisonExp>;
    is_fungible_v2?: InputMaybe<BooleanComparisonExp>;
    largest_property_version_v1?: InputMaybe<NumericComparisonExp>;
    maximum?: InputMaybe<NumericComparisonExp>;
    supply?: InputMaybe<NumericComparisonExp>;
    token_data_id?: InputMaybe<StringComparisonExp>;
    token_name?: InputMaybe<StringComparisonExp>;
    token_properties?: InputMaybe<JsonbComparisonExp>;
    token_standard?: InputMaybe<StringComparisonExp>;
    token_uri?: InputMaybe<StringComparisonExp>;
    transaction_timestamp?: InputMaybe<TimestampComparisonExp>;
    transaction_version?: InputMaybe<BigintComparisonExp>;
    write_set_change_index?: InputMaybe<BigintComparisonExp>;
};
/** unique or primary key constraints on table "token_datas_v2" */
declare enum TokenDatasV2Constraint {
    /** unique or primary key constraint on columns "write_set_change_index", "transaction_version" */
    TokenDatasV2Pkey = "token_datas_v2_pkey"
}
/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
type TokenDatasV2DeleteAtPathInput = {
    token_properties?: InputMaybe<Array<Scalars["String"]["input"]>>;
};
/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
type TokenDatasV2DeleteElemInput = {
    token_properties?: InputMaybe<Scalars["Int"]["input"]>;
};
/** delete key/value pair or string element. key/value pairs are matched based on their key value */
type TokenDatasV2DeleteKeyInput = {
    token_properties?: InputMaybe<Scalars["String"]["input"]>;
};
/** input type for incrementing numeric columns in table "token_datas_v2" */
type TokenDatasV2IncInput = {
    decimals?: InputMaybe<Scalars["bigint"]["input"]>;
    largest_property_version_v1?: InputMaybe<Scalars["numeric"]["input"]>;
    maximum?: InputMaybe<Scalars["numeric"]["input"]>;
    supply?: InputMaybe<Scalars["numeric"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** input type for inserting data into table "token_datas_v2" */
type TokenDatasV2InsertInput = {
    collection_id?: InputMaybe<Scalars["String"]["input"]>;
    decimals?: InputMaybe<Scalars["bigint"]["input"]>;
    description?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    is_deleted_v2?: InputMaybe<Scalars["Boolean"]["input"]>;
    is_fungible_v2?: InputMaybe<Scalars["Boolean"]["input"]>;
    largest_property_version_v1?: InputMaybe<Scalars["numeric"]["input"]>;
    maximum?: InputMaybe<Scalars["numeric"]["input"]>;
    supply?: InputMaybe<Scalars["numeric"]["input"]>;
    token_data_id?: InputMaybe<Scalars["String"]["input"]>;
    token_name?: InputMaybe<Scalars["String"]["input"]>;
    token_properties?: InputMaybe<Scalars["jsonb"]["input"]>;
    token_standard?: InputMaybe<Scalars["String"]["input"]>;
    token_uri?: InputMaybe<Scalars["String"]["input"]>;
    transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** aggregate max on columns */
type TokenDatasV2MaxFields = {
    collection_id?: Maybe<Scalars["String"]["output"]>;
    decimals?: Maybe<Scalars["bigint"]["output"]>;
    description?: Maybe<Scalars["String"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    largest_property_version_v1?: Maybe<Scalars["numeric"]["output"]>;
    maximum?: Maybe<Scalars["numeric"]["output"]>;
    supply?: Maybe<Scalars["numeric"]["output"]>;
    token_data_id?: Maybe<Scalars["String"]["output"]>;
    token_name?: Maybe<Scalars["String"]["output"]>;
    token_standard?: Maybe<Scalars["String"]["output"]>;
    token_uri?: Maybe<Scalars["String"]["output"]>;
    transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    write_set_change_index?: Maybe<Scalars["bigint"]["output"]>;
};
/** aggregate min on columns */
type TokenDatasV2MinFields = {
    collection_id?: Maybe<Scalars["String"]["output"]>;
    decimals?: Maybe<Scalars["bigint"]["output"]>;
    description?: Maybe<Scalars["String"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    largest_property_version_v1?: Maybe<Scalars["numeric"]["output"]>;
    maximum?: Maybe<Scalars["numeric"]["output"]>;
    supply?: Maybe<Scalars["numeric"]["output"]>;
    token_data_id?: Maybe<Scalars["String"]["output"]>;
    token_name?: Maybe<Scalars["String"]["output"]>;
    token_standard?: Maybe<Scalars["String"]["output"]>;
    token_uri?: Maybe<Scalars["String"]["output"]>;
    transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    write_set_change_index?: Maybe<Scalars["bigint"]["output"]>;
};
/** response of any mutation on the table "token_datas_v2" */
type TokenDatasV2MutationResponse = {
    /** number of rows affected by the mutation */
    affected_rows: Scalars["Int"]["output"];
    /** data from the rows affected by the mutation */
    returning: Array<TokenDatasV2>;
};
/** on_conflict condition type for table "token_datas_v2" */
type TokenDatasV2OnConflict = {
    constraint: TokenDatasV2Constraint;
    update_columns?: Array<TokenDatasV2UpdateColumn>;
    where?: InputMaybe<TokenDatasV2BoolExp>;
};
/** Ordering options when selecting data from "token_datas_v2". */
type TokenDatasV2OrderBy = {
    collection_id?: InputMaybe<OrderBy>;
    decimals?: InputMaybe<OrderBy>;
    description?: InputMaybe<OrderBy>;
    inserted_at?: InputMaybe<OrderBy>;
    is_deleted_v2?: InputMaybe<OrderBy>;
    is_fungible_v2?: InputMaybe<OrderBy>;
    largest_property_version_v1?: InputMaybe<OrderBy>;
    maximum?: InputMaybe<OrderBy>;
    supply?: InputMaybe<OrderBy>;
    token_data_id?: InputMaybe<OrderBy>;
    token_name?: InputMaybe<OrderBy>;
    token_properties?: InputMaybe<OrderBy>;
    token_standard?: InputMaybe<OrderBy>;
    token_uri?: InputMaybe<OrderBy>;
    transaction_timestamp?: InputMaybe<OrderBy>;
    transaction_version?: InputMaybe<OrderBy>;
    write_set_change_index?: InputMaybe<OrderBy>;
};
/** primary key columns input for table: token_datas_v2 */
type TokenDatasV2PkColumnsInput = {
    transaction_version: Scalars["bigint"]["input"];
    write_set_change_index: Scalars["bigint"]["input"];
};
/** prepend existing jsonb value of filtered columns with new jsonb value */
type TokenDatasV2PrependInput = {
    token_properties?: InputMaybe<Scalars["jsonb"]["input"]>;
};
/** select columns of table "token_datas_v2" */
declare enum TokenDatasV2SelectColumn {
    /** column name */
    CollectionId = "collection_id",
    /** column name */
    Decimals = "decimals",
    /** column name */
    Description = "description",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    IsDeletedV2 = "is_deleted_v2",
    /** column name */
    IsFungibleV2 = "is_fungible_v2",
    /** column name */
    LargestPropertyVersionV1 = "largest_property_version_v1",
    /** column name */
    Maximum = "maximum",
    /** column name */
    Supply = "supply",
    /** column name */
    TokenDataId = "token_data_id",
    /** column name */
    TokenName = "token_name",
    /** column name */
    TokenProperties = "token_properties",
    /** column name */
    TokenStandard = "token_standard",
    /** column name */
    TokenUri = "token_uri",
    /** column name */
    TransactionTimestamp = "transaction_timestamp",
    /** column name */
    TransactionVersion = "transaction_version",
    /** column name */
    WriteSetChangeIndex = "write_set_change_index"
}
/** input type for updating data in table "token_datas_v2" */
type TokenDatasV2SetInput = {
    collection_id?: InputMaybe<Scalars["String"]["input"]>;
    decimals?: InputMaybe<Scalars["bigint"]["input"]>;
    description?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    is_deleted_v2?: InputMaybe<Scalars["Boolean"]["input"]>;
    is_fungible_v2?: InputMaybe<Scalars["Boolean"]["input"]>;
    largest_property_version_v1?: InputMaybe<Scalars["numeric"]["input"]>;
    maximum?: InputMaybe<Scalars["numeric"]["input"]>;
    supply?: InputMaybe<Scalars["numeric"]["input"]>;
    token_data_id?: InputMaybe<Scalars["String"]["input"]>;
    token_name?: InputMaybe<Scalars["String"]["input"]>;
    token_properties?: InputMaybe<Scalars["jsonb"]["input"]>;
    token_standard?: InputMaybe<Scalars["String"]["input"]>;
    token_uri?: InputMaybe<Scalars["String"]["input"]>;
    transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** aggregate stddev on columns */
type TokenDatasV2StddevFields = {
    decimals?: Maybe<Scalars["Float"]["output"]>;
    largest_property_version_v1?: Maybe<Scalars["Float"]["output"]>;
    maximum?: Maybe<Scalars["Float"]["output"]>;
    supply?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_pop on columns */
type TokenDatasV2StddevPopFields = {
    decimals?: Maybe<Scalars["Float"]["output"]>;
    largest_property_version_v1?: Maybe<Scalars["Float"]["output"]>;
    maximum?: Maybe<Scalars["Float"]["output"]>;
    supply?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_samp on columns */
type TokenDatasV2StddevSampFields = {
    decimals?: Maybe<Scalars["Float"]["output"]>;
    largest_property_version_v1?: Maybe<Scalars["Float"]["output"]>;
    maximum?: Maybe<Scalars["Float"]["output"]>;
    supply?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};
/** Streaming cursor of the table "token_datas_v2" */
type TokenDatasV2StreamCursorInput = {
    /** Stream column input with initial value */
    initial_value: TokenDatasV2StreamCursorValueInput;
    /** cursor ordering */
    ordering?: InputMaybe<CursorOrdering>;
};
/** Initial value of the column from where the streaming should start */
type TokenDatasV2StreamCursorValueInput = {
    collection_id?: InputMaybe<Scalars["String"]["input"]>;
    decimals?: InputMaybe<Scalars["bigint"]["input"]>;
    description?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    is_deleted_v2?: InputMaybe<Scalars["Boolean"]["input"]>;
    is_fungible_v2?: InputMaybe<Scalars["Boolean"]["input"]>;
    largest_property_version_v1?: InputMaybe<Scalars["numeric"]["input"]>;
    maximum?: InputMaybe<Scalars["numeric"]["input"]>;
    supply?: InputMaybe<Scalars["numeric"]["input"]>;
    token_data_id?: InputMaybe<Scalars["String"]["input"]>;
    token_name?: InputMaybe<Scalars["String"]["input"]>;
    token_properties?: InputMaybe<Scalars["jsonb"]["input"]>;
    token_standard?: InputMaybe<Scalars["String"]["input"]>;
    token_uri?: InputMaybe<Scalars["String"]["input"]>;
    transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** aggregate sum on columns */
type TokenDatasV2SumFields = {
    decimals?: Maybe<Scalars["bigint"]["output"]>;
    largest_property_version_v1?: Maybe<Scalars["numeric"]["output"]>;
    maximum?: Maybe<Scalars["numeric"]["output"]>;
    supply?: Maybe<Scalars["numeric"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    write_set_change_index?: Maybe<Scalars["bigint"]["output"]>;
};
/** update columns of table "token_datas_v2" */
declare enum TokenDatasV2UpdateColumn {
    /** column name */
    CollectionId = "collection_id",
    /** column name */
    Decimals = "decimals",
    /** column name */
    Description = "description",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    IsDeletedV2 = "is_deleted_v2",
    /** column name */
    IsFungibleV2 = "is_fungible_v2",
    /** column name */
    LargestPropertyVersionV1 = "largest_property_version_v1",
    /** column name */
    Maximum = "maximum",
    /** column name */
    Supply = "supply",
    /** column name */
    TokenDataId = "token_data_id",
    /** column name */
    TokenName = "token_name",
    /** column name */
    TokenProperties = "token_properties",
    /** column name */
    TokenStandard = "token_standard",
    /** column name */
    TokenUri = "token_uri",
    /** column name */
    TransactionTimestamp = "transaction_timestamp",
    /** column name */
    TransactionVersion = "transaction_version",
    /** column name */
    WriteSetChangeIndex = "write_set_change_index"
}
type TokenDatasV2Updates = {
    /** append existing jsonb value of filtered columns with new jsonb value */
    _append?: InputMaybe<TokenDatasV2AppendInput>;
    /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
    _delete_at_path?: InputMaybe<TokenDatasV2DeleteAtPathInput>;
    /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
    _delete_elem?: InputMaybe<TokenDatasV2DeleteElemInput>;
    /** delete key/value pair or string element. key/value pairs are matched based on their key value */
    _delete_key?: InputMaybe<TokenDatasV2DeleteKeyInput>;
    /** increments the numeric columns with given value of the filtered values */
    _inc?: InputMaybe<TokenDatasV2IncInput>;
    /** prepend existing jsonb value of filtered columns with new jsonb value */
    _prepend?: InputMaybe<TokenDatasV2PrependInput>;
    /** sets the columns of the filtered rows to the given values */
    _set?: InputMaybe<TokenDatasV2SetInput>;
    /** filter the rows which have to be updated */
    where: TokenDatasV2BoolExp;
};
/** aggregate var_pop on columns */
type TokenDatasV2VarPopFields = {
    decimals?: Maybe<Scalars["Float"]["output"]>;
    largest_property_version_v1?: Maybe<Scalars["Float"]["output"]>;
    maximum?: Maybe<Scalars["Float"]["output"]>;
    supply?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate var_samp on columns */
type TokenDatasV2VarSampFields = {
    decimals?: Maybe<Scalars["Float"]["output"]>;
    largest_property_version_v1?: Maybe<Scalars["Float"]["output"]>;
    maximum?: Maybe<Scalars["Float"]["output"]>;
    supply?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate variance on columns */
type TokenDatasV2VarianceFields = {
    decimals?: Maybe<Scalars["Float"]["output"]>;
    largest_property_version_v1?: Maybe<Scalars["Float"]["output"]>;
    maximum?: Maybe<Scalars["Float"]["output"]>;
    supply?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate var_pop on columns */
type TokenDatasVarPopFields = {
    largest_property_version?: Maybe<Scalars["Float"]["output"]>;
    maximum?: Maybe<Scalars["Float"]["output"]>;
    royalty_points_denominator?: Maybe<Scalars["Float"]["output"]>;
    royalty_points_numerator?: Maybe<Scalars["Float"]["output"]>;
    supply?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate var_samp on columns */
type TokenDatasVarSampFields = {
    largest_property_version?: Maybe<Scalars["Float"]["output"]>;
    maximum?: Maybe<Scalars["Float"]["output"]>;
    royalty_points_denominator?: Maybe<Scalars["Float"]["output"]>;
    royalty_points_numerator?: Maybe<Scalars["Float"]["output"]>;
    supply?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate variance on columns */
type TokenDatasVarianceFields = {
    largest_property_version?: Maybe<Scalars["Float"]["output"]>;
    maximum?: Maybe<Scalars["Float"]["output"]>;
    royalty_points_denominator?: Maybe<Scalars["Float"]["output"]>;
    royalty_points_numerator?: Maybe<Scalars["Float"]["output"]>;
    supply?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** columns and relationships of "token_ownerships" */
type TokenOwnerships = {
    amount: Scalars["numeric"]["output"];
    collection_data_id_hash: Scalars["String"]["output"];
    collection_name: Scalars["String"]["output"];
    creator_address: Scalars["String"]["output"];
    inserted_at: Scalars["timestamp"]["output"];
    name: Scalars["String"]["output"];
    owner_address?: Maybe<Scalars["String"]["output"]>;
    property_version: Scalars["numeric"]["output"];
    table_handle: Scalars["String"]["output"];
    table_type?: Maybe<Scalars["String"]["output"]>;
    token_data_id_hash: Scalars["String"]["output"];
    transaction_timestamp: Scalars["timestamp"]["output"];
    transaction_version: Scalars["bigint"]["output"];
};
/** aggregated selection of "token_ownerships" */
type TokenOwnershipsAggregate = {
    aggregate?: Maybe<TokenOwnershipsAggregateFields>;
    nodes: Array<TokenOwnerships>;
};
/** aggregate fields of "token_ownerships" */
type TokenOwnershipsAggregateFields = {
    avg?: Maybe<TokenOwnershipsAvgFields>;
    count: Scalars["Int"]["output"];
    max?: Maybe<TokenOwnershipsMaxFields>;
    min?: Maybe<TokenOwnershipsMinFields>;
    stddev?: Maybe<TokenOwnershipsStddevFields>;
    stddev_pop?: Maybe<TokenOwnershipsStddevPopFields>;
    stddev_samp?: Maybe<TokenOwnershipsStddevSampFields>;
    sum?: Maybe<TokenOwnershipsSumFields>;
    var_pop?: Maybe<TokenOwnershipsVarPopFields>;
    var_samp?: Maybe<TokenOwnershipsVarSampFields>;
    variance?: Maybe<TokenOwnershipsVarianceFields>;
};
/** aggregate fields of "token_ownerships" */
type TokenOwnershipsAggregateFieldsCountArgs = {
    columns?: InputMaybe<Array<TokenOwnershipsSelectColumn>>;
    distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};
/** aggregate avg on columns */
type TokenOwnershipsAvgFields = {
    amount?: Maybe<Scalars["Float"]["output"]>;
    property_version?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** Boolean expression to filter rows from the table "token_ownerships". All fields are combined with a logical 'AND'. */
type TokenOwnershipsBoolExp = {
    _and?: InputMaybe<Array<TokenOwnershipsBoolExp>>;
    _not?: InputMaybe<TokenOwnershipsBoolExp>;
    _or?: InputMaybe<Array<TokenOwnershipsBoolExp>>;
    amount?: InputMaybe<NumericComparisonExp>;
    collection_data_id_hash?: InputMaybe<StringComparisonExp>;
    collection_name?: InputMaybe<StringComparisonExp>;
    creator_address?: InputMaybe<StringComparisonExp>;
    inserted_at?: InputMaybe<TimestampComparisonExp>;
    name?: InputMaybe<StringComparisonExp>;
    owner_address?: InputMaybe<StringComparisonExp>;
    property_version?: InputMaybe<NumericComparisonExp>;
    table_handle?: InputMaybe<StringComparisonExp>;
    table_type?: InputMaybe<StringComparisonExp>;
    token_data_id_hash?: InputMaybe<StringComparisonExp>;
    transaction_timestamp?: InputMaybe<TimestampComparisonExp>;
    transaction_version?: InputMaybe<BigintComparisonExp>;
};
/** unique or primary key constraints on table "token_ownerships" */
declare enum TokenOwnershipsConstraint {
    /** unique or primary key constraint on columns "property_version", "table_handle", "token_data_id_hash", "transaction_version" */
    TokenOwnershipsPkey = "token_ownerships_pkey"
}
/** input type for incrementing numeric columns in table "token_ownerships" */
type TokenOwnershipsIncInput = {
    amount?: InputMaybe<Scalars["numeric"]["input"]>;
    property_version?: InputMaybe<Scalars["numeric"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** input type for inserting data into table "token_ownerships" */
type TokenOwnershipsInsertInput = {
    amount?: InputMaybe<Scalars["numeric"]["input"]>;
    collection_data_id_hash?: InputMaybe<Scalars["String"]["input"]>;
    collection_name?: InputMaybe<Scalars["String"]["input"]>;
    creator_address?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    name?: InputMaybe<Scalars["String"]["input"]>;
    owner_address?: InputMaybe<Scalars["String"]["input"]>;
    property_version?: InputMaybe<Scalars["numeric"]["input"]>;
    table_handle?: InputMaybe<Scalars["String"]["input"]>;
    table_type?: InputMaybe<Scalars["String"]["input"]>;
    token_data_id_hash?: InputMaybe<Scalars["String"]["input"]>;
    transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** aggregate max on columns */
type TokenOwnershipsMaxFields = {
    amount?: Maybe<Scalars["numeric"]["output"]>;
    collection_data_id_hash?: Maybe<Scalars["String"]["output"]>;
    collection_name?: Maybe<Scalars["String"]["output"]>;
    creator_address?: Maybe<Scalars["String"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    name?: Maybe<Scalars["String"]["output"]>;
    owner_address?: Maybe<Scalars["String"]["output"]>;
    property_version?: Maybe<Scalars["numeric"]["output"]>;
    table_handle?: Maybe<Scalars["String"]["output"]>;
    table_type?: Maybe<Scalars["String"]["output"]>;
    token_data_id_hash?: Maybe<Scalars["String"]["output"]>;
    transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};
/** aggregate min on columns */
type TokenOwnershipsMinFields = {
    amount?: Maybe<Scalars["numeric"]["output"]>;
    collection_data_id_hash?: Maybe<Scalars["String"]["output"]>;
    collection_name?: Maybe<Scalars["String"]["output"]>;
    creator_address?: Maybe<Scalars["String"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    name?: Maybe<Scalars["String"]["output"]>;
    owner_address?: Maybe<Scalars["String"]["output"]>;
    property_version?: Maybe<Scalars["numeric"]["output"]>;
    table_handle?: Maybe<Scalars["String"]["output"]>;
    table_type?: Maybe<Scalars["String"]["output"]>;
    token_data_id_hash?: Maybe<Scalars["String"]["output"]>;
    transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};
/** response of any mutation on the table "token_ownerships" */
type TokenOwnershipsMutationResponse = {
    /** number of rows affected by the mutation */
    affected_rows: Scalars["Int"]["output"];
    /** data from the rows affected by the mutation */
    returning: Array<TokenOwnerships>;
};
/** on_conflict condition type for table "token_ownerships" */
type TokenOwnershipsOnConflict = {
    constraint: TokenOwnershipsConstraint;
    update_columns?: Array<TokenOwnershipsUpdateColumn>;
    where?: InputMaybe<TokenOwnershipsBoolExp>;
};
/** Ordering options when selecting data from "token_ownerships". */
type TokenOwnershipsOrderBy = {
    amount?: InputMaybe<OrderBy>;
    collection_data_id_hash?: InputMaybe<OrderBy>;
    collection_name?: InputMaybe<OrderBy>;
    creator_address?: InputMaybe<OrderBy>;
    inserted_at?: InputMaybe<OrderBy>;
    name?: InputMaybe<OrderBy>;
    owner_address?: InputMaybe<OrderBy>;
    property_version?: InputMaybe<OrderBy>;
    table_handle?: InputMaybe<OrderBy>;
    table_type?: InputMaybe<OrderBy>;
    token_data_id_hash?: InputMaybe<OrderBy>;
    transaction_timestamp?: InputMaybe<OrderBy>;
    transaction_version?: InputMaybe<OrderBy>;
};
/** primary key columns input for table: token_ownerships */
type TokenOwnershipsPkColumnsInput = {
    property_version: Scalars["numeric"]["input"];
    table_handle: Scalars["String"]["input"];
    token_data_id_hash: Scalars["String"]["input"];
    transaction_version: Scalars["bigint"]["input"];
};
/** select columns of table "token_ownerships" */
declare enum TokenOwnershipsSelectColumn {
    /** column name */
    Amount = "amount",
    /** column name */
    CollectionDataIdHash = "collection_data_id_hash",
    /** column name */
    CollectionName = "collection_name",
    /** column name */
    CreatorAddress = "creator_address",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    Name = "name",
    /** column name */
    OwnerAddress = "owner_address",
    /** column name */
    PropertyVersion = "property_version",
    /** column name */
    TableHandle = "table_handle",
    /** column name */
    TableType = "table_type",
    /** column name */
    TokenDataIdHash = "token_data_id_hash",
    /** column name */
    TransactionTimestamp = "transaction_timestamp",
    /** column name */
    TransactionVersion = "transaction_version"
}
/** input type for updating data in table "token_ownerships" */
type TokenOwnershipsSetInput = {
    amount?: InputMaybe<Scalars["numeric"]["input"]>;
    collection_data_id_hash?: InputMaybe<Scalars["String"]["input"]>;
    collection_name?: InputMaybe<Scalars["String"]["input"]>;
    creator_address?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    name?: InputMaybe<Scalars["String"]["input"]>;
    owner_address?: InputMaybe<Scalars["String"]["input"]>;
    property_version?: InputMaybe<Scalars["numeric"]["input"]>;
    table_handle?: InputMaybe<Scalars["String"]["input"]>;
    table_type?: InputMaybe<Scalars["String"]["input"]>;
    token_data_id_hash?: InputMaybe<Scalars["String"]["input"]>;
    transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** aggregate stddev on columns */
type TokenOwnershipsStddevFields = {
    amount?: Maybe<Scalars["Float"]["output"]>;
    property_version?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_pop on columns */
type TokenOwnershipsStddevPopFields = {
    amount?: Maybe<Scalars["Float"]["output"]>;
    property_version?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_samp on columns */
type TokenOwnershipsStddevSampFields = {
    amount?: Maybe<Scalars["Float"]["output"]>;
    property_version?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** Streaming cursor of the table "token_ownerships" */
type TokenOwnershipsStreamCursorInput = {
    /** Stream column input with initial value */
    initial_value: TokenOwnershipsStreamCursorValueInput;
    /** cursor ordering */
    ordering?: InputMaybe<CursorOrdering>;
};
/** Initial value of the column from where the streaming should start */
type TokenOwnershipsStreamCursorValueInput = {
    amount?: InputMaybe<Scalars["numeric"]["input"]>;
    collection_data_id_hash?: InputMaybe<Scalars["String"]["input"]>;
    collection_name?: InputMaybe<Scalars["String"]["input"]>;
    creator_address?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    name?: InputMaybe<Scalars["String"]["input"]>;
    owner_address?: InputMaybe<Scalars["String"]["input"]>;
    property_version?: InputMaybe<Scalars["numeric"]["input"]>;
    table_handle?: InputMaybe<Scalars["String"]["input"]>;
    table_type?: InputMaybe<Scalars["String"]["input"]>;
    token_data_id_hash?: InputMaybe<Scalars["String"]["input"]>;
    transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** aggregate sum on columns */
type TokenOwnershipsSumFields = {
    amount?: Maybe<Scalars["numeric"]["output"]>;
    property_version?: Maybe<Scalars["numeric"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};
/** update columns of table "token_ownerships" */
declare enum TokenOwnershipsUpdateColumn {
    /** column name */
    Amount = "amount",
    /** column name */
    CollectionDataIdHash = "collection_data_id_hash",
    /** column name */
    CollectionName = "collection_name",
    /** column name */
    CreatorAddress = "creator_address",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    Name = "name",
    /** column name */
    OwnerAddress = "owner_address",
    /** column name */
    PropertyVersion = "property_version",
    /** column name */
    TableHandle = "table_handle",
    /** column name */
    TableType = "table_type",
    /** column name */
    TokenDataIdHash = "token_data_id_hash",
    /** column name */
    TransactionTimestamp = "transaction_timestamp",
    /** column name */
    TransactionVersion = "transaction_version"
}
type TokenOwnershipsUpdates = {
    /** increments the numeric columns with given value of the filtered values */
    _inc?: InputMaybe<TokenOwnershipsIncInput>;
    /** sets the columns of the filtered rows to the given values */
    _set?: InputMaybe<TokenOwnershipsSetInput>;
    /** filter the rows which have to be updated */
    where: TokenOwnershipsBoolExp;
};
/** columns and relationships of "token_ownerships_v2" */
type TokenOwnershipsV2 = {
    amount: Scalars["numeric"]["output"];
    inserted_at: Scalars["timestamp"]["output"];
    is_fungible_v2?: Maybe<Scalars["Boolean"]["output"]>;
    is_soulbound_v2?: Maybe<Scalars["Boolean"]["output"]>;
    non_transferrable_by_owner?: Maybe<Scalars["Boolean"]["output"]>;
    owner_address?: Maybe<Scalars["String"]["output"]>;
    property_version_v1: Scalars["numeric"]["output"];
    storage_id: Scalars["String"]["output"];
    table_type_v1?: Maybe<Scalars["String"]["output"]>;
    token_data_id: Scalars["String"]["output"];
    token_properties_mutated_v1?: Maybe<Scalars["jsonb"]["output"]>;
    token_standard: Scalars["String"]["output"];
    transaction_timestamp: Scalars["timestamp"]["output"];
    transaction_version: Scalars["bigint"]["output"];
    write_set_change_index: Scalars["bigint"]["output"];
};
/** columns and relationships of "token_ownerships_v2" */
type TokenOwnershipsV2TokenPropertiesMutatedV1Args = {
    path?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregated selection of "token_ownerships_v2" */
type TokenOwnershipsV2Aggregate = {
    aggregate?: Maybe<TokenOwnershipsV2AggregateFields>;
    nodes: Array<TokenOwnershipsV2>;
};
/** aggregate fields of "token_ownerships_v2" */
type TokenOwnershipsV2AggregateFields = {
    avg?: Maybe<TokenOwnershipsV2AvgFields>;
    count: Scalars["Int"]["output"];
    max?: Maybe<TokenOwnershipsV2MaxFields>;
    min?: Maybe<TokenOwnershipsV2MinFields>;
    stddev?: Maybe<TokenOwnershipsV2StddevFields>;
    stddev_pop?: Maybe<TokenOwnershipsV2StddevPopFields>;
    stddev_samp?: Maybe<TokenOwnershipsV2StddevSampFields>;
    sum?: Maybe<TokenOwnershipsV2SumFields>;
    var_pop?: Maybe<TokenOwnershipsV2VarPopFields>;
    var_samp?: Maybe<TokenOwnershipsV2VarSampFields>;
    variance?: Maybe<TokenOwnershipsV2VarianceFields>;
};
/** aggregate fields of "token_ownerships_v2" */
type TokenOwnershipsV2AggregateFieldsCountArgs = {
    columns?: InputMaybe<Array<TokenOwnershipsV2SelectColumn>>;
    distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};
/** append existing jsonb value of filtered columns with new jsonb value */
type TokenOwnershipsV2AppendInput = {
    token_properties_mutated_v1?: InputMaybe<Scalars["jsonb"]["input"]>;
};
/** aggregate avg on columns */
type TokenOwnershipsV2AvgFields = {
    amount?: Maybe<Scalars["Float"]["output"]>;
    property_version_v1?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};
/** Boolean expression to filter rows from the table "token_ownerships_v2". All fields are combined with a logical 'AND'. */
type TokenOwnershipsV2BoolExp = {
    _and?: InputMaybe<Array<TokenOwnershipsV2BoolExp>>;
    _not?: InputMaybe<TokenOwnershipsV2BoolExp>;
    _or?: InputMaybe<Array<TokenOwnershipsV2BoolExp>>;
    amount?: InputMaybe<NumericComparisonExp>;
    inserted_at?: InputMaybe<TimestampComparisonExp>;
    is_fungible_v2?: InputMaybe<BooleanComparisonExp>;
    is_soulbound_v2?: InputMaybe<BooleanComparisonExp>;
    non_transferrable_by_owner?: InputMaybe<BooleanComparisonExp>;
    owner_address?: InputMaybe<StringComparisonExp>;
    property_version_v1?: InputMaybe<NumericComparisonExp>;
    storage_id?: InputMaybe<StringComparisonExp>;
    table_type_v1?: InputMaybe<StringComparisonExp>;
    token_data_id?: InputMaybe<StringComparisonExp>;
    token_properties_mutated_v1?: InputMaybe<JsonbComparisonExp>;
    token_standard?: InputMaybe<StringComparisonExp>;
    transaction_timestamp?: InputMaybe<TimestampComparisonExp>;
    transaction_version?: InputMaybe<BigintComparisonExp>;
    write_set_change_index?: InputMaybe<BigintComparisonExp>;
};
/** unique or primary key constraints on table "token_ownerships_v2" */
declare enum TokenOwnershipsV2Constraint {
    /** unique or primary key constraint on columns "write_set_change_index", "transaction_version" */
    TokenOwnershipsV2Pkey = "token_ownerships_v2_pkey"
}
/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
type TokenOwnershipsV2DeleteAtPathInput = {
    token_properties_mutated_v1?: InputMaybe<Array<Scalars["String"]["input"]>>;
};
/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
type TokenOwnershipsV2DeleteElemInput = {
    token_properties_mutated_v1?: InputMaybe<Scalars["Int"]["input"]>;
};
/** delete key/value pair or string element. key/value pairs are matched based on their key value */
type TokenOwnershipsV2DeleteKeyInput = {
    token_properties_mutated_v1?: InputMaybe<Scalars["String"]["input"]>;
};
/** input type for incrementing numeric columns in table "token_ownerships_v2" */
type TokenOwnershipsV2IncInput = {
    amount?: InputMaybe<Scalars["numeric"]["input"]>;
    property_version_v1?: InputMaybe<Scalars["numeric"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** input type for inserting data into table "token_ownerships_v2" */
type TokenOwnershipsV2InsertInput = {
    amount?: InputMaybe<Scalars["numeric"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    is_fungible_v2?: InputMaybe<Scalars["Boolean"]["input"]>;
    is_soulbound_v2?: InputMaybe<Scalars["Boolean"]["input"]>;
    non_transferrable_by_owner?: InputMaybe<Scalars["Boolean"]["input"]>;
    owner_address?: InputMaybe<Scalars["String"]["input"]>;
    property_version_v1?: InputMaybe<Scalars["numeric"]["input"]>;
    storage_id?: InputMaybe<Scalars["String"]["input"]>;
    table_type_v1?: InputMaybe<Scalars["String"]["input"]>;
    token_data_id?: InputMaybe<Scalars["String"]["input"]>;
    token_properties_mutated_v1?: InputMaybe<Scalars["jsonb"]["input"]>;
    token_standard?: InputMaybe<Scalars["String"]["input"]>;
    transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** aggregate max on columns */
type TokenOwnershipsV2MaxFields = {
    amount?: Maybe<Scalars["numeric"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    owner_address?: Maybe<Scalars["String"]["output"]>;
    property_version_v1?: Maybe<Scalars["numeric"]["output"]>;
    storage_id?: Maybe<Scalars["String"]["output"]>;
    table_type_v1?: Maybe<Scalars["String"]["output"]>;
    token_data_id?: Maybe<Scalars["String"]["output"]>;
    token_standard?: Maybe<Scalars["String"]["output"]>;
    transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    write_set_change_index?: Maybe<Scalars["bigint"]["output"]>;
};
/** aggregate min on columns */
type TokenOwnershipsV2MinFields = {
    amount?: Maybe<Scalars["numeric"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    owner_address?: Maybe<Scalars["String"]["output"]>;
    property_version_v1?: Maybe<Scalars["numeric"]["output"]>;
    storage_id?: Maybe<Scalars["String"]["output"]>;
    table_type_v1?: Maybe<Scalars["String"]["output"]>;
    token_data_id?: Maybe<Scalars["String"]["output"]>;
    token_standard?: Maybe<Scalars["String"]["output"]>;
    transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    write_set_change_index?: Maybe<Scalars["bigint"]["output"]>;
};
/** response of any mutation on the table "token_ownerships_v2" */
type TokenOwnershipsV2MutationResponse = {
    /** number of rows affected by the mutation */
    affected_rows: Scalars["Int"]["output"];
    /** data from the rows affected by the mutation */
    returning: Array<TokenOwnershipsV2>;
};
/** on_conflict condition type for table "token_ownerships_v2" */
type TokenOwnershipsV2OnConflict = {
    constraint: TokenOwnershipsV2Constraint;
    update_columns?: Array<TokenOwnershipsV2UpdateColumn>;
    where?: InputMaybe<TokenOwnershipsV2BoolExp>;
};
/** Ordering options when selecting data from "token_ownerships_v2". */
type TokenOwnershipsV2OrderBy = {
    amount?: InputMaybe<OrderBy>;
    inserted_at?: InputMaybe<OrderBy>;
    is_fungible_v2?: InputMaybe<OrderBy>;
    is_soulbound_v2?: InputMaybe<OrderBy>;
    non_transferrable_by_owner?: InputMaybe<OrderBy>;
    owner_address?: InputMaybe<OrderBy>;
    property_version_v1?: InputMaybe<OrderBy>;
    storage_id?: InputMaybe<OrderBy>;
    table_type_v1?: InputMaybe<OrderBy>;
    token_data_id?: InputMaybe<OrderBy>;
    token_properties_mutated_v1?: InputMaybe<OrderBy>;
    token_standard?: InputMaybe<OrderBy>;
    transaction_timestamp?: InputMaybe<OrderBy>;
    transaction_version?: InputMaybe<OrderBy>;
    write_set_change_index?: InputMaybe<OrderBy>;
};
/** primary key columns input for table: token_ownerships_v2 */
type TokenOwnershipsV2PkColumnsInput = {
    transaction_version: Scalars["bigint"]["input"];
    write_set_change_index: Scalars["bigint"]["input"];
};
/** prepend existing jsonb value of filtered columns with new jsonb value */
type TokenOwnershipsV2PrependInput = {
    token_properties_mutated_v1?: InputMaybe<Scalars["jsonb"]["input"]>;
};
/** select columns of table "token_ownerships_v2" */
declare enum TokenOwnershipsV2SelectColumn {
    /** column name */
    Amount = "amount",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    IsFungibleV2 = "is_fungible_v2",
    /** column name */
    IsSoulboundV2 = "is_soulbound_v2",
    /** column name */
    NonTransferrableByOwner = "non_transferrable_by_owner",
    /** column name */
    OwnerAddress = "owner_address",
    /** column name */
    PropertyVersionV1 = "property_version_v1",
    /** column name */
    StorageId = "storage_id",
    /** column name */
    TableTypeV1 = "table_type_v1",
    /** column name */
    TokenDataId = "token_data_id",
    /** column name */
    TokenPropertiesMutatedV1 = "token_properties_mutated_v1",
    /** column name */
    TokenStandard = "token_standard",
    /** column name */
    TransactionTimestamp = "transaction_timestamp",
    /** column name */
    TransactionVersion = "transaction_version",
    /** column name */
    WriteSetChangeIndex = "write_set_change_index"
}
/** input type for updating data in table "token_ownerships_v2" */
type TokenOwnershipsV2SetInput = {
    amount?: InputMaybe<Scalars["numeric"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    is_fungible_v2?: InputMaybe<Scalars["Boolean"]["input"]>;
    is_soulbound_v2?: InputMaybe<Scalars["Boolean"]["input"]>;
    non_transferrable_by_owner?: InputMaybe<Scalars["Boolean"]["input"]>;
    owner_address?: InputMaybe<Scalars["String"]["input"]>;
    property_version_v1?: InputMaybe<Scalars["numeric"]["input"]>;
    storage_id?: InputMaybe<Scalars["String"]["input"]>;
    table_type_v1?: InputMaybe<Scalars["String"]["input"]>;
    token_data_id?: InputMaybe<Scalars["String"]["input"]>;
    token_properties_mutated_v1?: InputMaybe<Scalars["jsonb"]["input"]>;
    token_standard?: InputMaybe<Scalars["String"]["input"]>;
    transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** aggregate stddev on columns */
type TokenOwnershipsV2StddevFields = {
    amount?: Maybe<Scalars["Float"]["output"]>;
    property_version_v1?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_pop on columns */
type TokenOwnershipsV2StddevPopFields = {
    amount?: Maybe<Scalars["Float"]["output"]>;
    property_version_v1?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_samp on columns */
type TokenOwnershipsV2StddevSampFields = {
    amount?: Maybe<Scalars["Float"]["output"]>;
    property_version_v1?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};
/** Streaming cursor of the table "token_ownerships_v2" */
type TokenOwnershipsV2StreamCursorInput = {
    /** Stream column input with initial value */
    initial_value: TokenOwnershipsV2StreamCursorValueInput;
    /** cursor ordering */
    ordering?: InputMaybe<CursorOrdering>;
};
/** Initial value of the column from where the streaming should start */
type TokenOwnershipsV2StreamCursorValueInput = {
    amount?: InputMaybe<Scalars["numeric"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    is_fungible_v2?: InputMaybe<Scalars["Boolean"]["input"]>;
    is_soulbound_v2?: InputMaybe<Scalars["Boolean"]["input"]>;
    non_transferrable_by_owner?: InputMaybe<Scalars["Boolean"]["input"]>;
    owner_address?: InputMaybe<Scalars["String"]["input"]>;
    property_version_v1?: InputMaybe<Scalars["numeric"]["input"]>;
    storage_id?: InputMaybe<Scalars["String"]["input"]>;
    table_type_v1?: InputMaybe<Scalars["String"]["input"]>;
    token_data_id?: InputMaybe<Scalars["String"]["input"]>;
    token_properties_mutated_v1?: InputMaybe<Scalars["jsonb"]["input"]>;
    token_standard?: InputMaybe<Scalars["String"]["input"]>;
    transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
    write_set_change_index?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** aggregate sum on columns */
type TokenOwnershipsV2SumFields = {
    amount?: Maybe<Scalars["numeric"]["output"]>;
    property_version_v1?: Maybe<Scalars["numeric"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
    write_set_change_index?: Maybe<Scalars["bigint"]["output"]>;
};
/** update columns of table "token_ownerships_v2" */
declare enum TokenOwnershipsV2UpdateColumn {
    /** column name */
    Amount = "amount",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    IsFungibleV2 = "is_fungible_v2",
    /** column name */
    IsSoulboundV2 = "is_soulbound_v2",
    /** column name */
    NonTransferrableByOwner = "non_transferrable_by_owner",
    /** column name */
    OwnerAddress = "owner_address",
    /** column name */
    PropertyVersionV1 = "property_version_v1",
    /** column name */
    StorageId = "storage_id",
    /** column name */
    TableTypeV1 = "table_type_v1",
    /** column name */
    TokenDataId = "token_data_id",
    /** column name */
    TokenPropertiesMutatedV1 = "token_properties_mutated_v1",
    /** column name */
    TokenStandard = "token_standard",
    /** column name */
    TransactionTimestamp = "transaction_timestamp",
    /** column name */
    TransactionVersion = "transaction_version",
    /** column name */
    WriteSetChangeIndex = "write_set_change_index"
}
type TokenOwnershipsV2Updates = {
    /** append existing jsonb value of filtered columns with new jsonb value */
    _append?: InputMaybe<TokenOwnershipsV2AppendInput>;
    /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
    _delete_at_path?: InputMaybe<TokenOwnershipsV2DeleteAtPathInput>;
    /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
    _delete_elem?: InputMaybe<TokenOwnershipsV2DeleteElemInput>;
    /** delete key/value pair or string element. key/value pairs are matched based on their key value */
    _delete_key?: InputMaybe<TokenOwnershipsV2DeleteKeyInput>;
    /** increments the numeric columns with given value of the filtered values */
    _inc?: InputMaybe<TokenOwnershipsV2IncInput>;
    /** prepend existing jsonb value of filtered columns with new jsonb value */
    _prepend?: InputMaybe<TokenOwnershipsV2PrependInput>;
    /** sets the columns of the filtered rows to the given values */
    _set?: InputMaybe<TokenOwnershipsV2SetInput>;
    /** filter the rows which have to be updated */
    where: TokenOwnershipsV2BoolExp;
};
/** aggregate var_pop on columns */
type TokenOwnershipsV2VarPopFields = {
    amount?: Maybe<Scalars["Float"]["output"]>;
    property_version_v1?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate var_samp on columns */
type TokenOwnershipsV2VarSampFields = {
    amount?: Maybe<Scalars["Float"]["output"]>;
    property_version_v1?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate variance on columns */
type TokenOwnershipsV2VarianceFields = {
    amount?: Maybe<Scalars["Float"]["output"]>;
    property_version_v1?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
    write_set_change_index?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate var_pop on columns */
type TokenOwnershipsVarPopFields = {
    amount?: Maybe<Scalars["Float"]["output"]>;
    property_version?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate var_samp on columns */
type TokenOwnershipsVarSampFields = {
    amount?: Maybe<Scalars["Float"]["output"]>;
    property_version?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate variance on columns */
type TokenOwnershipsVarianceFields = {
    amount?: Maybe<Scalars["Float"]["output"]>;
    property_version?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** columns and relationships of "tokens" */
type Tokens = {
    collection_data_id_hash: Scalars["String"]["output"];
    collection_name: Scalars["String"]["output"];
    creator_address: Scalars["String"]["output"];
    inserted_at: Scalars["timestamp"]["output"];
    name: Scalars["String"]["output"];
    property_version: Scalars["numeric"]["output"];
    token_data_id_hash: Scalars["String"]["output"];
    token_properties: Scalars["jsonb"]["output"];
    transaction_timestamp: Scalars["timestamp"]["output"];
    transaction_version: Scalars["bigint"]["output"];
};
/** columns and relationships of "tokens" */
type TokensTokenPropertiesArgs = {
    path?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregated selection of "tokens" */
type TokensAggregate = {
    aggregate?: Maybe<TokensAggregateFields>;
    nodes: Array<Tokens>;
};
/** aggregate fields of "tokens" */
type TokensAggregateFields = {
    avg?: Maybe<TokensAvgFields>;
    count: Scalars["Int"]["output"];
    max?: Maybe<TokensMaxFields>;
    min?: Maybe<TokensMinFields>;
    stddev?: Maybe<TokensStddevFields>;
    stddev_pop?: Maybe<TokensStddevPopFields>;
    stddev_samp?: Maybe<TokensStddevSampFields>;
    sum?: Maybe<TokensSumFields>;
    var_pop?: Maybe<TokensVarPopFields>;
    var_samp?: Maybe<TokensVarSampFields>;
    variance?: Maybe<TokensVarianceFields>;
};
/** aggregate fields of "tokens" */
type TokensAggregateFieldsCountArgs = {
    columns?: InputMaybe<Array<TokensSelectColumn>>;
    distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};
/** append existing jsonb value of filtered columns with new jsonb value */
type TokensAppendInput = {
    token_properties?: InputMaybe<Scalars["jsonb"]["input"]>;
};
/** aggregate avg on columns */
type TokensAvgFields = {
    property_version?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** Boolean expression to filter rows from the table "tokens". All fields are combined with a logical 'AND'. */
type TokensBoolExp = {
    _and?: InputMaybe<Array<TokensBoolExp>>;
    _not?: InputMaybe<TokensBoolExp>;
    _or?: InputMaybe<Array<TokensBoolExp>>;
    collection_data_id_hash?: InputMaybe<StringComparisonExp>;
    collection_name?: InputMaybe<StringComparisonExp>;
    creator_address?: InputMaybe<StringComparisonExp>;
    inserted_at?: InputMaybe<TimestampComparisonExp>;
    name?: InputMaybe<StringComparisonExp>;
    property_version?: InputMaybe<NumericComparisonExp>;
    token_data_id_hash?: InputMaybe<StringComparisonExp>;
    token_properties?: InputMaybe<JsonbComparisonExp>;
    transaction_timestamp?: InputMaybe<TimestampComparisonExp>;
    transaction_version?: InputMaybe<BigintComparisonExp>;
};
/** unique or primary key constraints on table "tokens" */
declare enum TokensConstraint {
    /** unique or primary key constraint on columns "property_version", "token_data_id_hash", "transaction_version" */
    TokensPkey = "tokens_pkey"
}
/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
type TokensDeleteAtPathInput = {
    token_properties?: InputMaybe<Array<Scalars["String"]["input"]>>;
};
/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
type TokensDeleteElemInput = {
    token_properties?: InputMaybe<Scalars["Int"]["input"]>;
};
/** delete key/value pair or string element. key/value pairs are matched based on their key value */
type TokensDeleteKeyInput = {
    token_properties?: InputMaybe<Scalars["String"]["input"]>;
};
/** input type for incrementing numeric columns in table "tokens" */
type TokensIncInput = {
    property_version?: InputMaybe<Scalars["numeric"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** input type for inserting data into table "tokens" */
type TokensInsertInput = {
    collection_data_id_hash?: InputMaybe<Scalars["String"]["input"]>;
    collection_name?: InputMaybe<Scalars["String"]["input"]>;
    creator_address?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    name?: InputMaybe<Scalars["String"]["input"]>;
    property_version?: InputMaybe<Scalars["numeric"]["input"]>;
    token_data_id_hash?: InputMaybe<Scalars["String"]["input"]>;
    token_properties?: InputMaybe<Scalars["jsonb"]["input"]>;
    transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** aggregate max on columns */
type TokensMaxFields = {
    collection_data_id_hash?: Maybe<Scalars["String"]["output"]>;
    collection_name?: Maybe<Scalars["String"]["output"]>;
    creator_address?: Maybe<Scalars["String"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    name?: Maybe<Scalars["String"]["output"]>;
    property_version?: Maybe<Scalars["numeric"]["output"]>;
    token_data_id_hash?: Maybe<Scalars["String"]["output"]>;
    transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};
/** aggregate min on columns */
type TokensMinFields = {
    collection_data_id_hash?: Maybe<Scalars["String"]["output"]>;
    collection_name?: Maybe<Scalars["String"]["output"]>;
    creator_address?: Maybe<Scalars["String"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    name?: Maybe<Scalars["String"]["output"]>;
    property_version?: Maybe<Scalars["numeric"]["output"]>;
    token_data_id_hash?: Maybe<Scalars["String"]["output"]>;
    transaction_timestamp?: Maybe<Scalars["timestamp"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};
/** response of any mutation on the table "tokens" */
type TokensMutationResponse = {
    /** number of rows affected by the mutation */
    affected_rows: Scalars["Int"]["output"];
    /** data from the rows affected by the mutation */
    returning: Array<Tokens>;
};
/** on_conflict condition type for table "tokens" */
type TokensOnConflict = {
    constraint: TokensConstraint;
    update_columns?: Array<TokensUpdateColumn>;
    where?: InputMaybe<TokensBoolExp>;
};
/** Ordering options when selecting data from "tokens". */
type TokensOrderBy = {
    collection_data_id_hash?: InputMaybe<OrderBy>;
    collection_name?: InputMaybe<OrderBy>;
    creator_address?: InputMaybe<OrderBy>;
    inserted_at?: InputMaybe<OrderBy>;
    name?: InputMaybe<OrderBy>;
    property_version?: InputMaybe<OrderBy>;
    token_data_id_hash?: InputMaybe<OrderBy>;
    token_properties?: InputMaybe<OrderBy>;
    transaction_timestamp?: InputMaybe<OrderBy>;
    transaction_version?: InputMaybe<OrderBy>;
};
/** primary key columns input for table: tokens */
type TokensPkColumnsInput = {
    property_version: Scalars["numeric"]["input"];
    token_data_id_hash: Scalars["String"]["input"];
    transaction_version: Scalars["bigint"]["input"];
};
/** prepend existing jsonb value of filtered columns with new jsonb value */
type TokensPrependInput = {
    token_properties?: InputMaybe<Scalars["jsonb"]["input"]>;
};
/** select columns of table "tokens" */
declare enum TokensSelectColumn {
    /** column name */
    CollectionDataIdHash = "collection_data_id_hash",
    /** column name */
    CollectionName = "collection_name",
    /** column name */
    CreatorAddress = "creator_address",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    Name = "name",
    /** column name */
    PropertyVersion = "property_version",
    /** column name */
    TokenDataIdHash = "token_data_id_hash",
    /** column name */
    TokenProperties = "token_properties",
    /** column name */
    TransactionTimestamp = "transaction_timestamp",
    /** column name */
    TransactionVersion = "transaction_version"
}
/** input type for updating data in table "tokens" */
type TokensSetInput = {
    collection_data_id_hash?: InputMaybe<Scalars["String"]["input"]>;
    collection_name?: InputMaybe<Scalars["String"]["input"]>;
    creator_address?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    name?: InputMaybe<Scalars["String"]["input"]>;
    property_version?: InputMaybe<Scalars["numeric"]["input"]>;
    token_data_id_hash?: InputMaybe<Scalars["String"]["input"]>;
    token_properties?: InputMaybe<Scalars["jsonb"]["input"]>;
    transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** aggregate stddev on columns */
type TokensStddevFields = {
    property_version?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_pop on columns */
type TokensStddevPopFields = {
    property_version?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_samp on columns */
type TokensStddevSampFields = {
    property_version?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** Streaming cursor of the table "tokens" */
type TokensStreamCursorInput = {
    /** Stream column input with initial value */
    initial_value: TokensStreamCursorValueInput;
    /** cursor ordering */
    ordering?: InputMaybe<CursorOrdering>;
};
/** Initial value of the column from where the streaming should start */
type TokensStreamCursorValueInput = {
    collection_data_id_hash?: InputMaybe<Scalars["String"]["input"]>;
    collection_name?: InputMaybe<Scalars["String"]["input"]>;
    creator_address?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    name?: InputMaybe<Scalars["String"]["input"]>;
    property_version?: InputMaybe<Scalars["numeric"]["input"]>;
    token_data_id_hash?: InputMaybe<Scalars["String"]["input"]>;
    token_properties?: InputMaybe<Scalars["jsonb"]["input"]>;
    transaction_timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** aggregate sum on columns */
type TokensSumFields = {
    property_version?: Maybe<Scalars["numeric"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};
/** update columns of table "tokens" */
declare enum TokensUpdateColumn {
    /** column name */
    CollectionDataIdHash = "collection_data_id_hash",
    /** column name */
    CollectionName = "collection_name",
    /** column name */
    CreatorAddress = "creator_address",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    Name = "name",
    /** column name */
    PropertyVersion = "property_version",
    /** column name */
    TokenDataIdHash = "token_data_id_hash",
    /** column name */
    TokenProperties = "token_properties",
    /** column name */
    TransactionTimestamp = "transaction_timestamp",
    /** column name */
    TransactionVersion = "transaction_version"
}
type TokensUpdates = {
    /** append existing jsonb value of filtered columns with new jsonb value */
    _append?: InputMaybe<TokensAppendInput>;
    /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
    _delete_at_path?: InputMaybe<TokensDeleteAtPathInput>;
    /** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
    _delete_elem?: InputMaybe<TokensDeleteElemInput>;
    /** delete key/value pair or string element. key/value pairs are matched based on their key value */
    _delete_key?: InputMaybe<TokensDeleteKeyInput>;
    /** increments the numeric columns with given value of the filtered values */
    _inc?: InputMaybe<TokensIncInput>;
    /** prepend existing jsonb value of filtered columns with new jsonb value */
    _prepend?: InputMaybe<TokensPrependInput>;
    /** sets the columns of the filtered rows to the given values */
    _set?: InputMaybe<TokensSetInput>;
    /** filter the rows which have to be updated */
    where: TokensBoolExp;
};
/** aggregate var_pop on columns */
type TokensVarPopFields = {
    property_version?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate var_samp on columns */
type TokensVarSampFields = {
    property_version?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate variance on columns */
type TokensVarianceFields = {
    property_version?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** columns and relationships of "transaction_size_info" */
type TransactionSizeInfo = {
    inserted_at: Scalars["timestamp"]["output"];
    size_bytes: Scalars["bigint"]["output"];
    transaction_version: Scalars["bigint"]["output"];
};
/** aggregated selection of "transaction_size_info" */
type TransactionSizeInfoAggregate = {
    aggregate?: Maybe<TransactionSizeInfoAggregateFields>;
    nodes: Array<TransactionSizeInfo>;
};
/** aggregate fields of "transaction_size_info" */
type TransactionSizeInfoAggregateFields = {
    avg?: Maybe<TransactionSizeInfoAvgFields>;
    count: Scalars["Int"]["output"];
    max?: Maybe<TransactionSizeInfoMaxFields>;
    min?: Maybe<TransactionSizeInfoMinFields>;
    stddev?: Maybe<TransactionSizeInfoStddevFields>;
    stddev_pop?: Maybe<TransactionSizeInfoStddevPopFields>;
    stddev_samp?: Maybe<TransactionSizeInfoStddevSampFields>;
    sum?: Maybe<TransactionSizeInfoSumFields>;
    var_pop?: Maybe<TransactionSizeInfoVarPopFields>;
    var_samp?: Maybe<TransactionSizeInfoVarSampFields>;
    variance?: Maybe<TransactionSizeInfoVarianceFields>;
};
/** aggregate fields of "transaction_size_info" */
type TransactionSizeInfoAggregateFieldsCountArgs = {
    columns?: InputMaybe<Array<TransactionSizeInfoSelectColumn>>;
    distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};
/** aggregate avg on columns */
type TransactionSizeInfoAvgFields = {
    size_bytes?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** Boolean expression to filter rows from the table "transaction_size_info". All fields are combined with a logical 'AND'. */
type TransactionSizeInfoBoolExp = {
    _and?: InputMaybe<Array<TransactionSizeInfoBoolExp>>;
    _not?: InputMaybe<TransactionSizeInfoBoolExp>;
    _or?: InputMaybe<Array<TransactionSizeInfoBoolExp>>;
    inserted_at?: InputMaybe<TimestampComparisonExp>;
    size_bytes?: InputMaybe<BigintComparisonExp>;
    transaction_version?: InputMaybe<BigintComparisonExp>;
};
/** unique or primary key constraints on table "transaction_size_info" */
declare enum TransactionSizeInfoConstraint {
    /** unique or primary key constraint on columns "transaction_version" */
    TransactionSizeInfoPkey = "transaction_size_info_pkey"
}
/** input type for incrementing numeric columns in table "transaction_size_info" */
type TransactionSizeInfoIncInput = {
    size_bytes?: InputMaybe<Scalars["bigint"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** input type for inserting data into table "transaction_size_info" */
type TransactionSizeInfoInsertInput = {
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    size_bytes?: InputMaybe<Scalars["bigint"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** aggregate max on columns */
type TransactionSizeInfoMaxFields = {
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    size_bytes?: Maybe<Scalars["bigint"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};
/** aggregate min on columns */
type TransactionSizeInfoMinFields = {
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    size_bytes?: Maybe<Scalars["bigint"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};
/** response of any mutation on the table "transaction_size_info" */
type TransactionSizeInfoMutationResponse = {
    /** number of rows affected by the mutation */
    affected_rows: Scalars["Int"]["output"];
    /** data from the rows affected by the mutation */
    returning: Array<TransactionSizeInfo>;
};
/** on_conflict condition type for table "transaction_size_info" */
type TransactionSizeInfoOnConflict = {
    constraint: TransactionSizeInfoConstraint;
    update_columns?: Array<TransactionSizeInfoUpdateColumn>;
    where?: InputMaybe<TransactionSizeInfoBoolExp>;
};
/** Ordering options when selecting data from "transaction_size_info". */
type TransactionSizeInfoOrderBy = {
    inserted_at?: InputMaybe<OrderBy>;
    size_bytes?: InputMaybe<OrderBy>;
    transaction_version?: InputMaybe<OrderBy>;
};
/** primary key columns input for table: transaction_size_info */
type TransactionSizeInfoPkColumnsInput = {
    transaction_version: Scalars["bigint"]["input"];
};
/** select columns of table "transaction_size_info" */
declare enum TransactionSizeInfoSelectColumn {
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    SizeBytes = "size_bytes",
    /** column name */
    TransactionVersion = "transaction_version"
}
/** input type for updating data in table "transaction_size_info" */
type TransactionSizeInfoSetInput = {
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    size_bytes?: InputMaybe<Scalars["bigint"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** aggregate stddev on columns */
type TransactionSizeInfoStddevFields = {
    size_bytes?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_pop on columns */
type TransactionSizeInfoStddevPopFields = {
    size_bytes?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_samp on columns */
type TransactionSizeInfoStddevSampFields = {
    size_bytes?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** Streaming cursor of the table "transaction_size_info" */
type TransactionSizeInfoStreamCursorInput = {
    /** Stream column input with initial value */
    initial_value: TransactionSizeInfoStreamCursorValueInput;
    /** cursor ordering */
    ordering?: InputMaybe<CursorOrdering>;
};
/** Initial value of the column from where the streaming should start */
type TransactionSizeInfoStreamCursorValueInput = {
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    size_bytes?: InputMaybe<Scalars["bigint"]["input"]>;
    transaction_version?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** aggregate sum on columns */
type TransactionSizeInfoSumFields = {
    size_bytes?: Maybe<Scalars["bigint"]["output"]>;
    transaction_version?: Maybe<Scalars["bigint"]["output"]>;
};
/** update columns of table "transaction_size_info" */
declare enum TransactionSizeInfoUpdateColumn {
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    SizeBytes = "size_bytes",
    /** column name */
    TransactionVersion = "transaction_version"
}
type TransactionSizeInfoUpdates = {
    /** increments the numeric columns with given value of the filtered values */
    _inc?: InputMaybe<TransactionSizeInfoIncInput>;
    /** sets the columns of the filtered rows to the given values */
    _set?: InputMaybe<TransactionSizeInfoSetInput>;
    /** filter the rows which have to be updated */
    where: TransactionSizeInfoBoolExp;
};
/** aggregate var_pop on columns */
type TransactionSizeInfoVarPopFields = {
    size_bytes?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate var_samp on columns */
type TransactionSizeInfoVarSampFields = {
    size_bytes?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate variance on columns */
type TransactionSizeInfoVarianceFields = {
    size_bytes?: Maybe<Scalars["Float"]["output"]>;
    transaction_version?: Maybe<Scalars["Float"]["output"]>;
};
/** columns and relationships of "transactions_view" */
type TransactionsView = {
    accumulator_root_hash?: Maybe<Scalars["String"]["output"]>;
    block_height?: Maybe<Scalars["bigint"]["output"]>;
    event_root_hash?: Maybe<Scalars["String"]["output"]>;
    gas_used?: Maybe<Scalars["numeric"]["output"]>;
    hash?: Maybe<Scalars["String"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    json_payload?: Maybe<Scalars["String"]["output"]>;
    num_events?: Maybe<Scalars["bigint"]["output"]>;
    num_write_set_changes?: Maybe<Scalars["bigint"]["output"]>;
    state_change_hash?: Maybe<Scalars["String"]["output"]>;
    state_checkpoint_hash?: Maybe<Scalars["String"]["output"]>;
    success?: Maybe<Scalars["Boolean"]["output"]>;
    type?: Maybe<Scalars["String"]["output"]>;
    version?: Maybe<Scalars["bigint"]["output"]>;
    vm_status?: Maybe<Scalars["String"]["output"]>;
};
/** aggregated selection of "transactions_view" */
type TransactionsViewAggregate = {
    aggregate?: Maybe<TransactionsViewAggregateFields>;
    nodes: Array<TransactionsView>;
};
/** aggregate fields of "transactions_view" */
type TransactionsViewAggregateFields = {
    avg?: Maybe<TransactionsViewAvgFields>;
    count: Scalars["Int"]["output"];
    max?: Maybe<TransactionsViewMaxFields>;
    min?: Maybe<TransactionsViewMinFields>;
    stddev?: Maybe<TransactionsViewStddevFields>;
    stddev_pop?: Maybe<TransactionsViewStddevPopFields>;
    stddev_samp?: Maybe<TransactionsViewStddevSampFields>;
    sum?: Maybe<TransactionsViewSumFields>;
    var_pop?: Maybe<TransactionsViewVarPopFields>;
    var_samp?: Maybe<TransactionsViewVarSampFields>;
    variance?: Maybe<TransactionsViewVarianceFields>;
};
/** aggregate fields of "transactions_view" */
type TransactionsViewAggregateFieldsCountArgs = {
    columns?: InputMaybe<Array<TransactionsViewSelectColumn>>;
    distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};
/** aggregate avg on columns */
type TransactionsViewAvgFields = {
    block_height?: Maybe<Scalars["Float"]["output"]>;
    gas_used?: Maybe<Scalars["Float"]["output"]>;
    num_events?: Maybe<Scalars["Float"]["output"]>;
    num_write_set_changes?: Maybe<Scalars["Float"]["output"]>;
    version?: Maybe<Scalars["Float"]["output"]>;
};
/** Boolean expression to filter rows from the table "transactions_view". All fields are combined with a logical 'AND'. */
type TransactionsViewBoolExp = {
    _and?: InputMaybe<Array<TransactionsViewBoolExp>>;
    _not?: InputMaybe<TransactionsViewBoolExp>;
    _or?: InputMaybe<Array<TransactionsViewBoolExp>>;
    accumulator_root_hash?: InputMaybe<StringComparisonExp>;
    block_height?: InputMaybe<BigintComparisonExp>;
    event_root_hash?: InputMaybe<StringComparisonExp>;
    gas_used?: InputMaybe<NumericComparisonExp>;
    hash?: InputMaybe<StringComparisonExp>;
    inserted_at?: InputMaybe<TimestampComparisonExp>;
    json_payload?: InputMaybe<StringComparisonExp>;
    num_events?: InputMaybe<BigintComparisonExp>;
    num_write_set_changes?: InputMaybe<BigintComparisonExp>;
    state_change_hash?: InputMaybe<StringComparisonExp>;
    state_checkpoint_hash?: InputMaybe<StringComparisonExp>;
    success?: InputMaybe<BooleanComparisonExp>;
    type?: InputMaybe<StringComparisonExp>;
    version?: InputMaybe<BigintComparisonExp>;
    vm_status?: InputMaybe<StringComparisonExp>;
};
/** input type for incrementing numeric columns in table "transactions_view" */
type TransactionsViewIncInput = {
    block_height?: InputMaybe<Scalars["bigint"]["input"]>;
    gas_used?: InputMaybe<Scalars["numeric"]["input"]>;
    num_events?: InputMaybe<Scalars["bigint"]["input"]>;
    num_write_set_changes?: InputMaybe<Scalars["bigint"]["input"]>;
    version?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** input type for inserting data into table "transactions_view" */
type TransactionsViewInsertInput = {
    accumulator_root_hash?: InputMaybe<Scalars["String"]["input"]>;
    block_height?: InputMaybe<Scalars["bigint"]["input"]>;
    event_root_hash?: InputMaybe<Scalars["String"]["input"]>;
    gas_used?: InputMaybe<Scalars["numeric"]["input"]>;
    hash?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    json_payload?: InputMaybe<Scalars["String"]["input"]>;
    num_events?: InputMaybe<Scalars["bigint"]["input"]>;
    num_write_set_changes?: InputMaybe<Scalars["bigint"]["input"]>;
    state_change_hash?: InputMaybe<Scalars["String"]["input"]>;
    state_checkpoint_hash?: InputMaybe<Scalars["String"]["input"]>;
    success?: InputMaybe<Scalars["Boolean"]["input"]>;
    type?: InputMaybe<Scalars["String"]["input"]>;
    version?: InputMaybe<Scalars["bigint"]["input"]>;
    vm_status?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregate max on columns */
type TransactionsViewMaxFields = {
    accumulator_root_hash?: Maybe<Scalars["String"]["output"]>;
    block_height?: Maybe<Scalars["bigint"]["output"]>;
    event_root_hash?: Maybe<Scalars["String"]["output"]>;
    gas_used?: Maybe<Scalars["numeric"]["output"]>;
    hash?: Maybe<Scalars["String"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    json_payload?: Maybe<Scalars["String"]["output"]>;
    num_events?: Maybe<Scalars["bigint"]["output"]>;
    num_write_set_changes?: Maybe<Scalars["bigint"]["output"]>;
    state_change_hash?: Maybe<Scalars["String"]["output"]>;
    state_checkpoint_hash?: Maybe<Scalars["String"]["output"]>;
    type?: Maybe<Scalars["String"]["output"]>;
    version?: Maybe<Scalars["bigint"]["output"]>;
    vm_status?: Maybe<Scalars["String"]["output"]>;
};
/** aggregate min on columns */
type TransactionsViewMinFields = {
    accumulator_root_hash?: Maybe<Scalars["String"]["output"]>;
    block_height?: Maybe<Scalars["bigint"]["output"]>;
    event_root_hash?: Maybe<Scalars["String"]["output"]>;
    gas_used?: Maybe<Scalars["numeric"]["output"]>;
    hash?: Maybe<Scalars["String"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    json_payload?: Maybe<Scalars["String"]["output"]>;
    num_events?: Maybe<Scalars["bigint"]["output"]>;
    num_write_set_changes?: Maybe<Scalars["bigint"]["output"]>;
    state_change_hash?: Maybe<Scalars["String"]["output"]>;
    state_checkpoint_hash?: Maybe<Scalars["String"]["output"]>;
    type?: Maybe<Scalars["String"]["output"]>;
    version?: Maybe<Scalars["bigint"]["output"]>;
    vm_status?: Maybe<Scalars["String"]["output"]>;
};
/** response of any mutation on the table "transactions_view" */
type TransactionsViewMutationResponse = {
    /** number of rows affected by the mutation */
    affected_rows: Scalars["Int"]["output"];
    /** data from the rows affected by the mutation */
    returning: Array<TransactionsView>;
};
/** Ordering options when selecting data from "transactions_view". */
type TransactionsViewOrderBy = {
    accumulator_root_hash?: InputMaybe<OrderBy>;
    block_height?: InputMaybe<OrderBy>;
    event_root_hash?: InputMaybe<OrderBy>;
    gas_used?: InputMaybe<OrderBy>;
    hash?: InputMaybe<OrderBy>;
    inserted_at?: InputMaybe<OrderBy>;
    json_payload?: InputMaybe<OrderBy>;
    num_events?: InputMaybe<OrderBy>;
    num_write_set_changes?: InputMaybe<OrderBy>;
    state_change_hash?: InputMaybe<OrderBy>;
    state_checkpoint_hash?: InputMaybe<OrderBy>;
    success?: InputMaybe<OrderBy>;
    type?: InputMaybe<OrderBy>;
    version?: InputMaybe<OrderBy>;
    vm_status?: InputMaybe<OrderBy>;
};
/** select columns of table "transactions_view" */
declare enum TransactionsViewSelectColumn {
    /** column name */
    AccumulatorRootHash = "accumulator_root_hash",
    /** column name */
    BlockHeight = "block_height",
    /** column name */
    EventRootHash = "event_root_hash",
    /** column name */
    GasUsed = "gas_used",
    /** column name */
    Hash = "hash",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    JsonPayload = "json_payload",
    /** column name */
    NumEvents = "num_events",
    /** column name */
    NumWriteSetChanges = "num_write_set_changes",
    /** column name */
    StateChangeHash = "state_change_hash",
    /** column name */
    StateCheckpointHash = "state_checkpoint_hash",
    /** column name */
    Success = "success",
    /** column name */
    Type = "type",
    /** column name */
    Version = "version",
    /** column name */
    VmStatus = "vm_status"
}
/** input type for updating data in table "transactions_view" */
type TransactionsViewSetInput = {
    accumulator_root_hash?: InputMaybe<Scalars["String"]["input"]>;
    block_height?: InputMaybe<Scalars["bigint"]["input"]>;
    event_root_hash?: InputMaybe<Scalars["String"]["input"]>;
    gas_used?: InputMaybe<Scalars["numeric"]["input"]>;
    hash?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    json_payload?: InputMaybe<Scalars["String"]["input"]>;
    num_events?: InputMaybe<Scalars["bigint"]["input"]>;
    num_write_set_changes?: InputMaybe<Scalars["bigint"]["input"]>;
    state_change_hash?: InputMaybe<Scalars["String"]["input"]>;
    state_checkpoint_hash?: InputMaybe<Scalars["String"]["input"]>;
    success?: InputMaybe<Scalars["Boolean"]["input"]>;
    type?: InputMaybe<Scalars["String"]["input"]>;
    version?: InputMaybe<Scalars["bigint"]["input"]>;
    vm_status?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregate stddev on columns */
type TransactionsViewStddevFields = {
    block_height?: Maybe<Scalars["Float"]["output"]>;
    gas_used?: Maybe<Scalars["Float"]["output"]>;
    num_events?: Maybe<Scalars["Float"]["output"]>;
    num_write_set_changes?: Maybe<Scalars["Float"]["output"]>;
    version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_pop on columns */
type TransactionsViewStddevPopFields = {
    block_height?: Maybe<Scalars["Float"]["output"]>;
    gas_used?: Maybe<Scalars["Float"]["output"]>;
    num_events?: Maybe<Scalars["Float"]["output"]>;
    num_write_set_changes?: Maybe<Scalars["Float"]["output"]>;
    version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_samp on columns */
type TransactionsViewStddevSampFields = {
    block_height?: Maybe<Scalars["Float"]["output"]>;
    gas_used?: Maybe<Scalars["Float"]["output"]>;
    num_events?: Maybe<Scalars["Float"]["output"]>;
    num_write_set_changes?: Maybe<Scalars["Float"]["output"]>;
    version?: Maybe<Scalars["Float"]["output"]>;
};
/** Streaming cursor of the table "transactions_view" */
type TransactionsViewStreamCursorInput = {
    /** Stream column input with initial value */
    initial_value: TransactionsViewStreamCursorValueInput;
    /** cursor ordering */
    ordering?: InputMaybe<CursorOrdering>;
};
/** Initial value of the column from where the streaming should start */
type TransactionsViewStreamCursorValueInput = {
    accumulator_root_hash?: InputMaybe<Scalars["String"]["input"]>;
    block_height?: InputMaybe<Scalars["bigint"]["input"]>;
    event_root_hash?: InputMaybe<Scalars["String"]["input"]>;
    gas_used?: InputMaybe<Scalars["numeric"]["input"]>;
    hash?: InputMaybe<Scalars["String"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    json_payload?: InputMaybe<Scalars["String"]["input"]>;
    num_events?: InputMaybe<Scalars["bigint"]["input"]>;
    num_write_set_changes?: InputMaybe<Scalars["bigint"]["input"]>;
    state_change_hash?: InputMaybe<Scalars["String"]["input"]>;
    state_checkpoint_hash?: InputMaybe<Scalars["String"]["input"]>;
    success?: InputMaybe<Scalars["Boolean"]["input"]>;
    type?: InputMaybe<Scalars["String"]["input"]>;
    version?: InputMaybe<Scalars["bigint"]["input"]>;
    vm_status?: InputMaybe<Scalars["String"]["input"]>;
};
/** aggregate sum on columns */
type TransactionsViewSumFields = {
    block_height?: Maybe<Scalars["bigint"]["output"]>;
    gas_used?: Maybe<Scalars["numeric"]["output"]>;
    num_events?: Maybe<Scalars["bigint"]["output"]>;
    num_write_set_changes?: Maybe<Scalars["bigint"]["output"]>;
    version?: Maybe<Scalars["bigint"]["output"]>;
};
type TransactionsViewUpdates = {
    /** increments the numeric columns with given value of the filtered values */
    _inc?: InputMaybe<TransactionsViewIncInput>;
    /** sets the columns of the filtered rows to the given values */
    _set?: InputMaybe<TransactionsViewSetInput>;
    /** filter the rows which have to be updated */
    where: TransactionsViewBoolExp;
};
/** aggregate var_pop on columns */
type TransactionsViewVarPopFields = {
    block_height?: Maybe<Scalars["Float"]["output"]>;
    gas_used?: Maybe<Scalars["Float"]["output"]>;
    num_events?: Maybe<Scalars["Float"]["output"]>;
    num_write_set_changes?: Maybe<Scalars["Float"]["output"]>;
    version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate var_samp on columns */
type TransactionsViewVarSampFields = {
    block_height?: Maybe<Scalars["Float"]["output"]>;
    gas_used?: Maybe<Scalars["Float"]["output"]>;
    num_events?: Maybe<Scalars["Float"]["output"]>;
    num_write_set_changes?: Maybe<Scalars["Float"]["output"]>;
    version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate variance on columns */
type TransactionsViewVarianceFields = {
    block_height?: Maybe<Scalars["Float"]["output"]>;
    gas_used?: Maybe<Scalars["Float"]["output"]>;
    num_events?: Maybe<Scalars["Float"]["output"]>;
    num_write_set_changes?: Maybe<Scalars["Float"]["output"]>;
    version?: Maybe<Scalars["Float"]["output"]>;
};
/** columns and relationships of "user_transactions" */
type UserTransactions = {
    block_height: Scalars["bigint"]["output"];
    entry_function_contract_address?: Maybe<Scalars["String"]["output"]>;
    entry_function_function_name?: Maybe<Scalars["String"]["output"]>;
    entry_function_id_str: Scalars["String"]["output"];
    entry_function_module_name?: Maybe<Scalars["String"]["output"]>;
    epoch: Scalars["bigint"]["output"];
    expiration_timestamp_secs: Scalars["timestamp"]["output"];
    gas_unit_price: Scalars["numeric"]["output"];
    inserted_at: Scalars["timestamp"]["output"];
    max_gas_amount: Scalars["numeric"]["output"];
    parent_signature_type: Scalars["String"]["output"];
    sender: Scalars["String"]["output"];
    sequence_number: Scalars["bigint"]["output"];
    timestamp: Scalars["timestamp"]["output"];
    version: Scalars["bigint"]["output"];
};
/** aggregated selection of "user_transactions" */
type UserTransactionsAggregate = {
    aggregate?: Maybe<UserTransactionsAggregateFields>;
    nodes: Array<UserTransactions>;
};
/** aggregate fields of "user_transactions" */
type UserTransactionsAggregateFields = {
    avg?: Maybe<UserTransactionsAvgFields>;
    count: Scalars["Int"]["output"];
    max?: Maybe<UserTransactionsMaxFields>;
    min?: Maybe<UserTransactionsMinFields>;
    stddev?: Maybe<UserTransactionsStddevFields>;
    stddev_pop?: Maybe<UserTransactionsStddevPopFields>;
    stddev_samp?: Maybe<UserTransactionsStddevSampFields>;
    sum?: Maybe<UserTransactionsSumFields>;
    var_pop?: Maybe<UserTransactionsVarPopFields>;
    var_samp?: Maybe<UserTransactionsVarSampFields>;
    variance?: Maybe<UserTransactionsVarianceFields>;
};
/** aggregate fields of "user_transactions" */
type UserTransactionsAggregateFieldsCountArgs = {
    columns?: InputMaybe<Array<UserTransactionsSelectColumn>>;
    distinct?: InputMaybe<Scalars["Boolean"]["input"]>;
};
/** aggregate avg on columns */
type UserTransactionsAvgFields = {
    block_height?: Maybe<Scalars["Float"]["output"]>;
    epoch?: Maybe<Scalars["Float"]["output"]>;
    gas_unit_price?: Maybe<Scalars["Float"]["output"]>;
    max_gas_amount?: Maybe<Scalars["Float"]["output"]>;
    sequence_number?: Maybe<Scalars["Float"]["output"]>;
    version?: Maybe<Scalars["Float"]["output"]>;
};
/** Boolean expression to filter rows from the table "user_transactions". All fields are combined with a logical 'AND'. */
type UserTransactionsBoolExp = {
    _and?: InputMaybe<Array<UserTransactionsBoolExp>>;
    _not?: InputMaybe<UserTransactionsBoolExp>;
    _or?: InputMaybe<Array<UserTransactionsBoolExp>>;
    block_height?: InputMaybe<BigintComparisonExp>;
    entry_function_contract_address?: InputMaybe<StringComparisonExp>;
    entry_function_function_name?: InputMaybe<StringComparisonExp>;
    entry_function_id_str?: InputMaybe<StringComparisonExp>;
    entry_function_module_name?: InputMaybe<StringComparisonExp>;
    epoch?: InputMaybe<BigintComparisonExp>;
    expiration_timestamp_secs?: InputMaybe<TimestampComparisonExp>;
    gas_unit_price?: InputMaybe<NumericComparisonExp>;
    inserted_at?: InputMaybe<TimestampComparisonExp>;
    max_gas_amount?: InputMaybe<NumericComparisonExp>;
    parent_signature_type?: InputMaybe<StringComparisonExp>;
    sender?: InputMaybe<StringComparisonExp>;
    sequence_number?: InputMaybe<BigintComparisonExp>;
    timestamp?: InputMaybe<TimestampComparisonExp>;
    version?: InputMaybe<BigintComparisonExp>;
};
/** unique or primary key constraints on table "user_transactions" */
declare enum UserTransactionsConstraint {
    /** unique or primary key constraint on columns "version" */
    UserTransactionsPkey = "user_transactions_pkey",
    /** unique or primary key constraint on columns "sender", "sequence_number" */
    UserTransactionsSenderSequenceNumberKey = "user_transactions_sender_sequence_number_key"
}
/** input type for incrementing numeric columns in table "user_transactions" */
type UserTransactionsIncInput = {
    block_height?: InputMaybe<Scalars["bigint"]["input"]>;
    epoch?: InputMaybe<Scalars["bigint"]["input"]>;
    gas_unit_price?: InputMaybe<Scalars["numeric"]["input"]>;
    max_gas_amount?: InputMaybe<Scalars["numeric"]["input"]>;
    sequence_number?: InputMaybe<Scalars["bigint"]["input"]>;
    version?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** input type for inserting data into table "user_transactions" */
type UserTransactionsInsertInput = {
    block_height?: InputMaybe<Scalars["bigint"]["input"]>;
    entry_function_contract_address?: InputMaybe<Scalars["String"]["input"]>;
    entry_function_function_name?: InputMaybe<Scalars["String"]["input"]>;
    entry_function_id_str?: InputMaybe<Scalars["String"]["input"]>;
    entry_function_module_name?: InputMaybe<Scalars["String"]["input"]>;
    epoch?: InputMaybe<Scalars["bigint"]["input"]>;
    expiration_timestamp_secs?: InputMaybe<Scalars["timestamp"]["input"]>;
    gas_unit_price?: InputMaybe<Scalars["numeric"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    max_gas_amount?: InputMaybe<Scalars["numeric"]["input"]>;
    parent_signature_type?: InputMaybe<Scalars["String"]["input"]>;
    sender?: InputMaybe<Scalars["String"]["input"]>;
    sequence_number?: InputMaybe<Scalars["bigint"]["input"]>;
    timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    version?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** aggregate max on columns */
type UserTransactionsMaxFields = {
    block_height?: Maybe<Scalars["bigint"]["output"]>;
    entry_function_contract_address?: Maybe<Scalars["String"]["output"]>;
    entry_function_function_name?: Maybe<Scalars["String"]["output"]>;
    entry_function_id_str?: Maybe<Scalars["String"]["output"]>;
    entry_function_module_name?: Maybe<Scalars["String"]["output"]>;
    epoch?: Maybe<Scalars["bigint"]["output"]>;
    expiration_timestamp_secs?: Maybe<Scalars["timestamp"]["output"]>;
    gas_unit_price?: Maybe<Scalars["numeric"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    max_gas_amount?: Maybe<Scalars["numeric"]["output"]>;
    parent_signature_type?: Maybe<Scalars["String"]["output"]>;
    sender?: Maybe<Scalars["String"]["output"]>;
    sequence_number?: Maybe<Scalars["bigint"]["output"]>;
    timestamp?: Maybe<Scalars["timestamp"]["output"]>;
    version?: Maybe<Scalars["bigint"]["output"]>;
};
/** aggregate min on columns */
type UserTransactionsMinFields = {
    block_height?: Maybe<Scalars["bigint"]["output"]>;
    entry_function_contract_address?: Maybe<Scalars["String"]["output"]>;
    entry_function_function_name?: Maybe<Scalars["String"]["output"]>;
    entry_function_id_str?: Maybe<Scalars["String"]["output"]>;
    entry_function_module_name?: Maybe<Scalars["String"]["output"]>;
    epoch?: Maybe<Scalars["bigint"]["output"]>;
    expiration_timestamp_secs?: Maybe<Scalars["timestamp"]["output"]>;
    gas_unit_price?: Maybe<Scalars["numeric"]["output"]>;
    inserted_at?: Maybe<Scalars["timestamp"]["output"]>;
    max_gas_amount?: Maybe<Scalars["numeric"]["output"]>;
    parent_signature_type?: Maybe<Scalars["String"]["output"]>;
    sender?: Maybe<Scalars["String"]["output"]>;
    sequence_number?: Maybe<Scalars["bigint"]["output"]>;
    timestamp?: Maybe<Scalars["timestamp"]["output"]>;
    version?: Maybe<Scalars["bigint"]["output"]>;
};
/** response of any mutation on the table "user_transactions" */
type UserTransactionsMutationResponse = {
    /** number of rows affected by the mutation */
    affected_rows: Scalars["Int"]["output"];
    /** data from the rows affected by the mutation */
    returning: Array<UserTransactions>;
};
/** input type for inserting object relation for remote table "user_transactions" */
type UserTransactionsObjRelInsertInput = {
    data: UserTransactionsInsertInput;
    /** upsert condition */
    on_conflict?: InputMaybe<UserTransactionsOnConflict>;
};
/** on_conflict condition type for table "user_transactions" */
type UserTransactionsOnConflict = {
    constraint: UserTransactionsConstraint;
    update_columns?: Array<UserTransactionsUpdateColumn>;
    where?: InputMaybe<UserTransactionsBoolExp>;
};
/** Ordering options when selecting data from "user_transactions". */
type UserTransactionsOrderBy = {
    block_height?: InputMaybe<OrderBy>;
    entry_function_contract_address?: InputMaybe<OrderBy>;
    entry_function_function_name?: InputMaybe<OrderBy>;
    entry_function_id_str?: InputMaybe<OrderBy>;
    entry_function_module_name?: InputMaybe<OrderBy>;
    epoch?: InputMaybe<OrderBy>;
    expiration_timestamp_secs?: InputMaybe<OrderBy>;
    gas_unit_price?: InputMaybe<OrderBy>;
    inserted_at?: InputMaybe<OrderBy>;
    max_gas_amount?: InputMaybe<OrderBy>;
    parent_signature_type?: InputMaybe<OrderBy>;
    sender?: InputMaybe<OrderBy>;
    sequence_number?: InputMaybe<OrderBy>;
    timestamp?: InputMaybe<OrderBy>;
    version?: InputMaybe<OrderBy>;
};
/** primary key columns input for table: user_transactions */
type UserTransactionsPkColumnsInput = {
    version: Scalars["bigint"]["input"];
};
/** select columns of table "user_transactions" */
declare enum UserTransactionsSelectColumn {
    /** column name */
    BlockHeight = "block_height",
    /** column name */
    EntryFunctionContractAddress = "entry_function_contract_address",
    /** column name */
    EntryFunctionFunctionName = "entry_function_function_name",
    /** column name */
    EntryFunctionIdStr = "entry_function_id_str",
    /** column name */
    EntryFunctionModuleName = "entry_function_module_name",
    /** column name */
    Epoch = "epoch",
    /** column name */
    ExpirationTimestampSecs = "expiration_timestamp_secs",
    /** column name */
    GasUnitPrice = "gas_unit_price",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    MaxGasAmount = "max_gas_amount",
    /** column name */
    ParentSignatureType = "parent_signature_type",
    /** column name */
    Sender = "sender",
    /** column name */
    SequenceNumber = "sequence_number",
    /** column name */
    Timestamp = "timestamp",
    /** column name */
    Version = "version"
}
/** input type for updating data in table "user_transactions" */
type UserTransactionsSetInput = {
    block_height?: InputMaybe<Scalars["bigint"]["input"]>;
    entry_function_contract_address?: InputMaybe<Scalars["String"]["input"]>;
    entry_function_function_name?: InputMaybe<Scalars["String"]["input"]>;
    entry_function_id_str?: InputMaybe<Scalars["String"]["input"]>;
    entry_function_module_name?: InputMaybe<Scalars["String"]["input"]>;
    epoch?: InputMaybe<Scalars["bigint"]["input"]>;
    expiration_timestamp_secs?: InputMaybe<Scalars["timestamp"]["input"]>;
    gas_unit_price?: InputMaybe<Scalars["numeric"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    max_gas_amount?: InputMaybe<Scalars["numeric"]["input"]>;
    parent_signature_type?: InputMaybe<Scalars["String"]["input"]>;
    sender?: InputMaybe<Scalars["String"]["input"]>;
    sequence_number?: InputMaybe<Scalars["bigint"]["input"]>;
    timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    version?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** aggregate stddev on columns */
type UserTransactionsStddevFields = {
    block_height?: Maybe<Scalars["Float"]["output"]>;
    epoch?: Maybe<Scalars["Float"]["output"]>;
    gas_unit_price?: Maybe<Scalars["Float"]["output"]>;
    max_gas_amount?: Maybe<Scalars["Float"]["output"]>;
    sequence_number?: Maybe<Scalars["Float"]["output"]>;
    version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_pop on columns */
type UserTransactionsStddevPopFields = {
    block_height?: Maybe<Scalars["Float"]["output"]>;
    epoch?: Maybe<Scalars["Float"]["output"]>;
    gas_unit_price?: Maybe<Scalars["Float"]["output"]>;
    max_gas_amount?: Maybe<Scalars["Float"]["output"]>;
    sequence_number?: Maybe<Scalars["Float"]["output"]>;
    version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate stddev_samp on columns */
type UserTransactionsStddevSampFields = {
    block_height?: Maybe<Scalars["Float"]["output"]>;
    epoch?: Maybe<Scalars["Float"]["output"]>;
    gas_unit_price?: Maybe<Scalars["Float"]["output"]>;
    max_gas_amount?: Maybe<Scalars["Float"]["output"]>;
    sequence_number?: Maybe<Scalars["Float"]["output"]>;
    version?: Maybe<Scalars["Float"]["output"]>;
};
/** Streaming cursor of the table "user_transactions" */
type UserTransactionsStreamCursorInput = {
    /** Stream column input with initial value */
    initial_value: UserTransactionsStreamCursorValueInput;
    /** cursor ordering */
    ordering?: InputMaybe<CursorOrdering>;
};
/** Initial value of the column from where the streaming should start */
type UserTransactionsStreamCursorValueInput = {
    block_height?: InputMaybe<Scalars["bigint"]["input"]>;
    entry_function_contract_address?: InputMaybe<Scalars["String"]["input"]>;
    entry_function_function_name?: InputMaybe<Scalars["String"]["input"]>;
    entry_function_id_str?: InputMaybe<Scalars["String"]["input"]>;
    entry_function_module_name?: InputMaybe<Scalars["String"]["input"]>;
    epoch?: InputMaybe<Scalars["bigint"]["input"]>;
    expiration_timestamp_secs?: InputMaybe<Scalars["timestamp"]["input"]>;
    gas_unit_price?: InputMaybe<Scalars["numeric"]["input"]>;
    inserted_at?: InputMaybe<Scalars["timestamp"]["input"]>;
    max_gas_amount?: InputMaybe<Scalars["numeric"]["input"]>;
    parent_signature_type?: InputMaybe<Scalars["String"]["input"]>;
    sender?: InputMaybe<Scalars["String"]["input"]>;
    sequence_number?: InputMaybe<Scalars["bigint"]["input"]>;
    timestamp?: InputMaybe<Scalars["timestamp"]["input"]>;
    version?: InputMaybe<Scalars["bigint"]["input"]>;
};
/** aggregate sum on columns */
type UserTransactionsSumFields = {
    block_height?: Maybe<Scalars["bigint"]["output"]>;
    epoch?: Maybe<Scalars["bigint"]["output"]>;
    gas_unit_price?: Maybe<Scalars["numeric"]["output"]>;
    max_gas_amount?: Maybe<Scalars["numeric"]["output"]>;
    sequence_number?: Maybe<Scalars["bigint"]["output"]>;
    version?: Maybe<Scalars["bigint"]["output"]>;
};
/** update columns of table "user_transactions" */
declare enum UserTransactionsUpdateColumn {
    /** column name */
    BlockHeight = "block_height",
    /** column name */
    EntryFunctionContractAddress = "entry_function_contract_address",
    /** column name */
    EntryFunctionFunctionName = "entry_function_function_name",
    /** column name */
    EntryFunctionIdStr = "entry_function_id_str",
    /** column name */
    EntryFunctionModuleName = "entry_function_module_name",
    /** column name */
    Epoch = "epoch",
    /** column name */
    ExpirationTimestampSecs = "expiration_timestamp_secs",
    /** column name */
    GasUnitPrice = "gas_unit_price",
    /** column name */
    InsertedAt = "inserted_at",
    /** column name */
    MaxGasAmount = "max_gas_amount",
    /** column name */
    ParentSignatureType = "parent_signature_type",
    /** column name */
    Sender = "sender",
    /** column name */
    SequenceNumber = "sequence_number",
    /** column name */
    Timestamp = "timestamp",
    /** column name */
    Version = "version"
}
type UserTransactionsUpdates = {
    /** increments the numeric columns with given value of the filtered values */
    _inc?: InputMaybe<UserTransactionsIncInput>;
    /** sets the columns of the filtered rows to the given values */
    _set?: InputMaybe<UserTransactionsSetInput>;
    /** filter the rows which have to be updated */
    where: UserTransactionsBoolExp;
};
/** aggregate var_pop on columns */
type UserTransactionsVarPopFields = {
    block_height?: Maybe<Scalars["Float"]["output"]>;
    epoch?: Maybe<Scalars["Float"]["output"]>;
    gas_unit_price?: Maybe<Scalars["Float"]["output"]>;
    max_gas_amount?: Maybe<Scalars["Float"]["output"]>;
    sequence_number?: Maybe<Scalars["Float"]["output"]>;
    version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate var_samp on columns */
type UserTransactionsVarSampFields = {
    block_height?: Maybe<Scalars["Float"]["output"]>;
    epoch?: Maybe<Scalars["Float"]["output"]>;
    gas_unit_price?: Maybe<Scalars["Float"]["output"]>;
    max_gas_amount?: Maybe<Scalars["Float"]["output"]>;
    sequence_number?: Maybe<Scalars["Float"]["output"]>;
    version?: Maybe<Scalars["Float"]["output"]>;
};
/** aggregate variance on columns */
type UserTransactionsVarianceFields = {
    block_height?: Maybe<Scalars["Float"]["output"]>;
    epoch?: Maybe<Scalars["Float"]["output"]>;
    gas_unit_price?: Maybe<Scalars["Float"]["output"]>;
    max_gas_amount?: Maybe<Scalars["Float"]["output"]>;
    sequence_number?: Maybe<Scalars["Float"]["output"]>;
    version?: Maybe<Scalars["Float"]["output"]>;
};

export { type AccountTransactions, type AccountTransactionsAggregate, type AccountTransactionsAggregateFields, type AccountTransactionsAggregateFieldsCountArgs, type AccountTransactionsAvgFields, type AccountTransactionsBoolExp, AccountTransactionsConstraint, type AccountTransactionsDelegatedStakingActivitiesAggregateArgs, type AccountTransactionsDelegatedStakingActivitiesArgs, type AccountTransactionsFungibleAssetActivitiesAggregateArgs, type AccountTransactionsFungibleAssetActivitiesArgs, type AccountTransactionsIncInput, type AccountTransactionsInsertInput, type AccountTransactionsMaxFields, type AccountTransactionsMinFields, type AccountTransactionsMutationResponse, type AccountTransactionsOnConflict, type AccountTransactionsOrderBy, type AccountTransactionsPkColumnsInput, AccountTransactionsSelectColumn, type AccountTransactionsSetInput, type AccountTransactionsStddevFields, type AccountTransactionsStddevPopFields, type AccountTransactionsStddevSampFields, type AccountTransactionsStreamCursorInput, type AccountTransactionsStreamCursorValueInput, type AccountTransactionsSumFields, type AccountTransactionsTokenActivitiesV2AggregateArgs, type AccountTransactionsTokenActivitiesV2Args, AccountTransactionsUpdateColumn, type AccountTransactionsUpdates, type AccountTransactionsVarPopFields, type AccountTransactionsVarSampFields, type AccountTransactionsVarianceFields, type AddressEventsSummary, type AddressEventsSummaryAggregate, type AddressEventsSummaryAggregateFields, type AddressEventsSummaryAggregateFieldsCountArgs, type AddressEventsSummaryAvgFields, type AddressEventsSummaryBoolExp, type AddressEventsSummaryMaxFields, type AddressEventsSummaryMinFields, type AddressEventsSummaryOrderBy, AddressEventsSummarySelectColumn, type AddressEventsSummaryStddevFields, type AddressEventsSummaryStddevPopFields, type AddressEventsSummaryStddevSampFields, type AddressEventsSummaryStreamCursorInput, type AddressEventsSummaryStreamCursorValueInput, type AddressEventsSummarySumFields, type AddressEventsSummaryVarPopFields, type AddressEventsSummaryVarSampFields, type AddressEventsSummaryVarianceFields, type AddressVersionFromEvents, type AddressVersionFromEventsAggregate, type AddressVersionFromEventsAggregateFields, type AddressVersionFromEventsAggregateFieldsCountArgs, type AddressVersionFromEventsAvgFields, type AddressVersionFromEventsBoolExp, type AddressVersionFromEventsDelegatedStakingActivitiesAggregateArgs, type AddressVersionFromEventsDelegatedStakingActivitiesArgs, type AddressVersionFromEventsMaxFields, type AddressVersionFromEventsMinFields, type AddressVersionFromEventsOrderBy, AddressVersionFromEventsSelectColumn, type AddressVersionFromEventsStddevFields, type AddressVersionFromEventsStddevPopFields, type AddressVersionFromEventsStddevSampFields, type AddressVersionFromEventsStreamCursorInput, type AddressVersionFromEventsStreamCursorValueInput, type AddressVersionFromEventsSumFields, type AddressVersionFromEventsTokenActivitiesV2AggregateArgs, type AddressVersionFromEventsTokenActivitiesV2Args, type AddressVersionFromEventsVarPopFields, type AddressVersionFromEventsVarSampFields, type AddressVersionFromEventsVarianceFields, type AddressVersionFromMoveResources, type AddressVersionFromMoveResourcesAggregate, type AddressVersionFromMoveResourcesAggregateFields, type AddressVersionFromMoveResourcesAggregateFieldsCountArgs, type AddressVersionFromMoveResourcesAvgFields, type AddressVersionFromMoveResourcesBoolExp, type AddressVersionFromMoveResourcesMaxFields, type AddressVersionFromMoveResourcesMinFields, type AddressVersionFromMoveResourcesOrderBy, AddressVersionFromMoveResourcesSelectColumn, type AddressVersionFromMoveResourcesStddevFields, type AddressVersionFromMoveResourcesStddevPopFields, type AddressVersionFromMoveResourcesStddevSampFields, type AddressVersionFromMoveResourcesStreamCursorInput, type AddressVersionFromMoveResourcesStreamCursorValueInput, type AddressVersionFromMoveResourcesSumFields, type AddressVersionFromMoveResourcesVarPopFields, type AddressVersionFromMoveResourcesVarSampFields, type AddressVersionFromMoveResourcesVarianceFields, type AnsLookup, type AnsLookupAggregate, type AnsLookupAggregateFields, type AnsLookupAggregateFieldsCountArgs, type AnsLookupAvgFields, type AnsLookupBoolExp, AnsLookupConstraint, type AnsLookupIncInput, type AnsLookupInsertInput, type AnsLookupMaxFields, type AnsLookupMinFields, type AnsLookupMutationResponse, type AnsLookupOnConflict, type AnsLookupOrderBy, type AnsLookupPkColumnsInput, AnsLookupSelectColumn, type AnsLookupSetInput, type AnsLookupStddevFields, type AnsLookupStddevPopFields, type AnsLookupStddevSampFields, type AnsLookupStreamCursorInput, type AnsLookupStreamCursorValueInput, type AnsLookupSumFields, AnsLookupUpdateColumn, type AnsLookupUpdates, type AnsLookupV2, type AnsLookupV2Aggregate, type AnsLookupV2AggregateFields, type AnsLookupV2AggregateFieldsCountArgs, type AnsLookupV2AvgFields, type AnsLookupV2BoolExp, AnsLookupV2Constraint, type AnsLookupV2IncInput, type AnsLookupV2InsertInput, type AnsLookupV2MaxFields, type AnsLookupV2MinFields, type AnsLookupV2MutationResponse, type AnsLookupV2OnConflict, type AnsLookupV2OrderBy, type AnsLookupV2PkColumnsInput, AnsLookupV2SelectColumn, type AnsLookupV2SetInput, type AnsLookupV2StddevFields, type AnsLookupV2StddevPopFields, type AnsLookupV2StddevSampFields, type AnsLookupV2StreamCursorInput, type AnsLookupV2StreamCursorValueInput, type AnsLookupV2SumFields, AnsLookupV2UpdateColumn, type AnsLookupV2Updates, type AnsLookupV2VarPopFields, type AnsLookupV2VarSampFields, type AnsLookupV2VarianceFields, type AnsLookupVarPopFields, type AnsLookupVarSampFields, type AnsLookupVarianceFields, type AnsPrimaryName, type AnsPrimaryNameAggregate, type AnsPrimaryNameAggregateFields, type AnsPrimaryNameAggregateFieldsCountArgs, type AnsPrimaryNameAvgFields, type AnsPrimaryNameBoolExp, AnsPrimaryNameConstraint, type AnsPrimaryNameIncInput, type AnsPrimaryNameInsertInput, type AnsPrimaryNameMaxFields, type AnsPrimaryNameMinFields, type AnsPrimaryNameMutationResponse, type AnsPrimaryNameOnConflict, type AnsPrimaryNameOrderBy, type AnsPrimaryNamePkColumnsInput, AnsPrimaryNameSelectColumn, type AnsPrimaryNameSetInput, type AnsPrimaryNameStddevFields, type AnsPrimaryNameStddevPopFields, type AnsPrimaryNameStddevSampFields, type AnsPrimaryNameStreamCursorInput, type AnsPrimaryNameStreamCursorValueInput, type AnsPrimaryNameSumFields, AnsPrimaryNameUpdateColumn, type AnsPrimaryNameUpdates, type AnsPrimaryNameV2, type AnsPrimaryNameV2Aggregate, type AnsPrimaryNameV2AggregateFields, type AnsPrimaryNameV2AggregateFieldsCountArgs, type AnsPrimaryNameV2AvgFields, type AnsPrimaryNameV2BoolExp, AnsPrimaryNameV2Constraint, type AnsPrimaryNameV2IncInput, type AnsPrimaryNameV2InsertInput, type AnsPrimaryNameV2MaxFields, type AnsPrimaryNameV2MinFields, type AnsPrimaryNameV2MutationResponse, type AnsPrimaryNameV2OnConflict, type AnsPrimaryNameV2OrderBy, type AnsPrimaryNameV2PkColumnsInput, AnsPrimaryNameV2SelectColumn, type AnsPrimaryNameV2SetInput, type AnsPrimaryNameV2StddevFields, type AnsPrimaryNameV2StddevPopFields, type AnsPrimaryNameV2StddevSampFields, type AnsPrimaryNameV2StreamCursorInput, type AnsPrimaryNameV2StreamCursorValueInput, type AnsPrimaryNameV2SumFields, AnsPrimaryNameV2UpdateColumn, type AnsPrimaryNameV2Updates, type AnsPrimaryNameV2VarPopFields, type AnsPrimaryNameV2VarSampFields, type AnsPrimaryNameV2VarianceFields, type AnsPrimaryNameVarPopFields, type AnsPrimaryNameVarSampFields, type AnsPrimaryNameVarianceFields, type AuthKeyAccountAddresses, type AuthKeyAccountAddressesAggregate, type AuthKeyAccountAddressesAggregateFields, type AuthKeyAccountAddressesAggregateFieldsCountArgs, type AuthKeyAccountAddressesAvgFields, type AuthKeyAccountAddressesBoolExp, AuthKeyAccountAddressesConstraint, type AuthKeyAccountAddressesIncInput, type AuthKeyAccountAddressesInsertInput, type AuthKeyAccountAddressesMaxFields, type AuthKeyAccountAddressesMinFields, type AuthKeyAccountAddressesMutationResponse, type AuthKeyAccountAddressesOnConflict, type AuthKeyAccountAddressesOrderBy, type AuthKeyAccountAddressesPkColumnsInput, AuthKeyAccountAddressesSelectColumn, type AuthKeyAccountAddressesSetInput, type AuthKeyAccountAddressesStddevFields, type AuthKeyAccountAddressesStddevPopFields, type AuthKeyAccountAddressesStddevSampFields, type AuthKeyAccountAddressesStreamCursorInput, type AuthKeyAccountAddressesStreamCursorValueInput, type AuthKeyAccountAddressesSumFields, AuthKeyAccountAddressesUpdateColumn, type AuthKeyAccountAddressesUpdates, type AuthKeyAccountAddressesVarPopFields, type AuthKeyAccountAddressesVarSampFields, type AuthKeyAccountAddressesVarianceFields, type BigintComparisonExp, type BlockMetadataTransactions, type BlockMetadataTransactionsAggregate, type BlockMetadataTransactionsAggregateFields, type BlockMetadataTransactionsAggregateFieldsCountArgs, type BlockMetadataTransactionsAppendInput, type BlockMetadataTransactionsAvgFields, type BlockMetadataTransactionsBoolExp, BlockMetadataTransactionsConstraint, type BlockMetadataTransactionsDeleteAtPathInput, type BlockMetadataTransactionsDeleteElemInput, type BlockMetadataTransactionsDeleteKeyInput, type BlockMetadataTransactionsFailedProposerIndicesArgs, type BlockMetadataTransactionsIncInput, type BlockMetadataTransactionsInsertInput, type BlockMetadataTransactionsMaxFields, type BlockMetadataTransactionsMinFields, type BlockMetadataTransactionsMutationResponse, type BlockMetadataTransactionsOnConflict, type BlockMetadataTransactionsOrderBy, type BlockMetadataTransactionsPkColumnsInput, type BlockMetadataTransactionsPrependInput, type BlockMetadataTransactionsPreviousBlockVotesBitvecArgs, BlockMetadataTransactionsSelectColumn, type BlockMetadataTransactionsSetInput, type BlockMetadataTransactionsStddevFields, type BlockMetadataTransactionsStddevPopFields, type BlockMetadataTransactionsStddevSampFields, type BlockMetadataTransactionsStreamCursorInput, type BlockMetadataTransactionsStreamCursorValueInput, type BlockMetadataTransactionsSumFields, BlockMetadataTransactionsUpdateColumn, type BlockMetadataTransactionsUpdates, type BlockMetadataTransactionsVarPopFields, type BlockMetadataTransactionsVarSampFields, type BlockMetadataTransactionsVarianceFields, type BooleanComparisonExp, type ByteaComparisonExp, type CoinActivities, type CoinActivitiesAggregate, type CoinActivitiesAggregateFields, type CoinActivitiesAggregateFieldsCountArgs, type CoinActivitiesAvgFields, type CoinActivitiesBoolExp, CoinActivitiesConstraint, type CoinActivitiesIncInput, type CoinActivitiesInsertInput, type CoinActivitiesMaxFields, type CoinActivitiesMinFields, type CoinActivitiesMutationResponse, type CoinActivitiesOnConflict, type CoinActivitiesOrderBy, type CoinActivitiesPkColumnsInput, CoinActivitiesSelectColumn, type CoinActivitiesSetInput, type CoinActivitiesStddevFields, type CoinActivitiesStddevPopFields, type CoinActivitiesStddevSampFields, type CoinActivitiesStreamCursorInput, type CoinActivitiesStreamCursorValueInput, type CoinActivitiesSumFields, CoinActivitiesUpdateColumn, type CoinActivitiesUpdates, type CoinActivitiesVarPopFields, type CoinActivitiesVarSampFields, type CoinActivitiesVarianceFields, type CoinBalances, type CoinBalancesAggregate, type CoinBalancesAggregateFields, type CoinBalancesAggregateFieldsCountArgs, type CoinBalancesAvgFields, type CoinBalancesBoolExp, CoinBalancesConstraint, type CoinBalancesIncInput, type CoinBalancesInsertInput, type CoinBalancesMaxFields, type CoinBalancesMinFields, type CoinBalancesMutationResponse, type CoinBalancesOnConflict, type CoinBalancesOrderBy, type CoinBalancesPkColumnsInput, CoinBalancesSelectColumn, type CoinBalancesSetInput, type CoinBalancesStddevFields, type CoinBalancesStddevPopFields, type CoinBalancesStddevSampFields, type CoinBalancesStreamCursorInput, type CoinBalancesStreamCursorValueInput, type CoinBalancesSumFields, CoinBalancesUpdateColumn, type CoinBalancesUpdates, type CoinBalancesVarPopFields, type CoinBalancesVarSampFields, type CoinBalancesVarianceFields, type CoinInfos, type CoinInfosAggregate, type CoinInfosAggregateFields, type CoinInfosAggregateFieldsCountArgs, type CoinInfosAvgFields, type CoinInfosBoolExp, CoinInfosConstraint, type CoinInfosIncInput, type CoinInfosInsertInput, type CoinInfosMaxFields, type CoinInfosMinFields, type CoinInfosMutationResponse, type CoinInfosOnConflict, type CoinInfosOrderBy, type CoinInfosPkColumnsInput, CoinInfosSelectColumn, type CoinInfosSetInput, type CoinInfosStddevFields, type CoinInfosStddevPopFields, type CoinInfosStddevSampFields, type CoinInfosStreamCursorInput, type CoinInfosStreamCursorValueInput, type CoinInfosSumFields, CoinInfosUpdateColumn, type CoinInfosUpdates, type CoinInfosVarPopFields, type CoinInfosVarSampFields, type CoinInfosVarianceFields, type CoinSupply, type CoinSupplyAggregate, type CoinSupplyAggregateFields, type CoinSupplyAggregateFieldsCountArgs, type CoinSupplyAvgFields, type CoinSupplyBoolExp, CoinSupplyConstraint, type CoinSupplyIncInput, type CoinSupplyInsertInput, type CoinSupplyMaxFields, type CoinSupplyMinFields, type CoinSupplyMutationResponse, type CoinSupplyOnConflict, type CoinSupplyOrderBy, type CoinSupplyPkColumnsInput, CoinSupplySelectColumn, type CoinSupplySetInput, type CoinSupplyStddevFields, type CoinSupplyStddevPopFields, type CoinSupplyStddevSampFields, type CoinSupplyStreamCursorInput, type CoinSupplyStreamCursorValueInput, type CoinSupplySumFields, CoinSupplyUpdateColumn, type CoinSupplyUpdates, type CoinSupplyVarPopFields, type CoinSupplyVarSampFields, type CoinSupplyVarianceFields, type CollectionDatas, type CollectionDatasAggregate, type CollectionDatasAggregateFields, type CollectionDatasAggregateFieldsCountArgs, type CollectionDatasAvgFields, type CollectionDatasBoolExp, CollectionDatasConstraint, type CollectionDatasIncInput, type CollectionDatasInsertInput, type CollectionDatasMaxFields, type CollectionDatasMinFields, type CollectionDatasMutationResponse, type CollectionDatasOnConflict, type CollectionDatasOrderBy, type CollectionDatasPkColumnsInput, CollectionDatasSelectColumn, type CollectionDatasSetInput, type CollectionDatasStddevFields, type CollectionDatasStddevPopFields, type CollectionDatasStddevSampFields, type CollectionDatasStreamCursorInput, type CollectionDatasStreamCursorValueInput, type CollectionDatasSumFields, CollectionDatasUpdateColumn, type CollectionDatasUpdates, type CollectionDatasVarPopFields, type CollectionDatasVarSampFields, type CollectionDatasVarianceFields, type CollectionsV2, type CollectionsV2Aggregate, type CollectionsV2AggregateFields, type CollectionsV2AggregateFieldsCountArgs, type CollectionsV2AppendInput, type CollectionsV2AvgFields, type CollectionsV2BoolExp, type CollectionsV2CollectionPropertiesArgs, CollectionsV2Constraint, type CollectionsV2DeleteAtPathInput, type CollectionsV2DeleteElemInput, type CollectionsV2DeleteKeyInput, type CollectionsV2IncInput, type CollectionsV2InsertInput, type CollectionsV2MaxFields, type CollectionsV2MinFields, type CollectionsV2MutationResponse, type CollectionsV2OnConflict, type CollectionsV2OrderBy, type CollectionsV2PkColumnsInput, type CollectionsV2PrependInput, CollectionsV2SelectColumn, type CollectionsV2SetInput, type CollectionsV2StddevFields, type CollectionsV2StddevPopFields, type CollectionsV2StddevSampFields, type CollectionsV2StreamCursorInput, type CollectionsV2StreamCursorValueInput, type CollectionsV2SumFields, CollectionsV2UpdateColumn, type CollectionsV2Updates, type CollectionsV2VarPopFields, type CollectionsV2VarSampFields, type CollectionsV2VarianceFields, type CurrentAnsLookup, type CurrentAnsLookupAggregate, type CurrentAnsLookupAggregateFields, type CurrentAnsLookupAggregateFieldsCountArgs, type CurrentAnsLookupAvgFields, type CurrentAnsLookupBoolExp, CurrentAnsLookupConstraint, type CurrentAnsLookupIncInput, type CurrentAnsLookupInsertInput, type CurrentAnsLookupMaxFields, type CurrentAnsLookupMinFields, type CurrentAnsLookupMutationResponse, type CurrentAnsLookupOnConflict, type CurrentAnsLookupOrderBy, type CurrentAnsLookupPkColumnsInput, CurrentAnsLookupSelectColumn, type CurrentAnsLookupSetInput, type CurrentAnsLookupStddevFields, type CurrentAnsLookupStddevPopFields, type CurrentAnsLookupStddevSampFields, type CurrentAnsLookupStreamCursorInput, type CurrentAnsLookupStreamCursorValueInput, type CurrentAnsLookupSumFields, CurrentAnsLookupUpdateColumn, type CurrentAnsLookupUpdates, type CurrentAnsLookupV2, type CurrentAnsLookupV2Aggregate, type CurrentAnsLookupV2AggregateFields, type CurrentAnsLookupV2AggregateFieldsCountArgs, type CurrentAnsLookupV2AvgFields, type CurrentAnsLookupV2BoolExp, CurrentAnsLookupV2Constraint, type CurrentAnsLookupV2IncInput, type CurrentAnsLookupV2InsertInput, type CurrentAnsLookupV2MaxFields, type CurrentAnsLookupV2MinFields, type CurrentAnsLookupV2MutationResponse, type CurrentAnsLookupV2OnConflict, type CurrentAnsLookupV2OrderBy, type CurrentAnsLookupV2PkColumnsInput, CurrentAnsLookupV2SelectColumn, type CurrentAnsLookupV2SetInput, type CurrentAnsLookupV2StddevFields, type CurrentAnsLookupV2StddevPopFields, type CurrentAnsLookupV2StddevSampFields, type CurrentAnsLookupV2StreamCursorInput, type CurrentAnsLookupV2StreamCursorValueInput, type CurrentAnsLookupV2SumFields, CurrentAnsLookupV2UpdateColumn, type CurrentAnsLookupV2Updates, type CurrentAnsLookupV2VarPopFields, type CurrentAnsLookupV2VarSampFields, type CurrentAnsLookupV2VarianceFields, type CurrentAnsLookupVarPopFields, type CurrentAnsLookupVarSampFields, type CurrentAnsLookupVarianceFields, type CurrentAnsPrimaryName, type CurrentAnsPrimaryNameAggregate, type CurrentAnsPrimaryNameAggregateFields, type CurrentAnsPrimaryNameAggregateFieldsCountArgs, type CurrentAnsPrimaryNameAvgFields, type CurrentAnsPrimaryNameBoolExp, CurrentAnsPrimaryNameConstraint, type CurrentAnsPrimaryNameIncInput, type CurrentAnsPrimaryNameInsertInput, type CurrentAnsPrimaryNameMaxFields, type CurrentAnsPrimaryNameMinFields, type CurrentAnsPrimaryNameMutationResponse, type CurrentAnsPrimaryNameOnConflict, type CurrentAnsPrimaryNameOrderBy, type CurrentAnsPrimaryNamePkColumnsInput, CurrentAnsPrimaryNameSelectColumn, type CurrentAnsPrimaryNameSetInput, type CurrentAnsPrimaryNameStddevFields, type CurrentAnsPrimaryNameStddevPopFields, type CurrentAnsPrimaryNameStddevSampFields, type CurrentAnsPrimaryNameStreamCursorInput, type CurrentAnsPrimaryNameStreamCursorValueInput, type CurrentAnsPrimaryNameSumFields, CurrentAnsPrimaryNameUpdateColumn, type CurrentAnsPrimaryNameUpdates, type CurrentAnsPrimaryNameV2, type CurrentAnsPrimaryNameV2Aggregate, type CurrentAnsPrimaryNameV2AggregateFields, type CurrentAnsPrimaryNameV2AggregateFieldsCountArgs, type CurrentAnsPrimaryNameV2AvgFields, type CurrentAnsPrimaryNameV2BoolExp, CurrentAnsPrimaryNameV2Constraint, type CurrentAnsPrimaryNameV2IncInput, type CurrentAnsPrimaryNameV2InsertInput, type CurrentAnsPrimaryNameV2MaxFields, type CurrentAnsPrimaryNameV2MinFields, type CurrentAnsPrimaryNameV2MutationResponse, type CurrentAnsPrimaryNameV2OnConflict, type CurrentAnsPrimaryNameV2OrderBy, type CurrentAnsPrimaryNameV2PkColumnsInput, CurrentAnsPrimaryNameV2SelectColumn, type CurrentAnsPrimaryNameV2SetInput, type CurrentAnsPrimaryNameV2StddevFields, type CurrentAnsPrimaryNameV2StddevPopFields, type CurrentAnsPrimaryNameV2StddevSampFields, type CurrentAnsPrimaryNameV2StreamCursorInput, type CurrentAnsPrimaryNameV2StreamCursorValueInput, type CurrentAnsPrimaryNameV2SumFields, CurrentAnsPrimaryNameV2UpdateColumn, type CurrentAnsPrimaryNameV2Updates, type CurrentAnsPrimaryNameV2VarPopFields, type CurrentAnsPrimaryNameV2VarSampFields, type CurrentAnsPrimaryNameV2VarianceFields, type CurrentAnsPrimaryNameVarPopFields, type CurrentAnsPrimaryNameVarSampFields, type CurrentAnsPrimaryNameVarianceFields, type CurrentCedraNames, type CurrentCedraNamesAggregate, type CurrentCedraNamesAggregateBoolExp, type CurrentCedraNamesAggregateBoolExpBoolAnd, type CurrentCedraNamesAggregateBoolExpBoolOr, type CurrentCedraNamesAggregateBoolExpCount, type CurrentCedraNamesAggregateFields, type CurrentCedraNamesAggregateFieldsCountArgs, type CurrentCedraNamesAggregateOrderBy, type CurrentCedraNamesArrRelInsertInput, type CurrentCedraNamesAvgFields, type CurrentCedraNamesAvgOrderBy, type CurrentCedraNamesBoolExp, type CurrentCedraNamesInsertInput, type CurrentCedraNamesMaxFields, type CurrentCedraNamesMaxOrderBy, type CurrentCedraNamesMinFields, type CurrentCedraNamesMinOrderBy, type CurrentCedraNamesObjRelInsertInput, type CurrentCedraNamesOrderBy, CurrentCedraNamesSelectColumn, CurrentCedraNamesSelectColumnCurrentCedraNamesAggregateBoolExpBoolAndArgumentsColumns, CurrentCedraNamesSelectColumnCurrentCedraNamesAggregateBoolExpBoolOrArgumentsColumns, type CurrentCedraNamesStddevFields, type CurrentCedraNamesStddevOrderBy, type CurrentCedraNamesStddevPopFields, type CurrentCedraNamesStddevPopOrderBy, type CurrentCedraNamesStddevSampFields, type CurrentCedraNamesStddevSampOrderBy, type CurrentCedraNamesStreamCursorInput, type CurrentCedraNamesStreamCursorValueInput, type CurrentCedraNamesSumFields, type CurrentCedraNamesSumOrderBy, type CurrentCedraNamesVarPopFields, type CurrentCedraNamesVarPopOrderBy, type CurrentCedraNamesVarSampFields, type CurrentCedraNamesVarSampOrderBy, type CurrentCedraNamesVarianceFields, type CurrentCedraNamesVarianceOrderBy, type CurrentCoinBalances, type CurrentCoinBalancesAggregate, type CurrentCoinBalancesAggregateFields, type CurrentCoinBalancesAggregateFieldsCountArgs, type CurrentCoinBalancesAvgFields, type CurrentCoinBalancesBoolExp, CurrentCoinBalancesConstraint, type CurrentCoinBalancesIncInput, type CurrentCoinBalancesInsertInput, type CurrentCoinBalancesMaxFields, type CurrentCoinBalancesMinFields, type CurrentCoinBalancesMutationResponse, type CurrentCoinBalancesOnConflict, type CurrentCoinBalancesOrderBy, type CurrentCoinBalancesPkColumnsInput, CurrentCoinBalancesSelectColumn, type CurrentCoinBalancesSetInput, type CurrentCoinBalancesStddevFields, type CurrentCoinBalancesStddevPopFields, type CurrentCoinBalancesStddevSampFields, type CurrentCoinBalancesStreamCursorInput, type CurrentCoinBalancesStreamCursorValueInput, type CurrentCoinBalancesSumFields, CurrentCoinBalancesUpdateColumn, type CurrentCoinBalancesUpdates, type CurrentCoinBalancesVarPopFields, type CurrentCoinBalancesVarSampFields, type CurrentCoinBalancesVarianceFields, type CurrentCollectionDatas, type CurrentCollectionDatasAggregate, type CurrentCollectionDatasAggregateFields, type CurrentCollectionDatasAggregateFieldsCountArgs, type CurrentCollectionDatasAvgFields, type CurrentCollectionDatasBoolExp, CurrentCollectionDatasConstraint, type CurrentCollectionDatasIncInput, type CurrentCollectionDatasInsertInput, type CurrentCollectionDatasMaxFields, type CurrentCollectionDatasMinFields, type CurrentCollectionDatasMutationResponse, type CurrentCollectionDatasOnConflict, type CurrentCollectionDatasOrderBy, type CurrentCollectionDatasPkColumnsInput, CurrentCollectionDatasSelectColumn, type CurrentCollectionDatasSetInput, type CurrentCollectionDatasStddevFields, type CurrentCollectionDatasStddevPopFields, type CurrentCollectionDatasStddevSampFields, type CurrentCollectionDatasStreamCursorInput, type CurrentCollectionDatasStreamCursorValueInput, type CurrentCollectionDatasSumFields, CurrentCollectionDatasUpdateColumn, type CurrentCollectionDatasUpdates, type CurrentCollectionDatasVarPopFields, type CurrentCollectionDatasVarSampFields, type CurrentCollectionDatasVarianceFields, type CurrentCollectionOwnershipV2View, type CurrentCollectionOwnershipV2ViewAggregate, type CurrentCollectionOwnershipV2ViewAggregateFields, type CurrentCollectionOwnershipV2ViewAggregateFieldsCountArgs, type CurrentCollectionOwnershipV2ViewAvgFields, type CurrentCollectionOwnershipV2ViewBoolExp, type CurrentCollectionOwnershipV2ViewMaxFields, type CurrentCollectionOwnershipV2ViewMinFields, type CurrentCollectionOwnershipV2ViewOrderBy, CurrentCollectionOwnershipV2ViewSelectColumn, type CurrentCollectionOwnershipV2ViewStddevFields, type CurrentCollectionOwnershipV2ViewStddevPopFields, type CurrentCollectionOwnershipV2ViewStddevSampFields, type CurrentCollectionOwnershipV2ViewStreamCursorInput, type CurrentCollectionOwnershipV2ViewStreamCursorValueInput, type CurrentCollectionOwnershipV2ViewSumFields, type CurrentCollectionOwnershipV2ViewVarPopFields, type CurrentCollectionOwnershipV2ViewVarSampFields, type CurrentCollectionOwnershipV2ViewVarianceFields, type CurrentCollectionOwnershipView, type CurrentCollectionOwnershipViewAggregate, type CurrentCollectionOwnershipViewAggregateFields, type CurrentCollectionOwnershipViewAggregateFieldsCountArgs, type CurrentCollectionOwnershipViewAvgFields, type CurrentCollectionOwnershipViewBoolExp, type CurrentCollectionOwnershipViewMaxFields, type CurrentCollectionOwnershipViewMinFields, type CurrentCollectionOwnershipViewOrderBy, CurrentCollectionOwnershipViewSelectColumn, type CurrentCollectionOwnershipViewStddevFields, type CurrentCollectionOwnershipViewStddevPopFields, type CurrentCollectionOwnershipViewStddevSampFields, type CurrentCollectionOwnershipViewStreamCursorInput, type CurrentCollectionOwnershipViewStreamCursorValueInput, type CurrentCollectionOwnershipViewSumFields, type CurrentCollectionOwnershipViewVarPopFields, type CurrentCollectionOwnershipViewVarSampFields, type CurrentCollectionOwnershipViewVarianceFields, type CurrentCollectionsV2, type CurrentCollectionsV2Aggregate, type CurrentCollectionsV2AggregateFields, type CurrentCollectionsV2AggregateFieldsCountArgs, type CurrentCollectionsV2AppendInput, type CurrentCollectionsV2AvgFields, type CurrentCollectionsV2BoolExp, type CurrentCollectionsV2CollectionPropertiesArgs, CurrentCollectionsV2Constraint, type CurrentCollectionsV2DeleteAtPathInput, type CurrentCollectionsV2DeleteElemInput, type CurrentCollectionsV2DeleteKeyInput, type CurrentCollectionsV2IncInput, type CurrentCollectionsV2InsertInput, type CurrentCollectionsV2MaxFields, type CurrentCollectionsV2MinFields, type CurrentCollectionsV2MutationResponse, type CurrentCollectionsV2ObjRelInsertInput, type CurrentCollectionsV2OnConflict, type CurrentCollectionsV2OrderBy, type CurrentCollectionsV2PkColumnsInput, type CurrentCollectionsV2PrependInput, CurrentCollectionsV2SelectColumn, type CurrentCollectionsV2SetInput, type CurrentCollectionsV2StddevFields, type CurrentCollectionsV2StddevPopFields, type CurrentCollectionsV2StddevSampFields, type CurrentCollectionsV2StreamCursorInput, type CurrentCollectionsV2StreamCursorValueInput, type CurrentCollectionsV2SumFields, CurrentCollectionsV2UpdateColumn, type CurrentCollectionsV2Updates, type CurrentCollectionsV2VarPopFields, type CurrentCollectionsV2VarSampFields, type CurrentCollectionsV2VarianceFields, type CurrentDelegatedStakingPoolBalances, type CurrentDelegatedStakingPoolBalancesAggregate, type CurrentDelegatedStakingPoolBalancesAggregateFields, type CurrentDelegatedStakingPoolBalancesAggregateFieldsCountArgs, type CurrentDelegatedStakingPoolBalancesAvgFields, type CurrentDelegatedStakingPoolBalancesBoolExp, CurrentDelegatedStakingPoolBalancesConstraint, type CurrentDelegatedStakingPoolBalancesIncInput, type CurrentDelegatedStakingPoolBalancesInsertInput, type CurrentDelegatedStakingPoolBalancesMaxFields, type CurrentDelegatedStakingPoolBalancesMinFields, type CurrentDelegatedStakingPoolBalancesMutationResponse, type CurrentDelegatedStakingPoolBalancesObjRelInsertInput, type CurrentDelegatedStakingPoolBalancesOnConflict, type CurrentDelegatedStakingPoolBalancesOrderBy, type CurrentDelegatedStakingPoolBalancesPkColumnsInput, CurrentDelegatedStakingPoolBalancesSelectColumn, type CurrentDelegatedStakingPoolBalancesSetInput, type CurrentDelegatedStakingPoolBalancesStddevFields, type CurrentDelegatedStakingPoolBalancesStddevPopFields, type CurrentDelegatedStakingPoolBalancesStddevSampFields, type CurrentDelegatedStakingPoolBalancesStreamCursorInput, type CurrentDelegatedStakingPoolBalancesStreamCursorValueInput, type CurrentDelegatedStakingPoolBalancesSumFields, CurrentDelegatedStakingPoolBalancesUpdateColumn, type CurrentDelegatedStakingPoolBalancesUpdates, type CurrentDelegatedStakingPoolBalancesVarPopFields, type CurrentDelegatedStakingPoolBalancesVarSampFields, type CurrentDelegatedStakingPoolBalancesVarianceFields, type CurrentDelegatedVoter, type CurrentDelegatedVoterAggregate, type CurrentDelegatedVoterAggregateFields, type CurrentDelegatedVoterAggregateFieldsCountArgs, type CurrentDelegatedVoterAvgFields, type CurrentDelegatedVoterBoolExp, CurrentDelegatedVoterConstraint, type CurrentDelegatedVoterIncInput, type CurrentDelegatedVoterInsertInput, type CurrentDelegatedVoterMaxFields, type CurrentDelegatedVoterMinFields, type CurrentDelegatedVoterMutationResponse, type CurrentDelegatedVoterOnConflict, type CurrentDelegatedVoterOrderBy, type CurrentDelegatedVoterPkColumnsInput, CurrentDelegatedVoterSelectColumn, type CurrentDelegatedVoterSetInput, type CurrentDelegatedVoterStddevFields, type CurrentDelegatedVoterStddevPopFields, type CurrentDelegatedVoterStddevSampFields, type CurrentDelegatedVoterStreamCursorInput, type CurrentDelegatedVoterStreamCursorValueInput, type CurrentDelegatedVoterSumFields, CurrentDelegatedVoterUpdateColumn, type CurrentDelegatedVoterUpdates, type CurrentDelegatedVoterVarPopFields, type CurrentDelegatedVoterVarSampFields, type CurrentDelegatedVoterVarianceFields, type CurrentDelegatorBalances, type CurrentDelegatorBalancesAggregate, type CurrentDelegatorBalancesAggregateFields, type CurrentDelegatorBalancesAggregateFieldsCountArgs, type CurrentDelegatorBalancesAvgFields, type CurrentDelegatorBalancesBoolExp, CurrentDelegatorBalancesConstraint, type CurrentDelegatorBalancesIncInput, type CurrentDelegatorBalancesInsertInput, type CurrentDelegatorBalancesMaxFields, type CurrentDelegatorBalancesMinFields, type CurrentDelegatorBalancesMutationResponse, type CurrentDelegatorBalancesOnConflict, type CurrentDelegatorBalancesOrderBy, type CurrentDelegatorBalancesPkColumnsInput, CurrentDelegatorBalancesSelectColumn, type CurrentDelegatorBalancesSetInput, type CurrentDelegatorBalancesStddevFields, type CurrentDelegatorBalancesStddevPopFields, type CurrentDelegatorBalancesStddevSampFields, type CurrentDelegatorBalancesStreamCursorInput, type CurrentDelegatorBalancesStreamCursorValueInput, type CurrentDelegatorBalancesSumFields, CurrentDelegatorBalancesUpdateColumn, type CurrentDelegatorBalancesUpdates, type CurrentDelegatorBalancesVarPopFields, type CurrentDelegatorBalancesVarSampFields, type CurrentDelegatorBalancesVarianceFields, type CurrentFungibleAssetBalances, type CurrentFungibleAssetBalancesAggregate, type CurrentFungibleAssetBalancesAggregateFields, type CurrentFungibleAssetBalancesAggregateFieldsCountArgs, type CurrentFungibleAssetBalancesAvgFields, type CurrentFungibleAssetBalancesBoolExp, CurrentFungibleAssetBalancesConstraint, type CurrentFungibleAssetBalancesIncInput, type CurrentFungibleAssetBalancesInsertInput, type CurrentFungibleAssetBalancesMaxFields, type CurrentFungibleAssetBalancesMinFields, type CurrentFungibleAssetBalancesMutationResponse, type CurrentFungibleAssetBalancesNew, type CurrentFungibleAssetBalancesNewAggregate, type CurrentFungibleAssetBalancesNewAggregateFields, type CurrentFungibleAssetBalancesNewAggregateFieldsCountArgs, type CurrentFungibleAssetBalancesNewAvgFields, type CurrentFungibleAssetBalancesNewBoolExp, CurrentFungibleAssetBalancesNewConstraint, type CurrentFungibleAssetBalancesNewIncInput, type CurrentFungibleAssetBalancesNewInsertInput, type CurrentFungibleAssetBalancesNewMaxFields, type CurrentFungibleAssetBalancesNewMinFields, type CurrentFungibleAssetBalancesNewMutationResponse, type CurrentFungibleAssetBalancesNewOnConflict, type CurrentFungibleAssetBalancesNewOrderBy, type CurrentFungibleAssetBalancesNewPkColumnsInput, CurrentFungibleAssetBalancesNewSelectColumn, type CurrentFungibleAssetBalancesNewSetInput, type CurrentFungibleAssetBalancesNewStddevFields, type CurrentFungibleAssetBalancesNewStddevPopFields, type CurrentFungibleAssetBalancesNewStddevSampFields, type CurrentFungibleAssetBalancesNewStreamCursorInput, type CurrentFungibleAssetBalancesNewStreamCursorValueInput, type CurrentFungibleAssetBalancesNewSumFields, CurrentFungibleAssetBalancesNewUpdateColumn, type CurrentFungibleAssetBalancesNewUpdates, type CurrentFungibleAssetBalancesNewVarPopFields, type CurrentFungibleAssetBalancesNewVarSampFields, type CurrentFungibleAssetBalancesNewVarianceFields, type CurrentFungibleAssetBalancesOnConflict, type CurrentFungibleAssetBalancesOrderBy, type CurrentFungibleAssetBalancesPkColumnsInput, CurrentFungibleAssetBalancesSelectColumn, type CurrentFungibleAssetBalancesSetInput, type CurrentFungibleAssetBalancesStddevFields, type CurrentFungibleAssetBalancesStddevPopFields, type CurrentFungibleAssetBalancesStddevSampFields, type CurrentFungibleAssetBalancesStreamCursorInput, type CurrentFungibleAssetBalancesStreamCursorValueInput, type CurrentFungibleAssetBalancesSumFields, CurrentFungibleAssetBalancesUpdateColumn, type CurrentFungibleAssetBalancesUpdates, type CurrentFungibleAssetBalancesVarPopFields, type CurrentFungibleAssetBalancesVarSampFields, type CurrentFungibleAssetBalancesVarianceFields, type CurrentObjects, type CurrentObjectsAggregate, type CurrentObjectsAggregateFields, type CurrentObjectsAggregateFieldsCountArgs, type CurrentObjectsAvgFields, type CurrentObjectsBoolExp, CurrentObjectsConstraint, type CurrentObjectsIncInput, type CurrentObjectsInsertInput, type CurrentObjectsMaxFields, type CurrentObjectsMinFields, type CurrentObjectsMutationResponse, type CurrentObjectsOnConflict, type CurrentObjectsOrderBy, type CurrentObjectsPkColumnsInput, CurrentObjectsSelectColumn, type CurrentObjectsSetInput, type CurrentObjectsStddevFields, type CurrentObjectsStddevPopFields, type CurrentObjectsStddevSampFields, type CurrentObjectsStreamCursorInput, type CurrentObjectsStreamCursorValueInput, type CurrentObjectsSumFields, CurrentObjectsUpdateColumn, type CurrentObjectsUpdates, type CurrentObjectsVarPopFields, type CurrentObjectsVarSampFields, type CurrentObjectsVarianceFields, type CurrentStakingPoolVoter, type CurrentStakingPoolVoterAggregate, type CurrentStakingPoolVoterAggregateFields, type CurrentStakingPoolVoterAggregateFieldsCountArgs, type CurrentStakingPoolVoterAvgFields, type CurrentStakingPoolVoterBoolExp, CurrentStakingPoolVoterConstraint, type CurrentStakingPoolVoterIncInput, type CurrentStakingPoolVoterInsertInput, type CurrentStakingPoolVoterMaxFields, type CurrentStakingPoolVoterMinFields, type CurrentStakingPoolVoterMutationResponse, type CurrentStakingPoolVoterObjRelInsertInput, type CurrentStakingPoolVoterOnConflict, type CurrentStakingPoolVoterOperatorCedraNameAggregateArgs, type CurrentStakingPoolVoterOperatorCedraNameArgs, type CurrentStakingPoolVoterOrderBy, type CurrentStakingPoolVoterPkColumnsInput, CurrentStakingPoolVoterSelectColumn, type CurrentStakingPoolVoterSetInput, type CurrentStakingPoolVoterStddevFields, type CurrentStakingPoolVoterStddevPopFields, type CurrentStakingPoolVoterStddevSampFields, type CurrentStakingPoolVoterStreamCursorInput, type CurrentStakingPoolVoterStreamCursorValueInput, type CurrentStakingPoolVoterSumFields, CurrentStakingPoolVoterUpdateColumn, type CurrentStakingPoolVoterUpdates, type CurrentStakingPoolVoterVarPopFields, type CurrentStakingPoolVoterVarSampFields, type CurrentStakingPoolVoterVarianceFields, type CurrentTableItems, type CurrentTableItemsAggregate, type CurrentTableItemsAggregateFields, type CurrentTableItemsAggregateFieldsCountArgs, type CurrentTableItemsAppendInput, type CurrentTableItemsAvgFields, type CurrentTableItemsBoolExp, CurrentTableItemsConstraint, type CurrentTableItemsDecodedKeyArgs, type CurrentTableItemsDecodedValueArgs, type CurrentTableItemsDeleteAtPathInput, type CurrentTableItemsDeleteElemInput, type CurrentTableItemsDeleteKeyInput, type CurrentTableItemsIncInput, type CurrentTableItemsInsertInput, type CurrentTableItemsMaxFields, type CurrentTableItemsMinFields, type CurrentTableItemsMutationResponse, type CurrentTableItemsOnConflict, type CurrentTableItemsOrderBy, type CurrentTableItemsPkColumnsInput, type CurrentTableItemsPrependInput, CurrentTableItemsSelectColumn, type CurrentTableItemsSetInput, type CurrentTableItemsStddevFields, type CurrentTableItemsStddevPopFields, type CurrentTableItemsStddevSampFields, type CurrentTableItemsStreamCursorInput, type CurrentTableItemsStreamCursorValueInput, type CurrentTableItemsSumFields, CurrentTableItemsUpdateColumn, type CurrentTableItemsUpdates, type CurrentTableItemsVarPopFields, type CurrentTableItemsVarSampFields, type CurrentTableItemsVarianceFields, type CurrentTableItemsView, type CurrentTableItemsViewAggregate, type CurrentTableItemsViewAggregateFields, type CurrentTableItemsViewAggregateFieldsCountArgs, type CurrentTableItemsViewAvgFields, type CurrentTableItemsViewBoolExp, type CurrentTableItemsViewIncInput, type CurrentTableItemsViewInsertInput, type CurrentTableItemsViewMaxFields, type CurrentTableItemsViewMinFields, type CurrentTableItemsViewMutationResponse, type CurrentTableItemsViewOrderBy, CurrentTableItemsViewSelectColumn, type CurrentTableItemsViewSetInput, type CurrentTableItemsViewStddevFields, type CurrentTableItemsViewStddevPopFields, type CurrentTableItemsViewStddevSampFields, type CurrentTableItemsViewStreamCursorInput, type CurrentTableItemsViewStreamCursorValueInput, type CurrentTableItemsViewSumFields, type CurrentTableItemsViewUpdates, type CurrentTableItemsViewVarPopFields, type CurrentTableItemsViewVarSampFields, type CurrentTableItemsViewVarianceFields, type CurrentTokenDatas, type CurrentTokenDatasAggregate, type CurrentTokenDatasAggregateFields, type CurrentTokenDatasAggregateFieldsCountArgs, type CurrentTokenDatasAppendInput, type CurrentTokenDatasAvgFields, type CurrentTokenDatasBoolExp, CurrentTokenDatasConstraint, type CurrentTokenDatasDefaultPropertiesArgs, type CurrentTokenDatasDeleteAtPathInput, type CurrentTokenDatasDeleteElemInput, type CurrentTokenDatasDeleteKeyInput, type CurrentTokenDatasIncInput, type CurrentTokenDatasInsertInput, type CurrentTokenDatasMaxFields, type CurrentTokenDatasMinFields, type CurrentTokenDatasMutationResponse, type CurrentTokenDatasOnConflict, type CurrentTokenDatasOrderBy, type CurrentTokenDatasPkColumnsInput, type CurrentTokenDatasPrependInput, CurrentTokenDatasSelectColumn, type CurrentTokenDatasSetInput, type CurrentTokenDatasStddevFields, type CurrentTokenDatasStddevPopFields, type CurrentTokenDatasStddevSampFields, type CurrentTokenDatasStreamCursorInput, type CurrentTokenDatasStreamCursorValueInput, type CurrentTokenDatasSumFields, CurrentTokenDatasUpdateColumn, type CurrentTokenDatasUpdates, type CurrentTokenDatasV2, type CurrentTokenDatasV2Aggregate, type CurrentTokenDatasV2AggregateFields, type CurrentTokenDatasV2AggregateFieldsCountArgs, type CurrentTokenDatasV2AppendInput, type CurrentTokenDatasV2AvgFields, type CurrentTokenDatasV2BoolExp, CurrentTokenDatasV2Constraint, type CurrentTokenDatasV2CurrentTokenOwnershipsAggregateArgs, type CurrentTokenDatasV2CurrentTokenOwnershipsArgs, type CurrentTokenDatasV2DeleteAtPathInput, type CurrentTokenDatasV2DeleteElemInput, type CurrentTokenDatasV2DeleteKeyInput, type CurrentTokenDatasV2IncInput, type CurrentTokenDatasV2InsertInput, type CurrentTokenDatasV2MaxFields, type CurrentTokenDatasV2MinFields, type CurrentTokenDatasV2MutationResponse, type CurrentTokenDatasV2ObjRelInsertInput, type CurrentTokenDatasV2OnConflict, type CurrentTokenDatasV2OrderBy, type CurrentTokenDatasV2PkColumnsInput, type CurrentTokenDatasV2PrependInput, CurrentTokenDatasV2SelectColumn, type CurrentTokenDatasV2SetInput, type CurrentTokenDatasV2StddevFields, type CurrentTokenDatasV2StddevPopFields, type CurrentTokenDatasV2StddevSampFields, type CurrentTokenDatasV2StreamCursorInput, type CurrentTokenDatasV2StreamCursorValueInput, type CurrentTokenDatasV2SumFields, type CurrentTokenDatasV2TokenPropertiesArgs, CurrentTokenDatasV2UpdateColumn, type CurrentTokenDatasV2Updates, type CurrentTokenDatasV2VarPopFields, type CurrentTokenDatasV2VarSampFields, type CurrentTokenDatasV2VarianceFields, type CurrentTokenDatasVarPopFields, type CurrentTokenDatasVarSampFields, type CurrentTokenDatasVarianceFields, type CurrentTokenOwnerships, type CurrentTokenOwnershipsAggregate, type CurrentTokenOwnershipsAggregateFields, type CurrentTokenOwnershipsAggregateFieldsCountArgs, type CurrentTokenOwnershipsAppendInput, type CurrentTokenOwnershipsAvgFields, type CurrentTokenOwnershipsBoolExp, CurrentTokenOwnershipsConstraint, type CurrentTokenOwnershipsDeleteAtPathInput, type CurrentTokenOwnershipsDeleteElemInput, type CurrentTokenOwnershipsDeleteKeyInput, type CurrentTokenOwnershipsIncInput, type CurrentTokenOwnershipsInsertInput, type CurrentTokenOwnershipsMaxFields, type CurrentTokenOwnershipsMinFields, type CurrentTokenOwnershipsMutationResponse, type CurrentTokenOwnershipsOnConflict, type CurrentTokenOwnershipsOrderBy, type CurrentTokenOwnershipsPkColumnsInput, type CurrentTokenOwnershipsPrependInput, CurrentTokenOwnershipsSelectColumn, type CurrentTokenOwnershipsSetInput, type CurrentTokenOwnershipsStddevFields, type CurrentTokenOwnershipsStddevPopFields, type CurrentTokenOwnershipsStddevSampFields, type CurrentTokenOwnershipsStreamCursorInput, type CurrentTokenOwnershipsStreamCursorValueInput, type CurrentTokenOwnershipsSumFields, type CurrentTokenOwnershipsTokenPropertiesArgs, CurrentTokenOwnershipsUpdateColumn, type CurrentTokenOwnershipsUpdates, type CurrentTokenOwnershipsV2, type CurrentTokenOwnershipsV2Aggregate, type CurrentTokenOwnershipsV2AggregateBoolExp, type CurrentTokenOwnershipsV2AggregateBoolExpBoolAnd, type CurrentTokenOwnershipsV2AggregateBoolExpBoolOr, type CurrentTokenOwnershipsV2AggregateBoolExpCount, type CurrentTokenOwnershipsV2AggregateFields, type CurrentTokenOwnershipsV2AggregateFieldsCountArgs, type CurrentTokenOwnershipsV2AggregateOrderBy, type CurrentTokenOwnershipsV2AppendInput, type CurrentTokenOwnershipsV2ArrRelInsertInput, type CurrentTokenOwnershipsV2AvgFields, type CurrentTokenOwnershipsV2AvgOrderBy, type CurrentTokenOwnershipsV2BoolExp, type CurrentTokenOwnershipsV2ComposedNftsAggregateArgs, type CurrentTokenOwnershipsV2ComposedNftsArgs, CurrentTokenOwnershipsV2Constraint, type CurrentTokenOwnershipsV2DeleteAtPathInput, type CurrentTokenOwnershipsV2DeleteElemInput, type CurrentTokenOwnershipsV2DeleteKeyInput, type CurrentTokenOwnershipsV2IncInput, type CurrentTokenOwnershipsV2InsertInput, type CurrentTokenOwnershipsV2MaxFields, type CurrentTokenOwnershipsV2MaxOrderBy, type CurrentTokenOwnershipsV2MinFields, type CurrentTokenOwnershipsV2MinOrderBy, type CurrentTokenOwnershipsV2MutationResponse, type CurrentTokenOwnershipsV2OnConflict, type CurrentTokenOwnershipsV2OrderBy, type CurrentTokenOwnershipsV2PkColumnsInput, type CurrentTokenOwnershipsV2PrependInput, CurrentTokenOwnershipsV2SelectColumn, CurrentTokenOwnershipsV2SelectColumnCurrentTokenOwnershipsV2AggregateBoolExpBoolAndArgumentsColumns, CurrentTokenOwnershipsV2SelectColumnCurrentTokenOwnershipsV2AggregateBoolExpBoolOrArgumentsColumns, type CurrentTokenOwnershipsV2SetInput, type CurrentTokenOwnershipsV2StddevFields, type CurrentTokenOwnershipsV2StddevOrderBy, type CurrentTokenOwnershipsV2StddevPopFields, type CurrentTokenOwnershipsV2StddevPopOrderBy, type CurrentTokenOwnershipsV2StddevSampFields, type CurrentTokenOwnershipsV2StddevSampOrderBy, type CurrentTokenOwnershipsV2StreamCursorInput, type CurrentTokenOwnershipsV2StreamCursorValueInput, type CurrentTokenOwnershipsV2SumFields, type CurrentTokenOwnershipsV2SumOrderBy, type CurrentTokenOwnershipsV2TokenPropertiesMutatedV1Args, CurrentTokenOwnershipsV2UpdateColumn, type CurrentTokenOwnershipsV2Updates, type CurrentTokenOwnershipsV2VarPopFields, type CurrentTokenOwnershipsV2VarPopOrderBy, type CurrentTokenOwnershipsV2VarSampFields, type CurrentTokenOwnershipsV2VarSampOrderBy, type CurrentTokenOwnershipsV2VarianceFields, type CurrentTokenOwnershipsV2VarianceOrderBy, type CurrentTokenOwnershipsVarPopFields, type CurrentTokenOwnershipsVarSampFields, type CurrentTokenOwnershipsVarianceFields, type CurrentTokenPendingClaims, type CurrentTokenPendingClaimsAggregate, type CurrentTokenPendingClaimsAggregateFields, type CurrentTokenPendingClaimsAggregateFieldsCountArgs, type CurrentTokenPendingClaimsAvgFields, type CurrentTokenPendingClaimsBoolExp, CurrentTokenPendingClaimsConstraint, type CurrentTokenPendingClaimsIncInput, type CurrentTokenPendingClaimsInsertInput, type CurrentTokenPendingClaimsMaxFields, type CurrentTokenPendingClaimsMinFields, type CurrentTokenPendingClaimsMutationResponse, type CurrentTokenPendingClaimsOnConflict, type CurrentTokenPendingClaimsOrderBy, type CurrentTokenPendingClaimsPkColumnsInput, CurrentTokenPendingClaimsSelectColumn, type CurrentTokenPendingClaimsSetInput, type CurrentTokenPendingClaimsStddevFields, type CurrentTokenPendingClaimsStddevPopFields, type CurrentTokenPendingClaimsStddevSampFields, type CurrentTokenPendingClaimsStreamCursorInput, type CurrentTokenPendingClaimsStreamCursorValueInput, type CurrentTokenPendingClaimsSumFields, CurrentTokenPendingClaimsUpdateColumn, type CurrentTokenPendingClaimsUpdates, type CurrentTokenPendingClaimsVarPopFields, type CurrentTokenPendingClaimsVarSampFields, type CurrentTokenPendingClaimsVarianceFields, type CurrentTokenRoyaltyV1, type CurrentTokenRoyaltyV1Aggregate, type CurrentTokenRoyaltyV1AggregateFields, type CurrentTokenRoyaltyV1AggregateFieldsCountArgs, type CurrentTokenRoyaltyV1AvgFields, type CurrentTokenRoyaltyV1BoolExp, CurrentTokenRoyaltyV1Constraint, type CurrentTokenRoyaltyV1IncInput, type CurrentTokenRoyaltyV1InsertInput, type CurrentTokenRoyaltyV1MaxFields, type CurrentTokenRoyaltyV1MinFields, type CurrentTokenRoyaltyV1MutationResponse, type CurrentTokenRoyaltyV1ObjRelInsertInput, type CurrentTokenRoyaltyV1OnConflict, type CurrentTokenRoyaltyV1OrderBy, type CurrentTokenRoyaltyV1PkColumnsInput, CurrentTokenRoyaltyV1SelectColumn, type CurrentTokenRoyaltyV1SetInput, type CurrentTokenRoyaltyV1StddevFields, type CurrentTokenRoyaltyV1StddevPopFields, type CurrentTokenRoyaltyV1StddevSampFields, type CurrentTokenRoyaltyV1StreamCursorInput, type CurrentTokenRoyaltyV1StreamCursorValueInput, type CurrentTokenRoyaltyV1SumFields, CurrentTokenRoyaltyV1UpdateColumn, type CurrentTokenRoyaltyV1Updates, type CurrentTokenRoyaltyV1VarPopFields, type CurrentTokenRoyaltyV1VarSampFields, type CurrentTokenRoyaltyV1VarianceFields, type CurrentTokenV2Metadata, type CurrentTokenV2MetadataAggregate, type CurrentTokenV2MetadataAggregateFields, type CurrentTokenV2MetadataAggregateFieldsCountArgs, type CurrentTokenV2MetadataAppendInput, type CurrentTokenV2MetadataAvgFields, type CurrentTokenV2MetadataBoolExp, CurrentTokenV2MetadataConstraint, type CurrentTokenV2MetadataDataArgs, type CurrentTokenV2MetadataDeleteAtPathInput, type CurrentTokenV2MetadataDeleteElemInput, type CurrentTokenV2MetadataDeleteKeyInput, type CurrentTokenV2MetadataIncInput, type CurrentTokenV2MetadataInsertInput, type CurrentTokenV2MetadataMaxFields, type CurrentTokenV2MetadataMinFields, type CurrentTokenV2MetadataMutationResponse, type CurrentTokenV2MetadataOnConflict, type CurrentTokenV2MetadataOrderBy, type CurrentTokenV2MetadataPkColumnsInput, type CurrentTokenV2MetadataPrependInput, CurrentTokenV2MetadataSelectColumn, type CurrentTokenV2MetadataSetInput, type CurrentTokenV2MetadataStddevFields, type CurrentTokenV2MetadataStddevPopFields, type CurrentTokenV2MetadataStddevSampFields, type CurrentTokenV2MetadataStreamCursorInput, type CurrentTokenV2MetadataStreamCursorValueInput, type CurrentTokenV2MetadataSumFields, CurrentTokenV2MetadataUpdateColumn, type CurrentTokenV2MetadataUpdates, type CurrentTokenV2MetadataVarPopFields, type CurrentTokenV2MetadataVarSampFields, type CurrentTokenV2MetadataVarianceFields, CursorOrdering, type DelegatedStakingActivities, type DelegatedStakingActivitiesAggregate, type DelegatedStakingActivitiesAggregateBoolExp, type DelegatedStakingActivitiesAggregateBoolExpCount, type DelegatedStakingActivitiesAggregateFields, type DelegatedStakingActivitiesAggregateFieldsCountArgs, type DelegatedStakingActivitiesAggregateOrderBy, type DelegatedStakingActivitiesArrRelInsertInput, type DelegatedStakingActivitiesAvgFields, type DelegatedStakingActivitiesAvgOrderBy, type DelegatedStakingActivitiesBoolExp, DelegatedStakingActivitiesConstraint, type DelegatedStakingActivitiesIncInput, type DelegatedStakingActivitiesInsertInput, type DelegatedStakingActivitiesMaxFields, type DelegatedStakingActivitiesMaxOrderBy, type DelegatedStakingActivitiesMinFields, type DelegatedStakingActivitiesMinOrderBy, type DelegatedStakingActivitiesMutationResponse, type DelegatedStakingActivitiesOnConflict, type DelegatedStakingActivitiesOrderBy, type DelegatedStakingActivitiesPkColumnsInput, DelegatedStakingActivitiesSelectColumn, type DelegatedStakingActivitiesSetInput, type DelegatedStakingActivitiesStddevFields, type DelegatedStakingActivitiesStddevOrderBy, type DelegatedStakingActivitiesStddevPopFields, type DelegatedStakingActivitiesStddevPopOrderBy, type DelegatedStakingActivitiesStddevSampFields, type DelegatedStakingActivitiesStddevSampOrderBy, type DelegatedStakingActivitiesStreamCursorInput, type DelegatedStakingActivitiesStreamCursorValueInput, type DelegatedStakingActivitiesSumFields, type DelegatedStakingActivitiesSumOrderBy, DelegatedStakingActivitiesUpdateColumn, type DelegatedStakingActivitiesUpdates, type DelegatedStakingActivitiesVarPopFields, type DelegatedStakingActivitiesVarPopOrderBy, type DelegatedStakingActivitiesVarSampFields, type DelegatedStakingActivitiesVarSampOrderBy, type DelegatedStakingActivitiesVarianceFields, type DelegatedStakingActivitiesVarianceOrderBy, type DelegatedStakingPoolBalances, type DelegatedStakingPoolBalancesAggregate, type DelegatedStakingPoolBalancesAggregateFields, type DelegatedStakingPoolBalancesAggregateFieldsCountArgs, type DelegatedStakingPoolBalancesAvgFields, type DelegatedStakingPoolBalancesBoolExp, DelegatedStakingPoolBalancesConstraint, type DelegatedStakingPoolBalancesIncInput, type DelegatedStakingPoolBalancesInsertInput, type DelegatedStakingPoolBalancesMaxFields, type DelegatedStakingPoolBalancesMinFields, type DelegatedStakingPoolBalancesMutationResponse, type DelegatedStakingPoolBalancesOnConflict, type DelegatedStakingPoolBalancesOrderBy, type DelegatedStakingPoolBalancesPkColumnsInput, DelegatedStakingPoolBalancesSelectColumn, type DelegatedStakingPoolBalancesSetInput, type DelegatedStakingPoolBalancesStddevFields, type DelegatedStakingPoolBalancesStddevPopFields, type DelegatedStakingPoolBalancesStddevSampFields, type DelegatedStakingPoolBalancesStreamCursorInput, type DelegatedStakingPoolBalancesStreamCursorValueInput, type DelegatedStakingPoolBalancesSumFields, DelegatedStakingPoolBalancesUpdateColumn, type DelegatedStakingPoolBalancesUpdates, type DelegatedStakingPoolBalancesVarPopFields, type DelegatedStakingPoolBalancesVarSampFields, type DelegatedStakingPoolBalancesVarianceFields, type DelegatedStakingPools, type DelegatedStakingPoolsAggregate, type DelegatedStakingPoolsAggregateFields, type DelegatedStakingPoolsAggregateFieldsCountArgs, type DelegatedStakingPoolsAvgFields, type DelegatedStakingPoolsBoolExp, DelegatedStakingPoolsConstraint, type DelegatedStakingPoolsIncInput, type DelegatedStakingPoolsInsertInput, type DelegatedStakingPoolsMaxFields, type DelegatedStakingPoolsMinFields, type DelegatedStakingPoolsMutationResponse, type DelegatedStakingPoolsOnConflict, type DelegatedStakingPoolsOrderBy, type DelegatedStakingPoolsPkColumnsInput, DelegatedStakingPoolsSelectColumn, type DelegatedStakingPoolsSetInput, type DelegatedStakingPoolsStddevFields, type DelegatedStakingPoolsStddevPopFields, type DelegatedStakingPoolsStddevSampFields, type DelegatedStakingPoolsStreamCursorInput, type DelegatedStakingPoolsStreamCursorValueInput, type DelegatedStakingPoolsSumFields, DelegatedStakingPoolsUpdateColumn, type DelegatedStakingPoolsUpdates, type DelegatedStakingPoolsVarPopFields, type DelegatedStakingPoolsVarSampFields, type DelegatedStakingPoolsVarianceFields, type DelegatorBalances, type DelegatorBalancesAggregate, type DelegatorBalancesAggregateFields, type DelegatorBalancesAggregateFieldsCountArgs, type DelegatorBalancesAvgFields, type DelegatorBalancesBoolExp, DelegatorBalancesConstraint, type DelegatorBalancesIncInput, type DelegatorBalancesInsertInput, type DelegatorBalancesMaxFields, type DelegatorBalancesMinFields, type DelegatorBalancesMutationResponse, type DelegatorBalancesOnConflict, type DelegatorBalancesOrderBy, type DelegatorBalancesPkColumnsInput, DelegatorBalancesSelectColumn, type DelegatorBalancesSetInput, type DelegatorBalancesStddevFields, type DelegatorBalancesStddevPopFields, type DelegatorBalancesStddevSampFields, type DelegatorBalancesStreamCursorInput, type DelegatorBalancesStreamCursorValueInput, type DelegatorBalancesSumFields, DelegatorBalancesUpdateColumn, type DelegatorBalancesUpdates, type DelegatorBalancesVarPopFields, type DelegatorBalancesVarSampFields, type DelegatorBalancesVarianceFields, type DelegatorDistinctPool, type DelegatorDistinctPoolAggregate, type DelegatorDistinctPoolAggregateFields, type DelegatorDistinctPoolAggregateFieldsCountArgs, type DelegatorDistinctPoolBoolExp, type DelegatorDistinctPoolMaxFields, type DelegatorDistinctPoolMinFields, type DelegatorDistinctPoolOrderBy, DelegatorDistinctPoolSelectColumn, type DelegatorDistinctPoolStreamCursorInput, type DelegatorDistinctPoolStreamCursorValueInput, type EventSizeInfo, type EventSizeInfoAggregate, type EventSizeInfoAggregateFields, type EventSizeInfoAggregateFieldsCountArgs, type EventSizeInfoAvgFields, type EventSizeInfoBoolExp, EventSizeInfoConstraint, type EventSizeInfoIncInput, type EventSizeInfoInsertInput, type EventSizeInfoMaxFields, type EventSizeInfoMinFields, type EventSizeInfoMutationResponse, type EventSizeInfoOnConflict, type EventSizeInfoOrderBy, type EventSizeInfoPkColumnsInput, EventSizeInfoSelectColumn, type EventSizeInfoSetInput, type EventSizeInfoStddevFields, type EventSizeInfoStddevPopFields, type EventSizeInfoStddevSampFields, type EventSizeInfoStreamCursorInput, type EventSizeInfoStreamCursorValueInput, type EventSizeInfoSumFields, EventSizeInfoUpdateColumn, type EventSizeInfoUpdates, type EventSizeInfoVarPopFields, type EventSizeInfoVarSampFields, type EventSizeInfoVarianceFields, type Events, type EventsAggregate, type EventsAggregateFields, type EventsAggregateFieldsCountArgs, type EventsAppendInput, type EventsAvgFields, type EventsBoolExp, EventsConstraint, type EventsDataArgs, type EventsDeleteAtPathInput, type EventsDeleteElemInput, type EventsDeleteKeyInput, type EventsIncInput, type EventsInsertInput, type EventsMaxFields, type EventsMinFields, type EventsMutationResponse, type EventsOnConflict, type EventsOrderBy, type EventsPkColumnsInput, type EventsPrependInput, EventsSelectColumn, type EventsSetInput, type EventsStddevFields, type EventsStddevPopFields, type EventsStddevSampFields, type EventsStreamCursorInput, type EventsStreamCursorValueInput, type EventsSumFields, EventsUpdateColumn, type EventsUpdates, type EventsVarPopFields, type EventsVarSampFields, type EventsVarianceFields, type EventsView, type EventsViewAggregate, type EventsViewAggregateFields, type EventsViewAggregateFieldsCountArgs, type EventsViewAvgFields, type EventsViewBoolExp, type EventsViewIncInput, type EventsViewInsertInput, type EventsViewMaxFields, type EventsViewMinFields, type EventsViewMutationResponse, type EventsViewOrderBy, EventsViewSelectColumn, type EventsViewSetInput, type EventsViewStddevFields, type EventsViewStddevPopFields, type EventsViewStddevSampFields, type EventsViewStreamCursorInput, type EventsViewStreamCursorValueInput, type EventsViewSumFields, type EventsViewUpdates, type EventsViewVarPopFields, type EventsViewVarSampFields, type EventsViewVarianceFields, type Exact, type FungibleAssetActivities, type FungibleAssetActivitiesAggregate, type FungibleAssetActivitiesAggregateBoolExp, type FungibleAssetActivitiesAggregateBoolExpBoolAnd, type FungibleAssetActivitiesAggregateBoolExpBoolOr, type FungibleAssetActivitiesAggregateBoolExpCount, type FungibleAssetActivitiesAggregateFields, type FungibleAssetActivitiesAggregateFieldsCountArgs, type FungibleAssetActivitiesAggregateOrderBy, type FungibleAssetActivitiesArrRelInsertInput, type FungibleAssetActivitiesAvgFields, type FungibleAssetActivitiesAvgOrderBy, type FungibleAssetActivitiesBoolExp, FungibleAssetActivitiesConstraint, type FungibleAssetActivitiesIncInput, type FungibleAssetActivitiesInsertInput, type FungibleAssetActivitiesMaxFields, type FungibleAssetActivitiesMaxOrderBy, type FungibleAssetActivitiesMinFields, type FungibleAssetActivitiesMinOrderBy, type FungibleAssetActivitiesMutationResponse, type FungibleAssetActivitiesOnConflict, type FungibleAssetActivitiesOrderBy, type FungibleAssetActivitiesOwnerCedraNamesAggregateArgs, type FungibleAssetActivitiesOwnerCedraNamesArgs, type FungibleAssetActivitiesPkColumnsInput, FungibleAssetActivitiesSelectColumn, FungibleAssetActivitiesSelectColumnFungibleAssetActivitiesAggregateBoolExpBoolAndArgumentsColumns, FungibleAssetActivitiesSelectColumnFungibleAssetActivitiesAggregateBoolExpBoolOrArgumentsColumns, type FungibleAssetActivitiesSetInput, type FungibleAssetActivitiesStddevFields, type FungibleAssetActivitiesStddevOrderBy, type FungibleAssetActivitiesStddevPopFields, type FungibleAssetActivitiesStddevPopOrderBy, type FungibleAssetActivitiesStddevSampFields, type FungibleAssetActivitiesStddevSampOrderBy, type FungibleAssetActivitiesStreamCursorInput, type FungibleAssetActivitiesStreamCursorValueInput, type FungibleAssetActivitiesSumFields, type FungibleAssetActivitiesSumOrderBy, FungibleAssetActivitiesUpdateColumn, type FungibleAssetActivitiesUpdates, type FungibleAssetActivitiesVarPopFields, type FungibleAssetActivitiesVarPopOrderBy, type FungibleAssetActivitiesVarSampFields, type FungibleAssetActivitiesVarSampOrderBy, type FungibleAssetActivitiesVarianceFields, type FungibleAssetActivitiesVarianceOrderBy, type FungibleAssetBalances, type FungibleAssetBalancesAggregate, type FungibleAssetBalancesAggregateFields, type FungibleAssetBalancesAggregateFieldsCountArgs, type FungibleAssetBalancesAvgFields, type FungibleAssetBalancesBoolExp, FungibleAssetBalancesConstraint, type FungibleAssetBalancesIncInput, type FungibleAssetBalancesInsertInput, type FungibleAssetBalancesMaxFields, type FungibleAssetBalancesMinFields, type FungibleAssetBalancesMutationResponse, type FungibleAssetBalancesOnConflict, type FungibleAssetBalancesOrderBy, type FungibleAssetBalancesPkColumnsInput, FungibleAssetBalancesSelectColumn, type FungibleAssetBalancesSetInput, type FungibleAssetBalancesStddevFields, type FungibleAssetBalancesStddevPopFields, type FungibleAssetBalancesStddevSampFields, type FungibleAssetBalancesStreamCursorInput, type FungibleAssetBalancesStreamCursorValueInput, type FungibleAssetBalancesSumFields, FungibleAssetBalancesUpdateColumn, type FungibleAssetBalancesUpdates, type FungibleAssetBalancesVarPopFields, type FungibleAssetBalancesVarSampFields, type FungibleAssetBalancesVarianceFields, type FungibleAssetMetadata, type FungibleAssetMetadataAggregate, type FungibleAssetMetadataAggregateFields, type FungibleAssetMetadataAggregateFieldsCountArgs, type FungibleAssetMetadataAvgFields, type FungibleAssetMetadataBoolExp, FungibleAssetMetadataConstraint, type FungibleAssetMetadataIncInput, type FungibleAssetMetadataInsertInput, type FungibleAssetMetadataMaxFields, type FungibleAssetMetadataMinFields, type FungibleAssetMetadataMutationResponse, type FungibleAssetMetadataObjRelInsertInput, type FungibleAssetMetadataOnConflict, type FungibleAssetMetadataOrderBy, type FungibleAssetMetadataPkColumnsInput, FungibleAssetMetadataSelectColumn, type FungibleAssetMetadataSetInput, type FungibleAssetMetadataStddevFields, type FungibleAssetMetadataStddevPopFields, type FungibleAssetMetadataStddevSampFields, type FungibleAssetMetadataStreamCursorInput, type FungibleAssetMetadataStreamCursorValueInput, type FungibleAssetMetadataSumFields, FungibleAssetMetadataUpdateColumn, type FungibleAssetMetadataUpdates, type FungibleAssetMetadataVarPopFields, type FungibleAssetMetadataVarSampFields, type FungibleAssetMetadataVarianceFields, type FungibleAssetToCoinMappings, type FungibleAssetToCoinMappingsAggregate, type FungibleAssetToCoinMappingsAggregateFields, type FungibleAssetToCoinMappingsAggregateFieldsCountArgs, type FungibleAssetToCoinMappingsAvgFields, type FungibleAssetToCoinMappingsBoolExp, FungibleAssetToCoinMappingsConstraint, type FungibleAssetToCoinMappingsIncInput, type FungibleAssetToCoinMappingsInsertInput, type FungibleAssetToCoinMappingsMaxFields, type FungibleAssetToCoinMappingsMinFields, type FungibleAssetToCoinMappingsMutationResponse, type FungibleAssetToCoinMappingsOnConflict, type FungibleAssetToCoinMappingsOrderBy, type FungibleAssetToCoinMappingsPkColumnsInput, FungibleAssetToCoinMappingsSelectColumn, type FungibleAssetToCoinMappingsSetInput, type FungibleAssetToCoinMappingsStddevFields, type FungibleAssetToCoinMappingsStddevPopFields, type FungibleAssetToCoinMappingsStddevSampFields, type FungibleAssetToCoinMappingsStreamCursorInput, type FungibleAssetToCoinMappingsStreamCursorValueInput, type FungibleAssetToCoinMappingsSumFields, FungibleAssetToCoinMappingsUpdateColumn, type FungibleAssetToCoinMappingsUpdates, type FungibleAssetToCoinMappingsVarPopFields, type FungibleAssetToCoinMappingsVarSampFields, type FungibleAssetToCoinMappingsVarianceFields, type GasFees, type GasFeesAggregate, type GasFeesAggregateFields, type GasFeesAggregateFieldsCountArgs, type GasFeesAvgFields, type GasFeesBoolExp, GasFeesConstraint, type GasFeesIncInput, type GasFeesInsertInput, type GasFeesMaxFields, type GasFeesMinFields, type GasFeesMutationResponse, type GasFeesOnConflict, type GasFeesOrderBy, type GasFeesPkColumnsInput, GasFeesSelectColumn, type GasFeesSetInput, type GasFeesStddevFields, type GasFeesStddevPopFields, type GasFeesStddevSampFields, type GasFeesStreamCursorInput, type GasFeesStreamCursorValueInput, type GasFeesSumFields, GasFeesUpdateColumn, type GasFeesUpdates, type GasFeesVarPopFields, type GasFeesVarSampFields, type GasFeesVarianceFields, type Incremental, type IndexerStatus, type IndexerStatusAggregate, type IndexerStatusAggregateFields, type IndexerStatusAggregateFieldsCountArgs, type IndexerStatusBoolExp, IndexerStatusConstraint, type IndexerStatusInsertInput, type IndexerStatusMaxFields, type IndexerStatusMinFields, type IndexerStatusMutationResponse, type IndexerStatusOnConflict, type IndexerStatusOrderBy, type IndexerStatusPkColumnsInput, IndexerStatusSelectColumn, type IndexerStatusSetInput, type IndexerStatusStreamCursorInput, type IndexerStatusStreamCursorValueInput, IndexerStatusUpdateColumn, type IndexerStatusUpdates, type InputMaybe, type IntComparisonExp, type JsonbCastExp, type JsonbComparisonExp, type MakeEmpty, type MakeMaybe, type MakeOptional, type Maybe, type MoveModules, type MoveModulesAggregate, type MoveModulesAggregateFields, type MoveModulesAggregateFieldsCountArgs, type MoveModulesAppendInput, type MoveModulesAvgFields, type MoveModulesBoolExp, MoveModulesConstraint, type MoveModulesDeleteAtPathInput, type MoveModulesDeleteElemInput, type MoveModulesDeleteKeyInput, type MoveModulesExposedFunctionsArgs, type MoveModulesFriendsArgs, type MoveModulesIncInput, type MoveModulesInsertInput, type MoveModulesMaxFields, type MoveModulesMinFields, type MoveModulesMutationResponse, type MoveModulesOnConflict, type MoveModulesOrderBy, type MoveModulesPkColumnsInput, type MoveModulesPrependInput, MoveModulesSelectColumn, type MoveModulesSetInput, type MoveModulesStddevFields, type MoveModulesStddevPopFields, type MoveModulesStddevSampFields, type MoveModulesStreamCursorInput, type MoveModulesStreamCursorValueInput, type MoveModulesStructsArgs, type MoveModulesSumFields, MoveModulesUpdateColumn, type MoveModulesUpdates, type MoveModulesVarPopFields, type MoveModulesVarSampFields, type MoveModulesVarianceFields, type MoveResources, type MoveResourcesAggregate, type MoveResourcesAggregateFields, type MoveResourcesAggregateFieldsCountArgs, type MoveResourcesAppendInput, type MoveResourcesAvgFields, type MoveResourcesBoolExp, MoveResourcesConstraint, type MoveResourcesDataArgs, type MoveResourcesDeleteAtPathInput, type MoveResourcesDeleteElemInput, type MoveResourcesDeleteKeyInput, type MoveResourcesGenericTypeParamsArgs, type MoveResourcesIncInput, type MoveResourcesInsertInput, type MoveResourcesMaxFields, type MoveResourcesMinFields, type MoveResourcesMutationResponse, type MoveResourcesOnConflict, type MoveResourcesOrderBy, type MoveResourcesPkColumnsInput, type MoveResourcesPrependInput, MoveResourcesSelectColumn, type MoveResourcesSetInput, type MoveResourcesStddevFields, type MoveResourcesStddevPopFields, type MoveResourcesStddevSampFields, type MoveResourcesStreamCursorInput, type MoveResourcesStreamCursorValueInput, type MoveResourcesSumFields, MoveResourcesUpdateColumn, type MoveResourcesUpdates, type MoveResourcesVarPopFields, type MoveResourcesVarSampFields, type MoveResourcesVarianceFields, type MoveResourcesView, type MoveResourcesViewAggregate, type MoveResourcesViewAggregateFields, type MoveResourcesViewAggregateFieldsCountArgs, type MoveResourcesViewAppendInput, type MoveResourcesViewAvgFields, type MoveResourcesViewBoolExp, type MoveResourcesViewDeleteAtPathInput, type MoveResourcesViewDeleteElemInput, type MoveResourcesViewDeleteKeyInput, type MoveResourcesViewGenericTypeParamsArgs, type MoveResourcesViewIncInput, type MoveResourcesViewInsertInput, type MoveResourcesViewMaxFields, type MoveResourcesViewMinFields, type MoveResourcesViewMutationResponse, type MoveResourcesViewOrderBy, type MoveResourcesViewPrependInput, MoveResourcesViewSelectColumn, type MoveResourcesViewSetInput, type MoveResourcesViewStddevFields, type MoveResourcesViewStddevPopFields, type MoveResourcesViewStddevSampFields, type MoveResourcesViewStreamCursorInput, type MoveResourcesViewStreamCursorValueInput, type MoveResourcesViewSumFields, type MoveResourcesViewUpdates, type MoveResourcesViewVarPopFields, type MoveResourcesViewVarSampFields, type MoveResourcesViewVarianceFields, type MutationRoot, type MutationRootDeleteAccountTransactionsArgs, type MutationRootDeleteAccountTransactionsByPkArgs, type MutationRootDeleteAnsLookupArgs, type MutationRootDeleteAnsLookupByPkArgs, type MutationRootDeleteAnsLookupV2Args, type MutationRootDeleteAnsLookupV2ByPkArgs, type MutationRootDeleteAnsPrimaryNameArgs, type MutationRootDeleteAnsPrimaryNameByPkArgs, type MutationRootDeleteAnsPrimaryNameV2Args, type MutationRootDeleteAnsPrimaryNameV2ByPkArgs, type MutationRootDeleteAuthKeyAccountAddressesArgs, type MutationRootDeleteAuthKeyAccountAddressesByPkArgs, type MutationRootDeleteBlockMetadataTransactionsArgs, type MutationRootDeleteBlockMetadataTransactionsByPkArgs, type MutationRootDeleteCoinActivitiesArgs, type MutationRootDeleteCoinActivitiesByPkArgs, type MutationRootDeleteCoinBalancesArgs, type MutationRootDeleteCoinBalancesByPkArgs, type MutationRootDeleteCoinInfosArgs, type MutationRootDeleteCoinInfosByPkArgs, type MutationRootDeleteCoinSupplyArgs, type MutationRootDeleteCoinSupplyByPkArgs, type MutationRootDeleteCollectionDatasArgs, type MutationRootDeleteCollectionDatasByPkArgs, type MutationRootDeleteCollectionsV2Args, type MutationRootDeleteCollectionsV2ByPkArgs, type MutationRootDeleteCurrentAnsLookupArgs, type MutationRootDeleteCurrentAnsLookupByPkArgs, type MutationRootDeleteCurrentAnsLookupV2Args, type MutationRootDeleteCurrentAnsLookupV2ByPkArgs, type MutationRootDeleteCurrentAnsPrimaryNameArgs, type MutationRootDeleteCurrentAnsPrimaryNameByPkArgs, type MutationRootDeleteCurrentAnsPrimaryNameV2Args, type MutationRootDeleteCurrentAnsPrimaryNameV2ByPkArgs, type MutationRootDeleteCurrentCoinBalancesArgs, type MutationRootDeleteCurrentCoinBalancesByPkArgs, type MutationRootDeleteCurrentCollectionDatasArgs, type MutationRootDeleteCurrentCollectionDatasByPkArgs, type MutationRootDeleteCurrentCollectionsV2Args, type MutationRootDeleteCurrentCollectionsV2ByPkArgs, type MutationRootDeleteCurrentDelegatedStakingPoolBalancesArgs, type MutationRootDeleteCurrentDelegatedStakingPoolBalancesByPkArgs, type MutationRootDeleteCurrentDelegatedVoterArgs, type MutationRootDeleteCurrentDelegatedVoterByPkArgs, type MutationRootDeleteCurrentDelegatorBalancesArgs, type MutationRootDeleteCurrentDelegatorBalancesByPkArgs, type MutationRootDeleteCurrentFungibleAssetBalancesArgs, type MutationRootDeleteCurrentFungibleAssetBalancesByPkArgs, type MutationRootDeleteCurrentFungibleAssetBalancesNewArgs, type MutationRootDeleteCurrentFungibleAssetBalancesNewByPkArgs, type MutationRootDeleteCurrentObjectsArgs, type MutationRootDeleteCurrentObjectsByPkArgs, type MutationRootDeleteCurrentStakingPoolVoterArgs, type MutationRootDeleteCurrentStakingPoolVoterByPkArgs, type MutationRootDeleteCurrentTableItemsArgs, type MutationRootDeleteCurrentTableItemsByPkArgs, type MutationRootDeleteCurrentTableItemsViewArgs, type MutationRootDeleteCurrentTokenDatasArgs, type MutationRootDeleteCurrentTokenDatasByPkArgs, type MutationRootDeleteCurrentTokenDatasV2Args, type MutationRootDeleteCurrentTokenDatasV2ByPkArgs, type MutationRootDeleteCurrentTokenOwnershipsArgs, type MutationRootDeleteCurrentTokenOwnershipsByPkArgs, type MutationRootDeleteCurrentTokenOwnershipsV2Args, type MutationRootDeleteCurrentTokenOwnershipsV2ByPkArgs, type MutationRootDeleteCurrentTokenPendingClaimsArgs, type MutationRootDeleteCurrentTokenPendingClaimsByPkArgs, type MutationRootDeleteCurrentTokenRoyaltyV1Args, type MutationRootDeleteCurrentTokenRoyaltyV1ByPkArgs, type MutationRootDeleteCurrentTokenV2MetadataArgs, type MutationRootDeleteCurrentTokenV2MetadataByPkArgs, type MutationRootDeleteDelegatedStakingActivitiesArgs, type MutationRootDeleteDelegatedStakingActivitiesByPkArgs, type MutationRootDeleteDelegatedStakingPoolBalancesArgs, type MutationRootDeleteDelegatedStakingPoolBalancesByPkArgs, type MutationRootDeleteDelegatedStakingPoolsArgs, type MutationRootDeleteDelegatedStakingPoolsByPkArgs, type MutationRootDeleteDelegatorBalancesArgs, type MutationRootDeleteDelegatorBalancesByPkArgs, type MutationRootDeleteEventSizeInfoArgs, type MutationRootDeleteEventSizeInfoByPkArgs, type MutationRootDeleteEventsArgs, type MutationRootDeleteEventsByPkArgs, type MutationRootDeleteEventsViewArgs, type MutationRootDeleteFungibleAssetActivitiesArgs, type MutationRootDeleteFungibleAssetActivitiesByPkArgs, type MutationRootDeleteFungibleAssetBalancesArgs, type MutationRootDeleteFungibleAssetBalancesByPkArgs, type MutationRootDeleteFungibleAssetMetadataArgs, type MutationRootDeleteFungibleAssetMetadataByPkArgs, type MutationRootDeleteFungibleAssetToCoinMappingsArgs, type MutationRootDeleteFungibleAssetToCoinMappingsByPkArgs, type MutationRootDeleteGasFeesArgs, type MutationRootDeleteGasFeesByPkArgs, type MutationRootDeleteIndexerStatusArgs, type MutationRootDeleteIndexerStatusByPkArgs, type MutationRootDeleteMoveModulesArgs, type MutationRootDeleteMoveModulesByPkArgs, type MutationRootDeleteMoveResourcesArgs, type MutationRootDeleteMoveResourcesByPkArgs, type MutationRootDeleteMoveResourcesViewArgs, type MutationRootDeleteNftMetadataCrawlerParsedAssetUrisArgs, type MutationRootDeleteNftMetadataCrawlerParsedAssetUrisByPkArgs, type MutationRootDeleteNftPointsArgs, type MutationRootDeleteNftPointsByPkArgs, type MutationRootDeleteObjectsArgs, type MutationRootDeleteObjectsByPkArgs, type MutationRootDeleteProcessorMetadataProcessorStatusArgs, type MutationRootDeleteProcessorMetadataProcessorStatusByPkArgs, type MutationRootDeleteProcessorStatusArgs, type MutationRootDeleteProcessorStatusByPkArgs, type MutationRootDeleteProposalVotesArgs, type MutationRootDeleteProposalVotesByPkArgs, type MutationRootDeletePublicKeyAuthKeysArgs, type MutationRootDeletePublicKeyAuthKeysByPkArgs, type MutationRootDeleteSignaturesArgs, type MutationRootDeleteSignaturesByPkArgs, type MutationRootDeleteSpamAssetsArgs, type MutationRootDeleteSpamAssetsByPkArgs, type MutationRootDeleteTableItemsArgs, type MutationRootDeleteTableItemsByPkArgs, type MutationRootDeleteTableItemsViewArgs, type MutationRootDeleteTableMetadatasArgs, type MutationRootDeleteTableMetadatasByPkArgs, type MutationRootDeleteTokenActivitiesArgs, type MutationRootDeleteTokenActivitiesByPkArgs, type MutationRootDeleteTokenActivitiesV2Args, type MutationRootDeleteTokenActivitiesV2ByPkArgs, type MutationRootDeleteTokenDatasArgs, type MutationRootDeleteTokenDatasByPkArgs, type MutationRootDeleteTokenDatasV2Args, type MutationRootDeleteTokenDatasV2ByPkArgs, type MutationRootDeleteTokenOwnershipsArgs, type MutationRootDeleteTokenOwnershipsByPkArgs, type MutationRootDeleteTokenOwnershipsV2Args, type MutationRootDeleteTokenOwnershipsV2ByPkArgs, type MutationRootDeleteTokensArgs, type MutationRootDeleteTokensByPkArgs, type MutationRootDeleteTransactionSizeInfoArgs, type MutationRootDeleteTransactionSizeInfoByPkArgs, type MutationRootDeleteTransactionsViewArgs, type MutationRootDeleteUserTransactionsArgs, type MutationRootDeleteUserTransactionsByPkArgs, type MutationRootInsertAccountTransactionsArgs, type MutationRootInsertAccountTransactionsOneArgs, type MutationRootInsertAnsLookupArgs, type MutationRootInsertAnsLookupOneArgs, type MutationRootInsertAnsLookupV2Args, type MutationRootInsertAnsLookupV2OneArgs, type MutationRootInsertAnsPrimaryNameArgs, type MutationRootInsertAnsPrimaryNameOneArgs, type MutationRootInsertAnsPrimaryNameV2Args, type MutationRootInsertAnsPrimaryNameV2OneArgs, type MutationRootInsertAuthKeyAccountAddressesArgs, type MutationRootInsertAuthKeyAccountAddressesOneArgs, type MutationRootInsertBlockMetadataTransactionsArgs, type MutationRootInsertBlockMetadataTransactionsOneArgs, type MutationRootInsertCoinActivitiesArgs, type MutationRootInsertCoinActivitiesOneArgs, type MutationRootInsertCoinBalancesArgs, type MutationRootInsertCoinBalancesOneArgs, type MutationRootInsertCoinInfosArgs, type MutationRootInsertCoinInfosOneArgs, type MutationRootInsertCoinSupplyArgs, type MutationRootInsertCoinSupplyOneArgs, type MutationRootInsertCollectionDatasArgs, type MutationRootInsertCollectionDatasOneArgs, type MutationRootInsertCollectionsV2Args, type MutationRootInsertCollectionsV2OneArgs, type MutationRootInsertCurrentAnsLookupArgs, type MutationRootInsertCurrentAnsLookupOneArgs, type MutationRootInsertCurrentAnsLookupV2Args, type MutationRootInsertCurrentAnsLookupV2OneArgs, type MutationRootInsertCurrentAnsPrimaryNameArgs, type MutationRootInsertCurrentAnsPrimaryNameOneArgs, type MutationRootInsertCurrentAnsPrimaryNameV2Args, type MutationRootInsertCurrentAnsPrimaryNameV2OneArgs, type MutationRootInsertCurrentCoinBalancesArgs, type MutationRootInsertCurrentCoinBalancesOneArgs, type MutationRootInsertCurrentCollectionDatasArgs, type MutationRootInsertCurrentCollectionDatasOneArgs, type MutationRootInsertCurrentCollectionsV2Args, type MutationRootInsertCurrentCollectionsV2OneArgs, type MutationRootInsertCurrentDelegatedStakingPoolBalancesArgs, type MutationRootInsertCurrentDelegatedStakingPoolBalancesOneArgs, type MutationRootInsertCurrentDelegatedVoterArgs, type MutationRootInsertCurrentDelegatedVoterOneArgs, type MutationRootInsertCurrentDelegatorBalancesArgs, type MutationRootInsertCurrentDelegatorBalancesOneArgs, type MutationRootInsertCurrentFungibleAssetBalancesArgs, type MutationRootInsertCurrentFungibleAssetBalancesNewArgs, type MutationRootInsertCurrentFungibleAssetBalancesNewOneArgs, type MutationRootInsertCurrentFungibleAssetBalancesOneArgs, type MutationRootInsertCurrentObjectsArgs, type MutationRootInsertCurrentObjectsOneArgs, type MutationRootInsertCurrentStakingPoolVoterArgs, type MutationRootInsertCurrentStakingPoolVoterOneArgs, type MutationRootInsertCurrentTableItemsArgs, type MutationRootInsertCurrentTableItemsOneArgs, type MutationRootInsertCurrentTableItemsViewArgs, type MutationRootInsertCurrentTableItemsViewOneArgs, type MutationRootInsertCurrentTokenDatasArgs, type MutationRootInsertCurrentTokenDatasOneArgs, type MutationRootInsertCurrentTokenDatasV2Args, type MutationRootInsertCurrentTokenDatasV2OneArgs, type MutationRootInsertCurrentTokenOwnershipsArgs, type MutationRootInsertCurrentTokenOwnershipsOneArgs, type MutationRootInsertCurrentTokenOwnershipsV2Args, type MutationRootInsertCurrentTokenOwnershipsV2OneArgs, type MutationRootInsertCurrentTokenPendingClaimsArgs, type MutationRootInsertCurrentTokenPendingClaimsOneArgs, type MutationRootInsertCurrentTokenRoyaltyV1Args, type MutationRootInsertCurrentTokenRoyaltyV1OneArgs, type MutationRootInsertCurrentTokenV2MetadataArgs, type MutationRootInsertCurrentTokenV2MetadataOneArgs, type MutationRootInsertDelegatedStakingActivitiesArgs, type MutationRootInsertDelegatedStakingActivitiesOneArgs, type MutationRootInsertDelegatedStakingPoolBalancesArgs, type MutationRootInsertDelegatedStakingPoolBalancesOneArgs, type MutationRootInsertDelegatedStakingPoolsArgs, type MutationRootInsertDelegatedStakingPoolsOneArgs, type MutationRootInsertDelegatorBalancesArgs, type MutationRootInsertDelegatorBalancesOneArgs, type MutationRootInsertEventSizeInfoArgs, type MutationRootInsertEventSizeInfoOneArgs, type MutationRootInsertEventsArgs, type MutationRootInsertEventsOneArgs, type MutationRootInsertEventsViewArgs, type MutationRootInsertEventsViewOneArgs, type MutationRootInsertFungibleAssetActivitiesArgs, type MutationRootInsertFungibleAssetActivitiesOneArgs, type MutationRootInsertFungibleAssetBalancesArgs, type MutationRootInsertFungibleAssetBalancesOneArgs, type MutationRootInsertFungibleAssetMetadataArgs, type MutationRootInsertFungibleAssetMetadataOneArgs, type MutationRootInsertFungibleAssetToCoinMappingsArgs, type MutationRootInsertFungibleAssetToCoinMappingsOneArgs, type MutationRootInsertGasFeesArgs, type MutationRootInsertGasFeesOneArgs, type MutationRootInsertIndexerStatusArgs, type MutationRootInsertIndexerStatusOneArgs, type MutationRootInsertMoveModulesArgs, type MutationRootInsertMoveModulesOneArgs, type MutationRootInsertMoveResourcesArgs, type MutationRootInsertMoveResourcesOneArgs, type MutationRootInsertMoveResourcesViewArgs, type MutationRootInsertMoveResourcesViewOneArgs, type MutationRootInsertNftMetadataCrawlerParsedAssetUrisArgs, type MutationRootInsertNftMetadataCrawlerParsedAssetUrisOneArgs, type MutationRootInsertNftPointsArgs, type MutationRootInsertNftPointsOneArgs, type MutationRootInsertObjectsArgs, type MutationRootInsertObjectsOneArgs, type MutationRootInsertProcessorMetadataProcessorStatusArgs, type MutationRootInsertProcessorMetadataProcessorStatusOneArgs, type MutationRootInsertProcessorStatusArgs, type MutationRootInsertProcessorStatusOneArgs, type MutationRootInsertProposalVotesArgs, type MutationRootInsertProposalVotesOneArgs, type MutationRootInsertPublicKeyAuthKeysArgs, type MutationRootInsertPublicKeyAuthKeysOneArgs, type MutationRootInsertSignaturesArgs, type MutationRootInsertSignaturesOneArgs, type MutationRootInsertSpamAssetsArgs, type MutationRootInsertSpamAssetsOneArgs, type MutationRootInsertTableItemsArgs, type MutationRootInsertTableItemsOneArgs, type MutationRootInsertTableItemsViewArgs, type MutationRootInsertTableItemsViewOneArgs, type MutationRootInsertTableMetadatasArgs, type MutationRootInsertTableMetadatasOneArgs, type MutationRootInsertTokenActivitiesArgs, type MutationRootInsertTokenActivitiesOneArgs, type MutationRootInsertTokenActivitiesV2Args, type MutationRootInsertTokenActivitiesV2OneArgs, type MutationRootInsertTokenDatasArgs, type MutationRootInsertTokenDatasOneArgs, type MutationRootInsertTokenDatasV2Args, type MutationRootInsertTokenDatasV2OneArgs, type MutationRootInsertTokenOwnershipsArgs, type MutationRootInsertTokenOwnershipsOneArgs, type MutationRootInsertTokenOwnershipsV2Args, type MutationRootInsertTokenOwnershipsV2OneArgs, type MutationRootInsertTokensArgs, type MutationRootInsertTokensOneArgs, type MutationRootInsertTransactionSizeInfoArgs, type MutationRootInsertTransactionSizeInfoOneArgs, type MutationRootInsertTransactionsViewArgs, type MutationRootInsertTransactionsViewOneArgs, type MutationRootInsertUserTransactionsArgs, type MutationRootInsertUserTransactionsOneArgs, type MutationRootUpdateAccountTransactionsArgs, type MutationRootUpdateAccountTransactionsByPkArgs, type MutationRootUpdateAccountTransactionsManyArgs, type MutationRootUpdateAnsLookupArgs, type MutationRootUpdateAnsLookupByPkArgs, type MutationRootUpdateAnsLookupManyArgs, type MutationRootUpdateAnsLookupV2Args, type MutationRootUpdateAnsLookupV2ByPkArgs, type MutationRootUpdateAnsLookupV2ManyArgs, type MutationRootUpdateAnsPrimaryNameArgs, type MutationRootUpdateAnsPrimaryNameByPkArgs, type MutationRootUpdateAnsPrimaryNameManyArgs, type MutationRootUpdateAnsPrimaryNameV2Args, type MutationRootUpdateAnsPrimaryNameV2ByPkArgs, type MutationRootUpdateAnsPrimaryNameV2ManyArgs, type MutationRootUpdateAuthKeyAccountAddressesArgs, type MutationRootUpdateAuthKeyAccountAddressesByPkArgs, type MutationRootUpdateAuthKeyAccountAddressesManyArgs, type MutationRootUpdateBlockMetadataTransactionsArgs, type MutationRootUpdateBlockMetadataTransactionsByPkArgs, type MutationRootUpdateBlockMetadataTransactionsManyArgs, type MutationRootUpdateCoinActivitiesArgs, type MutationRootUpdateCoinActivitiesByPkArgs, type MutationRootUpdateCoinActivitiesManyArgs, type MutationRootUpdateCoinBalancesArgs, type MutationRootUpdateCoinBalancesByPkArgs, type MutationRootUpdateCoinBalancesManyArgs, type MutationRootUpdateCoinInfosArgs, type MutationRootUpdateCoinInfosByPkArgs, type MutationRootUpdateCoinInfosManyArgs, type MutationRootUpdateCoinSupplyArgs, type MutationRootUpdateCoinSupplyByPkArgs, type MutationRootUpdateCoinSupplyManyArgs, type MutationRootUpdateCollectionDatasArgs, type MutationRootUpdateCollectionDatasByPkArgs, type MutationRootUpdateCollectionDatasManyArgs, type MutationRootUpdateCollectionsV2Args, type MutationRootUpdateCollectionsV2ByPkArgs, type MutationRootUpdateCollectionsV2ManyArgs, type MutationRootUpdateCurrentAnsLookupArgs, type MutationRootUpdateCurrentAnsLookupByPkArgs, type MutationRootUpdateCurrentAnsLookupManyArgs, type MutationRootUpdateCurrentAnsLookupV2Args, type MutationRootUpdateCurrentAnsLookupV2ByPkArgs, type MutationRootUpdateCurrentAnsLookupV2ManyArgs, type MutationRootUpdateCurrentAnsPrimaryNameArgs, type MutationRootUpdateCurrentAnsPrimaryNameByPkArgs, type MutationRootUpdateCurrentAnsPrimaryNameManyArgs, type MutationRootUpdateCurrentAnsPrimaryNameV2Args, type MutationRootUpdateCurrentAnsPrimaryNameV2ByPkArgs, type MutationRootUpdateCurrentAnsPrimaryNameV2ManyArgs, type MutationRootUpdateCurrentCoinBalancesArgs, type MutationRootUpdateCurrentCoinBalancesByPkArgs, type MutationRootUpdateCurrentCoinBalancesManyArgs, type MutationRootUpdateCurrentCollectionDatasArgs, type MutationRootUpdateCurrentCollectionDatasByPkArgs, type MutationRootUpdateCurrentCollectionDatasManyArgs, type MutationRootUpdateCurrentCollectionsV2Args, type MutationRootUpdateCurrentCollectionsV2ByPkArgs, type MutationRootUpdateCurrentCollectionsV2ManyArgs, type MutationRootUpdateCurrentDelegatedStakingPoolBalancesArgs, type MutationRootUpdateCurrentDelegatedStakingPoolBalancesByPkArgs, type MutationRootUpdateCurrentDelegatedStakingPoolBalancesManyArgs, type MutationRootUpdateCurrentDelegatedVoterArgs, type MutationRootUpdateCurrentDelegatedVoterByPkArgs, type MutationRootUpdateCurrentDelegatedVoterManyArgs, type MutationRootUpdateCurrentDelegatorBalancesArgs, type MutationRootUpdateCurrentDelegatorBalancesByPkArgs, type MutationRootUpdateCurrentDelegatorBalancesManyArgs, type MutationRootUpdateCurrentFungibleAssetBalancesArgs, type MutationRootUpdateCurrentFungibleAssetBalancesByPkArgs, type MutationRootUpdateCurrentFungibleAssetBalancesManyArgs, type MutationRootUpdateCurrentFungibleAssetBalancesNewArgs, type MutationRootUpdateCurrentFungibleAssetBalancesNewByPkArgs, type MutationRootUpdateCurrentFungibleAssetBalancesNewManyArgs, type MutationRootUpdateCurrentObjectsArgs, type MutationRootUpdateCurrentObjectsByPkArgs, type MutationRootUpdateCurrentObjectsManyArgs, type MutationRootUpdateCurrentStakingPoolVoterArgs, type MutationRootUpdateCurrentStakingPoolVoterByPkArgs, type MutationRootUpdateCurrentStakingPoolVoterManyArgs, type MutationRootUpdateCurrentTableItemsArgs, type MutationRootUpdateCurrentTableItemsByPkArgs, type MutationRootUpdateCurrentTableItemsManyArgs, type MutationRootUpdateCurrentTableItemsViewArgs, type MutationRootUpdateCurrentTableItemsViewManyArgs, type MutationRootUpdateCurrentTokenDatasArgs, type MutationRootUpdateCurrentTokenDatasByPkArgs, type MutationRootUpdateCurrentTokenDatasManyArgs, type MutationRootUpdateCurrentTokenDatasV2Args, type MutationRootUpdateCurrentTokenDatasV2ByPkArgs, type MutationRootUpdateCurrentTokenDatasV2ManyArgs, type MutationRootUpdateCurrentTokenOwnershipsArgs, type MutationRootUpdateCurrentTokenOwnershipsByPkArgs, type MutationRootUpdateCurrentTokenOwnershipsManyArgs, type MutationRootUpdateCurrentTokenOwnershipsV2Args, type MutationRootUpdateCurrentTokenOwnershipsV2ByPkArgs, type MutationRootUpdateCurrentTokenOwnershipsV2ManyArgs, type MutationRootUpdateCurrentTokenPendingClaimsArgs, type MutationRootUpdateCurrentTokenPendingClaimsByPkArgs, type MutationRootUpdateCurrentTokenPendingClaimsManyArgs, type MutationRootUpdateCurrentTokenRoyaltyV1Args, type MutationRootUpdateCurrentTokenRoyaltyV1ByPkArgs, type MutationRootUpdateCurrentTokenRoyaltyV1ManyArgs, type MutationRootUpdateCurrentTokenV2MetadataArgs, type MutationRootUpdateCurrentTokenV2MetadataByPkArgs, type MutationRootUpdateCurrentTokenV2MetadataManyArgs, type MutationRootUpdateDelegatedStakingActivitiesArgs, type MutationRootUpdateDelegatedStakingActivitiesByPkArgs, type MutationRootUpdateDelegatedStakingActivitiesManyArgs, type MutationRootUpdateDelegatedStakingPoolBalancesArgs, type MutationRootUpdateDelegatedStakingPoolBalancesByPkArgs, type MutationRootUpdateDelegatedStakingPoolBalancesManyArgs, type MutationRootUpdateDelegatedStakingPoolsArgs, type MutationRootUpdateDelegatedStakingPoolsByPkArgs, type MutationRootUpdateDelegatedStakingPoolsManyArgs, type MutationRootUpdateDelegatorBalancesArgs, type MutationRootUpdateDelegatorBalancesByPkArgs, type MutationRootUpdateDelegatorBalancesManyArgs, type MutationRootUpdateEventSizeInfoArgs, type MutationRootUpdateEventSizeInfoByPkArgs, type MutationRootUpdateEventSizeInfoManyArgs, type MutationRootUpdateEventsArgs, type MutationRootUpdateEventsByPkArgs, type MutationRootUpdateEventsManyArgs, type MutationRootUpdateEventsViewArgs, type MutationRootUpdateEventsViewManyArgs, type MutationRootUpdateFungibleAssetActivitiesArgs, type MutationRootUpdateFungibleAssetActivitiesByPkArgs, type MutationRootUpdateFungibleAssetActivitiesManyArgs, type MutationRootUpdateFungibleAssetBalancesArgs, type MutationRootUpdateFungibleAssetBalancesByPkArgs, type MutationRootUpdateFungibleAssetBalancesManyArgs, type MutationRootUpdateFungibleAssetMetadataArgs, type MutationRootUpdateFungibleAssetMetadataByPkArgs, type MutationRootUpdateFungibleAssetMetadataManyArgs, type MutationRootUpdateFungibleAssetToCoinMappingsArgs, type MutationRootUpdateFungibleAssetToCoinMappingsByPkArgs, type MutationRootUpdateFungibleAssetToCoinMappingsManyArgs, type MutationRootUpdateGasFeesArgs, type MutationRootUpdateGasFeesByPkArgs, type MutationRootUpdateGasFeesManyArgs, type MutationRootUpdateIndexerStatusArgs, type MutationRootUpdateIndexerStatusByPkArgs, type MutationRootUpdateIndexerStatusManyArgs, type MutationRootUpdateMoveModulesArgs, type MutationRootUpdateMoveModulesByPkArgs, type MutationRootUpdateMoveModulesManyArgs, type MutationRootUpdateMoveResourcesArgs, type MutationRootUpdateMoveResourcesByPkArgs, type MutationRootUpdateMoveResourcesManyArgs, type MutationRootUpdateMoveResourcesViewArgs, type MutationRootUpdateMoveResourcesViewManyArgs, type MutationRootUpdateNftMetadataCrawlerParsedAssetUrisArgs, type MutationRootUpdateNftMetadataCrawlerParsedAssetUrisByPkArgs, type MutationRootUpdateNftMetadataCrawlerParsedAssetUrisManyArgs, type MutationRootUpdateNftPointsArgs, type MutationRootUpdateNftPointsByPkArgs, type MutationRootUpdateNftPointsManyArgs, type MutationRootUpdateObjectsArgs, type MutationRootUpdateObjectsByPkArgs, type MutationRootUpdateObjectsManyArgs, type MutationRootUpdateProcessorMetadataProcessorStatusArgs, type MutationRootUpdateProcessorMetadataProcessorStatusByPkArgs, type MutationRootUpdateProcessorMetadataProcessorStatusManyArgs, type MutationRootUpdateProcessorStatusArgs, type MutationRootUpdateProcessorStatusByPkArgs, type MutationRootUpdateProcessorStatusManyArgs, type MutationRootUpdateProposalVotesArgs, type MutationRootUpdateProposalVotesByPkArgs, type MutationRootUpdateProposalVotesManyArgs, type MutationRootUpdatePublicKeyAuthKeysArgs, type MutationRootUpdatePublicKeyAuthKeysByPkArgs, type MutationRootUpdatePublicKeyAuthKeysManyArgs, type MutationRootUpdateSignaturesArgs, type MutationRootUpdateSignaturesByPkArgs, type MutationRootUpdateSignaturesManyArgs, type MutationRootUpdateSpamAssetsArgs, type MutationRootUpdateSpamAssetsByPkArgs, type MutationRootUpdateSpamAssetsManyArgs, type MutationRootUpdateTableItemsArgs, type MutationRootUpdateTableItemsByPkArgs, type MutationRootUpdateTableItemsManyArgs, type MutationRootUpdateTableItemsViewArgs, type MutationRootUpdateTableItemsViewManyArgs, type MutationRootUpdateTableMetadatasArgs, type MutationRootUpdateTableMetadatasByPkArgs, type MutationRootUpdateTableMetadatasManyArgs, type MutationRootUpdateTokenActivitiesArgs, type MutationRootUpdateTokenActivitiesByPkArgs, type MutationRootUpdateTokenActivitiesManyArgs, type MutationRootUpdateTokenActivitiesV2Args, type MutationRootUpdateTokenActivitiesV2ByPkArgs, type MutationRootUpdateTokenActivitiesV2ManyArgs, type MutationRootUpdateTokenDatasArgs, type MutationRootUpdateTokenDatasByPkArgs, type MutationRootUpdateTokenDatasManyArgs, type MutationRootUpdateTokenDatasV2Args, type MutationRootUpdateTokenDatasV2ByPkArgs, type MutationRootUpdateTokenDatasV2ManyArgs, type MutationRootUpdateTokenOwnershipsArgs, type MutationRootUpdateTokenOwnershipsByPkArgs, type MutationRootUpdateTokenOwnershipsManyArgs, type MutationRootUpdateTokenOwnershipsV2Args, type MutationRootUpdateTokenOwnershipsV2ByPkArgs, type MutationRootUpdateTokenOwnershipsV2ManyArgs, type MutationRootUpdateTokensArgs, type MutationRootUpdateTokensByPkArgs, type MutationRootUpdateTokensManyArgs, type MutationRootUpdateTransactionSizeInfoArgs, type MutationRootUpdateTransactionSizeInfoByPkArgs, type MutationRootUpdateTransactionSizeInfoManyArgs, type MutationRootUpdateTransactionsViewArgs, type MutationRootUpdateTransactionsViewManyArgs, type MutationRootUpdateUserTransactionsArgs, type MutationRootUpdateUserTransactionsByPkArgs, type MutationRootUpdateUserTransactionsManyArgs, type NftMetadataCrawlerParsedAssetUris, type NftMetadataCrawlerParsedAssetUrisAggregate, type NftMetadataCrawlerParsedAssetUrisAggregateFields, type NftMetadataCrawlerParsedAssetUrisAggregateFieldsCountArgs, type NftMetadataCrawlerParsedAssetUrisAvgFields, type NftMetadataCrawlerParsedAssetUrisBoolExp, NftMetadataCrawlerParsedAssetUrisConstraint, type NftMetadataCrawlerParsedAssetUrisIncInput, type NftMetadataCrawlerParsedAssetUrisInsertInput, type NftMetadataCrawlerParsedAssetUrisMaxFields, type NftMetadataCrawlerParsedAssetUrisMinFields, type NftMetadataCrawlerParsedAssetUrisMutationResponse, type NftMetadataCrawlerParsedAssetUrisObjRelInsertInput, type NftMetadataCrawlerParsedAssetUrisOnConflict, type NftMetadataCrawlerParsedAssetUrisOrderBy, type NftMetadataCrawlerParsedAssetUrisPkColumnsInput, NftMetadataCrawlerParsedAssetUrisSelectColumn, type NftMetadataCrawlerParsedAssetUrisSetInput, type NftMetadataCrawlerParsedAssetUrisStddevFields, type NftMetadataCrawlerParsedAssetUrisStddevPopFields, type NftMetadataCrawlerParsedAssetUrisStddevSampFields, type NftMetadataCrawlerParsedAssetUrisStreamCursorInput, type NftMetadataCrawlerParsedAssetUrisStreamCursorValueInput, type NftMetadataCrawlerParsedAssetUrisSumFields, NftMetadataCrawlerParsedAssetUrisUpdateColumn, type NftMetadataCrawlerParsedAssetUrisUpdates, type NftMetadataCrawlerParsedAssetUrisVarPopFields, type NftMetadataCrawlerParsedAssetUrisVarSampFields, type NftMetadataCrawlerParsedAssetUrisVarianceFields, type NftPoints, type NftPointsAggregate, type NftPointsAggregateFields, type NftPointsAggregateFieldsCountArgs, type NftPointsAvgFields, type NftPointsBoolExp, NftPointsConstraint, type NftPointsIncInput, type NftPointsInsertInput, type NftPointsMaxFields, type NftPointsMinFields, type NftPointsMutationResponse, type NftPointsOnConflict, type NftPointsOrderBy, type NftPointsPkColumnsInput, NftPointsSelectColumn, type NftPointsSetInput, type NftPointsStddevFields, type NftPointsStddevPopFields, type NftPointsStddevSampFields, type NftPointsStreamCursorInput, type NftPointsStreamCursorValueInput, type NftPointsSumFields, NftPointsUpdateColumn, type NftPointsUpdates, type NftPointsVarPopFields, type NftPointsVarSampFields, type NftPointsVarianceFields, type NumActiveDelegatorPerPool, type NumActiveDelegatorPerPoolAggregate, type NumActiveDelegatorPerPoolAggregateFields, type NumActiveDelegatorPerPoolAggregateFieldsCountArgs, type NumActiveDelegatorPerPoolAvgFields, type NumActiveDelegatorPerPoolBoolExp, type NumActiveDelegatorPerPoolMaxFields, type NumActiveDelegatorPerPoolMinFields, type NumActiveDelegatorPerPoolOrderBy, NumActiveDelegatorPerPoolSelectColumn, type NumActiveDelegatorPerPoolStddevFields, type NumActiveDelegatorPerPoolStddevPopFields, type NumActiveDelegatorPerPoolStddevSampFields, type NumActiveDelegatorPerPoolStreamCursorInput, type NumActiveDelegatorPerPoolStreamCursorValueInput, type NumActiveDelegatorPerPoolSumFields, type NumActiveDelegatorPerPoolVarPopFields, type NumActiveDelegatorPerPoolVarSampFields, type NumActiveDelegatorPerPoolVarianceFields, type NumericComparisonExp, type Objects, type ObjectsAggregate, type ObjectsAggregateFields, type ObjectsAggregateFieldsCountArgs, type ObjectsAvgFields, type ObjectsBoolExp, ObjectsConstraint, type ObjectsIncInput, type ObjectsInsertInput, type ObjectsMaxFields, type ObjectsMinFields, type ObjectsMutationResponse, type ObjectsOnConflict, type ObjectsOrderBy, type ObjectsPkColumnsInput, ObjectsSelectColumn, type ObjectsSetInput, type ObjectsStddevFields, type ObjectsStddevPopFields, type ObjectsStddevSampFields, type ObjectsStreamCursorInput, type ObjectsStreamCursorValueInput, type ObjectsSumFields, ObjectsUpdateColumn, type ObjectsUpdates, type ObjectsVarPopFields, type ObjectsVarSampFields, type ObjectsVarianceFields, OrderBy, type ProcessorMetadataProcessorStatus, type ProcessorMetadataProcessorStatusAggregate, type ProcessorMetadataProcessorStatusAggregateFields, type ProcessorMetadataProcessorStatusAggregateFieldsCountArgs, type ProcessorMetadataProcessorStatusAvgFields, type ProcessorMetadataProcessorStatusBoolExp, ProcessorMetadataProcessorStatusConstraint, type ProcessorMetadataProcessorStatusIncInput, type ProcessorMetadataProcessorStatusInsertInput, type ProcessorMetadataProcessorStatusMaxFields, type ProcessorMetadataProcessorStatusMinFields, type ProcessorMetadataProcessorStatusMutationResponse, type ProcessorMetadataProcessorStatusOnConflict, type ProcessorMetadataProcessorStatusOrderBy, type ProcessorMetadataProcessorStatusPkColumnsInput, ProcessorMetadataProcessorStatusSelectColumn, type ProcessorMetadataProcessorStatusSetInput, type ProcessorMetadataProcessorStatusStddevFields, type ProcessorMetadataProcessorStatusStddevPopFields, type ProcessorMetadataProcessorStatusStddevSampFields, type ProcessorMetadataProcessorStatusStreamCursorInput, type ProcessorMetadataProcessorStatusStreamCursorValueInput, type ProcessorMetadataProcessorStatusSumFields, ProcessorMetadataProcessorStatusUpdateColumn, type ProcessorMetadataProcessorStatusUpdates, type ProcessorMetadataProcessorStatusVarPopFields, type ProcessorMetadataProcessorStatusVarSampFields, type ProcessorMetadataProcessorStatusVarianceFields, type ProcessorStatus, type ProcessorStatusAggregate, type ProcessorStatusAggregateFields, type ProcessorStatusAggregateFieldsCountArgs, type ProcessorStatusAvgFields, type ProcessorStatusBoolExp, ProcessorStatusConstraint, type ProcessorStatusIncInput, type ProcessorStatusInsertInput, type ProcessorStatusMaxFields, type ProcessorStatusMinFields, type ProcessorStatusMutationResponse, type ProcessorStatusOnConflict, type ProcessorStatusOrderBy, type ProcessorStatusPkColumnsInput, ProcessorStatusSelectColumn, type ProcessorStatusSetInput, type ProcessorStatusStddevFields, type ProcessorStatusStddevPopFields, type ProcessorStatusStddevSampFields, type ProcessorStatusStreamCursorInput, type ProcessorStatusStreamCursorValueInput, type ProcessorStatusSumFields, ProcessorStatusUpdateColumn, type ProcessorStatusUpdates, type ProcessorStatusVarPopFields, type ProcessorStatusVarSampFields, type ProcessorStatusVarianceFields, type ProposalVotes, type ProposalVotesAggregate, type ProposalVotesAggregateFields, type ProposalVotesAggregateFieldsCountArgs, type ProposalVotesAvgFields, type ProposalVotesBoolExp, ProposalVotesConstraint, type ProposalVotesIncInput, type ProposalVotesInsertInput, type ProposalVotesMaxFields, type ProposalVotesMinFields, type ProposalVotesMutationResponse, type ProposalVotesOnConflict, type ProposalVotesOrderBy, type ProposalVotesPkColumnsInput, ProposalVotesSelectColumn, type ProposalVotesSetInput, type ProposalVotesStddevFields, type ProposalVotesStddevPopFields, type ProposalVotesStddevSampFields, type ProposalVotesStreamCursorInput, type ProposalVotesStreamCursorValueInput, type ProposalVotesSumFields, ProposalVotesUpdateColumn, type ProposalVotesUpdates, type ProposalVotesVarPopFields, type ProposalVotesVarSampFields, type ProposalVotesVarianceFields, type PublicKeyAuthKeys, type PublicKeyAuthKeysAggregate, type PublicKeyAuthKeysAggregateFields, type PublicKeyAuthKeysAggregateFieldsCountArgs, type PublicKeyAuthKeysAvgFields, type PublicKeyAuthKeysBoolExp, PublicKeyAuthKeysConstraint, type PublicKeyAuthKeysIncInput, type PublicKeyAuthKeysInsertInput, type PublicKeyAuthKeysMaxFields, type PublicKeyAuthKeysMinFields, type PublicKeyAuthKeysMutationResponse, type PublicKeyAuthKeysOnConflict, type PublicKeyAuthKeysOrderBy, type PublicKeyAuthKeysPkColumnsInput, PublicKeyAuthKeysSelectColumn, type PublicKeyAuthKeysSetInput, type PublicKeyAuthKeysStddevFields, type PublicKeyAuthKeysStddevPopFields, type PublicKeyAuthKeysStddevSampFields, type PublicKeyAuthKeysStreamCursorInput, type PublicKeyAuthKeysStreamCursorValueInput, type PublicKeyAuthKeysSumFields, PublicKeyAuthKeysUpdateColumn, type PublicKeyAuthKeysUpdates, type PublicKeyAuthKeysVarPopFields, type PublicKeyAuthKeysVarSampFields, type PublicKeyAuthKeysVarianceFields, type QueryRoot, type QueryRootAccountTransactionsAggregateArgs, type QueryRootAccountTransactionsArgs, type QueryRootAccountTransactionsByPkArgs, type QueryRootAddressEventsSummaryAggregateArgs, type QueryRootAddressEventsSummaryArgs, type QueryRootAddressVersionFromEventsAggregateArgs, type QueryRootAddressVersionFromEventsArgs, type QueryRootAddressVersionFromMoveResourcesAggregateArgs, type QueryRootAddressVersionFromMoveResourcesArgs, type QueryRootAnsLookupAggregateArgs, type QueryRootAnsLookupArgs, type QueryRootAnsLookupByPkArgs, type QueryRootAnsLookupV2AggregateArgs, type QueryRootAnsLookupV2Args, type QueryRootAnsLookupV2ByPkArgs, type QueryRootAnsPrimaryNameAggregateArgs, type QueryRootAnsPrimaryNameArgs, type QueryRootAnsPrimaryNameByPkArgs, type QueryRootAnsPrimaryNameV2AggregateArgs, type QueryRootAnsPrimaryNameV2Args, type QueryRootAnsPrimaryNameV2ByPkArgs, type QueryRootAuthKeyAccountAddressesAggregateArgs, type QueryRootAuthKeyAccountAddressesArgs, type QueryRootAuthKeyAccountAddressesByPkArgs, type QueryRootBlockMetadataTransactionsAggregateArgs, type QueryRootBlockMetadataTransactionsArgs, type QueryRootBlockMetadataTransactionsByPkArgs, type QueryRootCoinActivitiesAggregateArgs, type QueryRootCoinActivitiesArgs, type QueryRootCoinActivitiesByPkArgs, type QueryRootCoinBalancesAggregateArgs, type QueryRootCoinBalancesArgs, type QueryRootCoinBalancesByPkArgs, type QueryRootCoinInfosAggregateArgs, type QueryRootCoinInfosArgs, type QueryRootCoinInfosByPkArgs, type QueryRootCoinSupplyAggregateArgs, type QueryRootCoinSupplyArgs, type QueryRootCoinSupplyByPkArgs, type QueryRootCollectionDatasAggregateArgs, type QueryRootCollectionDatasArgs, type QueryRootCollectionDatasByPkArgs, type QueryRootCollectionsV2AggregateArgs, type QueryRootCollectionsV2Args, type QueryRootCollectionsV2ByPkArgs, type QueryRootCurrentAnsLookupAggregateArgs, type QueryRootCurrentAnsLookupArgs, type QueryRootCurrentAnsLookupByPkArgs, type QueryRootCurrentAnsLookupV2AggregateArgs, type QueryRootCurrentAnsLookupV2Args, type QueryRootCurrentAnsLookupV2ByPkArgs, type QueryRootCurrentAnsPrimaryNameAggregateArgs, type QueryRootCurrentAnsPrimaryNameArgs, type QueryRootCurrentAnsPrimaryNameByPkArgs, type QueryRootCurrentAnsPrimaryNameV2AggregateArgs, type QueryRootCurrentAnsPrimaryNameV2Args, type QueryRootCurrentAnsPrimaryNameV2ByPkArgs, type QueryRootCurrentCedraNamesAggregateArgs, type QueryRootCurrentCedraNamesArgs, type QueryRootCurrentCoinBalancesAggregateArgs, type QueryRootCurrentCoinBalancesArgs, type QueryRootCurrentCoinBalancesByPkArgs, type QueryRootCurrentCollectionDatasAggregateArgs, type QueryRootCurrentCollectionDatasArgs, type QueryRootCurrentCollectionDatasByPkArgs, type QueryRootCurrentCollectionOwnershipV2ViewAggregateArgs, type QueryRootCurrentCollectionOwnershipV2ViewArgs, type QueryRootCurrentCollectionOwnershipViewAggregateArgs, type QueryRootCurrentCollectionOwnershipViewArgs, type QueryRootCurrentCollectionsV2AggregateArgs, type QueryRootCurrentCollectionsV2Args, type QueryRootCurrentCollectionsV2ByPkArgs, type QueryRootCurrentDelegatedStakingPoolBalancesAggregateArgs, type QueryRootCurrentDelegatedStakingPoolBalancesArgs, type QueryRootCurrentDelegatedStakingPoolBalancesByPkArgs, type QueryRootCurrentDelegatedVoterAggregateArgs, type QueryRootCurrentDelegatedVoterArgs, type QueryRootCurrentDelegatedVoterByPkArgs, type QueryRootCurrentDelegatorBalancesAggregateArgs, type QueryRootCurrentDelegatorBalancesArgs, type QueryRootCurrentDelegatorBalancesByPkArgs, type QueryRootCurrentFungibleAssetBalancesAggregateArgs, type QueryRootCurrentFungibleAssetBalancesArgs, type QueryRootCurrentFungibleAssetBalancesByPkArgs, type QueryRootCurrentFungibleAssetBalancesNewAggregateArgs, type QueryRootCurrentFungibleAssetBalancesNewArgs, type QueryRootCurrentFungibleAssetBalancesNewByPkArgs, type QueryRootCurrentObjectsAggregateArgs, type QueryRootCurrentObjectsArgs, type QueryRootCurrentObjectsByPkArgs, type QueryRootCurrentStakingPoolVoterAggregateArgs, type QueryRootCurrentStakingPoolVoterArgs, type QueryRootCurrentStakingPoolVoterByPkArgs, type QueryRootCurrentTableItemsAggregateArgs, type QueryRootCurrentTableItemsArgs, type QueryRootCurrentTableItemsByPkArgs, type QueryRootCurrentTableItemsViewAggregateArgs, type QueryRootCurrentTableItemsViewArgs, type QueryRootCurrentTokenDatasAggregateArgs, type QueryRootCurrentTokenDatasArgs, type QueryRootCurrentTokenDatasByPkArgs, type QueryRootCurrentTokenDatasV2AggregateArgs, type QueryRootCurrentTokenDatasV2Args, type QueryRootCurrentTokenDatasV2ByPkArgs, type QueryRootCurrentTokenOwnershipsAggregateArgs, type QueryRootCurrentTokenOwnershipsArgs, type QueryRootCurrentTokenOwnershipsByPkArgs, type QueryRootCurrentTokenOwnershipsV2AggregateArgs, type QueryRootCurrentTokenOwnershipsV2Args, type QueryRootCurrentTokenOwnershipsV2ByPkArgs, type QueryRootCurrentTokenPendingClaimsAggregateArgs, type QueryRootCurrentTokenPendingClaimsArgs, type QueryRootCurrentTokenPendingClaimsByPkArgs, type QueryRootCurrentTokenRoyaltyV1AggregateArgs, type QueryRootCurrentTokenRoyaltyV1Args, type QueryRootCurrentTokenRoyaltyV1ByPkArgs, type QueryRootCurrentTokenV2MetadataAggregateArgs, type QueryRootCurrentTokenV2MetadataArgs, type QueryRootCurrentTokenV2MetadataByPkArgs, type QueryRootDelegatedStakingActivitiesAggregateArgs, type QueryRootDelegatedStakingActivitiesArgs, type QueryRootDelegatedStakingActivitiesByPkArgs, type QueryRootDelegatedStakingPoolBalancesAggregateArgs, type QueryRootDelegatedStakingPoolBalancesArgs, type QueryRootDelegatedStakingPoolBalancesByPkArgs, type QueryRootDelegatedStakingPoolsAggregateArgs, type QueryRootDelegatedStakingPoolsArgs, type QueryRootDelegatedStakingPoolsByPkArgs, type QueryRootDelegatorBalancesAggregateArgs, type QueryRootDelegatorBalancesArgs, type QueryRootDelegatorBalancesByPkArgs, type QueryRootDelegatorDistinctPoolAggregateArgs, type QueryRootDelegatorDistinctPoolArgs, type QueryRootEventSizeInfoAggregateArgs, type QueryRootEventSizeInfoArgs, type QueryRootEventSizeInfoByPkArgs, type QueryRootEventsAggregateArgs, type QueryRootEventsArgs, type QueryRootEventsByPkArgs, type QueryRootEventsViewAggregateArgs, type QueryRootEventsViewArgs, type QueryRootFungibleAssetActivitiesAggregateArgs, type QueryRootFungibleAssetActivitiesArgs, type QueryRootFungibleAssetActivitiesByPkArgs, type QueryRootFungibleAssetBalancesAggregateArgs, type QueryRootFungibleAssetBalancesArgs, type QueryRootFungibleAssetBalancesByPkArgs, type QueryRootFungibleAssetMetadataAggregateArgs, type QueryRootFungibleAssetMetadataArgs, type QueryRootFungibleAssetMetadataByPkArgs, type QueryRootFungibleAssetToCoinMappingsAggregateArgs, type QueryRootFungibleAssetToCoinMappingsArgs, type QueryRootFungibleAssetToCoinMappingsByPkArgs, type QueryRootGasFeesAggregateArgs, type QueryRootGasFeesArgs, type QueryRootGasFeesByPkArgs, type QueryRootIndexerStatusAggregateArgs, type QueryRootIndexerStatusArgs, type QueryRootIndexerStatusByPkArgs, type QueryRootMoveModulesAggregateArgs, type QueryRootMoveModulesArgs, type QueryRootMoveModulesByPkArgs, type QueryRootMoveResourcesAggregateArgs, type QueryRootMoveResourcesArgs, type QueryRootMoveResourcesByPkArgs, type QueryRootMoveResourcesViewAggregateArgs, type QueryRootMoveResourcesViewArgs, type QueryRootNftMetadataCrawlerParsedAssetUrisAggregateArgs, type QueryRootNftMetadataCrawlerParsedAssetUrisArgs, type QueryRootNftMetadataCrawlerParsedAssetUrisByPkArgs, type QueryRootNftPointsAggregateArgs, type QueryRootNftPointsArgs, type QueryRootNftPointsByPkArgs, type QueryRootNumActiveDelegatorPerPoolAggregateArgs, type QueryRootNumActiveDelegatorPerPoolArgs, type QueryRootObjectsAggregateArgs, type QueryRootObjectsArgs, type QueryRootObjectsByPkArgs, type QueryRootProcessorMetadataProcessorStatusAggregateArgs, type QueryRootProcessorMetadataProcessorStatusArgs, type QueryRootProcessorMetadataProcessorStatusByPkArgs, type QueryRootProcessorStatusAggregateArgs, type QueryRootProcessorStatusArgs, type QueryRootProcessorStatusByPkArgs, type QueryRootProposalVotesAggregateArgs, type QueryRootProposalVotesArgs, type QueryRootProposalVotesByPkArgs, type QueryRootPublicKeyAuthKeysAggregateArgs, type QueryRootPublicKeyAuthKeysArgs, type QueryRootPublicKeyAuthKeysByPkArgs, type QueryRootSignaturesAggregateArgs, type QueryRootSignaturesArgs, type QueryRootSignaturesByPkArgs, type QueryRootSpamAssetsAggregateArgs, type QueryRootSpamAssetsArgs, type QueryRootSpamAssetsByPkArgs, type QueryRootTableItemsAggregateArgs, type QueryRootTableItemsArgs, type QueryRootTableItemsByPkArgs, type QueryRootTableItemsViewAggregateArgs, type QueryRootTableItemsViewArgs, type QueryRootTableMetadatasAggregateArgs, type QueryRootTableMetadatasArgs, type QueryRootTableMetadatasByPkArgs, type QueryRootTokenActivitiesAggregateArgs, type QueryRootTokenActivitiesArgs, type QueryRootTokenActivitiesByPkArgs, type QueryRootTokenActivitiesV2AggregateArgs, type QueryRootTokenActivitiesV2Args, type QueryRootTokenActivitiesV2ByPkArgs, type QueryRootTokenDatasAggregateArgs, type QueryRootTokenDatasArgs, type QueryRootTokenDatasByPkArgs, type QueryRootTokenDatasV2AggregateArgs, type QueryRootTokenDatasV2Args, type QueryRootTokenDatasV2ByPkArgs, type QueryRootTokenOwnershipsAggregateArgs, type QueryRootTokenOwnershipsArgs, type QueryRootTokenOwnershipsByPkArgs, type QueryRootTokenOwnershipsV2AggregateArgs, type QueryRootTokenOwnershipsV2Args, type QueryRootTokenOwnershipsV2ByPkArgs, type QueryRootTokensAggregateArgs, type QueryRootTokensArgs, type QueryRootTokensByPkArgs, type QueryRootTransactionSizeInfoAggregateArgs, type QueryRootTransactionSizeInfoArgs, type QueryRootTransactionSizeInfoByPkArgs, type QueryRootTransactionsViewAggregateArgs, type QueryRootTransactionsViewArgs, type QueryRootUserTransactionsAggregateArgs, type QueryRootUserTransactionsArgs, type QueryRootUserTransactionsByPkArgs, type Scalars, type Signatures, type SignaturesAggregate, type SignaturesAggregateFields, type SignaturesAggregateFieldsCountArgs, type SignaturesAppendInput, type SignaturesAvgFields, type SignaturesBoolExp, SignaturesConstraint, type SignaturesDeleteAtPathInput, type SignaturesDeleteElemInput, type SignaturesDeleteKeyInput, type SignaturesIncInput, type SignaturesInsertInput, type SignaturesMaxFields, type SignaturesMinFields, type SignaturesMutationResponse, type SignaturesOnConflict, type SignaturesOrderBy, type SignaturesPkColumnsInput, type SignaturesPrependInput, type SignaturesPublicKeyIndicesArgs, SignaturesSelectColumn, type SignaturesSetInput, type SignaturesStddevFields, type SignaturesStddevPopFields, type SignaturesStddevSampFields, type SignaturesStreamCursorInput, type SignaturesStreamCursorValueInput, type SignaturesSumFields, SignaturesUpdateColumn, type SignaturesUpdates, type SignaturesVarPopFields, type SignaturesVarSampFields, type SignaturesVarianceFields, type SpamAssets, type SpamAssetsAggregate, type SpamAssetsAggregateFields, type SpamAssetsAggregateFieldsCountArgs, type SpamAssetsBoolExp, SpamAssetsConstraint, type SpamAssetsInsertInput, type SpamAssetsMaxFields, type SpamAssetsMinFields, type SpamAssetsMutationResponse, type SpamAssetsOnConflict, type SpamAssetsOrderBy, type SpamAssetsPkColumnsInput, SpamAssetsSelectColumn, type SpamAssetsSetInput, type SpamAssetsStreamCursorInput, type SpamAssetsStreamCursorValueInput, SpamAssetsUpdateColumn, type SpamAssetsUpdates, type StringComparisonExp, type SubscriptionRoot, type SubscriptionRootAccountTransactionsAggregateArgs, type SubscriptionRootAccountTransactionsArgs, type SubscriptionRootAccountTransactionsByPkArgs, type SubscriptionRootAccountTransactionsStreamArgs, type SubscriptionRootAddressEventsSummaryAggregateArgs, type SubscriptionRootAddressEventsSummaryArgs, type SubscriptionRootAddressEventsSummaryStreamArgs, type SubscriptionRootAddressVersionFromEventsAggregateArgs, type SubscriptionRootAddressVersionFromEventsArgs, type SubscriptionRootAddressVersionFromEventsStreamArgs, type SubscriptionRootAddressVersionFromMoveResourcesAggregateArgs, type SubscriptionRootAddressVersionFromMoveResourcesArgs, type SubscriptionRootAddressVersionFromMoveResourcesStreamArgs, type SubscriptionRootAnsLookupAggregateArgs, type SubscriptionRootAnsLookupArgs, type SubscriptionRootAnsLookupByPkArgs, type SubscriptionRootAnsLookupStreamArgs, type SubscriptionRootAnsLookupV2AggregateArgs, type SubscriptionRootAnsLookupV2Args, type SubscriptionRootAnsLookupV2ByPkArgs, type SubscriptionRootAnsLookupV2StreamArgs, type SubscriptionRootAnsPrimaryNameAggregateArgs, type SubscriptionRootAnsPrimaryNameArgs, type SubscriptionRootAnsPrimaryNameByPkArgs, type SubscriptionRootAnsPrimaryNameStreamArgs, type SubscriptionRootAnsPrimaryNameV2AggregateArgs, type SubscriptionRootAnsPrimaryNameV2Args, type SubscriptionRootAnsPrimaryNameV2ByPkArgs, type SubscriptionRootAnsPrimaryNameV2StreamArgs, type SubscriptionRootAuthKeyAccountAddressesAggregateArgs, type SubscriptionRootAuthKeyAccountAddressesArgs, type SubscriptionRootAuthKeyAccountAddressesByPkArgs, type SubscriptionRootAuthKeyAccountAddressesStreamArgs, type SubscriptionRootBlockMetadataTransactionsAggregateArgs, type SubscriptionRootBlockMetadataTransactionsArgs, type SubscriptionRootBlockMetadataTransactionsByPkArgs, type SubscriptionRootBlockMetadataTransactionsStreamArgs, type SubscriptionRootCoinActivitiesAggregateArgs, type SubscriptionRootCoinActivitiesArgs, type SubscriptionRootCoinActivitiesByPkArgs, type SubscriptionRootCoinActivitiesStreamArgs, type SubscriptionRootCoinBalancesAggregateArgs, type SubscriptionRootCoinBalancesArgs, type SubscriptionRootCoinBalancesByPkArgs, type SubscriptionRootCoinBalancesStreamArgs, type SubscriptionRootCoinInfosAggregateArgs, type SubscriptionRootCoinInfosArgs, type SubscriptionRootCoinInfosByPkArgs, type SubscriptionRootCoinInfosStreamArgs, type SubscriptionRootCoinSupplyAggregateArgs, type SubscriptionRootCoinSupplyArgs, type SubscriptionRootCoinSupplyByPkArgs, type SubscriptionRootCoinSupplyStreamArgs, type SubscriptionRootCollectionDatasAggregateArgs, type SubscriptionRootCollectionDatasArgs, type SubscriptionRootCollectionDatasByPkArgs, type SubscriptionRootCollectionDatasStreamArgs, type SubscriptionRootCollectionsV2AggregateArgs, type SubscriptionRootCollectionsV2Args, type SubscriptionRootCollectionsV2ByPkArgs, type SubscriptionRootCollectionsV2StreamArgs, type SubscriptionRootCurrentAnsLookupAggregateArgs, type SubscriptionRootCurrentAnsLookupArgs, type SubscriptionRootCurrentAnsLookupByPkArgs, type SubscriptionRootCurrentAnsLookupStreamArgs, type SubscriptionRootCurrentAnsLookupV2AggregateArgs, type SubscriptionRootCurrentAnsLookupV2Args, type SubscriptionRootCurrentAnsLookupV2ByPkArgs, type SubscriptionRootCurrentAnsLookupV2StreamArgs, type SubscriptionRootCurrentAnsPrimaryNameAggregateArgs, type SubscriptionRootCurrentAnsPrimaryNameArgs, type SubscriptionRootCurrentAnsPrimaryNameByPkArgs, type SubscriptionRootCurrentAnsPrimaryNameStreamArgs, type SubscriptionRootCurrentAnsPrimaryNameV2AggregateArgs, type SubscriptionRootCurrentAnsPrimaryNameV2Args, type SubscriptionRootCurrentAnsPrimaryNameV2ByPkArgs, type SubscriptionRootCurrentAnsPrimaryNameV2StreamArgs, type SubscriptionRootCurrentCedraNamesAggregateArgs, type SubscriptionRootCurrentCedraNamesArgs, type SubscriptionRootCurrentCedraNamesStreamArgs, type SubscriptionRootCurrentCoinBalancesAggregateArgs, type SubscriptionRootCurrentCoinBalancesArgs, type SubscriptionRootCurrentCoinBalancesByPkArgs, type SubscriptionRootCurrentCoinBalancesStreamArgs, type SubscriptionRootCurrentCollectionDatasAggregateArgs, type SubscriptionRootCurrentCollectionDatasArgs, type SubscriptionRootCurrentCollectionDatasByPkArgs, type SubscriptionRootCurrentCollectionDatasStreamArgs, type SubscriptionRootCurrentCollectionOwnershipV2ViewAggregateArgs, type SubscriptionRootCurrentCollectionOwnershipV2ViewArgs, type SubscriptionRootCurrentCollectionOwnershipV2ViewStreamArgs, type SubscriptionRootCurrentCollectionOwnershipViewAggregateArgs, type SubscriptionRootCurrentCollectionOwnershipViewArgs, type SubscriptionRootCurrentCollectionOwnershipViewStreamArgs, type SubscriptionRootCurrentCollectionsV2AggregateArgs, type SubscriptionRootCurrentCollectionsV2Args, type SubscriptionRootCurrentCollectionsV2ByPkArgs, type SubscriptionRootCurrentCollectionsV2StreamArgs, type SubscriptionRootCurrentDelegatedStakingPoolBalancesAggregateArgs, type SubscriptionRootCurrentDelegatedStakingPoolBalancesArgs, type SubscriptionRootCurrentDelegatedStakingPoolBalancesByPkArgs, type SubscriptionRootCurrentDelegatedStakingPoolBalancesStreamArgs, type SubscriptionRootCurrentDelegatedVoterAggregateArgs, type SubscriptionRootCurrentDelegatedVoterArgs, type SubscriptionRootCurrentDelegatedVoterByPkArgs, type SubscriptionRootCurrentDelegatedVoterStreamArgs, type SubscriptionRootCurrentDelegatorBalancesAggregateArgs, type SubscriptionRootCurrentDelegatorBalancesArgs, type SubscriptionRootCurrentDelegatorBalancesByPkArgs, type SubscriptionRootCurrentDelegatorBalancesStreamArgs, type SubscriptionRootCurrentFungibleAssetBalancesAggregateArgs, type SubscriptionRootCurrentFungibleAssetBalancesArgs, type SubscriptionRootCurrentFungibleAssetBalancesByPkArgs, type SubscriptionRootCurrentFungibleAssetBalancesNewAggregateArgs, type SubscriptionRootCurrentFungibleAssetBalancesNewArgs, type SubscriptionRootCurrentFungibleAssetBalancesNewByPkArgs, type SubscriptionRootCurrentFungibleAssetBalancesNewStreamArgs, type SubscriptionRootCurrentFungibleAssetBalancesStreamArgs, type SubscriptionRootCurrentObjectsAggregateArgs, type SubscriptionRootCurrentObjectsArgs, type SubscriptionRootCurrentObjectsByPkArgs, type SubscriptionRootCurrentObjectsStreamArgs, type SubscriptionRootCurrentStakingPoolVoterAggregateArgs, type SubscriptionRootCurrentStakingPoolVoterArgs, type SubscriptionRootCurrentStakingPoolVoterByPkArgs, type SubscriptionRootCurrentStakingPoolVoterStreamArgs, type SubscriptionRootCurrentTableItemsAggregateArgs, type SubscriptionRootCurrentTableItemsArgs, type SubscriptionRootCurrentTableItemsByPkArgs, type SubscriptionRootCurrentTableItemsStreamArgs, type SubscriptionRootCurrentTableItemsViewAggregateArgs, type SubscriptionRootCurrentTableItemsViewArgs, type SubscriptionRootCurrentTableItemsViewStreamArgs, type SubscriptionRootCurrentTokenDatasAggregateArgs, type SubscriptionRootCurrentTokenDatasArgs, type SubscriptionRootCurrentTokenDatasByPkArgs, type SubscriptionRootCurrentTokenDatasStreamArgs, type SubscriptionRootCurrentTokenDatasV2AggregateArgs, type SubscriptionRootCurrentTokenDatasV2Args, type SubscriptionRootCurrentTokenDatasV2ByPkArgs, type SubscriptionRootCurrentTokenDatasV2StreamArgs, type SubscriptionRootCurrentTokenOwnershipsAggregateArgs, type SubscriptionRootCurrentTokenOwnershipsArgs, type SubscriptionRootCurrentTokenOwnershipsByPkArgs, type SubscriptionRootCurrentTokenOwnershipsStreamArgs, type SubscriptionRootCurrentTokenOwnershipsV2AggregateArgs, type SubscriptionRootCurrentTokenOwnershipsV2Args, type SubscriptionRootCurrentTokenOwnershipsV2ByPkArgs, type SubscriptionRootCurrentTokenOwnershipsV2StreamArgs, type SubscriptionRootCurrentTokenPendingClaimsAggregateArgs, type SubscriptionRootCurrentTokenPendingClaimsArgs, type SubscriptionRootCurrentTokenPendingClaimsByPkArgs, type SubscriptionRootCurrentTokenPendingClaimsStreamArgs, type SubscriptionRootCurrentTokenRoyaltyV1AggregateArgs, type SubscriptionRootCurrentTokenRoyaltyV1Args, type SubscriptionRootCurrentTokenRoyaltyV1ByPkArgs, type SubscriptionRootCurrentTokenRoyaltyV1StreamArgs, type SubscriptionRootCurrentTokenV2MetadataAggregateArgs, type SubscriptionRootCurrentTokenV2MetadataArgs, type SubscriptionRootCurrentTokenV2MetadataByPkArgs, type SubscriptionRootCurrentTokenV2MetadataStreamArgs, type SubscriptionRootDelegatedStakingActivitiesAggregateArgs, type SubscriptionRootDelegatedStakingActivitiesArgs, type SubscriptionRootDelegatedStakingActivitiesByPkArgs, type SubscriptionRootDelegatedStakingActivitiesStreamArgs, type SubscriptionRootDelegatedStakingPoolBalancesAggregateArgs, type SubscriptionRootDelegatedStakingPoolBalancesArgs, type SubscriptionRootDelegatedStakingPoolBalancesByPkArgs, type SubscriptionRootDelegatedStakingPoolBalancesStreamArgs, type SubscriptionRootDelegatedStakingPoolsAggregateArgs, type SubscriptionRootDelegatedStakingPoolsArgs, type SubscriptionRootDelegatedStakingPoolsByPkArgs, type SubscriptionRootDelegatedStakingPoolsStreamArgs, type SubscriptionRootDelegatorBalancesAggregateArgs, type SubscriptionRootDelegatorBalancesArgs, type SubscriptionRootDelegatorBalancesByPkArgs, type SubscriptionRootDelegatorBalancesStreamArgs, type SubscriptionRootDelegatorDistinctPoolAggregateArgs, type SubscriptionRootDelegatorDistinctPoolArgs, type SubscriptionRootDelegatorDistinctPoolStreamArgs, type SubscriptionRootEventSizeInfoAggregateArgs, type SubscriptionRootEventSizeInfoArgs, type SubscriptionRootEventSizeInfoByPkArgs, type SubscriptionRootEventSizeInfoStreamArgs, type SubscriptionRootEventsAggregateArgs, type SubscriptionRootEventsArgs, type SubscriptionRootEventsByPkArgs, type SubscriptionRootEventsStreamArgs, type SubscriptionRootEventsViewAggregateArgs, type SubscriptionRootEventsViewArgs, type SubscriptionRootEventsViewStreamArgs, type SubscriptionRootFungibleAssetActivitiesAggregateArgs, type SubscriptionRootFungibleAssetActivitiesArgs, type SubscriptionRootFungibleAssetActivitiesByPkArgs, type SubscriptionRootFungibleAssetActivitiesStreamArgs, type SubscriptionRootFungibleAssetBalancesAggregateArgs, type SubscriptionRootFungibleAssetBalancesArgs, type SubscriptionRootFungibleAssetBalancesByPkArgs, type SubscriptionRootFungibleAssetBalancesStreamArgs, type SubscriptionRootFungibleAssetMetadataAggregateArgs, type SubscriptionRootFungibleAssetMetadataArgs, type SubscriptionRootFungibleAssetMetadataByPkArgs, type SubscriptionRootFungibleAssetMetadataStreamArgs, type SubscriptionRootFungibleAssetToCoinMappingsAggregateArgs, type SubscriptionRootFungibleAssetToCoinMappingsArgs, type SubscriptionRootFungibleAssetToCoinMappingsByPkArgs, type SubscriptionRootFungibleAssetToCoinMappingsStreamArgs, type SubscriptionRootGasFeesAggregateArgs, type SubscriptionRootGasFeesArgs, type SubscriptionRootGasFeesByPkArgs, type SubscriptionRootGasFeesStreamArgs, type SubscriptionRootIndexerStatusAggregateArgs, type SubscriptionRootIndexerStatusArgs, type SubscriptionRootIndexerStatusByPkArgs, type SubscriptionRootIndexerStatusStreamArgs, type SubscriptionRootMoveModulesAggregateArgs, type SubscriptionRootMoveModulesArgs, type SubscriptionRootMoveModulesByPkArgs, type SubscriptionRootMoveModulesStreamArgs, type SubscriptionRootMoveResourcesAggregateArgs, type SubscriptionRootMoveResourcesArgs, type SubscriptionRootMoveResourcesByPkArgs, type SubscriptionRootMoveResourcesStreamArgs, type SubscriptionRootMoveResourcesViewAggregateArgs, type SubscriptionRootMoveResourcesViewArgs, type SubscriptionRootMoveResourcesViewStreamArgs, type SubscriptionRootNftMetadataCrawlerParsedAssetUrisAggregateArgs, type SubscriptionRootNftMetadataCrawlerParsedAssetUrisArgs, type SubscriptionRootNftMetadataCrawlerParsedAssetUrisByPkArgs, type SubscriptionRootNftMetadataCrawlerParsedAssetUrisStreamArgs, type SubscriptionRootNftPointsAggregateArgs, type SubscriptionRootNftPointsArgs, type SubscriptionRootNftPointsByPkArgs, type SubscriptionRootNftPointsStreamArgs, type SubscriptionRootNumActiveDelegatorPerPoolAggregateArgs, type SubscriptionRootNumActiveDelegatorPerPoolArgs, type SubscriptionRootNumActiveDelegatorPerPoolStreamArgs, type SubscriptionRootObjectsAggregateArgs, type SubscriptionRootObjectsArgs, type SubscriptionRootObjectsByPkArgs, type SubscriptionRootObjectsStreamArgs, type SubscriptionRootProcessorMetadataProcessorStatusAggregateArgs, type SubscriptionRootProcessorMetadataProcessorStatusArgs, type SubscriptionRootProcessorMetadataProcessorStatusByPkArgs, type SubscriptionRootProcessorMetadataProcessorStatusStreamArgs, type SubscriptionRootProcessorStatusAggregateArgs, type SubscriptionRootProcessorStatusArgs, type SubscriptionRootProcessorStatusByPkArgs, type SubscriptionRootProcessorStatusStreamArgs, type SubscriptionRootProposalVotesAggregateArgs, type SubscriptionRootProposalVotesArgs, type SubscriptionRootProposalVotesByPkArgs, type SubscriptionRootProposalVotesStreamArgs, type SubscriptionRootPublicKeyAuthKeysAggregateArgs, type SubscriptionRootPublicKeyAuthKeysArgs, type SubscriptionRootPublicKeyAuthKeysByPkArgs, type SubscriptionRootPublicKeyAuthKeysStreamArgs, type SubscriptionRootSignaturesAggregateArgs, type SubscriptionRootSignaturesArgs, type SubscriptionRootSignaturesByPkArgs, type SubscriptionRootSignaturesStreamArgs, type SubscriptionRootSpamAssetsAggregateArgs, type SubscriptionRootSpamAssetsArgs, type SubscriptionRootSpamAssetsByPkArgs, type SubscriptionRootSpamAssetsStreamArgs, type SubscriptionRootTableItemsAggregateArgs, type SubscriptionRootTableItemsArgs, type SubscriptionRootTableItemsByPkArgs, type SubscriptionRootTableItemsStreamArgs, type SubscriptionRootTableItemsViewAggregateArgs, type SubscriptionRootTableItemsViewArgs, type SubscriptionRootTableItemsViewStreamArgs, type SubscriptionRootTableMetadatasAggregateArgs, type SubscriptionRootTableMetadatasArgs, type SubscriptionRootTableMetadatasByPkArgs, type SubscriptionRootTableMetadatasStreamArgs, type SubscriptionRootTokenActivitiesAggregateArgs, type SubscriptionRootTokenActivitiesArgs, type SubscriptionRootTokenActivitiesByPkArgs, type SubscriptionRootTokenActivitiesStreamArgs, type SubscriptionRootTokenActivitiesV2AggregateArgs, type SubscriptionRootTokenActivitiesV2Args, type SubscriptionRootTokenActivitiesV2ByPkArgs, type SubscriptionRootTokenActivitiesV2StreamArgs, type SubscriptionRootTokenDatasAggregateArgs, type SubscriptionRootTokenDatasArgs, type SubscriptionRootTokenDatasByPkArgs, type SubscriptionRootTokenDatasStreamArgs, type SubscriptionRootTokenDatasV2AggregateArgs, type SubscriptionRootTokenDatasV2Args, type SubscriptionRootTokenDatasV2ByPkArgs, type SubscriptionRootTokenDatasV2StreamArgs, type SubscriptionRootTokenOwnershipsAggregateArgs, type SubscriptionRootTokenOwnershipsArgs, type SubscriptionRootTokenOwnershipsByPkArgs, type SubscriptionRootTokenOwnershipsStreamArgs, type SubscriptionRootTokenOwnershipsV2AggregateArgs, type SubscriptionRootTokenOwnershipsV2Args, type SubscriptionRootTokenOwnershipsV2ByPkArgs, type SubscriptionRootTokenOwnershipsV2StreamArgs, type SubscriptionRootTokensAggregateArgs, type SubscriptionRootTokensArgs, type SubscriptionRootTokensByPkArgs, type SubscriptionRootTokensStreamArgs, type SubscriptionRootTransactionSizeInfoAggregateArgs, type SubscriptionRootTransactionSizeInfoArgs, type SubscriptionRootTransactionSizeInfoByPkArgs, type SubscriptionRootTransactionSizeInfoStreamArgs, type SubscriptionRootTransactionsViewAggregateArgs, type SubscriptionRootTransactionsViewArgs, type SubscriptionRootTransactionsViewStreamArgs, type SubscriptionRootUserTransactionsAggregateArgs, type SubscriptionRootUserTransactionsArgs, type SubscriptionRootUserTransactionsByPkArgs, type SubscriptionRootUserTransactionsStreamArgs, type TableItems, type TableItemsAggregate, type TableItemsAggregateFields, type TableItemsAggregateFieldsCountArgs, type TableItemsAppendInput, type TableItemsAvgFields, type TableItemsBoolExp, TableItemsConstraint, type TableItemsDecodedKeyArgs, type TableItemsDecodedValueArgs, type TableItemsDeleteAtPathInput, type TableItemsDeleteElemInput, type TableItemsDeleteKeyInput, type TableItemsIncInput, type TableItemsInsertInput, type TableItemsMaxFields, type TableItemsMinFields, type TableItemsMutationResponse, type TableItemsOnConflict, type TableItemsOrderBy, type TableItemsPkColumnsInput, type TableItemsPrependInput, TableItemsSelectColumn, type TableItemsSetInput, type TableItemsStddevFields, type TableItemsStddevPopFields, type TableItemsStddevSampFields, type TableItemsStreamCursorInput, type TableItemsStreamCursorValueInput, type TableItemsSumFields, TableItemsUpdateColumn, type TableItemsUpdates, type TableItemsVarPopFields, type TableItemsVarSampFields, type TableItemsVarianceFields, type TableItemsView, type TableItemsViewAggregate, type TableItemsViewAggregateFields, type TableItemsViewAggregateFieldsCountArgs, type TableItemsViewAvgFields, type TableItemsViewBoolExp, type TableItemsViewIncInput, type TableItemsViewInsertInput, type TableItemsViewMaxFields, type TableItemsViewMinFields, type TableItemsViewMutationResponse, type TableItemsViewOrderBy, TableItemsViewSelectColumn, type TableItemsViewSetInput, type TableItemsViewStddevFields, type TableItemsViewStddevPopFields, type TableItemsViewStddevSampFields, type TableItemsViewStreamCursorInput, type TableItemsViewStreamCursorValueInput, type TableItemsViewSumFields, type TableItemsViewUpdates, type TableItemsViewVarPopFields, type TableItemsViewVarSampFields, type TableItemsViewVarianceFields, type TableMetadatas, type TableMetadatasAggregate, type TableMetadatasAggregateFields, type TableMetadatasAggregateFieldsCountArgs, type TableMetadatasBoolExp, TableMetadatasConstraint, type TableMetadatasInsertInput, type TableMetadatasMaxFields, type TableMetadatasMinFields, type TableMetadatasMutationResponse, type TableMetadatasOnConflict, type TableMetadatasOrderBy, type TableMetadatasPkColumnsInput, TableMetadatasSelectColumn, type TableMetadatasSetInput, type TableMetadatasStreamCursorInput, type TableMetadatasStreamCursorValueInput, TableMetadatasUpdateColumn, type TableMetadatasUpdates, type TimestampComparisonExp, type TokenActivities, type TokenActivitiesAggregate, type TokenActivitiesAggregateFields, type TokenActivitiesAggregateFieldsCountArgs, type TokenActivitiesAvgFields, type TokenActivitiesBoolExp, TokenActivitiesConstraint, type TokenActivitiesIncInput, type TokenActivitiesInsertInput, type TokenActivitiesMaxFields, type TokenActivitiesMinFields, type TokenActivitiesMutationResponse, type TokenActivitiesOnConflict, type TokenActivitiesOrderBy, type TokenActivitiesPkColumnsInput, TokenActivitiesSelectColumn, type TokenActivitiesSetInput, type TokenActivitiesStddevFields, type TokenActivitiesStddevPopFields, type TokenActivitiesStddevSampFields, type TokenActivitiesStreamCursorInput, type TokenActivitiesStreamCursorValueInput, type TokenActivitiesSumFields, TokenActivitiesUpdateColumn, type TokenActivitiesUpdates, type TokenActivitiesV2, type TokenActivitiesV2Aggregate, type TokenActivitiesV2AggregateBoolExp, type TokenActivitiesV2AggregateBoolExpBoolAnd, type TokenActivitiesV2AggregateBoolExpBoolOr, type TokenActivitiesV2AggregateBoolExpCount, type TokenActivitiesV2AggregateFields, type TokenActivitiesV2AggregateFieldsCountArgs, type TokenActivitiesV2AggregateOrderBy, type TokenActivitiesV2ArrRelInsertInput, type TokenActivitiesV2AvgFields, type TokenActivitiesV2AvgOrderBy, type TokenActivitiesV2BoolExp, type TokenActivitiesV2CedraNamesFromAggregateArgs, type TokenActivitiesV2CedraNamesFromArgs, type TokenActivitiesV2CedraNamesToAggregateArgs, type TokenActivitiesV2CedraNamesToArgs, TokenActivitiesV2Constraint, type TokenActivitiesV2IncInput, type TokenActivitiesV2InsertInput, type TokenActivitiesV2MaxFields, type TokenActivitiesV2MaxOrderBy, type TokenActivitiesV2MinFields, type TokenActivitiesV2MinOrderBy, type TokenActivitiesV2MutationResponse, type TokenActivitiesV2OnConflict, type TokenActivitiesV2OrderBy, type TokenActivitiesV2PkColumnsInput, TokenActivitiesV2SelectColumn, TokenActivitiesV2SelectColumnTokenActivitiesV2AggregateBoolExpBoolAndArgumentsColumns, TokenActivitiesV2SelectColumnTokenActivitiesV2AggregateBoolExpBoolOrArgumentsColumns, type TokenActivitiesV2SetInput, type TokenActivitiesV2StddevFields, type TokenActivitiesV2StddevOrderBy, type TokenActivitiesV2StddevPopFields, type TokenActivitiesV2StddevPopOrderBy, type TokenActivitiesV2StddevSampFields, type TokenActivitiesV2StddevSampOrderBy, type TokenActivitiesV2StreamCursorInput, type TokenActivitiesV2StreamCursorValueInput, type TokenActivitiesV2SumFields, type TokenActivitiesV2SumOrderBy, TokenActivitiesV2UpdateColumn, type TokenActivitiesV2Updates, type TokenActivitiesV2VarPopFields, type TokenActivitiesV2VarPopOrderBy, type TokenActivitiesV2VarSampFields, type TokenActivitiesV2VarSampOrderBy, type TokenActivitiesV2VarianceFields, type TokenActivitiesV2VarianceOrderBy, type TokenActivitiesVarPopFields, type TokenActivitiesVarSampFields, type TokenActivitiesVarianceFields, type TokenDatas, type TokenDatasAggregate, type TokenDatasAggregateFields, type TokenDatasAggregateFieldsCountArgs, type TokenDatasAppendInput, type TokenDatasAvgFields, type TokenDatasBoolExp, TokenDatasConstraint, type TokenDatasDefaultPropertiesArgs, type TokenDatasDeleteAtPathInput, type TokenDatasDeleteElemInput, type TokenDatasDeleteKeyInput, type TokenDatasIncInput, type TokenDatasInsertInput, type TokenDatasMaxFields, type TokenDatasMinFields, type TokenDatasMutationResponse, type TokenDatasOnConflict, type TokenDatasOrderBy, type TokenDatasPkColumnsInput, type TokenDatasPrependInput, TokenDatasSelectColumn, type TokenDatasSetInput, type TokenDatasStddevFields, type TokenDatasStddevPopFields, type TokenDatasStddevSampFields, type TokenDatasStreamCursorInput, type TokenDatasStreamCursorValueInput, type TokenDatasSumFields, TokenDatasUpdateColumn, type TokenDatasUpdates, type TokenDatasV2, type TokenDatasV2Aggregate, type TokenDatasV2AggregateFields, type TokenDatasV2AggregateFieldsCountArgs, type TokenDatasV2AppendInput, type TokenDatasV2AvgFields, type TokenDatasV2BoolExp, TokenDatasV2Constraint, type TokenDatasV2DeleteAtPathInput, type TokenDatasV2DeleteElemInput, type TokenDatasV2DeleteKeyInput, type TokenDatasV2IncInput, type TokenDatasV2InsertInput, type TokenDatasV2MaxFields, type TokenDatasV2MinFields, type TokenDatasV2MutationResponse, type TokenDatasV2OnConflict, type TokenDatasV2OrderBy, type TokenDatasV2PkColumnsInput, type TokenDatasV2PrependInput, TokenDatasV2SelectColumn, type TokenDatasV2SetInput, type TokenDatasV2StddevFields, type TokenDatasV2StddevPopFields, type TokenDatasV2StddevSampFields, type TokenDatasV2StreamCursorInput, type TokenDatasV2StreamCursorValueInput, type TokenDatasV2SumFields, type TokenDatasV2TokenPropertiesArgs, TokenDatasV2UpdateColumn, type TokenDatasV2Updates, type TokenDatasV2VarPopFields, type TokenDatasV2VarSampFields, type TokenDatasV2VarianceFields, type TokenDatasVarPopFields, type TokenDatasVarSampFields, type TokenDatasVarianceFields, type TokenOwnerships, type TokenOwnershipsAggregate, type TokenOwnershipsAggregateFields, type TokenOwnershipsAggregateFieldsCountArgs, type TokenOwnershipsAvgFields, type TokenOwnershipsBoolExp, TokenOwnershipsConstraint, type TokenOwnershipsIncInput, type TokenOwnershipsInsertInput, type TokenOwnershipsMaxFields, type TokenOwnershipsMinFields, type TokenOwnershipsMutationResponse, type TokenOwnershipsOnConflict, type TokenOwnershipsOrderBy, type TokenOwnershipsPkColumnsInput, TokenOwnershipsSelectColumn, type TokenOwnershipsSetInput, type TokenOwnershipsStddevFields, type TokenOwnershipsStddevPopFields, type TokenOwnershipsStddevSampFields, type TokenOwnershipsStreamCursorInput, type TokenOwnershipsStreamCursorValueInput, type TokenOwnershipsSumFields, TokenOwnershipsUpdateColumn, type TokenOwnershipsUpdates, type TokenOwnershipsV2, type TokenOwnershipsV2Aggregate, type TokenOwnershipsV2AggregateFields, type TokenOwnershipsV2AggregateFieldsCountArgs, type TokenOwnershipsV2AppendInput, type TokenOwnershipsV2AvgFields, type TokenOwnershipsV2BoolExp, TokenOwnershipsV2Constraint, type TokenOwnershipsV2DeleteAtPathInput, type TokenOwnershipsV2DeleteElemInput, type TokenOwnershipsV2DeleteKeyInput, type TokenOwnershipsV2IncInput, type TokenOwnershipsV2InsertInput, type TokenOwnershipsV2MaxFields, type TokenOwnershipsV2MinFields, type TokenOwnershipsV2MutationResponse, type TokenOwnershipsV2OnConflict, type TokenOwnershipsV2OrderBy, type TokenOwnershipsV2PkColumnsInput, type TokenOwnershipsV2PrependInput, TokenOwnershipsV2SelectColumn, type TokenOwnershipsV2SetInput, type TokenOwnershipsV2StddevFields, type TokenOwnershipsV2StddevPopFields, type TokenOwnershipsV2StddevSampFields, type TokenOwnershipsV2StreamCursorInput, type TokenOwnershipsV2StreamCursorValueInput, type TokenOwnershipsV2SumFields, type TokenOwnershipsV2TokenPropertiesMutatedV1Args, TokenOwnershipsV2UpdateColumn, type TokenOwnershipsV2Updates, type TokenOwnershipsV2VarPopFields, type TokenOwnershipsV2VarSampFields, type TokenOwnershipsV2VarianceFields, type TokenOwnershipsVarPopFields, type TokenOwnershipsVarSampFields, type TokenOwnershipsVarianceFields, type Tokens, type TokensAggregate, type TokensAggregateFields, type TokensAggregateFieldsCountArgs, type TokensAppendInput, type TokensAvgFields, type TokensBoolExp, TokensConstraint, type TokensDeleteAtPathInput, type TokensDeleteElemInput, type TokensDeleteKeyInput, type TokensIncInput, type TokensInsertInput, type TokensMaxFields, type TokensMinFields, type TokensMutationResponse, type TokensOnConflict, type TokensOrderBy, type TokensPkColumnsInput, type TokensPrependInput, TokensSelectColumn, type TokensSetInput, type TokensStddevFields, type TokensStddevPopFields, type TokensStddevSampFields, type TokensStreamCursorInput, type TokensStreamCursorValueInput, type TokensSumFields, type TokensTokenPropertiesArgs, TokensUpdateColumn, type TokensUpdates, type TokensVarPopFields, type TokensVarSampFields, type TokensVarianceFields, type TransactionSizeInfo, type TransactionSizeInfoAggregate, type TransactionSizeInfoAggregateFields, type TransactionSizeInfoAggregateFieldsCountArgs, type TransactionSizeInfoAvgFields, type TransactionSizeInfoBoolExp, TransactionSizeInfoConstraint, type TransactionSizeInfoIncInput, type TransactionSizeInfoInsertInput, type TransactionSizeInfoMaxFields, type TransactionSizeInfoMinFields, type TransactionSizeInfoMutationResponse, type TransactionSizeInfoOnConflict, type TransactionSizeInfoOrderBy, type TransactionSizeInfoPkColumnsInput, TransactionSizeInfoSelectColumn, type TransactionSizeInfoSetInput, type TransactionSizeInfoStddevFields, type TransactionSizeInfoStddevPopFields, type TransactionSizeInfoStddevSampFields, type TransactionSizeInfoStreamCursorInput, type TransactionSizeInfoStreamCursorValueInput, type TransactionSizeInfoSumFields, TransactionSizeInfoUpdateColumn, type TransactionSizeInfoUpdates, type TransactionSizeInfoVarPopFields, type TransactionSizeInfoVarSampFields, type TransactionSizeInfoVarianceFields, type TransactionsView, type TransactionsViewAggregate, type TransactionsViewAggregateFields, type TransactionsViewAggregateFieldsCountArgs, type TransactionsViewAvgFields, type TransactionsViewBoolExp, type TransactionsViewIncInput, type TransactionsViewInsertInput, type TransactionsViewMaxFields, type TransactionsViewMinFields, type TransactionsViewMutationResponse, type TransactionsViewOrderBy, TransactionsViewSelectColumn, type TransactionsViewSetInput, type TransactionsViewStddevFields, type TransactionsViewStddevPopFields, type TransactionsViewStddevSampFields, type TransactionsViewStreamCursorInput, type TransactionsViewStreamCursorValueInput, type TransactionsViewSumFields, type TransactionsViewUpdates, type TransactionsViewVarPopFields, type TransactionsViewVarSampFields, type TransactionsViewVarianceFields, type UserTransactions, type UserTransactionsAggregate, type UserTransactionsAggregateFields, type UserTransactionsAggregateFieldsCountArgs, type UserTransactionsAvgFields, type UserTransactionsBoolExp, UserTransactionsConstraint, type UserTransactionsIncInput, type UserTransactionsInsertInput, type UserTransactionsMaxFields, type UserTransactionsMinFields, type UserTransactionsMutationResponse, type UserTransactionsObjRelInsertInput, type UserTransactionsOnConflict, type UserTransactionsOrderBy, type UserTransactionsPkColumnsInput, UserTransactionsSelectColumn, type UserTransactionsSetInput, type UserTransactionsStddevFields, type UserTransactionsStddevPopFields, type UserTransactionsStddevSampFields, type UserTransactionsStreamCursorInput, type UserTransactionsStreamCursorValueInput, type UserTransactionsSumFields, UserTransactionsUpdateColumn, type UserTransactionsUpdates, type UserTransactionsVarPopFields, type UserTransactionsVarSampFields, type UserTransactionsVarianceFields };
