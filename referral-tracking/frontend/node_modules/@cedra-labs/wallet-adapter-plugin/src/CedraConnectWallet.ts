// Copyright Â© Cedra

// SPDX-License-Identifier: Apache-2.0

import { ClaimOptions } from "@cedra-labs/connect-wallet-api";

import {
  AccountAddress,
  AccountAuthenticator,
  AnyRawTransaction,
  Cedra,
  CedraConfig,
  Ed25519PrivateKey,
  HexInput,
  MultiAgentTransaction,
  Network,
  NetworkToNodeAPI,
  SimpleTransaction,
} from "@cedra-labs/ts-sdk";

import {
  AccountInfo,
  CEDRA_CHAINS,
  CedraSignAndSubmitTransactionInput,
  CedraSignAndSubmitTransactionOutput,
  CedraSignInInput,
  CedraSignInOutput,
  CedraSignMessageInput,
  CedraSignMessageOutput,
  CedraSignTransactionInputV1_1,
  CedraSignTransactionOutputV1_1,
  CedraWalletError,
  CedraWalletErrorCode,
  NetworkInfo,
  UserResponse,
  UserResponseStatus,
} from "@cedra-labs/wallet-standard";

import {
  deserializePublicKeyB64,
  serializePublicKeyB64,
} from "@cedra-labs/crypto";

import { ACDappClient, ACDappClientConfig } from "@cedra-labs/dapp-sdk";

import { CedraConnectAccount } from "./CedraConnectAccount";

import {
  customAccountToStandardAccount,
  networkToChainId,
  unwrapUserResponse,
} from "./helpers";

interface SerializedCurrentAccount {
  address: string;

  publicKey: string;
}

type WithSSOProvider<T> = T & {
  provider: "google" | "apple";
};

export interface CedraConnectWalletConfig
  extends Omit<ACDappClientConfig, "defaultNetworkName" | "provider"> {
  claimSecretKey?: HexInput;

  network?: Network;

  preferredWalletName?: string;
}

export abstract class CedraConnectWallet {
  // region connectedAccount

  protected static connectedAccountStorageKey = "@cedra-labs/connectedAccount";

  protected static get connectedAccount(): AccountInfo | undefined {
    const serialized = localStorage.getItem(
      CedraConnectWallet.connectedAccountStorageKey,
    );

    if (!serialized) {
      return undefined;
    }

    try {
      const { address, publicKey } = JSON.parse(
        serialized,
      ) as SerializedCurrentAccount;

      return new AccountInfo({
        address: AccountAddress.from(address),

        publicKey: deserializePublicKeyB64(publicKey),
      });
    } catch (err) {
      // eslint-disable-next-line no-console

      console.warn("Inconsistent state, resetting it");

      this.connectedAccount = undefined;

      return undefined;
    }
  }

  protected static set connectedAccount(value: AccountInfo | undefined) {
    if (value !== undefined) {
      const serialized: SerializedCurrentAccount = {
        address: value.address.toString(),

        publicKey: serializePublicKeyB64(value.publicKey),
      };

      localStorage.setItem(
        CedraConnectWallet.connectedAccountStorageKey,
        JSON.stringify(serialized),
      );
    } else {
      localStorage.removeItem(CedraConnectWallet.connectedAccountStorageKey);
    }
  }

  // endregion

  // region CedraWallet

  readonly version = "1.0.0";

  readonly chains = CEDRA_CHAINS;

  // eslint-disable-next-line class-methods-use-this

  get accounts() {
    const { connectedAccount } = CedraConnectWallet;

    return connectedAccount ? [new CedraConnectAccount(connectedAccount)] : [];
  }

  // endregion

  // PetraWallet

  private readonly cedraClient: Cedra;

  private readonly client: ACDappClient;

  private readonly preferredWalletName?: string;

  private readonly claimOptions?: ClaimOptions;

  constructor({
    claimSecretKey,

    network = Network.MAINNET,

    preferredWalletName,

    ...clientConfig
  }: WithSSOProvider<CedraConnectWalletConfig>) {
    this.client = new ACDappClient(clientConfig);

    if (!NetworkToNodeAPI[network]) {
      throw new Error("Network not supported");
    }

    const cedraConfig = new CedraConfig({ network });

    this.cedraClient = new Cedra(cedraConfig);

    this.preferredWalletName = preferredWalletName;

    this.claimOptions = claimSecretKey
      ? { network, secretKey: new Ed25519PrivateKey(claimSecretKey) }
      : undefined;
  }

  async connect(): Promise<UserResponse<AccountInfo>> {
    // If this is an auto-connect, try not opening the prompt

    const { connectedAccount } = CedraConnectWallet;

    if (connectedAccount !== undefined) {
      return { args: connectedAccount, status: UserResponseStatus.APPROVED };
    }

    const response = await this.client.connect({
      claimOptions: this.claimOptions,

      preferredWalletName: this.preferredWalletName,
    });

    if (response.status === "dismissed") {
      return { status: UserResponseStatus.REJECTED };
    }

    const newConnectedAccount = customAccountToStandardAccount(
      response.args.account,
    );

    CedraConnectWallet.connectedAccount = newConnectedAccount;

    return {
      args: newConnectedAccount,

      status: UserResponseStatus.APPROVED,
    };
  }

  async disconnect() {
    const { connectedAccount } = CedraConnectWallet;

    if (connectedAccount) {
      await this.client.disconnect(connectedAccount.address);

      CedraConnectWallet.connectedAccount = undefined;
    }
  }

  async signIn(
    input: CedraSignInInput,
  ): Promise<UserResponse<CedraSignInOutput>> {
    const response = await this.client.signIn({
      network: this.cedraClient.config.network,
      ...input,
    });

    if (response.status === "dismissed") {
      return { status: UserResponseStatus.REJECTED };
    }

    const output = response.args;

    CedraConnectWallet.connectedAccount = output.account;

    return { args: output, status: UserResponseStatus.APPROVED };
  }

  // eslint-disable-next-line class-methods-use-this

  async getAccount(): Promise<AccountInfo> {
    const { connectedAccount } = CedraConnectWallet;

    if (!connectedAccount) {
      // TODO: this function should fail gracefully

      throw new CedraWalletError(CedraWalletErrorCode.Unauthorized);
    }

    return customAccountToStandardAccount(connectedAccount);
  }

  async getNetwork(): Promise<NetworkInfo> {
    const { network } = this.cedraClient.config;

    const chainId = await this.cedraClient.getChainId();

    const url = NetworkToNodeAPI[network];

    return {
      chainId,

      name: network,

      url,
    };
  }

  async signMessage(
    input: CedraSignMessageInput,
  ): Promise<UserResponse<CedraSignMessageOutput>> {
    const { connectedAccount } = CedraConnectWallet;

    if (!connectedAccount) {
      throw new CedraWalletError(CedraWalletErrorCode.Unauthorized);
    }

    const chainId = networkToChainId(this.cedraClient.config.network);

    const { message, nonce } = input;

    const encoder = new TextEncoder();

    const messageBytes = encoder.encode(message);

    const nonceBytes = encoder.encode(nonce);

    const response = await this.client.signMessage({
      chainId,

      message: messageBytes,

      nonce: nonceBytes,

      signerAddress: connectedAccount.address,
    });

    if (response.status === "dismissed") {
      return { status: UserResponseStatus.REJECTED };
    }

    const { fullMessage, signature } = response.args;

    const extraResponseArgs = {
      address: connectedAccount.address.toString(),

      application: this.client.dappInfo.domain,

      chainId,

      message,

      nonce,

      prefix: "CEDRA" as const,
    };

    return {
      args: {
        fullMessage,

        signature,

        ...extraResponseArgs,
      },

      status: UserResponseStatus.APPROVED,
    };
  }

  async signTransaction(
    rawTxn: AnyRawTransaction,
  ): Promise<UserResponse<AccountAuthenticator>>;

  async signTransaction(
    args: CedraSignTransactionInputV1_1,
  ): Promise<UserResponse<CedraSignTransactionOutputV1_1>>;

  async signTransaction(
    txnOrArgs: AnyRawTransaction | CedraSignTransactionInputV1_1,

    _asFeePayer?: boolean,
  ): Promise<
    UserResponse<AccountAuthenticator | CedraSignTransactionOutputV1_1>
  > {
    const { connectedAccount } = CedraConnectWallet;

    if (!connectedAccount) {
      throw new CedraWalletError(CedraWalletErrorCode.Unauthorized);
    }

    if ("bcsToBytes" in txnOrArgs) {
      const transaction = txnOrArgs;

      const feePayer = transaction.feePayerAddress
        ? { address: transaction.feePayerAddress }
        : undefined;

      const secondarySigners = transaction.secondarySignerAddresses?.map(
        (address) => ({ address }),
      );

      const response = await this.client.signTransaction({
        feePayer,

        secondarySigners,

        signerAddress: connectedAccount.address,

        transaction: transaction.rawTransaction,
      });

      return unwrapUserResponse(response, (args) => args.authenticator);
    }

    const requestArgs = txnOrArgs;

    const response = await this.client.signTransaction({
      ...requestArgs,

      signerAddress: connectedAccount.address,
    });

    return unwrapUserResponse(response, (responseArgs) => {
      const { authenticator, rawTransaction } = responseArgs;

      if (!rawTransaction) {
        throw new Error("Expected raw transaction in response args");
      }

      const secondarySigners = requestArgs.secondarySigners ?? [];

      let transaction: AnyRawTransaction;

      if (secondarySigners.length > 0) {
        transaction = new MultiAgentTransaction(
          rawTransaction,

          secondarySigners.map((s) => s.address),

          requestArgs.feePayer?.address,
        );
      } else {
        transaction = new SimpleTransaction(
          rawTransaction,
          requestArgs.feePayer?.address,
        );
      }

      return {
        authenticator,

        rawTransaction: transaction,
      };
    });
  }

  async signAndSubmitTransaction(
    args: CedraSignAndSubmitTransactionInput,
  ): Promise<UserResponse<CedraSignAndSubmitTransactionOutput>> {
    const { gasUnitPrice, maxGasAmount, payload } = args;

    const { connectedAccount } = CedraConnectWallet;

    if (!connectedAccount) {
      throw new CedraWalletError(CedraWalletErrorCode.Unauthorized);
    }

    const response = await this.client.signAndSubmitTransaction({
      gasUnitPrice,

      maxGasAmount,

      network: this.cedraClient.config.network,

      payload,

      signerAddress: connectedAccount.address,
    });

    if (response.status === "dismissed") {
      return { status: UserResponseStatus.REJECTED };
    }

    return {
      args: { hash: response.args.txnHash },

      status: UserResponseStatus.APPROVED,
    };
  }

  // eslint-disable-next-line class-methods-use-this

  async onAccountChange(
    _callback?: (newAccount: AccountInfo) => void,
  ): Promise<void> {
    // TODO
  }

  // eslint-disable-next-line class-methods-use-this

  async onNetworkChange(
    _callback?: (newNetwork: NetworkInfo) => void,
  ): Promise<void> {
    // Not applicable
  }

  // endregion
}
